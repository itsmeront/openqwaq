'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 25 May 2011 at 8:50:47 pm'!!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm (auto pragmas 12/08) 3/28/1999 16:24'!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	<inline: true>	result := 0.	remaining := n.	[true] whileTrue: [		shift := remaining - bitPosition.		result := result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining := remaining - bitPosition.							currentByte := (encodedBytes at: (byteIndex := byteIndex + 1)).				bitPosition := 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition := bitPosition - remaining.				"mask out the consumed bits:"				currentByte := currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]].! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm (auto pragmas 12/08) 3/28/1999 20:21'!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	<inline: true>	buf := anInteger.	bufBits := n.	[true] whileTrue: [		bitsAvailable := 8 - bitPosition.		shift := bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte := currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte.				bitPosition := 0.				currentByte := 0.				"clear saved high bits of buf:"				buf := buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits := bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition := bitPosition + bufBits.				^ self]].! !!ADPCMCodec methodsFor: 'private' stamp: 'zz (auto pragmas 12/08) 3/2/2004 07:58'!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash actually computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	<inline: true>	diff := nextSample - thisSample.	diff < 0 ifTrue: [diff := 0 - diff].	bestIndex := 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex := j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted := self nextBits: 16.				predicted > 32767 ifTrue: [predicted := predicted - 65536].				index := self nextBits: 6.				samples at: (sampleIndex := sampleIndex + 1) put: predicted]			ifFalse: [				delta := self nextBits: bitsPerSample.				step := stepSizeTable at: index + 1.				predictedDelta := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta := predictedDelta + step].					step := step bitShift: -1.					bit := bit bitShift: -1].				predictedDelta := predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted := predicted - predictedDelta]					ifFalse: [predicted := predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted := 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].				index := index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index := 0]					ifFalse: [index > 88 ifTrue: [index := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	<var: #rightSamples declareC: 'short int *rightSamples'>	<var: #predicted declareC: 'short int *predicted'>	<var: #index declareC: 'short int *index'>	"make local copies of decoder state variables"	predictedLeft := predicted at: 1.	predictedRight := predicted at: 2.	indexLeft := index at: 1.	indexRight := index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft := self nextBits: 16.				indexLeft := self nextBits: 6.				predictedRight := self nextBits: 16.				indexRight := self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft := predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight := predictedRight - 65536].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft := self nextBits: bitsPerSample.				deltaRight := self nextBits: bitsPerSample.				stepLeft := stepSizeTable at: indexLeft + 1.				stepRight := stepSizeTable at: indexRight + 1.				predictedDeltaLeft := predictedDeltaRight := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft := predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight := predictedDeltaRight + stepRight].					stepLeft := stepLeft bitShift: -1.					stepRight := stepRight bitShift: -1.					bit := bit bitShift: -1].				predictedDeltaLeft := predictedDeltaLeft + stepLeft.				predictedDeltaRight := predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft := predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft := predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight := predictedRight - predictedDeltaRight]					ifFalse: [predictedRight := predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft := 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft := -32768]].				predictedRight > 32767					ifTrue: [predictedRight := 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight := -32768]].				indexLeft := indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft := 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft := 88]].				indexRight := indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight := 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	step := stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted := samples at: (sampleIndex := sampleIndex + 1).			(p := predicted) < 0 ifTrue: [p := p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index := self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign := 0.			diff := (samples at: (sampleIndex := sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign := deltaSignMask.				diff := 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta := (4 * diff) / step.				predictedDelta := ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta := 0.			predictedDelta := 0.			bit := deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta := delta + bit.					predictedDelta := predictedDelta + step.					diff := diff - step].				step := step bitShift: -1.				bit := bit bitShift: -1].			predictedDelta := predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted := predicted - predictedDelta]				ifFalse: [predicted := predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted := 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].			"compute new index and step values"			index := index + (indexTable at: delta + 1).			index < 0				ifTrue: [index := 0]				ifFalse: [index > 88 ifTrue: [index := 88]].			step := stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:12'!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	"not yet implemented"	<inline: false>	self success: false.! !!AbstractObjectsAsMethod methodsFor: 'as yet unclassified' stamp: 'md 3/1/2006 14:25'!flushCache! !!AbstractObjectsAsMethod methodsFor: 'as yet unclassified' stamp: 'md 3/1/2006 14:23'!methodClass: aMethodClass! !!AbstractObjectsAsMethod methodsFor: 'as yet unclassified' stamp: 'md 3/1/2006 14:23'!selector: aSymbol! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'ar 12/18/2008 16:26'!updateScorePlayers	| soundsBeingEdited |	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	Smalltalk at: #ScorePlayer ifPresent:[:cls| 		cls allSubInstancesDo:[:p | p pause].	].	SoundPlayer shutDown.	Smalltalk at: #ScorePlayer ifPresent:[:cls| 		soundsBeingEdited := cls allSubInstances collect: [:ed | ed soundBeingEdited].	].	Smalltalk at: #ScorePlayerMorph ifPresent:[:cls| 		cls allSubInstancesDo:[:p | p updateInstrumentsFromLibraryExcept: soundsBeingEdited].	].! !!AllocationTest methodsFor: 'tests' stamp: 'ar 7/27/2010 12:21'!expectedFailures 	"should be fixed with latest VMs but unix is still pending"	Smalltalk isRunningCogit ifTrue:[^#(testOneGigAllocation)].	self isSafeVM		ifTrue: [ ^#() ]		ifFalse: [ ^#(testOneGigAllocation testOutOfMemorySignal) ]! !!AllocationTest methodsFor: 'tests' stamp: 'ar 12/4/2009 14:08'!testOneGigAllocation	"Documentating a weird bug in the allocator"	| sz array failed |	failed := false.	sz := 1024*1024*1024.	array := [Array new: sz] on: OutOfMemory do:[:ex| failed := true].	self assert: (failed or:[array size = sz]).	! !!AllocationTest methodsFor: 'tests' stamp: 'ar 12/4/2009 14:08'!testOneMegAllocation	"Documentating a weird bug in the allocator"	| sz array failed |	failed := false.	sz := 1024*1024.	array := [Array new: sz] on: OutOfMemory do:[:ex| failed := true].	self assert: (failed or:[array size = sz]).	! !!AllocationTest methodsFor: 'tests' stamp: 'dtl 4/7/2010 09:47'!testOutOfMemorySignal	"Ensure that OOM is signaled eventually"	| sz |	self isSafeVM ifFalse: [ "avoid crashing"		^self assert: false ].	sz := 512*1024*1024. "work around the 1GB alloc bug"	self should:[(1 to: 2000) collect:[:i| Array new: sz]] raise: OutOfMemory.	"Call me when this test fails, I want your machine"	sz := 1024*1024*1024*1024.	self should:[Array new: sz] raise: OutOfMemory.! !!AllocationTest methodsFor: 'workarounds' stamp: 'dtl 4/7/2010 10:02'!isSafeVM	"False if the VM is a Unix VM that has not been updated to version 4.	Earlier versions may be subject to a bug that can crash the VM when	running AllocationTest."	self flag: #toRemove. "April 2010 dtl - remove this about one year from now"	^ Smalltalk platformName ~= 'unix'		or: [(((Smalltalk getSystemAttribute: 0)				findTokens: FileDirectory slash)				select: [:e | e beginsWith: '4.']) isEmpty not]! !!Arc methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^center! !!Arc methodsFor: 'accessing'!center: aPoint 	"Set aPoint to be the receiver's center."	center := aPoint! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger 	"The receiver is defined by a point at the center and a radius. The 	quadrant is not reset."	center := aPoint.	radius := anInteger! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger quadrant: section 	"Set the receiver's quadrant to be the argument, section. The size of the 	receiver is defined by the center and its radius."	center := aPoint.	radius := anInteger.	quadrant := section! !!Arc methodsFor: 'accessing'!quadrant	"Answer the part of the circle represented by the receiver."	^quadrant! !!Arc methodsFor: 'accessing'!quadrant: section 	"Set the part of the circle represented by the receiver to be the argument, 	section."	quadrant := section! !!Arc methodsFor: 'accessing'!radius	"Answer the receiver's radius."	^radius! !!Arc methodsFor: 'accessing'!radius: anInteger 	"Set the receiver's radius to be the argument, anInteger."	radius := anInteger! !!Arc methodsFor: 'display box access'!computeBoundingBox	| aRectangle aPoint |	aRectangle := center - radius + form offset extent: form extent + (radius * 2) asPoint.	aPoint := center + form extent.	quadrant = 1 ifTrue: [^ aRectangle encompass: center x @ aPoint y].	quadrant = 2 ifTrue: [^ aRectangle encompass: aPoint x @ aPoint y].	quadrant = 3 ifTrue: [^ aRectangle encompass: aPoint x @ center y].	quadrant = 4 ifTrue: [^ aRectangle encompass: center x @ center y]! !!Arc methodsFor: 'displaying' stamp: 'nice 12/27/2009 04:00'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| nSegments line angle sin cos xn yn |	nSegments := 12.0.	line := Line new.	line form: self form.	angle := 90.0 / nSegments.	sin := (angle * (2 * Float pi / 360.0)) sin.	cos := (angle * (2 * Float pi / 360.0)) cos.	quadrant = 1		ifTrue: 			[xn := radius asFloat.			yn := 0.0].	quadrant = 2		ifTrue: 			[xn := 0.0.			yn := 0.0 - radius asFloat].	quadrant = 3		ifTrue: 			[xn := 0.0 - radius asFloat.			yn := 0.0].	quadrant = 4		ifTrue: 			[xn := 0.0.			yn := radius asFloat].	nSegments asInteger		timesRepeat: 			[ | xn1 yn1 |			xn1 := xn * cos + (yn * sin).			yn1 := yn * cos - (xn * sin).			line beginPoint: center + (xn asInteger @ yn asInteger).			line endPoint: center + (xn1 asInteger @ yn1 asInteger).			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			xn := xn1.			yn := yn1]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newArc tempCenter |	newArc := Arc new.	tempCenter := aTransformation applyTo: self center.	newArc center: tempCenter x asInteger @ tempCenter y asInteger.	newArc quadrant: self quadrant.	newArc radius: (self radius * aTransformation scale x) asInteger.	newArc form: self form.	newArc		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Arc commentStamp: '<historical>' prior: 0!Arcs are an unusual implementation of splines due to Ted Kaehler.  Imagine two lines that meet at a corner. Now imagine two moving points; one moves from the corner to the end on one line, the other moves from the end of the other line in to the corner.  Now imagine a series of lines drawn between those moving points at each step along the way (they form a sort of spider web pattern).  By connecting segments of the intersecting lines, a smooth curve is achieved that is tangent to both of the original lines.  Voila.!!Arc class methodsFor: 'examples'!example	"Click the button somewhere on the screen. The designated point will	be the center of an Arc with radius 50 in the 4th quadrant."	| anArc aForm |	aForm := Form extent: 1 @ 30.	"make a long thin Form for display"	aForm fillBlack.						"turn it black"	anArc := Arc new.	anArc form: aForm.					"set the form for display"	anArc radius: 50.0.	anArc center: Sensor waitButton.	anArc quadrant: 4.	anArc displayOn: Display.	Sensor waitButton	"Arc example"! !!Archive methodsFor: 'archive operations' stamp: 'bf 11/11/2008 22:25'!memberNamed: aString	"Return the first member whose zip name or local file name matches aString, or nil"	^members detect: [ :ea | (ea fileName = aString) or: [ ea localFileName = aString ]] ifNone: [		members detect: [ :ea | (ea fileName sameAs: aString) or: [ ea localFileName sameAs: aString ]]			ifNone: [ ]]! !!Array methodsFor: 'private' stamp: 'eem 11/29/2008 17:02'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in the receiver, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self size do:		[:index | | lit |		lit := self at: index.		((litBlock value: lit)		or: [lit isArray and: [lit hasLiteralSuchThat: litBlock]]) ifTrue:			[^true]].	^false! !!ArrayLiteralTest methodsFor: 'initialize-release' stamp: 'avi 2/16/2004 21:09'!tearDown	self class removeSelector: #array! !!ArrayLiteralTest methodsFor: 'tests' stamp: 'avi 2/16/2004 21:08'!testReservedIdentifiers	self class compile: 'array ^ #(nil true false)'.	self assert: self array = {nil. true. false}.! !!ArrayLiteralTest methodsFor: 'tests' stamp: 'avi 2/16/2004 21:09'!testSymbols	self class compile: 'array ^ #(#nil #true #false #''nil'' #''true'' #''false'')'.	self assert: self array = {#nil. #true. #false. #nil. #true. #false}.! !!ArrayTest methodsFor: 'initialize-release' stamp: 'ar 3/5/2010 20:25'!setUp	literalArray := #(1 true 3 #four).	selfEvaluatingArray := { 1. true. (3/4). Color black. (2 to: 4) . 5 }.	nonSEArray1 := { 1 . Set with: 1 }.	nonSEarray2 := { Smalltalk globals associationAt: #Array }.	example1 := #(1 2 3 4 5).	example2 := {1. 2. 3/4. 4. 5}. ! !!ArrayTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:40'!testAtWrap	|tabTest|	tabTest := #(5 6 8).	self assert:(tabTest atWrap: 2) = 6.	self assert:(tabTest atWrap:7) = 5.	self assert:( tabTest atWrap:5) = 6.	self assert:(tabTest atWrap:0)= 8.	self assert:(tabTest atWrap:1)= 5.	self assert:(tabTest atWrap:-2) = 5.! !!ArrayTest methodsFor: 'testing' stamp: 'zz 12/5/2005 17:12'!testIsArray		self assert: example1 isArray! !!ArrayTest methodsFor: 'testing' stamp: 'nice 11/3/2009 21:28'!testIsLiteral	"We work with a copy of literalArray, to avoid corrupting the code."		| aLiteralArray |	aLiteralArray := literalArray copy.	self assert: aLiteralArray isLiteral.	aLiteralArray at: 1 put: self class.	self deny: aLiteralArray isLiteral.	self deny: (literalArray as: WeakArray) isLiteral description: 'instances of Array subclasses are not literal'.! !!ArrayTest methodsFor: 'testing' stamp: 'zz 12/5/2005 17:50'!testLiteralEqual	self		deny: (example1 literalEqual: example1 asIntegerArray)! !!ArrayTest methodsFor: 'testing' stamp: 'nice 11/1/2009 19:14'!testLiteralStoreOn	"Test that a literal Array is stored and evaluated back unchanged"		| anArray |	anArray := {true. false. nil. #a. 'a'. $a. -1. 0. 1. Float pi. Float halfPi. Float halfPi negated.}.	anArray := anArray copyWith: anArray.	self assert: anArray isLiteral.	self assert: (Compiler evaluate: anArray storeString) = anArray.! !!ArrayTest methodsFor: 'testing' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := Array new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!ArrayTest methodsFor: 'testing' stamp: 'zz 12/5/2005 17:50'!testPremultiply	self assert: example1 +* #(2 ) = #(2 4 6 8 10 ) ! !!ArrayTest methodsFor: 'testing' stamp: 'ul 11/11/2009 16:27'!testPrinting	self assert: literalArray printString = '#(1 true 3 #four)'.	self assert: (literalArray = (Compiler evaluate: literalArray printString)).	self assert: selfEvaluatingArray printString =  '{1 . true . (3/4) . Color black . (2 to: 4) . 5}'.	self assert: (selfEvaluatingArray = (Compiler evaluate: selfEvaluatingArray printString)).	self assert: nonSEArray1 printString =  '{1 . a Set(1)}'.	self assert: nonSEarray2 printString =  '{#Array}'! !!ArrayTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Array. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!ArrayedCollection methodsFor: 'printing' stamp: 'tk 3/18/2005 17:57'!storeOn: aStream	(self size between: 1 and: 6) ifTrue: [^ self storeWithOn: aStream].	"(Array with: element)"	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new: '.	aStream store: self size.	aStream nextPut: $).	(self storeElementsFrom: 1 to: self size on: aStream)		ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!ArrayedCollection methodsFor: 'private' stamp: 'tk 3/18/2005 17:56'!storeWithOn: aStream	"Use (Array with: x with: x) if possible.  Sizes 1 to 6."	aStream nextPutAll: '('.	aStream nextPutAll: self class name.	self do: [:ele |		aStream nextPutAll: ' with: '.		ele storeOn: aStream].	aStream nextPut: $).! !!AssertionFailure commentStamp: 'gh 5/2/2002 20:29' prior: 0!AsssertionFailure is the exception signaled from Object>>assert: when the assertion block evaluates to false.!!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!Association methodsFor: 'comparing' stamp: 'eem 11/29/2008 11:09'!analogousCodeTo: anObject	"For MethodProperties comparison."	^anObject isVariableBinding	  and: [key = anObject key	  and: [value = anObject value]]! !!AssociationTest methodsFor: 'setup' stamp: 'zz 12/5/2005 18:33'!setUp	a := 1 -> 'one'.	b := 1 -> 'een'.! !!AssociationTest methodsFor: 'tests' stamp: 'md 3/8/2004 16:37'!testEquality		self 		assert: (a key = b key);		deny: (a value = b value);		deny: (a = b)! !!AssociationTest methodsFor: 'tests' stamp: 'nice 2/13/2010 05:25'!testHash	self 		assert: (a hash = a copy hash)! !!AsyncFile methodsFor: 'initialize' stamp: 'ar 6/1/2007 21:59'!initialize	"Initialize the receiver"	super initialize.	position := 0.! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:56'!next: anInteger into: buffer startingAt: startIndex	"Read n bytes into the given buffer.  Return aCollection or a partial copy if less than	n elements have been read."	| n |	self primReadStart: fileHandle fPosition: position count: anInteger.	[semaphore wait.	n := self primReadResult: fileHandle intoBuffer: buffer at: startIndex count: anInteger.	n = Busy] whileTrue.  "loop while busy in case the semaphore had excess signals"	n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].	position := position + n.	n = anInteger		ifTrue:[^buffer]		ifFalse:[^buffer copyFrom: 1 to: startIndex+n-1].! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:57'!next: anInteger putAll: aCollection	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aCollection startingAt: 1! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:57'!next: anInteger putAll: buffer startingAt: startIndex	"Store the next anInteger elements from the given collection."	| n count |	count := buffer size - startIndex + 1.	self primWriteStart: fileHandle		fPosition: position		fromBuffer: buffer		at: startIndex		count: count.	[semaphore wait.	n := self primWriteResult: fileHandle.	n = Busy] whileTrue.  "loop while busy in case the semaphore had excess signals"	n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].	n = count ifFalse: [^ self error: 'did not write the entire buffer'].	position := position + n.! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:58'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:59'!nextInto: aCollection startingAt: startIndex	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !!AsyncFile methodsFor: 'read/write' stamp: 'ar 6/1/2007 21:58'!nextPutAll: aCollection	"Store the entire collection on the receiver"	^self next: aCollection size putAll: aCollection startingAt: 1! !!AsyncFile methodsFor: 'accessing' stamp: 'ar 6/1/2007 22:01'!position	^position! !!AsyncFile methodsFor: 'accessing' stamp: 'ar 6/1/2007 22:01'!position: anInteger	position := anInteger! !!AsyncFile commentStamp: '<historical>' prior: 0!An asynchronous file allows simple file read and write operations to be performed in parallel with other processing. This is useful in multimedia applications that need to stream large amounts of sound or image data from or to a file while doing other work.!!AutoStart class methodsFor: 'class initialization' stamp: 'eem 10/23/2008 15:12'!deinstall	"AutoStart deinstall"	Smalltalk removeFromStartUpList: AutoStart.	Smalltalk removeFromShutDownList: AutoStart.	InstalledLaunchers := nil! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 6/16/2002 17:24'!read24BmpFile	"Read 24-bit pixel data from the given a BMP stream."	| form formBits pixelLine bitsIndex |	form := Form extent: biWidth@biHeight depth: 32.	pixelLine := ByteArray new: (((24 * biWidth) + 31) // 32) * 4.	bitsIndex := form height - 1 * biWidth + 1.	formBits := form bits.	1 to: biHeight do: [:i |		pixelLine := stream nextInto: pixelLine.		self read24BmpLine: pixelLine into: formBits startingAt: bitsIndex width: biWidth.		bitsIndex := bitsIndex - biWidth.	].	^ form! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 6/16/2002 18:47'!read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width	| pixIndex rgb bitsIndex |	<primitive: 'primitiveRead24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := 			(pixelLine at: (pixIndex := pixIndex+1)) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).		rgb = 0 ifTrue:[rgb := 16rFF000001] ifFalse:[rgb := rgb + 16rFF000000].		formBits at: (bitsIndex := bitsIndex+1) put: rgb.	].! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 9/27/2007 20:32'!store24BitBmpLine: pixelLine from: formBits startingAt: formBitsIndex width: width	| pixIndex rgb bitsIndex |	<primitive: 'primitiveWrite24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := (formBits at: (bitsIndex := bitsIndex+1)) bitAnd: 16rFFFFFF.		pixelLine at: (pixIndex := pixIndex+1) put: (rgb bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -8) bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -16) bitAnd: 255).	].! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/25/2005 02:22'!bmpData16bit	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest16b.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk24AAAAAAAAADYAAAAoAAAACAAAAAgAAAABABAAAAAAAIIAAADDDgAAww4AAAAAAAAAAAAA4APgA+AD4AMfAB8AHwAfAOAD4APgA+ADHwAfAB8AHwDgA+AD/3//f/9//38fAB8A4APgA/9//3//f/9/HwAfAAAAAAD/f/9//3//fwB8AHwAAAAA/3//f/9//38AfAB8AAAAAAAAAAAAfAB8AHwAfAAAAAAAAAAAAHwAfAB8AHwAAA==' readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/24/2005 21:27'!bmpData24bit	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest24.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk32AAAAAAAAADYAAAAoAAAACAAAAAgAAAABABgAAAAAAAAAAADEDgAAxA4AAAAAAAAAAAAAAP8AAP8AAP8AAP8A/wAA/wAA/wAA/wAAAP8AAP8AAP8AAP8A/wAA/wAA/wAA/wAAAP8AAP8A/////////////////wAA/wAAAP8AAP8A/////////////////wAA/wAAAAAAAAAA////////////////AAD/AAD/AAAAAAAA////////////////AAD/AAD/AAAAAAAAAAAAAAAAAAD/AAD/AAD/AAD/AAAAAAAAAAAAAAAAAAD/AAD/AAD/AAD/' readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/25/2005 02:22'!bmpData32bit	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest32b.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk04AQAAAAAAADYAAAAoAAAACAAAAAgAAAABACAAAAAAAAIBAADDDgAAww4AAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAP8AAAD/AAAA/wAAAP8AAAAA/wAAAP8AAAD/AAAA/wAA/wAAAP8AAAD/AAAA/wAAAAD/AAAA/wAA////AP///wD///8A////AP8AAAD/AAAAAP8AAAD/AAD///8A////AP///wD///8A/wAAAP8AAAAAAAAAAAAAAP///wD///8A////AP///wAAAP8AAAD/AAAAAAAAAAAA////AP///wD///8A////AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAD/AAAA'readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/24/2005 21:41'!bmpData4bit	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest4.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk12BAAAAAAAADYEAAAoAAAACAAAAAgAAAABAAgAAAAAAEAAAADEDgAAxA4AAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwADA3MAA8MqmAAAgQAAAIGAAACCAAAAgoAAAIMAAACDgAABAAAAAQCAAAEBAAABAYAAAQIAAAECgAABAwAAAQOAAAGAAAABgIAAAYEAAAGBgAABggAAAYKAAAGDAAABg4AAAgAAAAIAgAACAQAAAgGAAAICAAACAoAAAgMAAAIDgAACgAAAAoCAAAKBAAACgYAAAoIAAAKCgAACgwAAAoOAAAMAAAADAIAAAwEAAAMBgAADAgAAAwKAAAMDAAADA4AAA4AAAAOAgAADgQAAA4GAAAOCAAADgoAAA4MAAAODgAEAAAABAACAAQABAAEAAYABAAIAAQACgAEAAwABAAOAAQCAAAEAgIABAIEAAQCBgAEAggABAIKAAQCDAAEAg4ABAQAAAQEAgAEBAQABAQGAAQECAAEBAoABAQMAAQEDgAEBgAABAYCAAQGBAAEBgYABAYIAAQGCgAEBgwABAYOAAQIAAAECAIABAgEAAQIBgAECAgABAgKAAQIDAAECA4ABAoAAAQKAgAECgQABAoGAAQKCAAECgoABAoMAAQKDgAEDAAABAwCAAQMBAAEDAYABAwIAAQMCgAEDAwABAwOAAQOAAAEDgIABA4EAAQOBgAEDggABA4KAAQODAAEDg4ACAAAAAgAAgAIAAQACAAGAAgACAAIAAoACAAMAAgADgAIAgAACAICAAgCBAAIAgYACAIIAAgCCgAIAgwACAIOAAgEAAAIBAIACAQEAAgEBgAIBAgACAQKAAgEDAAIBA4ACAYAAAgGAgAIBgQACAYGAAgGCAAIBgoACAYMAAgGDgAICAAACAgCAAgIBAAICAYACAgIAAgICgAICAwACAgOAAgKAAAICgIACAoEAAgKBgAICggACAoKAAgKDAAICg4ACAwAAAgMAgAIDAQACAwGAAgMCAAIDAoACAwMAAgMDgAIDgAACA4CAAgOBAAIDgYACA4IAAgOCgAIDgwACA4OAAwAAAAMAAIADAAEAAwABgAMAAgADAAKAAwADAAMAA4ADAIAAAwCAgAMAgQADAIGAAwCCAAMAgoADAIMAAwCDgAMBAAADAQCAAwEBAAMBAYADAQIAAwECgAMBAwADAQOAAwGAAAMBgIADAYEAAwGBgAMBggADAYKAAwGDAAMBg4ADAgAAAwIAgAMCAQADAgGAAwICAAMCAoADAgMAAwIDgAMCgAADAoCAAwKBAAMCgYADAoIAAwKCgAMCgwADAoOAAwMAAAMDAIADAwEAAwMBgAMDAgADAwKAA8Pv/AKSgoACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////APr6+vr8/Pz8+vr6+vz8/Pz6+v/////8/Pr6//////z8AAD/////+fkAAP/////5+QAAAAD5+fn5AAAAAPn5+fk=' readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/24/2005 21:27'!bmpData8bit	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest8.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk12BAAAAAAAADYEAAAoAAAACAAAAAgAAAABAAgAAAAAAEAAAADEDgAAxA4AAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwADA3MAA8MqmAAAgQAAAIGAAACCAAAAgoAAAIMAAACDgAABAAAAAQCAAAEBAAABAYAAAQIAAAECgAABAwAAAQOAAAGAAAABgIAAAYEAAAGBgAABggAAAYKAAAGDAAABg4AAAgAAAAIAgAACAQAAAgGAAAICAAACAoAAAgMAAAIDgAACgAAAAoCAAAKBAAACgYAAAoIAAAKCgAACgwAAAoOAAAMAAAADAIAAAwEAAAMBgAADAgAAAwKAAAMDAAADA4AAA4AAAAOAgAADgQAAA4GAAAOCAAADgoAAA4MAAAODgAEAAAABAACAAQABAAEAAYABAAIAAQACgAEAAwABAAOAAQCAAAEAgIABAIEAAQCBgAEAggABAIKAAQCDAAEAg4ABAQAAAQEAgAEBAQABAQGAAQECAAEBAoABAQMAAQEDgAEBgAABAYCAAQGBAAEBgYABAYIAAQGCgAEBgwABAYOAAQIAAAECAIABAgEAAQIBgAECAgABAgKAAQIDAAECA4ABAoAAAQKAgAECgQABAoGAAQKCAAECgoABAoMAAQKDgAEDAAABAwCAAQMBAAEDAYABAwIAAQMCgAEDAwABAwOAAQOAAAEDgIABA4EAAQOBgAEDggABA4KAAQODAAEDg4ACAAAAAgAAgAIAAQACAAGAAgACAAIAAoACAAMAAgADgAIAgAACAICAAgCBAAIAgYACAIIAAgCCgAIAgwACAIOAAgEAAAIBAIACAQEAAgEBgAIBAgACAQKAAgEDAAIBA4ACAYAAAgGAgAIBgQACAYGAAgGCAAIBgoACAYMAAgGDgAICAAACAgCAAgIBAAICAYACAgIAAgICgAICAwACAgOAAgKAAAICgIACAoEAAgKBgAICggACAoKAAgKDAAICg4ACAwAAAgMAgAIDAQACAwGAAgMCAAIDAoACAwMAAgMDgAIDgAACA4CAAgOBAAIDgYACA4IAAgOCgAIDgwACA4OAAwAAAAMAAIADAAEAAwABgAMAAgADAAKAAwADAAMAA4ADAIAAAwCAgAMAgQADAIGAAwCCAAMAgoADAIMAAwCDgAMBAAADAQCAAwEBAAMBAYADAQIAAwECgAMBAwADAQOAAwGAAAMBgIADAYEAAwGBgAMBggADAYKAAwGDAAMBg4ADAgAAAwIAgAMCAQADAgGAAwICAAMCAoADAgMAAwIDgAMCgAADAoCAAwKBAAMCgYADAoIAAwKCgAMCgwADAoOAAwMAAAMDAIADAwEAAwMBgAMDAgADAwKAA8Pv/AKSgoACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////APr6+vr8/Pz8+vr6+vz8/Pz6+v/////8/Pr6//////z8AAD/////+fkAAP/////5+QAAAAD5+fn5AAAAAPn5+fk=' readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/25/2005 14:04'!bmpDataR5G6B5	"This is a BMP file based on BitmapV4Header which is currently unsupported."	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest16-R5G6B5.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk3IAAAAAAAAAEYAAAA4AAAACAAAAAgAAAABABAAAwAAAIIAAADDDgAAww4AAAAAAAAAAAAAAPgAAOAHAAAfAAAAAAAAAOAH4AfgB+AHHwAfAB8AHwDgB+AH4AfgBx8AHwAfAB8A4AfgB///////////HwAfAOAH4Af//////////x8AHwAAAAAA//////////8A+AD4AAAAAP//////////APgA+AAAAAAAAAAAAPgA+AD4APgAAAAAAAAAAAD4APgA+AD4AAA='readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/25/2005 14:04'!bmpDataX4R4G4B4	"This is a BMP file based on BitmapV4Header which is currently unsupported."	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest16-X4R4G4B4.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk3IAAAAAAAAAEYAAAA4AAAACAAAAAgAAAABABAAAwAAAIIAAADDDgAAww4AAAAAAAAAAAAAAA8AAPAAAAAPAAAAAAAAAPAA8ADwAPAADwAPAA8ADwDwAPAA8ADwAA8ADwAPAA8A8ADwAP8P/w//D/8PDwAPAPAA8AD/D/8P/w//Dw8ADwAAAAAA/w//D/8P/w8ADwAPAAAAAP8P/w//D/8PAA8ADwAAAAAAAAAAAA8ADwAPAA8AAAAAAAAAAAAPAA8ADwAPAAA='readStream) contents! !!BMPReadWriterTest methodsFor: 'data' stamp: 'ar 10/25/2005 14:05'!bmpDataX8R8G8B8	"This is a BMP file based on BitmapV4Header which is currently unsupported."	"Created via:		(Base64MimeConverter mimeEncode: 			(FileStream readOnlyFileNamed: 'bmptest32-X8R8G8B8.bmp') binary)				contents	"	^(Base64MimeConverter mimeDecodeToBytes:'Qk1IAQAAAAAAAEYAAAA4AAAACAAAAAgAAAABACAAAwAAAAIBAADDDgAAww4AAAAAAAAAAAAAAAAA/wAA/wAA/wAAAAAAAAAA/wAAAP8AAAD/AAAA/wAA/wAAAP8AAAD/AAAA/wAAAAD/AAAA/wAAAP8AAAD/AAD/AAAA/wAAAP8AAAD/AAAAAP8AAAD/AAD///8A////AP///wD///8A/wAAAP8AAAAA/wAAAP8AAP///wD///8A////AP///wD/AAAA/wAAAAAAAAAAAAAA////AP///wD///8A////AAAA/wAAAP8AAAAAAAAAAAD///8A////AP///wD///8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAA=='readStream) contents! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 10/25/2005 13:46'!testBmp16Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData16bit).	form := reader nextImage.	"special black here to compensate for zero-is-transparent effect"	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.	self assert: (form pixelValueAt: 1@1) = 16r8000.! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 7/27/2010 12:17'!testBmp24Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData24bit).	form := reader nextImage.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.	self assert: (form pixelValueAt: 1@1) = 16rFF000001.! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 10/25/2005 13:46'!testBmp32Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData32bit).	form := reader nextImage.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.	self assert: (form pixelValueAt: 1@1) = 16rFF000000.! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 10/24/2005 21:42'!testBmp4Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData4bit).	form := reader nextImage.	self assert: (form colorAt: 1@1) = Color black.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 10/24/2005 21:30'!testBmp8Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData8bit).	form := reader nextImage.	self assert: (form colorAt: 1@1) = Color black.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.! !!BadEqualer methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!= other 	self class = other class		ifFalse: [^ false].	^ 100 atRandom < 30 ! !!BadEqualer commentStamp: 'mjr 8/20/2003 13:28' prior: 0!I am an object that doesn't always report #= correctly.  Used for testing the EqualityTester.!!BadHasher methodsFor: 'comparing' stamp: 'mjr 8/20/2003 18:56'!hash	"answer with a different hash some of the time"	100 atRandom < 30		ifTrue: [^ 1]. 	^ 2! !!BadHasher commentStamp: 'mjr 8/20/2003 13:28' prior: 0!I am an object that doesn't always hash correctly.  I am used for testing the HashTester.!!BagTest methodsFor: 'basic tests' stamp: 'sd 3/21/2006 22:28'!testAdd	"self run: #testAdd"	"self debug: #testAdd"	| aBag |	aBag := Bag new.	aBag add: 'a'.	aBag add: 'b'.		self assert: aBag size = 2.	aBag add: 'a'.	self assert: aBag size = 3.	self assert: (aBag occurrencesOf: 'a') = 2	! !!BagTest methodsFor: 'basic tests' stamp: 'sd 3/21/2006 22:28'!testAddWithOccurrences	"self debug:#testAddWithOccurrences"		| aBag | 	aBag := Bag new.		aBag add: 'a' withOccurrences: 3.	self assert: (aBag size = 3).						! !!BagTest methodsFor: 'basic tests' stamp: 'TJ 3/8/2006 08:42'!testAsBag	| aBag | 	aBag := Bag new.			self assert: aBag asBag = aBag.! !!BagTest methodsFor: 'basic tests' stamp: 'sd 3/21/2006 22:29'!testAsSet	| aBag aSet |	aBag := Bag new.		aBag add:'a' withOccurrences: 4.	aBag add:'b' withOccurrences: 2.	aSet := aBag asSet.	self assert: aSet size = 2.	self assert: (aSet occurrencesOf: 'a') = 1 	! !!BagTest methodsFor: 'basic tests' stamp: 'sd 3/21/2006 22:30'!testCopy	"self run: #testCopy"		| aBag newBag |	aBag := Bag new.	aBag add:'a' withOccurrences: 4.	aBag add:'b' withOccurrences: 2.	newBag := aBag copy.	self assert: newBag = newBag.	self assert: newBag asSet size = 2.! !!BagTest methodsFor: 'basic tests' stamp: 'sd 3/21/2006 22:32'!testOccurrencesOf	"self debug: #testOccurrencesOf"	| aBag | 	aBag := Bag new.		aBag add: 'a' withOccurrences: 3.	aBag add: 'b'.	aBag add: 'b'.	aBag add: 'b'.	aBag add: 'b'.		self assert: (aBag occurrencesOf:'a') = 3.	self assert: (aBag occurrencesOf:'b') = 4.	self assert: (aBag occurrencesOf:'c') = 0.	self assert: (aBag occurrencesOf: nil) =0.	aBag add: nil.	self assert: (aBag occurrencesOf: nil) =1.	! !!BagTest methodsFor: 'tests' stamp: 'EP 2/28/2006 09:56'!testCreation	"self run: #testCreation"	"self debug: #testCreation"			| bag |	bag := Bag new.	self assert: (bag size) = 0.	self assert: (bag isEmpty).	! !!BagTest methodsFor: 'tests' stamp: 'EP 2/28/2006 10:05'!testCumulativeCounts	"self run: #testCumulativeCounts"	"self debug: #testCumulativeCounts"			| bag cumulativeCounts |	bag := Bag new.	bag add: '1' withOccurrences: 50.	bag add: '2' withOccurrences: 40.	bag add: '3' withOccurrences: 10.		cumulativeCounts := bag cumulativeCounts.		self assert: cumulativeCounts size = 3.	self assert: cumulativeCounts first = (50 -> '1').	self assert: cumulativeCounts second = (90 -> '2').	self assert: cumulativeCounts third = (100 -> '3').! !!BagTest methodsFor: 'tests' stamp: 'EP 3/8/2006 08:39'!testEqual	"(self run: #testEqual)"	"(self debug: #testEqual)"	| bag1 bag2 |	bag1 := Bag new.	bag2 := Bag new.	self assert: bag1 = bag2.	bag1 add: #a;		 add: #b.	bag2 add: #a;		 add: #a.	self deny: bag1 = bag2.	self assert: bag1 = bag1.	bag1 add: #a.	bag2 add: #b.	self assert: bag1 = bag2.	bag1 add: #c.	self deny: bag1 = bag2.	bag2 add: #c.	self assert: bag1 = bag2! !!BagTest methodsFor: 'tests' stamp: 'EP 2/28/2006 09:57'!testRemove	"self run: #testRemove"	"self debug: #testRemove"		| bag item |	item := 'test item'.	bag := Bag new.		bag add: item.	self assert: (bag size) = 1.	bag remove: item.	self assert: bag isEmpty.		bag add: item withOccurrences: 2.	bag remove: item.	bag remove: item.	self assert: (bag size) = 0.		self should: [bag remove: item.] raise: Error.! !!BagTest methodsFor: 'tests' stamp: 'nice 9/14/2009 21:05'!testRemoveAll	"Allows one to remove all elements of a collection" 		| c1 c2 s2 |	c1 := #(10 9 8 7 5 4 4 2) asBag.	c2 := c1 copy.	s2 := c2 size.		c1 removeAll.		self assert: c1 size = 0.	self assert: c2 size = s2 description: 'the copy has not been modified'.! !!BagTest methodsFor: 'tests' stamp: 'EP 2/28/2006 09:48'!testSortedCounts	"self run: #testSortedCounts"	"self debug: #testSortedCounts"		| bag sortedCounts|	bag := Bag new.	bag add: '1' withOccurrences: 10.	bag add: '2' withOccurrences: 1.	bag add: '3' withOccurrences: 5.		sortedCounts := bag sortedCounts.	self assert: sortedCounts size = 3.		self assert: sortedCounts first = (10->'1').	self assert: sortedCounts second =  (5->'3').	self assert: sortedCounts third =  (1->'2').	! !!BagTest methodsFor: 'tests' stamp: 'EP 2/28/2006 09:48'!testSortedElements	"self run: #testSortedElements"	"self debug: #testSortedElements"		| bag sortedElements|	bag := Bag new.	bag add: '2' withOccurrences: 1.	bag add: '1' withOccurrences: 10.	bag add: '3' withOccurrences: 5.		sortedElements := bag sortedElements.		self assert: sortedElements size = 3.		self assert: sortedElements first = ('1'->10).	self assert: sortedElements second =  ('2'->1).	self assert: sortedElements third =  ('3'->5).	! !!BalloonCanvas methodsFor: 'drawing' stamp: 'jcg 11/17/2008 17:03'!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel == 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonEngine methodsFor: 'accessing' stamp: 'ar 7/7/2007 11:12'!bitBlt: aBitBlt	| destWidth |	bitBlt := aBitBlt.	bitBlt isNil ifTrue:[^self].	destWidth := bitBlt destForm width.	destWidth > span size ifTrue:[span := Bitmap new: destWidth].	self class primitiveSetBitBltPlugin: bitBlt getPluginName.	self clipRect: bitBlt clipRect.	bitBlt 		sourceForm: (Form extent: span size @ 1 depth: 32 bits: span);		sourceRect: (0@0 extent: 1@span size);		colorMap: (Color colorMapIfNeededFrom: 32 to: bitBlt destForm depth);		combinationRule: (bitBlt destForm depth >= 8 ifTrue:[34] ifFalse:[Form paint]).! !!BalloonEngine methodsFor: 'initialize' stamp: 'ar 7/7/2007 11:11'!initialize	externals := OrderedCollection new: 100.	span := Bitmap new: 2048.	bitBlt := nil.	self bitBlt: ((BitBlt toForm: Display) destRect: Display boundingBox; yourself).	forms := #().	deferred := false.! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:48'!primClipRectInto: rect	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primFlushNeeded	<primitive: 'primitiveNeedsFlush' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primFlushNeeded: aBoolean	<primitive: 'primitiveNeedsFlushPut' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetAALevel	"Set the AA level"	<primitive: 'primitiveGetAALevel' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetBezierStats: statsArray	<primitive: 'primitiveGetBezierStats' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetClipRect: rect	<primitive: 'primitiveGetClipRect' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetCounts: statsArray	<primitive: 'primitiveGetCounts' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primGetDepth	<primitive: 'primitiveGetDepth' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetFailureReason	<primitive: 'primitiveGetFailureReason' module: 'B2DPlugin' error: errorCode>	^0! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetOffset	<primitive: 'primitiveGetOffset' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primGetTimes: statsArray	<primitive: 'primitiveGetTimes' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primSetAALevel: level	"Set the AA level"	<primitive: 'primitiveSetAALevel' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primSetClipRect: rect	<primitive: 'primitiveSetClipRect' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primSetColorTransform: transform	<primitive: 'primitiveSetColorTransform' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primSetDepth: depth	<primitive: 'primitiveSetDepth' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primSetEdgeTransform: transform	<primitive: 'primitiveSetEdgeTransform' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-access' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primSetOffset: point	<primitive: 'primitiveSetOffset' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveAddBezier' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierFrom: start to: end via: via leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'primitiveAddBezierShape' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBezierShape: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	<primitive: 'primitiveAddBitmapFill' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddBitmapFill: form colormap: cmap tile: tileFlag from: origin along: direction normal: normal xIndex: xIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	<primitive: 'primitiveAddCompressedShape' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddCompressedShape: points segments: nSegments leftFills: leftFills rightFills: rightFills lineWidths: lineWidths lineFills: lineFills fillIndexList: fillIndexList	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveRegisterExternalEdge' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalEdge: index initialX: initialX initialY: initialY initialZ: initialZ leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddExternalFill: index	<primitive: 'primitiveRegisterExternalFill' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddExternalFill: index	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddGradientFill: colorRamp from: origin along: direction normal: normal radial: isRadial	<primitive: 'primitiveAddGradientFill' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddGradientFill: colorRamp 				from: origin 				along: direction 				normal: normal 				radial: isRadial	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	<primitive: 'primitiveAddLine' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddLineFrom: start to: end leftFillIndex: leftFillIndex rightFillIndex: rightFillIndex	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'primitiveAddOval' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddOvalFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	<primitive: 'primitiveAddPolygon' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddPolygon: points segments: nSegments fill: fillStyle lineWidth: lineWidth lineFill: lineFill	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-adding' stamp: 'ar (auto errcode) 2/2/2001 15:47'!primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	<primitive: 'primitiveAddRect' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddRectFrom: start to: end fillIndex: fillIndex borderWidth: width borderColor: pixelValue32	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:48'!primAddActiveEdgeTableEntryFrom: edgeEntry	"Add edge entry to the AET."	<primitive: 'primitiveAddActiveEdgeEntry' module: 'B2DPlugin' error: errorCode>	(self canProceedAfter: self primGetFailureReason) ifTrue:[		^self primAddActiveEdgeTableEntryFrom: edgeEntry	].	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:48'!primChangeActiveEdgeTableEntryFrom: edgeEntry	"Change the entry in the active edge table from edgeEntry"	<primitive: 'primitiveChangedActiveEdgeEntry' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:48'!primDisplaySpanBuffer	"Display the current scan line if necessary"	<primitive: 'primitiveDisplaySpanBuffer' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primFinishedProcessing	"Return true if there are no more entries in AET and GET and the last scan line has been displayed"	<primitive: 'primitiveFinishedProcessing' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primInitializeProcessing	"Initialize processing in the GE.	Create the active edge table and sort it."	<primitive: 'primitiveInitializeProcessing' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primMergeFill: fillBitmap from: fill	"Merge the filled bitmap into the current output buffer."	<primitive: 'primitiveMergeFillFrom' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primNextActiveEdgeEntryInto: edgeEntry	"Store the next entry of the AET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'primitiveNextActiveEdgeEntry' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primNextFillEntryInto: fillEntry	"Store the next fill entry of the active edge table in fillEntry.	Return false if there is no such entry, true otherwise"	<primitive: 'primitiveNextFillEntry' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primNextGlobalEdgeEntryInto: edgeEntry	"Store the next entry of the GET at the current y-value in edgeEntry.	Return false if there is no entry, true otherwise."	<primitive: 'primitiveNextGlobalEdgeEntry' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primRenderImage: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'primitiveRenderImage' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-incremental' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primRenderScanline: edge with: fill	"Start/Proceed rendering the current scan line"	<primitive: 'primitiveRenderScanline' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar (auto errcode) 2/2/2001 15:48'!primCopyBufferFrom: oldBuffer to: newBuffer	"Copy the contents of oldBuffer into the (larger) newBuffer"	<primitive: 'primitiveCopyBuffer' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine methodsFor: 'primitives-misc' stamp: 'ar (auto errcode) 2/2/2001 15:49'!primInitializeBuffer: buffer	<primitive: 'primitiveInitializeBuffer' module: 'B2DPlugin' error: errorCode>	^self primitiveFailed! !!BalloonEngine class methodsFor: 'accessing' stamp: 'ar (auto errcode) 2/2/2001 15:47'!doProfileStats: aBool	"Note: On Macintosh systems turning on profiling can significantly	degrade the performance of Balloon since we're using the high	accuracy timer for measuring."	"BalloonEngine doProfileStats: true"	"BalloonEngine doProfileStats: false"	<primitive: 'primitiveDoProfileStats' module: 'B2DPlugin' error: errorCode>	^false! !!BalloonEngine class methodsFor: 'private' stamp: 'ar (auto errcode) 5/28/2000 22:17'!primitiveSetBitBltPlugin: pluginName	<primitive: 'primitiveSetBitBltPlugin' module: 'B2DPlugin' error: errorCode>	^nil! !!BalloonEngineConstants class methodsFor: 'pool definition' stamp: 'eem 6/4/2009 18:07'!initPrimitiveConstants	"Initialize the primitive constants"	"Primitive type constants"	GEPrimitiveUnknown := 0.	GEPrimitiveEdgeMask := 16rFF.	GEPrimitiveFillMask := 16rFF00.	GEPrimitiveTypeMask := 16rFFFF.	"General state constants (Note: could be compressed later)"	GEObjectType := 0.				"Type of object"	GEObjectLength := 1.			"Length of object"	GEObjectIndex := 2.			"Index into external objects"	GEObjectUnused := 3.			"Currently unused"	"Primitive failure codes"	GEFAlreadyFailed := 100.	GEFEngineIsInteger := 101.	GEFEngineIsWords := 102.	GEFEngineTooSmall := 103.	GEFEngineStopped := 104.	GEFWorkBufferIsInteger := 105.	GEFWorkBufferIsPointers := 106.	GEFWorkBufferTooSmall := 107.	GEFWorkBufferBadMagic := 108.	GEFWorkBufferWrongSize := 109.	GEFWorkBufferStartWrong := 110.	GEFWorkTooBig := 111.	GEFEdgeDataTooSmall := 112.	GEFFillDataTooSmall := 113.	GEFClassMismatch := 114.	GEFSizeMismatch := 115.	GEFWrongState := 116.	GEFWrongFill := 117.	GEFWrongEdge := 118.	GEFEntityLoadFailed := 119.	GEFEntityCheckFailed := 120.	GEFBadPoint := 121.	GEFBitBltLoadFailed := 122.	GEFFormLoadFailed := 123! !!BalloonFontTest methodsFor: 'tests' stamp: 'sd 12/9/2001 21:44'!testDefaultFont	"(self selector: #testDefaultFont) debug"	self assert: RectangleMorph new balloonFont = BalloonMorph balloonFont.	self assert: RectangleMorph new defaultBalloonFont = BalloonMorph balloonFont.! !!BalloonFontTest methodsFor: 'tests' stamp: 'sd 12/9/2001 21:55'!testSpecificFont	"(self selector: #testSpecificFont) debug"	| aMorph |	aMorph := RectangleMorph new.	self assert: RectangleMorph new balloonFont = BalloonMorph balloonFont.	self assert: RectangleMorph new defaultBalloonFont = BalloonMorph balloonFont.	aMorph		balloonFont: (StrikeFont familyName: #ComicPlain size: 19).	self assert: aMorph balloonFont			= (StrikeFont familyName: #ComicPlain size: 19).	"The next test is horrible because I do no know how to access the font 	with the appropiate interface"	self assert: (((BalloonMorph getTextMorph: 'lulu' for: aMorph) text runs at: 1)			at: 1) font			= (StrikeFont familyName: #ComicPlain size: 19)! !!Base64MimeConverterTest methodsFor: 'initialize-release' stamp: 'jcg 9/1/2009 00:21'!setUp	message := 'Hi There!!' readStream.! !!Base64MimeConverterTest methodsFor: 'tests' stamp: 'jcg 9/1/2009 00:23'!testBase64Encoded	| encoded |	encoded := (Base64MimeConverter mimeEncode: message) contents.	self assert: encoded = 'Hi There!!' base64Encoded.	! !!Base64MimeConverterTest methodsFor: 'tests' stamp: 'ar 3/9/2010 22:19'!testMimeEncodeDecode	| encoded |	encoded := Base64MimeConverter mimeEncode: message.	self assert: (encoded contents = 'SGkgVGhlcmUh').     self assert: ((Base64MimeConverter mimeDecodeToChars: encoded) contents = message contents).	"Encoding should start from the beginning of the stream."	message reset.	message skip: 2.	encoded := Base64MimeConverter mimeEncode: message.	self assert: (encoded contents = 'SGkgVGhlcmUh').		"Encoding should start from the current position of the stream."	message reset.	message skip: 2.	encoded := Base64MimeConverter mimeEncodeContinue: message.	self assert: (encoded contents = 'IFRoZXJlIQ==').! !!Base64MimeConverterTest methodsFor: 'tests' stamp: 'ar 3/9/2010 22:21'!testMimeEncodeDecodeMultiLine	| encoded |	encoded := (Base64MimeConverter mimeEncode: (String new: 100 withAll: $a) readStream) contents.	self assert: encoded = 'YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=='.	encoded := (Base64MimeConverter mimeEncode: (String new: 100 withAll: $a) readStream multiLine: false) contents.	self assert: encoded = 'YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ=='.! !!Base64MimeConverterTest methodsFor: 'tests' stamp: 'jcg 9/1/2009 00:38'!testOnByteArray	self assert: ('Hi There!!' base64Encoded = 'Hi There!!' asByteArray base64Encoded)! !!Base64MimeConverterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Base64MimeConverter. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:19'!testBehaviorClassClassDescriptionMetaclassHierarchy	"self run: #testBehaviorClassClassDescriptionMetaclassHierarchy"		self assert: Class superclass  == ClassDescription.	self assert: Metaclass superclass == ClassDescription.	self assert: ClassDescription superclass  == Behavior.	self assert: Behavior superclass  = Object.	self assert: Class class class ==  Metaclass.	self assert: Metaclass class class  == Metaclass.	self assert: ClassDescription class class == Metaclass.	self assert: Behavior class class == Metaclass.						! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'ar 1/1/2010 16:22'!testClassDescriptionAllSubInstances	"self run: #testClassDescriptionAllSubInstances"	| cdNo clsNo metaclsNo |	cdNo := ClassDescription allSubInstances size.	clsNo := Class allSubInstances size .	metaclsNo := Metaclass allSubInstances size.	"When traits are present, discount all traits if necessary"	Smalltalk at: #Trait ifPresent:[:aClass|		(aClass inheritsFrom: ClassDescription) 			ifTrue:[cdNo := cdNo - aClass instanceCount]].	Smalltalk at: #ClassTrait ifPresent:[:aClass|		(aClass inheritsFrom: ClassDescription) 			ifTrue:[cdNo := cdNo - aClass instanceCount]].	self assert: cdNo = (clsNo + metaclsNo).! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:17'!testMetaclass	"self run: #testMetaclass"		self assert: OrderedCollection class class == Metaclass.	self assert: Dictionary class class == Metaclass.	self assert: Object class class == Metaclass.						! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:12'!testMetaclassName	"self run: #testMetaclassName"	self assert: Dictionary class  name = 'Dictionary class'.	self assert: OrderedCollection class name = 'OrderedCollection class'.	! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:12'!testMetaclassNumberOfInstances	"self run: #testMetaclassNumberOfInstances"	self assert: Dictionary class allInstances size  = 1.	self assert: OrderedCollection class allInstances size  = 1.! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:18'!testMetaclassPointOfCircularity	"self run: #testMetaclassPointOfCircularity"	self assert: Metaclass class instanceCount = 1.	self assert: Metaclass class someInstance == Metaclass.						! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'ul 11/19/2009 01:53'!testMetaclassSuperclass	"self run: #testMetaclassSuperclass"	self assert: Dictionary class superclass == HashedCollection class.	self assert: OrderedCollection class superclass == SequenceableCollection class.	! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:14'!testMetaclassSuperclassHierarchy	"self run: #testMetaclassSuperclassHierarchy"	| s |	self assert: SequenceableCollection class instanceCount  = 1.	self assert: Collection class instanceCount  = 1.	self assert: Object class instanceCount  = 1.	self assert: ProtoObject class instanceCount  = 1.		s := OrderedCollection new.	s add: SequenceableCollection class.	s add: Collection class.	s add: Object class.	s add: ProtoObject class.	s add: Class.	s add: ClassDescription.	s add: Behavior.	s add: Object.	s add: ProtoObject.	self assert: OrderedCollection class allSuperclasses  = s.			! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'sd 6/5/2005 08:21'!testObjectAllSubclasses	"self run: #testObjectAllSubclasses"	| n2 |	n2 := Object allSubclasses size.	self assert: n2 = (Object allSubclasses			select: [:cls | cls class class == Metaclass					or: [cls class == Metaclass]]) size! !!BasicBehaviorClassMetaclassTest methodsFor: 'testing' stamp: 'ul 11/19/2009 01:53'!testSuperclass	"self run: #testSuperclass"	| s |	self assert: Dictionary superclass == HashedCollection.	self assert: OrderedCollection superclass == SequenceableCollection.	s := OrderedCollection new.	s add: SequenceableCollection.	s add: Collection.	s add: Object.	s add: ProtoObject.	self assert: OrderedCollection allSuperclasses = s.		! !!BasicBehaviorClassMetaclassTest commentStamp: '<historical>' prior: 0!This class contains some tests regarding the classes 	Behavior		ClassDescription			Class			Metaclass---	!!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:28'!testBecome	"Test the two way become. Note. we cannot use string literals for this test"	| a b c d |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	a become: b.	self 		assert: a = 'cd';		assert: b = 'ab';		assert: c = 'cd';		assert: d = 'ab'.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:28'!testBecomeForward	"Test the forward become."	| a b c d |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	a becomeForward: b.	self 		assert: a = 'cd';		assert: b = 'cd';		assert: c = 'cd';		assert: d = 'cd'.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 17:36'!testBecomeForwardDontCopyIdentityHash	"Check that		1. the argument to becomeForward: is NOT modified to have the receiver's identity hash.		2. the receiver's identity hash is unchanged." 	| a b hb |	a := 'ab' copy.	b := 'cd' copy.	hb := b identityHash.	a becomeForward: b copyHash: false.	self 		assert: a identityHash = hb;		assert: b identityHash = hb.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:29'!testBecomeForwardHash	| a b c hb |	a := 'ab' copy.	b := 'cd' copy.	c := a.	hb := b hash.	a becomeForward: b.	self 		assert: a hash = hb;		assert: b hash = hb;		assert: c hash = hb.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:27'!testBecomeForwardIdentityHash	"Check that		1. the argument to becomeForward: is modified to have the receiver's identity hash.		2. the receiver's identity hash is unchanged." 	| a b ha |	a := 'ab' copy.	b := 'cd' copy.	ha := a identityHash.	a becomeForward: b.	self 		assert: a identityHash = ha;		assert: b identityHash = ha.! !!BecomeTest methodsFor: 'Testing' stamp: 'brp 9/19/2003 15:30'!testBecomeHash	| a b c d ha hb |	a := 'ab' copy.	b := 'cd' copy.	c := a.	d := b.	ha := a hash.	hb := b hash.	a become: b.	self 		assert: a hash = hb;		assert: b hash = ha;		assert: c hash = hb;		assert: d hash = ha.! !!BecomeTest methodsFor: 'Testing' stamp: 'ar 8/16/2010 11:22'!testBecomeIdentityHash	"Note. The identity hash of both objects seems to change after the become:"	| a b c d |	a := 'ab' copy.	"Must make sure that we have a different hash here since Cog currently can	assign the same hash twice in a row"	[b := 'cd' copy.	a identityHash = b identityHash] whileTrue.	self deny: a identityHash = b identityHash.	c := a.	d := b.	a become: b.	self 		assert: a identityHash = c identityHash;		assert: b identityHash = d identityHash;		deny: a identityHash = b identityHash.! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'jcg 4/1/2009 16:10'!lastInstance	"Answer the 'last' instance of this class."	| instance |	instance := nil.	self allInstancesDo: [:inst | instance := inst].	^instance! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'jcg 4/1/2009 16:17'!lastSubInstance	"Answer the 'last' sub-instance of this class."	| instance |	instance := nil.	self allSubInstancesDo: [:inst | instance := inst].	^instance! !!Behavior methodsFor: 'compiling' stamp: 'eem 10/15/2008 11:20'!recompileAll	"Compile all the receiver's methods.	This validates sourceCode and variable references and forces	methods to use the current bytecode set"	self selectorsDo:		[:sel | self recompile: sel from: self]! !!Behavior methodsFor: 'instance creation' stamp: 'eem 5/22/2009 17:10'!adoptInstance: anObject	"Primitive. Change the class of the argument to make it an instance of the receiver	 given that the format of the receiver matches the format of the argument's class.	 Fail if receiver or argument are SmallIntegers, or the receiver is a compact class	 and the argument isn't an instance of a compact class, or when the argument's class	 is compact and the receiver isn't a compact class, or when the format of the receiver	 is different from the format of the argument's class, or when the arguments class is	 fixed and the receiver's size differs from the size that an instance of the argument's	 class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of	 a) the difference between compact and non-compact classes, and	 b) because of differences in the format.	As an example, 'Morph adoptInstance: (Array new: 3)' would fail for three of the reasons	 mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph	 is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too	 short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes	 changing shape) and not for casual use."	<primitive: 160 error: ec>	self primitiveFailed! !!Behavior methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:32'!startUp: resuming	"This message is sent to registered classes when the system is coming up.	 resuming will be true if a sapshot is being resumed.  resuming will be false	 if the system is merely reinitializing after writing a snapshot."	^self startUp! !!Behavior methodsFor: 'user interface' stamp: 'eem 6/30/2010 15:51'!allLocalCallsOn: aLiteral	"Answer a SortedCollection of all the methods that call on aLiteral, anywhere in my class hierarchy."	| aSet special byte cls thorough query |	aSet := Set new.	cls := self theNonMetaClass.	special := Smalltalk					hasSpecialSelector: aLiteral					ifTrueSetByte: [:b | byte := b ].	thorough := (aLiteral isSymbol)				and: ["Possibly search for symbols embedded in literal arrays"					Preferences thoroughSenders].	query := thorough				ifTrue: [#thoroughWhichSelectorsReferTo:special:byte:]				ifFalse: [#whichSelectorsReferTo:special:byte:].	cls withAllSuperAndSubclassesDoGently:		[ :class |		(class perform: query with: aLiteral with: special with: byte) do:			[:sel |			sel ~~ #DoIt ifTrue:				[aSet add: (MethodReference new setStandardClass: class methodSymbol: sel)]]].	cls class withAllSuperAndSubclassesDoGently:		[ :class |		(class perform: query with: aLiteral with: special with: byte) do:			[:sel |			sel ~~ #DoIt ifTrue: [aSet add: (MethodReference new setStandardClass: class methodSymbol: sel)]]].	^aSet! !!Behavior methodsFor: 'user interface' stamp: 'eem 6/11/2008 16:03'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	^ self allInstVarNames copy reject:		[:ivn | | any definingClass |		any := false.		definingClass := self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do:			[:class |  any ifFalse:				[(class whichSelectorsAccess: ivn asSymbol) do: 					[:sel | sel ~~ #DoIt ifTrue: [any := true]]]].			any]! !!Behavior methodsFor: '*Tools-Browser-accessors' stamp: 'eem 8/12/2009 11:45'!settersReturnValue	"Determine whether the browser's createInstVarAccessors code will generate	 setters that answer self (the default here) or the value set.  Classes that want	 to answer the value set (e.g. VMStructType) override."	^false! !!BehaviorTest methodsFor: 'as yet unclassified' stamp: 'md 2/18/2006 16:42'!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key = nil.! !!BehaviorTest methodsFor: 'tests' stamp: 'nice 12/25/2009 18:58'!sampleMessageWithFirstArgument: firstArgument "This is a comment intended to explain arg1"   andInterleavedCommentBeforeSecondArgument: secondArgument	"This method is here to test a few utilities like formalParametersAt:"		| thisIsAnUnusedTemp |	thisIsAnUnusedTemp := self.	^thisIsAnUnusedTemp! !!BehaviorTest methodsFor: 'tests' stamp: 'ul 12/3/2009 04:56'!testAllSelectors	self assert: ProtoObject allSelectors = ProtoObject selectors asIdentitySet.	self assert: Object allSelectors = (Object selectors union: ProtoObject selectors) asIdentitySet.! !!BehaviorTest methodsFor: 'tests' stamp: 'ul 12/3/2009 05:39'!testAllSelectorsBelow	self assert: (Object allSelectorsBelow: ProtoObject) = Object selectors asIdentitySet.	self assert: (Object allSelectorsBelow: nil) = (Object selectors union: ProtoObject selectors) asIdentitySet! !!BehaviorTest methodsFor: 'tests' stamp: 'sd 3/14/2004 18:11'!testBehaviorSubclasses	"self run: #testBehaviorSubclasses"		| b b2 |	b := Behavior new.	b superclass: OrderedCollection.	b methodDictionary: MethodDictionary new.	self shouldnt: [b subclasses ] raise: Error.	self shouldnt: [b withAllSubclasses] raise: Error.	self shouldnt: [b allSubclasses] raise: Error.	b2 := Behavior new.	b2 superclass: b.	b2 methodDictionary: MethodDictionary new.	self assert: (b subclasses includes: b2).	self assert: (b withAllSubclasses includes: b).! !!BehaviorTest methodsFor: 'tests' stamp: 'sd 11/19/2004 15:38'!testBehaviornewnewShouldNotCrash	Behavior new new.	"still not working correctly but at least does not crash the image"	! !!BehaviorTest methodsFor: 'tests' stamp: 'ar 9/27/2005 21:43'!testChange	"self debug: #testChange"	| behavior model |	behavior := Behavior new.	behavior superclass: Model.	behavior setFormat: Model format.	model := Model new.	model primitiveChangeClassTo: behavior new.	behavior compile: 'thisIsATest  ^ 2'.	self assert: model thisIsATest = 2.	self should: [Model new thisIsATest] raise: MessageNotUnderstood.! !!BehaviorTest methodsFor: 'tests' stamp: 'nice 12/25/2009 19:10'!testFormalParameterNames	| method |	method := #sampleMessageWithFirstArgument:andInterleavedCommentBeforeSecondArgument:.	self assert: (self class formalParametersAt: method) size = 2.	self assert: (self class formalParametersAt: method) asArray = #('firstArgument' 'secondArgument').	Object selectorsDo: [:e |		self assert: (Object formalParametersAt: e) size = e numArgs].! !!BitBlt methodsFor: 'accessing' stamp: 'ar 2/21/2000 22:06'!sourceForm	^ sourceForm! !!BitBlt methodsFor: 'accessing' stamp: 'ar 12/1/2003 12:50'!sourceForm: aForm 	"Set the receiver's source form to be the argument, aForm."	sourceForm := aForm.	sourceForm ifNotNil:[sourceForm := sourceForm asSourceForm].! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copy: destRectangle from: sourcePt in: srcForm	| destOrigin |	self sourceForm: srcForm.	halftoneForm := nil.	combinationRule := 3.  "store"	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	self sourceForm: srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule := rule.	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	srcForm == nil ifFalse:		[colorMap := srcForm colormapIfNeededFor: destForm].	^ self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copy: destRectangle from: sourcePt in: srcForm halftoneForm: hf rule: rule 	| destOrigin |	self sourceForm: srcForm.	self fillColor: hf.		"sets halftoneForm"	combinationRule := rule.	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:52'!copyForm: srcForm to: destPt rule: rule color: color	self sourceForm: srcForm.	halftoneForm := color.	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyForm: srcForm to: destPt rule: rule colorMap: map	self sourceForm: srcForm.	halftoneForm := nil.	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	colorMap := map.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyForm: srcForm to: destPt rule: rule fillColor: color	self sourceForm: srcForm.	self fillColor: color.	"sets halftoneForm"	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'ar 12/1/2003 12:51'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	self sourceForm: srcForm.	halftoneForm := nil.	combinationRule := 3.  "store"	destX := destPt x.	destY := destPt y.	sourceOrigin := sourceRectangle origin.	sourceX := sourceOrigin x.	sourceY := sourceOrigin y.	width := sourceRectangle width.	height := sourceRectangle height.	colorMap := srcForm colormapIfNeededFor: destForm.	self copyBits! !!BitBlt methodsFor: 'private' stamp: 'ar 3/15/2003 02:29'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	| sx sy dx dy bbW bbH |	"fill in the lazy state if needed"	destX ifNil:[destX := 0].	destY ifNil:[destY := 0].	width ifNil:[width := destForm width].	height ifNil:[height := destForm height].	sourceX ifNil:[sourceX := 0].	sourceY ifNil:[sourceY := 0].	clipX ifNil:[clipX := 0].	clipY ifNil:[clipY := 0].	clipWidth ifNil:[clipWidth := destForm width].	clipHeight ifNil:[clipHeight := destForm height].	destX >= clipX		ifTrue: [sx := sourceX.				dx := destX.				bbW := width]		ifFalse: [sx := sourceX + (clipX - destX).				bbW := width - (clipX - destX).				dx := clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW := bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy := sourceY.				dy := destY.				bbH := height]		ifFalse: [sy := sourceY + clipY - destY.				bbH := height - (clipY - destY).				dy := clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH := bbH - ((dy + bbH) - (clipY + clipHeight))].	sourceForm ifNotNil:[		sx < 0			ifTrue: [dx := dx - sx.					bbW := bbW + sx.					sx := 0].		sx + bbW > sourceForm width			ifTrue: [bbW := bbW - (sx + bbW - sourceForm width)].		sy < 0			ifTrue: [dy := dy - sy.					bbH := bbH + sy.					sy := 0].		sy + bbH > sourceForm height			ifTrue: [bbH := bbH - (sy + bbH - sourceForm height)].	].	(bbW <= 0 or:[bbH <= 0]) ifTrue:[		sourceX := sourceY := destX := destY := clipX := clipY := width := height := clipWidth := clipHeight := 0.		^true].	(sx = sourceX 		and:[sy = sourceY 		and:[dx = destX 		and:[dy = destY 		and:[bbW = width 		and:[bbH = height]]]]]) ifTrue:[^false].	sourceX := sx.	sourceY := sy.	destX := dx.	destY := dy.	width := bbW.	height := bbH.	^true! !!BitBlt methodsFor: 'private' stamp: 'dvd 4/15/2009 12:11'!installNativeFont: aNativeFont foregroundColor: fgColor backgroundColor: bgColor	self sourceForm: aNativeFont glyphs.	CachedNativeFontColorMaps ifNil: [CachedNativeFontColorMaps := Dictionary new].	colorMap := (CachedNativeFontColorMaps at: destForm depth ifAbsentPut: [Dictionary new])		at: (fgColor pixelWordForDepth: destForm depth)		ifAbsentPut: [self nativeFontColorMapFor: fgColor].	combinationRule := 	(destForm depth > 1)		ifTrue: [Form blend]		ifFalse: [Form paint].	halftoneForm := nil.	height := aNativeFont height.	sourceY := 0.! !!BitBlt methodsFor: 'private' stamp: 'df 7/15/2009 15:04'!nativeFontColorMapFor: aColor	| alphaBase |	alphaBase := aColor alpha.	^(destForm depth > 1)		ifTrue: [ColorMap colors: ((0 to: 255) collect: [ :i |			(aColor alpha: i * alphaBase / 255.0) pixelWordForDepth: destForm depth])]		ifFalse: [ColorMap colors: ((0 to: 255) collect: [ :i |			(aColor alpha: (i roundTo: 255) / 255.0) pixelWordForDepth: destForm depth])]! !!BitBlt methodsFor: 'private' stamp: 'ar 12/1/2003 12:52'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm := df.	self sourceForm: sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule := cr.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourceOrigin x.	sourceY := sourceOrigin y.	width := extent x.	height := extent y.	aPoint := clipRect origin.	clipX := aPoint x.	clipY := aPoint y.	aPoint := clipRect corner.	clipWidth := aPoint x - clipX.	clipHeight := aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap := sourceForm colormapIfNeededFor: destForm]! !!BitBlt commentStamp: 'ar 8/4/2009 20:19' prior: 0!WARNING: BitBlt's shape cannot be modified since WarpBlt relies on the exact layout.I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt class methodsFor: 'private' stamp: 'dvd 4/15/2009 12:42'!initialize	"BitBlt initialize"	CachedFontColorMaps := nil.	CachedNativeFontColorMaps := nil.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside2	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:33'!testDrawingWayOutside3	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside4	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside5	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:34'!testDrawingWayOutside6	| f1 bb f2 |	f1 := Form extent: 100@100 depth: 1.	f2 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb sourceForm: f2.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	bb sourceOrigin: SmallInteger maxVal squared asPoint.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: 100; height: 100.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside2	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: 0@0.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltClipBugs methodsFor: 'as yet unclassified' stamp: 'ar 3/8/2003 00:32'!testFillingWayOutside3	| f1 bb |	f1 := Form extent: 100@100 depth: 1.	bb := BitBlt toForm: f1.	bb combinationRule: 3.	bb fillColor: Color black.	bb destOrigin: SmallInteger maxVal squared asPoint.	bb width: SmallInteger maxVal squared; height: SmallInteger maxVal squared.	self shouldnt:[bb copyBits] raise: Error.! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:21'!testAllAlphasRgbAdd	"self run: #testAllAlphasRgbAdd"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 20.	"rgbAdd"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = (destAlpha + sourceAlpha min: 255)                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:21'!testAllAlphasRgbMax	"self run: #testAllAlphasRgbMax"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 27.	"rgbMax"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = (destAlpha max: sourceAlpha)                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:22'!testAllAlphasRgbMin	"self run: #testAllAlphasRgbMin"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 28.	"rgbMin"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = (destAlpha min: sourceAlpha)                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:22'!testAllAlphasRgbMinInvert	"self run: #testAllAlphasRgbMinInvert"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 29.	"rgbMinInvert"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = (destAlpha min: 255-sourceAlpha)                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:22'!testAllAlphasRgbMul	"self run: #testAllAlphasRgbMul"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 37.	"rgbMul"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = ((destAlpha+1) * (sourceAlpha+1)- 1 // 256)                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'jmv 10/26/2009 09:21'!testAllAlphasRgbSub	"self run: #testAllAlphasRgbSub"	| sourceForm destForm blt correctAlphas |     correctAlphas := 0.     0  to: 255 do: [:sourceAlpha |         sourceForm := Form extent: 1 @ 1 depth: 32.         sourceForm bits at: 1 put: sourceAlpha << 24 + (33 << 16) + (25 << 8) + 27.         0 to: 255 do: [:destAlpha |             destForm := Form extent: 1 @ 1 depth: 32.             destForm bits at: 1 put: destAlpha << 24 + (255 << 16) + (255 << 8) + 255.              blt := BitBlt new.              blt sourceForm: sourceForm.              blt sourceOrigin: 0 @ 0.              blt setDestForm: destForm.              blt destOrigin: 0 @ 0.              blt combinationRule: 21.	"rgbSub"              blt copyBits.              correctAlphas := correctAlphas                + (((blt destForm bits at: 1) digitAt: 4) = (destAlpha - sourceAlpha) abs                         ifTrue: [1]                         ifFalse: [0])      ]].     self assert: 65536 equals: correctAlphas! !!BitBltTest methodsFor: 'bugs' stamp: 'sd 6/5/2005 10:12'!testAlphaCompositing	"self run: #testAlphaCompositing"	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color blue.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBits.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: (result blue - (1.0 - mixColor alpha)) abs < eps.		self assert: result alpha = 1.0.	].! !!BitBltTest methodsFor: 'bugs' stamp: 'sd 6/5/2005 10:12'!testAlphaCompositing2	"self run: #testAlphaCompositing2"	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color transparent.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBits.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: result alpha = mixColor alpha.	].! !!BitBltTest methodsFor: 'bugs' stamp: 'nice 12/26/2009 00:24'!testAlphaCompositing2Simulated	"self run: #testAlphaCompositing2Simulated"	Smalltalk at: #BitBltSimulation ifPresent: [:bitblt|	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color transparent.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: result alpha = mixColor alpha.	].]! !!BitBltTest methodsFor: 'bugs' stamp: 'nice 12/26/2009 00:24'!testAlphaCompositingSimulated	"self run: #testAlphaCompositingSimulated"		Smalltalk at: #BitBltSimulation ifPresent:[:bitblt|	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color blue.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: (result blue - (1.0 - mixColor alpha)) abs < eps.		self assert: result alpha = 1.0.	]].! !!BitBltTest methodsFor: 'bugs' stamp: 'sd 6/5/2005 10:13'!testPeekerUnhibernateBug	"self run: #testPeekerUnhibernateBug"	| bitBlt |	bitBlt := BitBlt bitPeekerFromForm: Display.	bitBlt destForm hibernate.	self shouldnt:[bitBlt pixelAt: 1@1] raise: Error.! !!BitBltTest methodsFor: 'bugs' stamp: 'sd 6/5/2005 10:14'!testPokerUnhibernateBug	"self run: #testPokerUnhibernateBug"	| bitBlt |	bitBlt := BitBlt bitPokerToForm: Display.	bitBlt sourceForm hibernate.	self shouldnt:[bitBlt pixelAt: 1@1 put: 0] raise: Error.! !!BitEditor methodsFor: 'menu messages'!accept	"The edited information should now be accepted by the view."	view accept! !!BitEditor methodsFor: 'menu messages'!cancel	"The edited informatin should be forgotten by the view."	view cancel! !!BitEditor methodsFor: 'menu messages' stamp: 'CdG 10/17/2005 20:51'!fileOut	| fileName |	fileName := UIManager default 		request: 'File name?' translated		initialAnswer: 'Filename.form'.	fileName isEmpty ifTrue: [^ self].	Cursor normal		showWhile: [model writeOnFileNamed: fileName].! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:53'!getCurrentColor	| formExtent form c |	c := Color colorFromPixelValue: color depth: Display depth.	formExtent := 30@30" min: 10@ 10//(2+1@2)".  "compute this better"	form := Form extent: formExtent depth: Display depth.	form borderWidth: 5.	form border: form boundingBox width: 4 fillColor: Color white.	form fill: form boundingBox fillColor: c.	^form! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:21'!setColor: aColor 	"Set the color that the next edited dots of the model to be the argument,  	aSymbol. aSymbol can be any color changing message understood by a  	Form, such as white or black."	color := aColor pixelValueForDepth: Display depth.	squareForm fillColor: aColor.	self changed: #getCurrentColor! !!BitEditor methodsFor: 'menu messages' stamp: 'sma 3/15/2000 21:10'!setTransparentColor	squareForm fillColor: Color gray.	color := Color transparent! !!BitEditor methodsFor: 'menu messages'!test	view workingForm follow: [Sensor cursorPoint] while: [Sensor noButtonPressed].	Sensor waitNoButton! !!BitEditor methodsFor: 'basic control sequence'!controlInitialize	super controlInitialize.	Cursor crossHair show! !!BitEditor methodsFor: 'basic control sequence'!controlTerminate	Cursor normal show! !!BitEditor methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:04'!getPluggableYellowButtonMenu: shiftKeyState	^ YellowButtonMenu! !!BitEditor methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:52'!isControlActive	^ super isControlActive and: [sensor keyboardPressed not]! !!BitEditor methodsFor: 'control defaults'!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color := 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint := view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor methodsFor: 'initialize-release'!release	super release.	squareForm release.	squareForm := nil! !!BitEditor methodsFor: 'view access'!view: aView	super view: aView.	scale := aView transformation scale.		scale := scale x rounded @ scale y rounded.	squareForm := Form extent: scale depth: aView model depth.	squareForm fillBlack! !!BitEditor commentStamp: '<historical>' prior: 0!I am a bit-magnifying tool for editing small Forms directly on the display screen. I continue to be active until the user points outside of my viewing area.!!BitEditor class methodsFor: 'private' stamp: 'BG 12/4/2003 10:18'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView	"Create a BitEditor on aForm. That is, aForm is a small image that will 	change as a result of the BitEditor changing a second and magnified 	view of me. magnifiedFormLocation is where the magnified form is to be 	located on the screen. scaleFactor is the amount of magnification. This 	method implements a scheduled view containing both a small and 	magnified view of aForm. Upon accept, aForm is updated."	| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |	scaledFormView := FormHolderView new model: aForm.	scaledFormView scaleBy: scaleFactor.	bitEditor := self new.	scaledFormView controller: bitEditor.	bitEditor setColor: Color black.	topView := ColorSystemView new.	remoteView == nil ifTrue: [topView label: 'Bit Editor'].	topView borderWidth: 2.	topView addSubView: scaledFormView.	remoteView == nil		ifTrue:  "If no remote view, then provide a local view of the form"			[aFormView := FormView new model: scaledFormView workingForm.			aFormView controller: NoController new.			aForm height < 50				ifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 2]				ifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 0].			topView addSubView: aFormView below: scaledFormView]		 ifFalse:  "Otherwise, the remote one should view the same form"			[remoteView model: scaledFormView workingForm].	lowerRightExtent := remoteView == nil			ifTrue:				[(scaledFormView viewport width - aFormView viewport width) @					(aFormView viewport height max: 50)]			ifFalse:				[scaledFormView viewport width @ 50].	menuView := self buildColorMenu: lowerRightExtent colorCount: 1.	menuView model: bitEditor.	menuView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	topView		addSubView: menuView		align: menuView viewport topRight		with: scaledFormView viewport bottomRight.	extent := scaledFormView viewport extent + (0 @ lowerRightExtent y)			+ (4 @ 4).  "+4 for borders"	topView minimumSize: extent.	topView maximumSize: extent.	topView translateBy: magnifiedFormLocation.	topView insideColor: Color white.	^topView! !!BitEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 13:40'!buildColorMenu: extent colorCount: nColors	"See BitEditor magnifyWithSmall."	| menuView form aSwitchView	 button formExtent highlightForm color leftOffset |	menuView := FormMenuView new.	menuView window: (0@0 corner: extent).	formExtent := 30@30 min: extent//(nColors*2+1@2).  "compute this better"	leftOffset := extent x-(nColors*2-1*formExtent x)//2.	highlightForm := Form extent: formExtent.	highlightForm borderWidth: 4.	1 to: nColors do: [:index | 		color := (nColors = 1			ifTrue: [#(black)]			ifFalse: [#(black gray)]) at: index.		form := Form extent: formExtent.		form fill: form boundingBox fillColor: (Color perform: color).		form borderWidth: 5.		form border: form boundingBox width: 4 fillColor: Color white.		button := Button new.		aSwitchView := PluggableButtonView			on: button			getState: #isOn			action: #turnOn			label: #getCurrentColor.		index = 1			ifTrue: [button onAction: [menuView model setColor: Color fromUser.									  aSwitchView label: menuView model getCurrentColor;									                  displayView					                     ]				    ]			ifFalse: [button onAction: [menuView model setTransparentColor]].		aSwitchView			shortcutCharacter: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index);			label: form;			window: (0@0 extent: form extent);			translateBy: (((index - 1) * 2 * form width) + leftOffset)@(form height // 2);			borderWidth: 1.		menuView addSubView: aSwitchView].	^ menuView! !!BitEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 14:48'!initialize	"The Bit Editor is the only controller to override the use of the blue	button with a different pop-up menu. Initialize this menu."	YellowButtonMenu := SelectionMenu		labels:'cancelacceptfile outtest'		lines: #(2 3)		selections: #(cancel accept fileOut test)	"BitEditor initialize"! !!BitEditor class methodsFor: 'examples' stamp: 'dtl 1/23/2010 18:13'!magnifyOnScreen	"Bit editing of an area of the display screen. User designates a 	rectangular area that is magnified by 8 to allow individual screens dots to	be modified. red button is used to set a bit to black and yellow button is	used to set a bit to white. Editor is not scheduled in a view. Original	screen location is updated immediately. This is the same as FormEditor	magnify."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8 @ 8.	smallRect := Rectangle fromUser.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	tempRect := Rectangle locateMagnifiedView: smallForm scale: scaleFactor.	"show magnified form size until mouse is depressed"	self		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor	"BitEditor magnifyOnScreen."! !!BitEditor class methodsFor: 'examples'!magnifyWithSmall"	Also try:	BitEditor openOnForm:		(Form extent: 32@32 depth: Display depth)	BitEditor openOnForm:		((MaskedForm extent: 32@32 depth: Display depth)		withTransparentPixelValue: -1)"	"Open a BitEditor viewing an area on the screen which the user chooses"	| area form |	area := Rectangle fromUser.	area isNil ifTrue: [^ self].	form := Form fromDisplay: area.	self openOnForm: form	"BitEditor magnifyWithSmall."! !!BitEditor class methodsFor: 'instance creation' stamp: 'dtl 1/23/2010 18:13'!openOnForm: aForm 	"Create and schedule a BitEditor on the form aForm at its top left corner. 	Show the small and magnified view of aForm."	| scaleFactor |	scaleFactor := 8 @ 8.	^self openOnForm: aForm		at: (Rectangle locateMagnifiedView: aForm scale: scaleFactor) topLeft		scale: scaleFactor! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm at: magnifiedLocation 	"Create and schedule a BitEditor on the form aForm at magnifiedLocation. 	Show the small and magnified view of aForm."	^self openOnForm: aForm		at: magnifiedLocation		scale: 8 @ 8! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm at: magnifiedLocation scale: scaleFactor 	"Create and schedule a BitEditor on the form aForm. Show the small and 	magnified view of aForm."	| aScheduledView |	aScheduledView := self				bitEdit: aForm				at: magnifiedLocation				scale: scaleFactor				remoteView: nil.	aScheduledView controller openDisplayAt:		aScheduledView displayBox topLeft + (aScheduledView displayBox extent / 2)! !!BitEditor class methodsFor: 'instance creation' stamp: 'sma 3/11/2000 11:29'!openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor	"Create and schedule a BitEditor on the form aForm. Show the magnified	view of aForm in a scheduled window."	| smallFormView bitEditor savedForm r |	smallFormView := FormView new model: aForm.	smallFormView align: smallFormView viewport topLeft with: formLocation.	bitEditor := self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.	savedForm := Form fromDisplay: (r := bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	savedForm displayOn: Display at: r topLeft.	bitEditor release.	smallFormView release.	"BitEditor magnifyOnScreen."! !!Bitmap methodsFor: 'accessing' stamp: 'eem 1/30/2009 10:07'!unsignedShortAt: byteIndex	"Compatiblity with the ByteArray & Alien methods of the same name."	| zi |	^((zi := byteIndex - 1) bitAnd: 1) = 0		ifTrue: [(zi bitAnd: 2) ~= 0					ifTrue: [(self at: zi - 2 // 4 + 1) bitAnd: 16rFFFF]					ifFalse: [(self at: zi // 4 + 1) bitShift: -16]]		ifFalse: [(self unsignedLongAt: byteIndex bigEndian: false) bitShift: -16]! !!Bitmap methodsFor: 'accessing' stamp: 'eem 1/30/2009 10:08'!unsignedShortAt: byteIndex put: aValue	"Compatiblity with the ByteArray & Alien methods of the same name."	| zi |	(aValue < 0 or: [aValue > 16rFFFF])  ifTrue:		[^self errorImproperStore].	((zi := byteIndex - 1) bitAnd: 1) = 0		ifTrue: [(zi bitAnd: 2) ~= 0					ifTrue: [self at: (zi := zi - 2 // 4 + 1) put: (16rFFFF0000 bitAnd: (self at: zi)) + aValue]					ifFalse: [self at: (zi := zi // 4 + 1) put: (16rFFFF bitAnd: (self at: zi)) + (aValue bitShift: 16)]]		ifFalse: [self notYetImplemented].	^aValue! !!Bitmap methodsFor: 'filing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:11'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	size := bm size.	i := self encodeInt: size in: ba at: 1.	k := 1.	[k <= size] whileTrue:		[word := bm at: k.		lowByte := word bitAnd: 16rFF.		eqBytes := ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j := k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j := j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i := self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i := i+1]				ifFalse: [i := self encodeInt: j-k+1*4+2 in: ba at: i.						i := self encodeBytesOf: word in: ba at: i].			k := j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i := self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i := i+1.				k := k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j := j+1].				j = size ifTrue: [j := j + 1].				"We have one or more unmatching words, ending at j-1"				i := self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i := self encodeBytesOf: (bm at: m) in: ba at: i].				k := j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n := rawBytes := myBytes := 0.Form allInstancesDo:	[:f | f unhibernate.	b := f bits.	n := n + 1.	rawBytes := rawBytes + (b size*4).	myBytes := myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:11'!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	i := index.  "byteArray read index"	end := ba size.	k := 1.  "bitmap write index"	pastEnd := bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt := ba at: i.  i := i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]				ifFalse: [anInt := 0.						1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].		n := anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code := anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data := ba at: i.  i := i+1.						data := data bitOr: (data bitShift: 8).						data := data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data := 0.						1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data := 0.							1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].							bm at: k put: data.  k := k+1]]]! !!Bitmap methodsFor: 'filing' stamp: 'jm (auto pragmas 12/08) 2/15/98 17:27'!encodeBytesOf: anInt in: ba at: i	"Copy the integer anInt into byteArray ba at index i, and return the next index"	<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	0 to: 3 do:		[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].	^ i+4! !!Bitmap methodsFor: 'filing' stamp: 'jm (auto pragmas 12/08) 2/15/98 17:26'!encodeInt: anInt in: ba at: i	"Encode the integer anInt in byteArray ba at index i, and return the next index.	The encoding is as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes"			<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	anInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].	anInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\256.  ^ i+2].	ba at: i put: 255.	^ self encodeBytesOf: anInt in: ba at: i+1! !!Bitmap methodsFor: 'copying' stamp: 'RAA 7/28/2000 21:51'!copy	^self clone! !!BitmapBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/2/2003 19:21'!testBitmapByteAt	| bm |	bm := Bitmap new: 1.	1 to: 4 do:[:i|		self should:[bm byteAt: i put: 1000] raise: Error.	].! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'nk 3/17/2004 16:39'!createSampleShortRunArray	^ShortRunArray newFrom: { 0. 1. 1. 2. 2. 2. 3. 3. 3. 3 }! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortRunArrayWithImageSegment	array := self createSampleShortRunArray.	self validateImageSegment 	! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortRunArrayWithRefStream	array := self createSampleShortRunArray.	self validateRefStream 	! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortRunArrayWithRefStreamOnDisk	array := self createSampleShortRunArray.	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortRunArrayWithSmartRefStream	array := self createSampleShortRunArray.	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'nice 1/18/2010 13:38'!testShortRunArrayWithSmartRefStream2	array := self createSampleShortRunArray.	self validateSmartRefStream.	self assert: (stream contents asByteArray last: 23) = #[0 0 0 4 0 1 0 0 0 2 0 1 0 3 0 2 0 4 0 3 33 13 13 ]! !!BitmapStreamTests methodsFor: 'tests-ShortRunArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortRunArrayWithSmartRefStreamOnDisk	array := self createSampleShortRunArray.	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'private' stamp: 'stephaneducasse 2/3/2006 22:39'!randomFloat	"Answer a random 32-bit float"	| w |	random seed: (w := random nextValue).	^w! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 16:33'!randomShortInt	^((random next * 65536) - 32768) truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'nk 7/5/2003 16:00'!randomShortPoint	^(((random next * 65536) @ (random next * 65536)) - (32768 @ 32768)) truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'stephaneducasse 2/3/2006 22:39'!randomWord	"Answer a random 32-bit integer"	| w |	random seed: (w := random nextValue).	^w truncated! !!BitmapStreamTests methodsFor: 'private' stamp: 'mha 7/30/2009 11:21'!validateImageSegment	"array is set up with an array."	| other filename |	filename := 'bitmapStreamTest.extSeg'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	(ImageSegment new copyFromRootsForExport: (Array with: array))         writeForExport: filename.	other := (FileDirectory default readOnlyFileNamed: filename)		fileInObjectAndCode.	self assert: array = other originalRoots first.		"clean up disk"	FileDirectory default deleteFileNamed: filename ifAbsent: [ ]! !!BitmapStreamTests methodsFor: 'private' stamp: 'stephaneducasse 2/3/2006 22:39'!validateRefStream	"array is set up with an array."	| other rwstream |	rwstream := RWBinaryOrTextStream on: (ByteArray new: array basicSize * 6).	stream := ReferenceStream on: rwstream.	stream nextPut: array; close.	rwstream position: 0.	stream := ReferenceStream on: rwstream.	other := stream next.	stream close.	self assert: array = other! !!BitmapStreamTests methodsFor: 'private' stamp: 'mha 7/30/2009 11:22'!validateRefStreamOnDisk	"array is set up with an array."	| other filename |	filename := 'bitmapStreamTest.ref'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	stream := ReferenceStream fileNamed: filename.	stream nextPut: array; close.	stream := ReferenceStream fileNamed: filename.	other := stream next.	stream close.	self assert: array = other.		"clean up disk"	FileDirectory default deleteFileNamed: filename ifAbsent: [ ]! !!BitmapStreamTests methodsFor: 'private' stamp: 'stephaneducasse 2/3/2006 22:39'!validateSmartRefStream	"array is set up with an array."	| other |	stream := RWBinaryOrTextStream on: (ByteArray new: array basicSize * 6).	stream binary.	stream fileOutClass: nil andObject: array.	stream position: 0.	stream binary.	other := stream fileInObjectAndCode.	self assert: array = other! !!BitmapStreamTests methodsFor: 'private' stamp: 'mha 7/30/2009 11:22'!validateSmartRefStreamOnDisk	"array is set up with an array."	| other filename |	filename := 'bitmapStreamTest.ref'.	FileDirectory default deleteFileNamed: filename ifAbsent: [ ].	stream := FileDirectory default fileNamed: filename.	stream fileOutClass: nil andObject: array.	stream close.	stream := FileDirectory default fileNamed: filename.	other := stream fileInObjectAndCode.	stream close.	self assert: array = other.		"clean up disk"	FileDirectory default deleteFileNamed: filename ifAbsent: [ ]! !!BitmapStreamTests methodsFor: 'Running' stamp: 'stephaneducasse 2/3/2006 22:39'!setUp	random := Random new.! !!BitmapStreamTests methodsFor: 'tests-MatrixTransform2x3' stamp: 'stephaneducasse 2/3/2006 22:39'!testMatrixTransform2x3WithImageSegment	array := MatrixTransform2x3 new.	1 to: 6 do: [ :i | array at: i put: self randomFloat ].	self validateImageSegment	! !!BitmapStreamTests methodsFor: 'tests-MatrixTransform2x3' stamp: 'stephaneducasse 2/3/2006 22:39'!testMatrixTransform2x3WithRefStream	array := MatrixTransform2x3 new.	1 to: 6 do: [ :i | array at: i put: self randomFloat ].	self validateRefStream	! !!BitmapStreamTests methodsFor: 'tests-MatrixTransform2x3' stamp: 'stephaneducasse 2/3/2006 22:39'!testMatrixTransform2x3WithRefStreamOnDisk	array := MatrixTransform2x3 new.	1 to: 6 do: [ :i | array at: i put: self randomFloat ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-MatrixTransform2x3' stamp: 'stephaneducasse 2/3/2006 22:39'!testMatrixTransform2x3WithSmartRefStream	array := MatrixTransform2x3 new.	1 to: 6 do: [ :i | array at: i put: self randomFloat ].	self validateSmartRefStream	! !!BitmapStreamTests methodsFor: 'tests-MatrixTransform2x3' stamp: 'stephaneducasse 2/3/2006 22:39'!testMatrixTransform2x3WithSmartRefStreamOnDisk	array := MatrixTransform2x3 new.	1 to: 6 do: [ :i | array at: i put: self randomFloat ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-misc' stamp: 'bf 11/19/2009 18:56'!testOtherClasses	#(WordArrayForSegment FloatArray PointArray IntegerArray SoundBuffer String ShortPointArray ShortIntegerArray WordArray Array ByteArray Bitmap ColorArray ) do: [:s | | a |		a := (Smalltalk at: s) new: 3.		self assert: (a basicSize * a bytesPerBasicElement = a byteSize). ]! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'nice 1/18/2010 15:01'!testShortIntegerArrayReadRefStream2	| refStrm |	refStrm := ReferenceStream on: #[20 6 17 83 104 111 114 116 73 110 116 101 103 101 114 65 114 114 97 121 0 0 0 2 0 0 0 1 0 2 0 3 ] readStream.	self assert: (refStrm next = (ShortIntegerArray with: 0 with: 1 with: 2 with: 3)).! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortIntegerArrayWithImageSegment	array := ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateImageSegment	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortIntegerArrayWithRefStream	array := ShortIntegerArray with: 0 with: 1 with: 2 with: 3.	self validateRefStream	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'nice 1/18/2010 13:36'!testShortIntegerArrayWithRefStream2	array := ShortIntegerArray with: 0 with: 1 with: 2 with: 3.	self validateRefStream.	self assert: stream byteStream contents = #[20 6 17 83 104 111 114 116 73 110 116 101 103 101 114 65 114 114 97 121 0 0 0 2 0 0 0 1 0 2 0 3]	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortIntegerArrayWithRefStreamOnDisk	array := ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortIntegerArrayWithSmartRefStream	array := ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'nice 1/18/2010 13:37'!testShortIntegerArrayWithSmartRefStream2	array := ShortIntegerArray with: 0 with: 1 with: 2 with: 3.	self validateSmartRefStream.	self assert: (stream contents asByteArray last: 15) = #[0 0 0 2  0 0  0 1  0 2  0 3  33 13 13]	! !!BitmapStreamTests methodsFor: 'tests-ShortIntegerArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortIntegerArrayWithSmartRefStreamOnDisk	array := ShortIntegerArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortInt ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortPointArrayWithImageSegment	array := ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateImageSegment 	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortPointArrayWithRefStream	array := ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateRefStream 	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'nice 1/18/2010 13:37'!testShortPointArrayWithRefStream2	array := ShortPointArray with: 0@1 with: 2@3.	self validateRefStream.	self assert: stream byteStream contents = #[20 6 15 83 104 111 114 116 80 111 105 110 116 65 114 114 97 121  0 0 0 2  0 0  0 1  0 2  0 3 ]	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortPointArrayWithRefStreamOnDisk	array := ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortPointArrayWithSmartRefStream	array := ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateSmartRefStream 	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'nice 1/18/2010 13:38'!testShortPointArrayWithSmartRefStream2	array := ShortPointArray with: 0@1 with: 2@3.	self validateSmartRefStream.	self assert: (stream contents asByteArray last: 15) = #[0 0 0 2  0 0  0 1  0 2  0 3  33 13 13 ]	! !!BitmapStreamTests methodsFor: 'tests-ShortPointArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testShortPointArrayWithSmartRefStreamOnDisk	array := ShortPointArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomShortPoint ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-WordArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testWordArrayWithImageSegment	array := WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateImageSegment	! !!BitmapStreamTests methodsFor: 'tests-WordArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testWordArrayWithRefStream	array := WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateRefStream	! !!BitmapStreamTests methodsFor: 'tests-WordArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testWordArrayWithRefStreamOnDisk	array := WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateRefStreamOnDisk	! !!BitmapStreamTests methodsFor: 'tests-WordArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testWordArrayWithSmartRefStream	array := WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateSmartRefStream	! !!BitmapStreamTests methodsFor: 'tests-WordArray' stamp: 'stephaneducasse 2/3/2006 22:39'!testWordArrayWithSmartRefStreamOnDisk	array := WordArray new: 10.	1 to: 10 do: [ :i | array at: i put: self randomWord ].	self validateSmartRefStreamOnDisk	! !!BitmapStreamTests commentStamp: 'nk 3/7/2004 14:26' prior: 0!This is an incomplete test suite for storing and reading various word- and short-word subclasses of ArrayedCollection.It demonstrates some problems with filing in of certain kinds of arrayed objects, including:ShortPointArrayShortIntegerArrayShortRunArrayWordArrayMatrixTransform2x3In 3.6b-5331, I get 8 passed/6 failed/6 errors (not counting the MatrixTransform2x3 tests, which were added later).I ran into problems when trying to read back the SqueakLogo flash character morph, after I'd done a 'save morph to disk' from its debug menu.The words within the ShortPointArrays and ShortRunArrays were reversed.!!BlockClosure methodsFor: 'controlling' stamp: 'jcg 7/28/2009 01:09'!whileNotNilDo: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	| value |	^ [(value := self value) notNil] whileTrue: [aBlock value: value]	! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:52'!once	"Answer and remember my value, answering exactly the same object in any further sends	 of once or value until I become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."	numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 8/18/2009 16:47'!simulateValueWithArguments: anArray caller: aContext	| newContext sz |	(anArray class ~~ Array	 or: [numArgs ~= anArray size]) ifTrue:		[^{ContextPart primitiveFailToken. nil}].	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 11:50'!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the copied values to the activation as its copied	 temps. Primitive. Essential."	<primitive: 201>	| newContext |	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:21'!value: firstArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the argument and copied values to the activation	 as its argument and copied temps. Primitive. Essential."	<primitive: 202>	| newContext |	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 203>	| newContext |	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 204>	| newContext |	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:31'!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 205>	| newContext |	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			newContext at: 4 put: fourthArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:29'!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments in an anArray and copied values to	 the activation as its arguments and copied temps. Primitive. Essential."	<primitive: 206>	| newContext |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			1 to: numArgs do:				[:i| newContext at: i put: (anArray at: i)].			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'md 3/28/2006 20:17'!valueWithExit 	  self value: [ ^nil ]! !!BlockClosure methodsFor: 'scheduling' stamp: 'eem 4/12/2010 11:00'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			"Since control is now at the bottom there is no need to terminate (which			 runs unwinds) since all unwnds have been run.  Simply suspend.			 Note that we must use this form rather than e.g. Processor suspendActive			 so that isTerminated answers true.  isTerminated requires that if there is a			 suspended context it is the bottom-most, but using a send would result in			 the process's suspendedContext /not/ being the bottom-most."			Processor activeProcess suspend] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/1/2010 19:30'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^((MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc) privRefresh! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:23'!becomeCached	self become: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:19'!becomeUncached	"The receiver is already uncached."	^self! !!BlockClosureTest methodsFor: 'tests - evaluating' stamp: 'ul 2/21/2010 17:02'!testCull	self shouldnt: [ [ ] cull: 1 ] raise: Error.	self shouldnt: [ [ :x | ] cull: 1 ] raise: Error.	self should: [ [ :x :y | ] cull: 1 ] raise: Error.	self should: [ [ :x :y :z | ] cull: 1 ] raise: Error.	self should: [ [ :x :y :z :a | ] cull: 1 ] raise: Error.	self should: [ [ :x :y :z :a :b | ] cull: 1 ] raise: Error.	self assert: ([ 0 ] cull: 1) = 0.	self assert: ([ :x | x ] cull: 1) = 1	! !!BlockClosureTest methodsFor: 'tests - evaluating' stamp: 'ul 2/21/2010 16:55'!testCullCull	self shouldnt: [ [ ] cull: 1 cull: 2 ] raise: Error.	self shouldnt: [ [ :x | ] cull: 1 cull: 2 ] raise: Error.	self shouldnt: [ [ :x :y | ] cull: 1 cull: 2 ] raise: Error.	self should: [ [ :x :y :z | ] cull: 1 cull: 2 ] raise: Error.	self should: [ [ :x :y :z :a | ] cull: 1 cull: 2 ] raise: Error.	self should: [ [ :x :y :z :a :b | ] cull: 1 cull: 2 ] raise: Error.	self assert: ([ 0 ] cull: 1 cull: 2) = 0.	self assert: ([ :x | x ] cull: 1 cull: 2) = 1.	self assert: ([ :x :y | y ] cull: 1 cull: 2) = 2.	! !!BlockClosureTest methodsFor: 'tests - evaluating' stamp: 'ul 2/21/2010 17:02'!testCullCullCull	self shouldnt: [ [ ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self shouldnt: [ [ :x | ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self shouldnt: [ [ :x :y | ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self shouldnt: [ [ :x :y :z | ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self should: [ [ :x :y :z :a | ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self should: [ [ :x :y :z :a :b | ] cull: 1 cull: 2 cull: 3 ] raise: Error.	self assert: ([ 0 ] cull: 1 cull: 2 cull: 3) = 0.	self assert: ([ :x | x ] cull: 1 cull: 2 cull: 3) = 1.	self assert: ([ :x :y | y ] cull: 1 cull: 2 cull: 3) = 2.	self assert: ([ :x :y :z | z ] cull: 1 cull: 2 cull: 3) = 3.	! !!BlockClosureTest methodsFor: 'tests - evaluating' stamp: 'ul 2/21/2010 17:03'!testCullCullCullCull	self shouldnt: [ [ ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self shouldnt: [ [ :x | ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self shouldnt: [ [ :x :y | ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self shouldnt: [ [ :x :y :z | ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self shouldnt: [ [ :x :y :z :a | ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self should: [ [ :x :y :z :a :b | ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.	self assert: ([ 0 ] cull: 1 cull: 2 cull: 3 cull: 4) = 0.	self assert: ([ :x | x ] cull: 1 cull: 2 cull: 3 cull: 4) = 1.	self assert: ([ :x :y | y ] cull: 1 cull: 2 cull: 3 cull: 4) = 2.	self assert: ([ :x :y :z | z ] cull: 1 cull: 2 cull: 3 cull: 4) = 3.	self assert: ([ :x :y :z :a | a ] cull: 1 cull: 2 cull: 3 cull: 4) = 4.! !!BlockContext methodsFor: 'accessing' stamp: 'ajh 9/28/2001 02:16'!method	"Answer the compiled method in which the receiver was defined."	^home method! !!BlockContext methodsFor: 'controlling' stamp: 'jcg 7/8/2007 18:25'!whileNil: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value isNil] whileTrue: [aBlock value]	! !!BlockContext methodsFor: 'controlling' stamp: 'jcg 7/8/2007 18:25'!whileNotNil: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value notNil] whileTrue: [aBlock value]	! !!BlockContext methodsFor: 'controlling' stamp: 'jcg 7/28/2009 01:07'!whileNotNilDo: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	| value |	^ [(value := self value) notNil] whileTrue: [aBlock value: value]	! !!BlockContext methodsFor: 'evaluating' stamp: 'eem 5/23/2008 13:55'!valueWithPossibleArgument: anArg 	"Evaluate the block represented by the receiver. 	 If the block requires one argument, use anArg, if it requires more than one,	 fill up the rest with nils."	| numArgs a |	numArgs := self numArgs.	numArgs = 0 ifTrue: [^self value].	numArgs = 1 ifTrue: [^self value: anArg].	a := Array new: numArgs.	a at: 1 put: anArg.	^self valueWithArguments: a! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 2/4/2008 12:48'!fork	"Create and schedule a Process running the code in the receiver."	^self forkAt: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 2/4/2008 12:46'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess helperProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	priority = Processor activePriority ifTrue:[		"If a process is being forked at the same priority as the active process, 		delay its resumption to a later point in time. This avoids problems like:			p := [self doSomething] fork.		where -depending on environmental factors, like external interrupts-		p may or may not be assigned when activating the block. With the		version below we ensure that behavior of #fork is deterministic in such		that forking at the same priority will behave like forking at a lesser		priority (e.g., p in the above *will* be assigned when the block is entered)."		helperProcess := [forkedProcess resume] newProcess.		helperProcess priority: priority-1.		helperProcess resume.	] ifFalse:[		forkedProcess resume	].	^forkedProcess! !!BlockContextTest methodsFor: 'setup' stamp: 'md 9/6/2005 19:56'!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BlockContextTest methodsFor: 'tests - printing' stamp: 'md 2/22/2006 15:39'!testDecompile	self assert: ([3 + 4] decompile printString = '{[3 + 4]}').! !!BlockContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 13:13'!testNew	self	should: [ContextPart new: 5] raise: Error.	[ContextPart new: 5]		ifError: [:error :receiver | error = 'Error: Contexts must only be created with newForMethod:'].	[ContextPart new]		ifError: [:error :receiver | error = 'Error: Contexts must only be created with newForMethod:'].		[ContextPart basicNew]		ifError: [:error :receiver | error = 'Error: Contexts must only be created with newForMethod:'].				! !!BlockContextTest methodsFor: 'tests' stamp: 'mjr 8/24/2003 18:27'!testNoArguments	[10		timesRepeat: [:arg | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 1 arguments.'].	[10		timesRepeat: [:arg1 :arg2 | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 2 arguments.'] ! !!BlockContextTest methodsFor: 'tests' stamp: 'mjr 8/24/2003 18:25'!testOneArgument	| c |	c := OrderedCollection new.	c add: 'hello'.	[c		do: [1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 0 arguments.'].	[c		do: [:arg1 :arg2 | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 2 arguments.'] ! !!BlockContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 12:50'!testRunSimulated	self assert: (ContextPart runSimulated: aBlockContext) class = Rectangle.! !!BlockContextTest methodsFor: 'tests' stamp: 'laza 8/31/2009 01:45'!testSetUp	"Note: In addition to verifying that the setUp worked the way it was expected to, testSetUp is used to illustrate the meaning of the simple access methods, methods that are not normally otherwise 'tested'"	self deny: aBlockContext isMethodContext.	self deny: aBlockContext isPseudoContext.	self assert: aBlockContext home = contextOfaBlockContext.	self assert: aBlockContext receiver = self.	self assert: (aBlockContext method isKindOf: CompiledMethod).! !!BlockContextTest methodsFor: 'tests' stamp: 'jrp 10/4/2004 19:27'!testSupplyAnswerUsingOnlySubstringOfQuestion	self should: [false = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('like' false))]! !!BlockContextTest methodsFor: 'tests' stamp: 'jrp 10/10/2004 22:31'!testSupplyAnswerUsingRegexMatchOfQuestion	(String includesSelector: #matchesRegex:) ifFalse: [^ self].		self should: [true = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('.*Smalltalk\?' true))]! !!BlockContextTest methodsFor: 'tests' stamp: 'jrp 10/4/2004 19:26'!testSupplySpecificAnswerToQuestion	self should: [false = ([self confirm: 'You like Smalltalk?'] 		valueSupplyingAnswer: #('You like Smalltalk?' false))]! !!BlockContextTest methodsFor: 'tests' stamp: 'jrp 10/4/2004 19:35'!testSuppressInform	self should: [[nil inform: 'Should not see this message or this test failed!!'] valueSuppressingAllMessages isNil]! !!BlockContextTest methodsFor: 'tests' stamp: 'jrp 10/10/2004 22:29'!testSuppressInformUsingStringMatchOptions	self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('Should not see this message or this test failed!!')) isNil].		self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('not see this message')) isNil].		self should: [([nil inform: 'Should not see this message or this test failed!!'] valueSuppressingMessages: #('*message*failed#')) isNil].! !!BlockContextTest methodsFor: 'tests' stamp: 'md 9/6/2005 19:58'!testTallyInstructions	self assert: (ContextPart tallyInstructions: aBlockContext) size = 15.! !!BlockContextTest methodsFor: 'testing' stamp: 'rbb 3/1/2005 10:23'!testSupplyAnswerOfFillInTheBlank	self should: ['blue' = ([UIManager default request: 'Your favorite color?'] 		valueSupplyingAnswer: #('Your favorite color?' 'blue'))]! !!BlockContextTest methodsFor: 'testing' stamp: 'rbb 3/1/2005 10:24'!testSupplyAnswerOfFillInTheBlankUsingDefaultAnswer	self should: ['red' = ([UIManager default  request: 'Your favorite color?' initialAnswer: 'red'] 		valueSupplyingAnswer: #('Your favorite color?' #default))]! !!BlockContextTest methodsFor: 'tests - evaluating' stamp: 'md 10/7/2004 13:52'!testValueWithPossibleArgs	| block  blockWithArg blockWith2Arg |	block := [1].	blockWithArg  := [:arg | arg].	blockWith2Arg := [:arg1 :arg2 | {arg1. arg2}].	self assert: (block valueWithPossibleArgs: #()) = 1.	self assert: (block valueWithPossibleArgs: #(1)) = 1.		self assert: (blockWithArg valueWithPossibleArgs: #()) = nil.	self assert: (blockWithArg valueWithPossibleArgs: #(1)) = 1.	self assert: (blockWithArg valueWithPossibleArgs: #(1 2)) = 1.	self assert: (blockWith2Arg valueWithPossibleArgs: #()) = {nil .nil}.	self assert: (blockWith2Arg valueWithPossibleArgs: #(1)) =  {1 . nil}.	self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2)) =  #(1 2).	self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2 3)) = #(1 2).			! !!BlockContextTest methodsFor: 'tests - evaluating' stamp: 'md 10/7/2004 13:59'!testValueWithPossibleArgument	| block  blockWithArg blockWith2Arg |	block := [1].	blockWithArg  := [:arg | arg].	blockWith2Arg := [:arg1 :arg2 | {arg1. arg2}].	self assert: (block valueWithPossibleArgument: 1) = 1.		self assert: (blockWithArg valueWithPossibleArgument: 1) = 1.		self assert: (blockWith2Arg valueWithPossibleArgument: 1) = {1 . nil}.		! !!BlockContextTest commentStamp: 'jrp 10/17/2004 12:22' prior: 0!I am an SUnit Test of BlockContext and its supertype ContextPart.  See also MethodContextTest.My fixtures are:aBlockContext     - just some trivial block, i.e., [100@100 corner: 200@200].NOTES ABOUT AUTOMATING USER INPUTSWhen executing non-interactive programs you will inevitably run into programs (like SqueakMap or Monticello installation packages -- and other programs, to be fair) that require user input during their execution and these sort of problems shoot the whole non-interactiveness of your enclosing program.BlockContext helper methods have been made available and tests of these helpers are provided in this class to demonstrate that it can intercept PopUpMenu and FillInTheBlankMorph requests for user interaction.  Of course, PopUpMenu and FillInTheBlankMorph were modified to first signal a ProvideAnswerNotification and if someone handles that (e.g. the enclosing block) then the user interaction will be circumvented and the provided answer of the enclosing block will be used.  The basic syntax looks like:	[self confirm: 'Install spyware?'] valueSupplyingAnswer: #('Install spyware?' false)There a few variants on this theme making it easy to provide a literal list of answers for the block so that you can handle a bunch of questions in a block with appropriate answers.Additionally, it is possible to suppress Object>>inform: modal dialog boxes as these get in the way of automating anything.  After applying this changeset you should be able to tryout the following code snippets to see the variants on this theme that are available.Examples:So you don't need any introduction here -- this one works like usual.[self inform: 'hello'. #done] value.Now let's suppress all inform: messages.[self inform: 'hello'; inform: 'there'. #done] valueSuppressingAllMessages.Here we can just suppress a single inform: message.[self inform: 'hi'; inform: 'there'. #done] valueSuppressingMessages: #('there')Here you see how you can suppress a list of messages.[self inform: 'hi'; inform: 'there'; inform: 'bill'. #done] valueSuppressingMessages: #('hi' 'there')Enough about inform:, let's look at confirm:. As you see this one works as expected.[self confirm: 'You like Squeak?'] valueLet's supply answers to one of the questions -- check out the return value.[{self confirm: 'You like Smalltalk?'. self confirm: 'You like Squeak?'}]	valueSupplyingAnswer: #('You like Smalltalk?' true)Here we supply answers using only substrings of the questions (for simplicity).[{self confirm: 'You like Squeak?'. self confirm: 'You like MVC?'}]	valueSupplyingAnswers: #( ('Squeak' true) ('MVC' false) )This time let's answer all questions exactly the same way.[{self confirm: 'You like Squeak?'. self confirm: 'You like Morphic?'}]	valueSupplyingAnswer: true	And, of course, we can answer FillInTheBlank questions in the same manner.[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswer: 'the first day of the rest of your life'	We can also return whatever the initialAnswer of the FillInTheBlank was by using the #default answer.[FillInTheBlank request: 'What day is it?' initialAnswer: DateAndTime now dayOfWeekName]	valueSupplyingAnswer: #default	Finally, you can also do regex matches on any of the question text (or inform text) (should you have VB-Regex enhancements in your image).[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswers: { {'What day.*\?'. DateAndTime now dayOfWeekName} }!!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:31'!arguments	^arguments ifNil: [#()]! !!BlockNode methodsFor: 'accessing' stamp: 'tk 8/4/1999 22:53'!firstArgument	^ arguments first! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:30'!temporaries	^temporaries ifNil: [#()]! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark	^tempsMark! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark: anInteger	tempsMark := anInteger! !!BlockNode methodsFor: 'code generation' stamp: 'eem 6/2/2008 13:29'!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:28'!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:36'!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/29/2008 15:21'!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode commentStamp: '<historical>' prior: 0!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!BookMorph class methodsFor: 'parts bin' stamp: 'ar 8/9/2010 17:18'!supplementaryPartsDescriptions	"Answer a list of DescriptionForPartsBin objects that characterize objects that this class wishes to contribute to Stationery bins *other* than by the standard default #newStandAlone protocol"	^ {DescriptionForPartsBin			formalName: 'NextPage'			categoryList: #(Presentation)			documentation: 'A button which, when clicked, takes the reader to the next page of a book'			globalReceiverSymbol: #BookMorph			nativitySelector: #nextPageButton.		DescriptionForPartsBin			formalName: 'PreviousPage'			categoryList: #(Presentation)			documentation: 'A button which, when clicked, takes the reader to the next page of a book'			globalReceiverSymbol: #BookMorph			nativitySelector: #previousPageButton.}! !!Boolean methodsFor: 'printing' stamp: 'sw 4/25/1998 12:51'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	self printOn: aStream! !!Boolean methodsFor: 'converting' stamp: 'jcg 3/26/2010 16:24'!asBoolean	"Booleans are already Booleans."	^self! !!BooleanTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:02'!testBooleanInitializedInstance	self assert: (Boolean initializedInstance = nil).! !!BooleanTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:02'!testBooleanNew	self should: [Boolean new] raise: TestResult error. 	self should: [True new] raise: TestResult error. 	self should: [False new] raise: TestResult error. ! !!BooleanTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:02'!testNew	self should: [Boolean new] raise: TestResult error. ! !!BooleanTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Boolean. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/20/2010 13:33'!drawOn: aCanvas	"aCanvas fillRectangle: self bounds color: Color red" "for debugging"! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:22'!setDefaultColors! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:21'!setInverseColors! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'spfa 8/15/2009 11:43'!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position).	self		addMorphBack: (TopGripMorph new target: self;position: self position).	self		addMorphBack: (BottomGripMorph new target: self;position: self position).	self		addMorphBack: (RightGripMorph new target: self;position: self position).	self		addMorphBack: (LeftGripMorph new target: self;position: self position).! !!BottomGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:37'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!BottomGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!BottomGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ self defaultHeight negated corner: 0@ 0)! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!ptName	^#bottom! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!resizeCursor	^ Cursor resizeForEdge: #top! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:40'!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:22'!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBraceNode: self! !!BrowseTest methodsFor: 'private' stamp: 'mu 3/6/2004 15:41'!currentBrowsers	^ (ActiveWorld submorphs		select: [:each | (each isKindOf: SystemWindow)				and: [each model isKindOf: Browser]]) asSet! !!BrowseTest methodsFor: 'private' stamp: 'mu 3/11/2004 15:52'!currentHierarchyBrowsers	^ (ActiveWorld submorphs		select: [:each | (each isKindOf: SystemWindow)				and: [each model isKindOf: HierarchyBrowser]]) asSet! !!BrowseTest methodsFor: 'private' stamp: 'mu 3/6/2004 15:27'!ensureMorphic	self isMorphic ifFalse: [self error: 'This test should be run in Morphic'].! !!BrowseTest methodsFor: 'private' stamp: 'mu 3/6/2004 15:26'!isMorphic	^Smalltalk isMorphic! !!BrowseTest methodsFor: 'running' stamp: 'mu 3/11/2004 15:57'!setUp	| systemNavigation |	systemNavigation := SystemNavigation default.	originalBrowserClass := systemNavigation browserClass.	originalHierarchyBrowserClass := systemNavigation hierarchyBrowserClass.		 systemNavigation browserClass: nil.	 systemNavigation hierarchyBrowserClass: nil.		! !!BrowseTest methodsFor: 'running' stamp: 'mu 3/11/2004 15:57'!tearDown	| systemNavigation |	systemNavigation := SystemNavigation default.	 systemNavigation browserClass: originalBrowserClass.	 systemNavigation hierarchyBrowserClass: originalHierarchyBrowserClass.! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/6/2004 15:43'!testBrowseClass	"self debug: #testBrowseClass"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentBrowsers.	1 class browse.	browsersAfter := self currentBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == SmallInteger).		opened delete			! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/11/2004 15:56'!testBrowseHierarchyClass	"self debug: #testBrowseHierarchyClass"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentHierarchyBrowsers.	1 class browseHierarchy.	browsersAfter := self currentHierarchyBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == SmallInteger).		opened delete			! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/11/2004 15:52'!testBrowseHierarchyInstance	"self debug: #testBrowseHierarchyInstance"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentHierarchyBrowsers.	1 browseHierarchy.	browsersAfter := self currentHierarchyBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == SmallInteger).		opened delete			! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/11/2004 16:00'!testBrowseHierarchyMataclass	"self debug: #testBrowseHierarchyMataclass"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentHierarchyBrowsers.	1 class class browseHierarchy.	browsersAfter := self currentHierarchyBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == Metaclass).		opened delete			! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/6/2004 15:43'!testBrowseInstance	"self debug: #testBrowseInstance"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentBrowsers.	1 browse.	browsersAfter := self currentBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == SmallInteger).		opened delete			! !!BrowseTest methodsFor: 'testing' stamp: 'mu 3/6/2004 15:44'!testBrowseMetaclass	"self debug: #testBrowseMetaclass"	| browsersBefore browsersAfter opened |	self ensureMorphic.		browsersBefore := self currentBrowsers.	1 class class browse.	browsersAfter := self currentBrowsers.		self assert:  (browsersAfter size  = (browsersBefore size + 1)).	opened := browsersAfter removeAll: browsersBefore; yourself.	self assert:  (opened size = 1).	opened := opened asArray first.	self assert: (opened model selectedClass == Metaclass).		opened delete			! !!Browser methodsFor: 'class comment pane' stamp: 'bgf 9/28/2007 21:56'!noCommentNagString	^ Preferences browserNagIfNoClassComment		ifTrue: [Text string: 'This class has no comment.' translated 					 attribute: (TextEmphasis italic)]		ifFalse: ['']		! !!Browser methodsFor: 'class functions' stamp: 'eem 7/27/2010 11:14'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	(self menuHook: aMenu named: #classListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue:[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'class functions' stamp: 'eem 8/12/2009 11:52'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection,	 except do NOT clobber or override any selectors already understood by the instances of the selected class"	self selectedClassOrMetaClass ifNotNil:		[:aClass| | cr |		cr := String with: Character cr.		aClass instVarNames do: 			[:aName | | newMessage setter |			(aClass canUnderstand: aName asSymbol) ifFalse:				[newMessage :=					aName, cr,					'	"Answer the value of ', aName, '"', cr, cr,					'	^ ', aName.				aClass compile: newMessage classified: #accessing notifying: nil].			(aClass canUnderstand: (setter := aName, ':') asSymbol) ifFalse:				[newMessage :=					setter, ' anObject', cr,					'	"Set the value of ', aName, '"', cr, cr,						(aClass settersReturnValue ifTrue: ['	^'] ifFalse: ['	']),						aName, ' := anObject'.				aClass compile: newMessage classified: #accessing notifying: nil]]]! !!Browser methodsFor: 'class functions' stamp: 'eem 7/22/2010 12:03'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self okToChange ifFalse: [^ self].	self editSelection: #newClass.	self contentsChanged.	"Force the text view to assume there are changes"	self changed: #editString with: self contents! !!Browser methodsFor: 'class functions' stamp: 'eem 8/30/2010 11:23'!shiftedClassListMenu: aMenu	"Set up the menu to apply to the receiver's class list when the shift key is down"	^ aMenu addList: #(			-			('local senders...'			browseLocalSenders	'browse senders local to this class')			('unsent methods'			browseUnusedMethods	'browse all methods defined by this class that have no senders')			('unreferenced inst vars'	showUnreferencedInstVars	'show a list of all instance variables that are not referenced in methods')			('unreferenced class vars'	showUnreferencedClassVars	'show a list of all class variables that are not referenced in methods')			('subclass template'			makeNewSubclass		'put a template into the code pane for defining of a subclass of this class')			-			('sample instance'			makeSampleInstance		'give me a sample instance of this class, if possible')			('inspect instances'			inspectInstances			'open an inspector on all the extant instances of this class')			('inspect subinstances'		inspectSubInstances		'open an inspector on all the extant instances of this class and of all of its subclasses')			-			('add all meths to current chgs'		addAllMethodsToCurrentChangeSet																'place all the methods defined by this class into the current change set')			('create inst var accessors'	createInstVarAccessors	'compile instance-variable access methods for any instance variables that do not yet have them')			-			('more...'					offerUnshiftedClassListMenu	'return to the standard class-list menu'))! !!Browser methodsFor: 'class list' stamp: 'eem 5/14/2008 17:58'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].	classListIndex := anInteger.	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	messageCategoryListIndex := self messageCategoryList										indexOf: currentMessageCategoryName										ifAbsent: [0].	messageListIndex := messageCategoryListIndex = 0							ifTrue: [0]							ifFalse: [self messageList										indexOf: currentMessageName										ifAbsent: [0]].	messageListIndex ~= 0 ifTrue:		[self editSelection: #editMessage] ifFalse:	[messageCategoryListIndex ~= 0 ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'code pane' stamp: 'eem 7/22/2010 11:58'!aboutToStyle: aStyler	"This is a notification that aStyler is about to re-style its text.	Set the classOrMetaClass in aStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	| type |		self isModeStyleable ifFalse: [^false].	type := self editSelection.	(#(newMessage editMessage editClass newClass) includes: type) ifFalse:[^false].	aStyler classOrMetaClass: ((#(editClass newClass) includes: type) ifFalse:[self selectedClassOrMetaClass]).	^true! !!Browser methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 19:06'!labelString	| label |	label := self selectedClass				ifNil: [ self defaultBrowserTitle ]				ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].	(multiWindowState notNil	 and: [multiWindowState models size > 1]) ifTrue:		[label := (multiWindowState models indexOf: self) printString, '. ', label].	^label! !!Browser methodsFor: 'initialize-release' stamp: 'eem 7/6/2010 11:51'!openEditString: aString        "Create a pluggable version of all the views for a Browser, including views and controllers."	"Example: 		Browser fullOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	^self buildWindowWith: builder specs: {		(0@0 corner: 0.25@max) -> [self buildSystemCategoryListWith: builder].		(self classListFrame: max) -> [self buildClassListWith: builder].		(self switchesFrame: max) -> [self buildSwitchesWith: builder].		(0.5@0 corner: 0.75@max) -> [self buildMessageCategoryListWith: builder].		(0.75@0 corner: 1@max) -> [self buildMessageListWith: builder].		"(0@max corner: 1@0.5) -> [self buildOptionalButtonsWith: builder]."		(0@max corner: 1@1) -> [self buildCodePaneWith: builder editString: aString].	}! !!Browser methodsFor: 'initialize-release' stamp: 'eem 7/6/2010 11:52'!openMessageCatEditString: aString        "Create a pluggable version of the views for a Browser that just shows one message category."	"Example: 		Preferences browseThemes.	" 	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0@0 corner: 1.0@0.08) -> [self buildMessageListCatSingletonWith: builder].		(0.0@0.08 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder editString: aString].	}.! !!Browser methodsFor: 'initialize-release' stamp: 'eem 7/6/2010 11:51'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(0.5@0.0 corner: 1.0@0.08) -> [self buildSwitchesWith: builder].		(0.0@0.08 corner: 0.5@max) -> [self buildMessageCategoryListWith: builder].		(0.5@0.08 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder editString: aString].	}! !!Browser methodsFor: 'initialize-release' stamp: 'eem 7/6/2010 11:51'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	"Example:		Browser new browseAllClasses.	"	| builder catPaneHeight max |	catPaneHeight := 0.08.	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32 + catPaneHeight] ifFalse:[0.4 + catPaneHeight].	^self buildWindowWith: builder specs: {		(0@0 corner: 1.0@0.08) -> [self buildSystemCatListSingletonWith: builder].		(self classListFrame: max fromTop: catPaneHeight fromLeft: 0 width: 0.333) -> [self buildClassListWith: builder].		(self switchesFrame: max fromLeft: 0 width: 0.333) -> [self buildSwitchesWith: builder].		(0.333@0.08 corner: 0.666@max) -> [self buildMessageCategoryListWith: builder].		(0.666@0.08 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder editString: aString].	}! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!exploreMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod explore]! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!inspectMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod inspect]! !!Browser methodsFor: 'message functions' stamp: 'eem 6/29/2010 17:07'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message list' stamp: 'eem 7/4/2010 18:52'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	contents == nil ifFalse: [^ contents copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContents].	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	method := class ifNotNil: [class compiledMethodAt: selector ifAbsent: [^ '']].	"method deleted while in another project?"	(currentCompiledMethod := method) ifNil: [^''].	(method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents := (class decompilerClass new decompile: selector in: class method: method)			decompileString.		contents := contents asText makeSelectorBoldIn: class.		^ contents copy].	self showingDocumentation		ifFalse:			[contents := self sourceStringPrettifiedAndDiffed]		ifTrue:			[contents := self commentContents].	^ contents := contents copy asText makeSelectorBoldIn: class! !!Browser methodsFor: 'metaclass' stamp: 'eem 4/30/2009 13:59'!setClassOrganizer	"Install whatever organization is appropriate"	classOrganizer := nil.	metaClassOrganizer := nil.	classListIndex = 0 ifTrue: [^ self].	self selectedClass		ifNil: [classOrganizer := metaClassOrganizer := nil]		ifNotNil:			[:theClass|			classOrganizer := theClass organization.			metaClassOrganizer := theClass class organization]! !!Browser methodsFor: 'system category functions' stamp: 'eem 7/1/2010 10:39'!findClass	"Search for a class by name."	| pattern foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	pattern := UIManager default request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^self classNotFound].	foundClass := Utilities classFromPattern: pattern withCaption: ''.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:44'!arrowKey: aChar from: view	"Intercept Apple-Digit to select panes"	| index |	(aChar isDigit	 and: [multiWindowState notNil]) ifTrue:	 	[index := aChar asciiValue - $0 asciiValue.		index = 0 ifTrue: [index := 10].		^index <= multiWindowState models size			ifTrue: [multiWindowState selectWindowIndex: index]			ifFalse: [self changed: #flash]].	^super arrowKey: aChar from: view! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:36'!classHierarchy	| behavior newBrowser |	(behavior := self selectedClassOrMetaClass) isNil ifTrue:		[^self].	(self isPackage "PackageBrowser pains can't support a hierarchy browser; not sure why."	 or: [multiWindowState isNil]) ifTrue:		[^super classHierarchy].	(newBrowser := HierarchyBrowser new initHierarchyForClass: behavior)		messageCategoryListIndex: messageCategoryListIndex;		messageListIndex: messageListIndex;		editSelection: editSelection.	multiWindowState addWindow: newBrowser! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self selectedClass			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[s print: self selectedClass.				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:23'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'className:')			ifNil: [(getarg value: 'restoreToCategory:')					ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]					ifNotNil: [:categoryName| s nextPutAll: categoryName]]			ifNotNil:				[:className|				s nextPutAll: className.				(getarg value: 'meta:') ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy'].				(getarg value: 'selector:')					ifNil: [(getarg value: 'protocol:') ifNotNil:							[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]					ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 17:34'!okToClose	^super okToClose	  and: [multiWindowState isNil or: [multiWindowState okToClose]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:20'!restoreMultiWindowState: aMessage	"Restore the state after a multi-window switch.."	aMessage sentTo: self! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:28'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self metaClassIndicated: metaBool.	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:23'!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:meta:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!Browser class methodsFor: 'instance creation' stamp: 'eem 7/1/2010 11:44'!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	ToolBuilder open: aBrowserView label: aString.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	^true! !!BrowserHierarchicalListTest methodsFor: 'assertion' stamp: 'rkrk 8/24/2009 05:03'!assertCorrectOrderOf: classB followedBy: classA in: classCollection	"classB comes before classA. Assert that classB is a superclass of classB or that 	a common superclass is in front of both"	| commonSuperclasses commonSuperclass classAIndex classBIndex superIndex |	classA == classB ifTrue: [^ self].	(classA inheritsFrom: classB) ifTrue: [^ self].	commonSuperclasses := classA withAllSuperclasses intersection: classB withAllSuperclasses.	commonSuperclass := commonSuperclasses first.	(classCollection includes: commonSuperclass) ifFalse: [^ self].	classAIndex := classCollection indexOf: classA.	classBIndex := classCollection indexOf: classB.	superIndex := classCollection indexOf: commonSuperclass.	(superIndex < classAIndex and: [superIndex < classBIndex]) ifTrue: [^self].	self fail.! !!BrowserHierarchicalListTest methodsFor: 'helper' stamp: 'rkrk 8/24/2009 05:05'!hierarchicalClassListForCategory: category	| b index |	b := Browser new.	index := b systemCategoryList indexOf: category.	b systemCategoryListIndex: index.	^ b hierarchicalClassList.! !!BrowserHierarchicalListTest methodsFor: 'helper' stamp: 'rkrk 8/24/2009 04:32'!nameToClass: classNameWithIndent	^ Smalltalk classNamed: classNameWithIndent withoutLeadingBlanks asSymbol! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'rkrk 8/24/2009 05:10'!testListClassesHierarchically1	| result classes category |	category := 'Collections-Abstract'.	result := self hierarchicalClassListForCategory: category.	self assert: (SystemOrganization listAtCategoryNamed: category) size equals: result size.	classes := result collect: [:ea | self nameToClass: ea].	classes withIndexDo: [:ea : i |		classes 			from: 1 to: i			do: [:other | self assertCorrectOrderOf: other followedBy: ea in: classes]].! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'rkrk 8/24/2009 05:09'!testListClassesHierarchically2	| result classes category |	category := 'Tools-Browser'.	result := self hierarchicalClassListForCategory: category.	self assert: (SystemOrganization listAtCategoryNamed: category) size equals: result size.	classes := result collect: [:ea | self nameToClass: ea].	classes withIndexDo: [:ea : i |		classes 			from: 1 to: i			do: [:other | self assertCorrectOrderOf: other followedBy: ea in: classes]].! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'nice 12/26/2009 00:33'!testListClassesHierarchicallyIndent	| result dict  |	result := self hierarchicalClassListForCategory: 'Tools-Browser'.	"Create class->indent mapping"	dict := result inject: Dictionary new into: [:classIndentMapping :className |		| indent |		indent := className count: [:char | char = Character space or: [char = Character tab]].		classIndentMapping at: (self nameToClass: className) put: indent.		classIndentMapping].	"assert that indent of class is larger than indent of superclass"	dict keysAndValuesDo: [:class :myIndent |		dict at: class superclass ifPresent: [:superIndent |			self assert: myIndent > superIndent]].! !!BrowserHierarchicalListTest commentStamp: 'rkrk 8/24/2009 05:11' prior: 0!Tests the optional hierarchical class ordering of Browser.!!Button methodsFor: 'state'!turnOff	"Sets the state of the receiver to 'off'. The off action of the receiver is not  	executed."	on := false! !!Button methodsFor: 'state'!turnOn	"The receiver remains in the 'off' state'."	self doAction: onAction.	self doAction: offAction! !!Button commentStamp: '<historical>' prior: 0!I am a Switch that turns off automatically after being turned on, that is, I act like a push-button switch.!!Button class methodsFor: 'instance creation'!newOn 	"Refer to the comment in Switch|newOn."	self error: 'Buttons cannot be created in the on state'.	^nil! !!ByteArray methodsFor: 'comparing' stamp: 'ar 5/26/2007 17:27'!hasEqualElements: aByteArray	"A little hack to speed up ByteArray content comparisons."	<primitive: 'primitiveCompareBytes'>	^super hasEqualElements: aByteArray! !!ByteArray methodsFor: 'converting' stamp: 'ar 4/2/2009 22:57'!asInteger	"Convert the recevier into an equivalent integer"	^(LargePositiveInteger new: self size)		replaceFrom: 1 to: self size with: self startingAt: 1;		normalize! !!ByteArray methodsFor: 'converting' stamp: 'sma 5/12/2000 17:35'!asString	"Convert to a String with Characters for each byte.	Fast code uses primitive that avoids character conversion"	^ (String new: self size) replaceFrom: 1 to: self size with: self! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!ByteArray class methodsFor: 'byte based hash' stamp: 'SqR (auto pragmas 12/08) 8/21/2002 16:21'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteArrayBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/2/2003 19:28'!testByteArrayLongAt	| ba value |	ba := ByteArray new: 4.	value := -1.	self shouldnt:[ba longAt: 1 put: value bigEndian: true] raise: Error.	self assert: (ba longAt: 1 bigEndian: true) = value.	self shouldnt:[ba longAt: 1 put: value bigEndian: false] raise: Error.	self assert: (ba longAt: 1 bigEndian: false) = value.! !!ByteArrayTest methodsFor: 'hex tests' stamp: 'ar 2/23/2010 07:16'!testHex	self assert: #[122 43 213 7] hex = '7a2bd507'.	self assert: (UUID fromString: '97c1f2dd-f920-9948-b329-319a30c16386') hex					= '97c1f2ddf9209948b329319a30c16386'.! !!ByteArrayTest methodsFor: 'hex tests' stamp: 'ar 2/23/2010 07:15'!testReadHexFrom	self assert: (ByteArray readHexFrom: '7a2bd507') = #[122 43 213 7].	self assert: (UUID readHexFrom: '97c1f2ddf9209948b329319a30c16386')					= (UUID fromString: '97c1f2dd-f920-9948-b329-319a30c16386').! !!ByteString methodsFor: 'comparing' stamp: 'bf (auto pragmas 12/08) 8/31/2004 13:50'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!ByteString methodsFor: 'comparing' stamp: 'eem 5/22/2008 13:41'!hasEqualElements: aByteArray	"A little hack to speed up ByteArray content comparisons."	<primitive: 'primitiveCompareBytes'>	^super hasEqualElements: aByteArray! !!ByteString methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment! !!ByteString class methodsFor: 'primitives' stamp: 'ar 6/22/2010 12:50'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	<var: #string1 declareC: 'unsigned char *string1'>	<var: #string2 declareC: 'unsigned char *string2'>	<var: #order declareC: 'unsigned char *order'>	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:12'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	<var: #aString declareC: 'unsigned char *aString'>	<var: #inclusionMap  declareC: 'char *inclusionMap'>	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:13'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	<var: #aCharacter declareC: 'int anInteger'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 9/28/2001 04:35'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:12'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	<var: #table  declareC: 'unsigned char *table'>	<var: #aString  declareC: 'unsigned char *aString'>	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!ByteSymbol methodsFor: 'comparing' stamp: 'eem 5/22/2008 13:49'!hasEqualElements: aByteArray	"A little hack to speed up ByteString and ByteSymbol comparisons."	<primitive: 'primitiveCompareBytes'>	^super hasEqualElements: aByteArray! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:24'!becomeCached	"The receiver is already cached."	^self! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:21'!becomeUncached	self become: (BlockClosure 					outerContext: outerContext					startpc: startpc					numArgs: numArgs					copiedValues: self)! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:24'!once	^cachedValue! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:17'!value	^cachedValue! !!CachedBlockClosure methodsFor: 'initialize-release' stamp: 'eem 7/22/2010 12:16'!outerContext: aContext startpc: aStartpc numArgs: argCount cachedValue: aValue copiedValues: anArrayOrNil	cachedValue := aValue.	super outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil! !!CachedBlockClosure commentStamp: 'eem 7/22/2010 12:34' prior: 0!I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure.  Originally by Travis Griggs, from whom we copy this idea with thanks.Instance Variables	cachedValue	<Object>cachedValue	- result of having sent value to myself when i was just a BlockClosure!!Canvas methodsFor: 'initialization' stamp: 'ar 6/17/2010 16:43'!finish: allDamage	"If there are any pending operations on the receiver complete them. 	Do not return before all modifications have taken effect."	^self finish! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:41'!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:39'!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCascadeNode: self! !!Categorizer methodsFor: 'printing' stamp: 'ar 3/23/2006 19:30'!printString	^self fullPrintString! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:10'!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:18'!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:54'!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:22'!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 15:15'!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:55'!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 14:49'!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:14'!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 6/29/2010 17:58'!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addTitle: 'change list'.	aMenu addStayUpItemSpecial.	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged definitions'				selectUnchangedDefinitions			'select class definitions, class comments and methods in the file whose in-image versions are the same as their in-file counterparts' )	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	('select methods for extant classes'			selectMethodsForExtantClasses		'select all methods in the file that belong to a class that exists in the image')	('select changes with contents matching'		selectContentsMatching				'select all changes in the file whose text includes a pattern')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse all versions of single selection'			browseVersions		'open a version browser showing the versions of the currently selected method')	('browse all versions of selections'			browseAllVersionsOfSelections		'open a version browser showing all the versions of all the selected methods')	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/18/2009 15:21'!selectContentsMatching	| pattern |	pattern := UIManager default request: 'pattern to match'.	pattern isEmpty ifTrue: [^self].	^Cursor execute showWhile:		[self selectSuchThat: ((pattern includesAnyOf: '?*')								ifTrue: [[ :change | pattern match: change string]]								ifFalse: [[ :change | change string includesSubString: pattern]])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 8/18/2009 13:41'!selectMethodsForExtantClasses	^self selectSuchThat:		[ :change |		Smalltalk hasClassNamed: change methodClassName]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 7/22/2010 13:40'!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableSubclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!ChangeList methodsFor: 'scanning' stamp: 'eem 7/17/2008 15:50'!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp anIndex |	itemPosition := file position.	item := file nextChunk.	((item includesSubString: 'commentStamp:')	or: [(item includesSubString: 'methodsFor:')	or: [item endsWith: 'reorganize']]) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp := tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk].	self assert: tokens last == #reorganize.	self addItem:		(ChangeRecord new			file: file position: file position type: #reorganize			class: tokens first category: nil meta: false stamp: stamp)		text: 'organization for ' , tokens first, (tokens second == #class ifTrue: [' class'] ifFalse: ['']).	file nextChunk! !!ChangeList methodsFor: 'scanning' stamp: 'eem 1/28/2009 16:39'!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method selector |	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, ((selector := (Smalltalk at: class ifAbsent: [Object]) parserClass new parseSelector: method) isNil					ifTrue: ['unparsableSelector']					ifFalse: [selector])				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'viewing access' stamp: 'eem 5/22/2007 10:40'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^TextDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 5/18/2010 20:25'!fileIndex	SourceFiles withIndexDo: [:sf :i| sf name = file name ifTrue: [^i]].	^nil! !!ChangeRecord methodsFor: 'access' stamp: 'eem 8/14/2010 20:35'!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/6/2009 13:06'!methodClassName	| text tokens |	(class isNil	and: [type = #doIt	and: [((text := self text) includes: $.) not "exclude multi-statement doits"	and: [(tokens := Scanner new scanTokens: text) size >= 4	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [tokens includes: #instanceVariableNames:]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [tokens third = #instanceVariableNames:		  and: [tokens last isString]]]) ifTrue:			[^tokens first]].	^class! !!ChangeRecord methodsFor: 'initialization' stamp: 'eem 7/17/2008 17:19'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := Smalltalk at: class asSymbol.				 cls := meta ifTrue: [cls class] ifFalse: [cls].				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeSet methodsFor: 'class changes' stamp: 'eem 3/7/2009 17:20'!trimHistoryAggressively	"Drop non-essential and/or obsolete history (rename, reorg, method removals) from newly-added or missing classes."	changeRecords do: [:chgRecord | chgRecord trimHistoryAggressively]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'bobw 7/27/2010 08:51'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'eem 7/17/2008 15:05'!fileOutChangesFor: class forWhich: aBlock on: stream 	"Write out all the method changes for this class for which aBlock evaluates to true when given the change type."	| changes |	changes := Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | 		(aBlock value: mAssoc value) ifTrue:			[changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		 stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'eem 7/12/2008 17:27'!fileOutIn: aDirectory	"File out the receiver, to a file whose name is a function of the  	 change-set name and either of the date & time or chosen to have a  	 unique numeric tag, depending on the preference  	 'changeSetVersionNumbers'"	| slips nameToUse internalStream |	nameToUse := Preferences changeSetVersionNumbers					ifTrue: [aDirectory nextNameFor: self name extension: FileStream cs]					ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	nameToUse := aDirectory fullNameFor: nameToUse.	Cursor write showWhile:		[internalStream := WriteStream on: (String new: 10000).		 internalStream header; timeStamp.		 self fileOutPreambleOn: internalStream.		 self fileOutOn: internalStream.		 self fileOutPostscriptOn: internalStream.		 internalStream trailer.		 FileStream			writeSourceCodeFrom: internalStream			baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3)			isSt: false			useHtml: false].	Preferences checkForSlips ifFalse:		[^self].	((slips := self checkForSlips) notEmpty	and: [(UIManager default			chooseFrom: #('Ignore' 'Browse slips')			title: 'Methods in change set ', self name, ' have halts\or references to the Transcript\or other ''slips'' in them.\Would you like to browse them?' withCRs )					= 2]) ifTrue:		[self systemNavigation browseMessageList: slips name: 'Possible slips in ', self name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'eem 7/17/2008 15:15'!fileOutOn: stream 	"Write out all the changes the receiver knows about.  Be very careful	 about the order. File-out additions first, then changes and then removals."	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].	classList := ChangeSet superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the methods for added classes"	classList do:		[:aClass |		self fileOutChangesFor: aClass			forWhich: ((self atClass: aClass includes: #add)						ifTrue: [[:changeType| true]]						ifFalse: [[:changeType| false]])			on: stream].	"Then put out all the added methods in old classes"	classList do:		[:aClass |		self fileOutChangesFor: aClass			forWhich: ((self atClass: aClass includes: #add)						ifTrue: [[:changeType| false]]						ifFalse: [[:changeType| changeType == #add]])			on: stream].	"Then put out all the changed methods in old classes"	classList do:		[:aClass |		self fileOutChangesFor: aClass			forWhich: ((self atClass: aClass includes: #add)						ifTrue: [[:changeType| false]]						ifFalse: [[:changeType| changeType == #change]])			on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'method changes' stamp: 'eem 7/17/2008 10:48'!codeChangesList	"Answer a list of MethodReferences and ClassReferences for all the receiver's method and class changes"	| messageList classNameInFull classNameInParts |	messageList := OrderedCollection new.	changeRecords associationsDo:		[:clAssoc |		classNameInFull := clAssoc key asString.		classNameInParts := classNameInFull findTokens: ' '.		(clAssoc value allChangeTypes includesAnyOf: #(add change)) ifTrue:			[messageList add:				(ClassReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false					stringVersion: classNameInFull)].		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(MethodReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false 					methodSymbol: #Comment 					stringVersion: classNameInFull, ' Comment')].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					(MethodReference new						setClassSymbol: classNameInParts first asSymbol						classIsMeta: classNameInParts size > 1 						methodSymbol: mAssoc key 						stringVersion: classNameInFull, ' ', mAssoc key)]]].	^messageList asSortedArray! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'eem 5/16/2008 14:52'!rootClassesIn: classes	"Answer the subset of classes which do not have superclasses in classes"	| classSet size |	classSet := Set withAll: classes.	size := classSet size.	[classSet := classSet reject: [:class| class superclass notNil and: [classSet includes: class superclass]].	 classSet size = size]		whileFalse: [size := classSet size].	^classSet! !!ChangeSet class methodsFor: 'scanning' stamp: 'eem 5/19/2010 10:08'!directAncestryOfVersions: changeRecords	"Take a sequence of ChangeRecords as answered by scanVersionsOf:class:meta:category:selector:	 and answer a filtered subsequence consisting only of direct ancestors.  For example, if the input is		eem 7/7/2009 20:06	7 July 2009 8:06 pm		eem 6/18/2009 19:21	18 June 2009 7:21 pm		eem 5/5/2009 12:16	5 May 2009 12:16 pm		eem 6/18/2009 19:19	18 June 2009 7:19 pm		eem 6/18/2009 18:57	18 June 2009 6:57 pm		eem 5/5/2009 12:16	5 May 2009 12:16 pm		eem 6/18/2009 18:17	18 June 2009 6:17 pm		eem 6/18/2009 18:14	18 June 2009 6:14 pm		eem 6/18/2009 18:06	18 June 2009 6:06 pm		eem 5/5/2009 12:16	5 May 2009 12:16 pm		eem 5/4/2009 19:19	4 May 2009 7:19 pm	the output should be		eem 7/7/2009 20:06	7 July 2009 8:06 pm		eem 6/18/2009 19:21	18 June 2009 7:21 pm		eem 5/5/2009 12:16	5 May 2009 12:16 pm		eem 5/4/2009 19:19	4 May 2009 7:19 pm"	| filtered i last |	filtered := OrderedCollection new.	i := 1.	[i <= changeRecords size] whileTrue:		[filtered addLast: (changeRecords at: i).		 last := changeRecords findLast: [:chgRec| filtered last stamp = chgRec stamp] startingAt: i.		 i := last = 0 ifTrue: [i + 1] ifFalse: [last + 1]].	^filtered! !!ChangeSet class methodsFor: 'services' stamp: 'eem 3/20/2010 11:29'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet newStream |	oldChanges := ChangeSet current.	PreviousSet := oldChanges name. 		"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := (self named: newName)				ifNotNil: [:existingSet|						(self confirm: newName, ' already exists, file into it?') ifFalse:							[^self].						existingSet]				ifNil: [self basicNewChangeSet: newName].	[newSet ifNotNil:[		(aStream respondsTo: #converter:) ifFalse: [			newStream := MultiByteBinaryOrTextStream with: (aStream contentsOfEntireFile).			newStream reset.		] ifTrue: [			newStream := aStream.		].		self newChanges: newSet.		newStream setConverterForCode.		newStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [self newChanges: oldChanges].	PreviousSet := nil.	^ newSet! !!ChangeSetClassChangesTest methodsFor: 'support' stamp: 'dtl 2/19/2005 13:08'!isDefinition: firstString equivalentTo: secondString 	"When a class definition is reconstructed with #fatDefForClass, it may 	contain extra trailing space characters in parts of the definition. This 	is probably a minor bug, but it should be overlooked for purposes of 	testing the change set update mechanism. The expedient here is to just 	remove spaces before comparing the definition strings."	^ firstString notNil		and: [(firstString copyReplaceAll: ' ''' with: '''')				= (secondString copyReplaceAll: ' ''' with: '''')]! !!ChangeSetClassChangesTest methodsFor: 'running' stamp: 'ar 7/13/2010 16:29'!tearDown	(Smalltalk classNamed: #JunkClass) ifNotNil: [:c | c removeFromSystem: true].	SystemOrganization removeCategory: #'DeleteMe-1'.	SystemOrganization removeCategory: #'DeleteMe-2'.	"Also clean out bogus MC package"	Smalltalk at: #MCWorkingCopy ifPresent:[:aClass|		aClass managersForCategory: #'DeleteMe-1' 				do:[:mgr| mgr unregister].	].	ChangeSet current removeClassChanges: 'JunkClass'! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'stephaneducasse 2/3/2006 22:39'!testAddInstanceVariable	"Adding an instance variable to the class should result in a change	record being added to the current change set."	| saveClassDefinition |	"Define a class and save its definition"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	saveClassDefinition := (Smalltalk classNamed: #JunkClass) definition.	self assert: (self		isDefinition: saveClassDefinition		equivalentTo: (ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass))).	"Redefine the class, adding one instance variable"	Object subclass: #JunkClass		instanceVariableNames: 'zzz aaa'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	"Assert that the class definition has changed"	self deny: (self		isDefinition: (Smalltalk classNamed: #JunkClass) definition		equivalentTo: saveClassDefinition).	self deny: (self		isDefinition: saveClassDefinition		equivalentTo: (ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass))).	self assert: (self		isDefinition: (Smalltalk classNamed: #JunkClass) definition		equivalentTo: (ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass))).	"Assert that the change has been recorded in the current change set"	self assert: (self		isDefinition: (ChangeSet current changeRecorderFor: (Smalltalk classNamed: #JunkClass))			priorDefinition		equivalentTo: saveClassDefinition).! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'dtl 2/19/2005 11:55'!testAddInstanceVariableAddsNewChangeRecord	"Changing the class category for a class should result in a change	record being updated in the current change set."	"At the start of this test, JunkClass should not exist, and there should be	no change records pertaining to it in the change set."	self deny: (Smalltalk hasClassNamed: 'JunkClass').	self assert: (ChangeSet current changeRecorderFor: (Smalltalk classNamed: #JunkClass))		thisName = 'nil'.	"Remove bogus change records created as side effect of preceding assert"	ChangeSet current removeClassChanges: 'nil'.	"Define a class and save its definition"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	"Forget about JunkClass in the change set"	ChangeSet current removeClassChanges: 'JunkClass'.	"Redefine the class, adding one instance variable"	Object subclass: #JunkClass		instanceVariableNames: 'zzz aaa'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	"A change record should now exist in the change set"	self assert: (self		isDefinition: (ChangeSet current			changeRecorderFor: (Smalltalk classNamed: #JunkClass)) priorDefinition		equivalentTo:'Object subclass: #JunkClass	instanceVariableNames: ''zzz ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''DeleteMe-1''')! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'stephaneducasse 2/3/2006 22:39'!testChangeClassCategory	"Changing the class category for a class should result in a change	record being added to the current change set."	| saveClassDefinition |	"Define a class and save its definition"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	saveClassDefinition := (Smalltalk classNamed: #JunkClass) definition.	self assert: saveClassDefinition =		(ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass)).	"Redefine the class, changing only the class category"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-2'.	"Assert that the class definition has changed"	self deny: (self		isDefinition: (Smalltalk classNamed: #JunkClass) definition		equivalentTo: saveClassDefinition).	self deny: (self		isDefinition: saveClassDefinition		equivalentTo: (ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass))).	self assert: (self		isDefinition: (Smalltalk classNamed: #JunkClass) definition		equivalentTo: (ChangeSet current fatDefForClass: (Smalltalk classNamed: #JunkClass))).	"Assert that the change has been recorded in the current change set"	self assert: (self		isDefinition: (ChangeSet current changeRecorderFor: (Smalltalk classNamed: #JunkClass))			priorDefinition		equivalentTo:'Object subclass: #JunkClass	instanceVariableNames: ''zzz ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''DeleteMe-2''')! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'dtl 2/19/2005 12:01'!testChangeClassCategoryAddsNewChangeRecord	"Changing the class category for a class should result in a change	record being updated in the current change set."	"At the start of this test, JunkClass should not exist, and there should be	no change records pertaining to it in the change set."	self deny: (Smalltalk hasClassNamed: 'JunkClass').	self assert: (ChangeSet current changeRecorderFor: (Smalltalk classNamed: #JunkClass))		thisName = 'nil'.	"Remove bogus change records created as side effect of preceding assert"	ChangeSet current removeClassChanges: 'nil'.	"Define a class and save its definition"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-1'.	"Forget about JunkClass in the change set"	ChangeSet current removeClassChanges: 'JunkClass'.	"Redefine the class, changing only the class category"	Object subclass: #JunkClass		instanceVariableNames: 'zzz'		classVariableNames: ''		poolDictionaries: ''		category: 'DeleteMe-2'.	"A change record should now exist in the change set"	self assert: (self		isDefinition: (ChangeSet current			changeRecorderFor: (Smalltalk classNamed: #JunkClass)) priorDefinition		equivalentTo:'Object subclass: #JunkClass	instanceVariableNames: ''zzz ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''DeleteMe-2''')! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSetClassChangesTest commentStamp: 'dtl 2/19/2005 13:21' prior: 0!Class category changes are not being properly added to the default changeset in Squeak 3.7. This test case will pass in Squeak 3.6, and fail in Squeak 3.[7-9].!!Character methodsFor: 'printing' stamp: 'ar 4/9/2005 21:53'!isLiteral	^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/22/2005 23:58'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex := lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		"ar 8/18/2003: Why would we set the character block's extent to the rest of the line here? It screws up scrolling as suddenly we will try *really* hard to show the rest of the line, so I removed it."		"self lastCharacterExtentSetX: rightMargin - destX."		^true! !!CharacterSetComplementTest methodsFor: 'testing' stamp: 'nice 9/2/2008 10:29'!testPrintString	"This is about CharacterSetComplementTest"		self shouldnt: [CharacterSet separators complement printString] raise: Error! !!CharacterSetComplementTest commentStamp: '<historical>' prior: 0!CharacterSetComplementTest hold unit tests for CharacterSetComplement!!CharacterSetTest methodsFor: 'testing' stamp: 'nice 11/20/2007 00:38'!testCopy    | theOriginal theCopy |    theOriginal := CharacterSet newFrom: 'abc'.    theCopy := theOriginal copy.    theCopy remove: $a.    ^self should: [theOriginal includes: $a] description: 'Changing the copy should not change the original'.! !!CharacterSetTest commentStamp: 'nice 11/20/2007 00:35' prior: 0!CharacterSetTest holds tests for CharacterSet!!CharacterTest methodsFor: 'tests - creation' stamp: 'ar 9/1/2009 00:41'!testCodePoint	self assert: (Character codePoint: $A asciiValue) = $A.	self shouldnt:[Character codePoint: 500] raise: Error.	self assert: (Character codePoint: 500) asciiValue = 500.! !!CharacterTest methodsFor: 'testing - Class Methods' stamp: 'sd 6/5/2005 09:25'!testNew	self should: [Character new] raise: Error.! !!CharacterTest methodsFor: 'testing-printing' stamp: 'lr 11/21/2005 17:41'!testPrintString	self assert: $a printString = '$a'.	self assert: $5 printString = '$5'.	self assert: $@ printString = '$@'.	self assert: Character cr printString = 'Character cr'.	self assert: Character lf printString = 'Character lf'.	self assert: Character space printString = 'Character space'.	self assert: (Character value: 0) printString = 'Character value: 0'.	self assert: (Character value: 17) printString = 'Character value: 17'.! !!CharacterTest methodsFor: 'testing-printing' stamp: 'lr 11/21/2005 17:41'!testPrintStringAll	Character allCharacters do: [ :each |		self assert: (self class compilerClass 			evaluate: each printString) = each ].! !!CharacterTest methodsFor: 'testing-printing' stamp: 'lr 11/21/2005 17:22'!testStoreString	self assert: $a storeString = '$a'.	self assert: $5 storeString = '$5'.	self assert: $@ storeString = '$@'.	self assert: Character cr storeString = 'Character cr'.	self assert: Character lf storeString = 'Character lf'.	self assert: Character space storeString = 'Character space'.	self assert: (Character value: 0) storeString = '(Character value: 0)'.	self assert: (Character value: 17) storeString = '(Character value: 17)'.! !!CharacterTest methodsFor: 'testing-printing' stamp: 'lr 11/21/2005 17:24'!testStoreStringAll	Character allCharacters do: [ :each |		self assert: (self class compilerClass 			evaluate: each storeString) = each ].! !!CharacterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Character. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Circle methodsFor: 'display box access'!computeBoundingBox	^center - radius + form offset extent: form extent + (radius * 2) asPoint! !!Circle methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	1 to: 4 do:		[:i |		super quadrant: i.		super displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Circle methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	1 to: 4 do:		[:i |		super quadrant: i.		super displayOn: aDisplayMedium			transformation: aTransformation			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Circle commentStamp: '<historical>' prior: 0!I represent a full circle. I am made from four Arcs.!!Circle class methodsFor: 'examples'!exampleOne 	"Click any button somewhere on the screen. The point will be the center	of the circcle of radius 150."	| aCircle aForm |	aForm := Form extent: 1@30.	aForm fillBlack.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display		"Circle exampleOne"! !!Circle class methodsFor: 'examples'!exampleTwo	"Designate a rectangular area that should be used as the brush for	displaying the circle. Click any button at a point on the screen which	will be the center location for the circle. The curve will be displayed	with a long black form."	| aCircle aForm |	aForm := Form fromUser.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display at: 0 @ 0 rule: Form reverse 	 "Circle exampleTwo"! !!CircleMorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testCircleInstance"""self run: #testCircleInstance" | circ |self assert: (circ := CircleMorph initializedInstance) extent = circ extent x asPoint! !!CircleMorphTest methodsFor: 'initialize-release' stamp: 'tlk 5/21/2006 14:17'!setUp	morph := CircleMorph new! !!CircleMorphTest commentStamp: 'tlk 5/21/2006 14:16' prior: 0!A CircleMorphTest is a subclass of MorphTest.  It was first implemented when removing some unused and broken functionality.My fixtures are morph, a CircleMorph and world.!!Class methodsFor: 'class variables' stamp: 'ar 2/21/2008 15:35'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol := aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do:[:classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				ifNotEmpty:[^Undeclared declare: aSymbol from: classPool]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool := nil].! !!ClassBuilder methodsFor: 'private' stamp: 'eem 7/19/2010 10:24'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject Message	)! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!baseClassName	^#DummyClassBuilderFormatTestSuperClass! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!cleanup	subClass ifNotNil:[subClass removeFromSystem].	baseClass ifNotNil:[baseClass removeFromSystem].! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeByteVariableSubclassOf: aClass	subClass := aClass variableByteSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeIVarsSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: 'var3 var4'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeNormalSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:15'!makeVariableSubclassOf: aClass	subClass := aClass variableSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!makeWeakSubclassOf: aClass	subClass := aClass weakSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!makeWordVariableSubclassOf: aClass	subClass := aClass variableWordSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'ar 1/4/2004 20:16'!subClassName	^#DummyClassBuilderFormatTestSubClass! !!ClassBuilderTest methodsFor: 'running' stamp: 'abc 2/12/2010 11:24'!tearDown	self cleanup.! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:21'!testByteVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableByteSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 7/13/2009 21:18'!testChangeToVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[		self shouldnt:[baseClass := Object variableSubclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:20'!testSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self assert:(subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:21'!testSubclassWithInstanceVariables	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var1 var2'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:20'!testVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:20'!testWeakSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object weakSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'ar 1/4/2004 20:20'!testWordVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableWordSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'abc 2/12/2010 12:33'!testDuplicateClassVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: 'TestVar'		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'abc 2/12/2010 12:32'!testDuplicateInstanceVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'abc 2/12/2010 12:32'!testMoveVarFromSubToSuperclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	subClass := baseClass subclass: self subClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	subInst instVarAt: 1 put: 123.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	] on: DuplicateVariableError do:[:ex| ex resume].	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	"the assumption here is that an existing value is propagated up"	self assert: (baseInst instVarAt: 1) = nil.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	"the assumption here is that the current (subclass) value is propagated up"	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'abc 2/12/2010 12:32'!testMoveVarFromSuperToSubclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	baseInst instVarAt: 1 put: 42.	subInst instVarAt: 1 put: 123.	self assert: (baseInst instVarAt: 1) = 42.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: 'Kernel-Tests-ClassBuilder'	] on: DuplicateVariableError do:[:ex| ex resume].	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	self assert: (baseInst instVarAt: 1) = 42.	"the assumption below is that for duplicate variables the values get duplicated too.	this isn't strictly necessary; what we really need is that the old var doesn't get 	nuked but it has some advantages when moving vars up the hierarchy"	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	self assert: (subInst superGet) = 123.	self assert: (subInst subGet) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	baseClass removeSelector: #superGet.	baseClass removeSelector: #superSet:.	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Kernel-Tests-ClassBuilder'.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'eem 3/7/2009 17:29'!trimHistoryAggressively	"Drop non-essential or obsolete history."	| realClass |	(realClass := self realClass) ifNil:		[methodChanges keysAndValuesRemove: [:sel :chgRecord | true].		 changeTypes removeAllFoundIn: #(rename reorganize add change).		 ^self].	"Forget methods for removed classes.  Forget methods added and later	 removed.  Forget added/changed records for methods no longer existing"	methodChanges keysAndValuesRemove:		[:sel :chgRecord |		chgRecord changeType == #addedThenRemoved		or: [(#(added change) includes: chgRecord changeType)			and: [(realClass includesSelector: sel) not]]].	"Forget renaming and reorganization of newly-added classes."	(changeTypes includes: #add) ifTrue:		[changeTypes removeAllFoundIn: #(rename reorganize)]! !!ClassDescription methodsFor: 'copying' stamp: 'eem 7/5/2010 11:22'!copy: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	"Useful when modifying an existing class"	(class sourceCodeAt: sel ifAbsent: []) ifNotNil:		[:code| | method category |		method := class compiledMethodAt: sel.		category := cat == nil						ifTrue: [class organization categoryOfElement: sel]						ifFalse: [cat].		((self methodDict includesKey: sel)		 and: [code asString ~= (self sourceCodeAt: sel) asString]) ifTrue:			[self error: self name , ' '  , sel  , ' will be redefined if you proceed.'].		self compile: code classified: category withStamp: method timeStamp notifying: nil]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'eem 1/28/2009 16:31'!hasChangedMethods	"Answer if any of the receiver's methods would appear on the changes file	if it were condensed."	self methodsDo: [:meth | meth fileIndex > 1 ifTrue: [^true]].	^false! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'eem 1/28/2009 16:04'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble := self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble := ''].	method := self methodDict at: selector ifAbsent:		[outStream nextPutAll: selector; cr.		outStream tab; nextChunkPut: '** ERROR!!  THIS SCRIPT IS MISSING ** ' translated; cr; cr.		outStream nextPutAll: '  '.		^ outStream].	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos := method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile := SourceFiles at: method fileIndex.		preamble size > 0			ifTrue:    "Copy the preamble"				[outStream copyPreamble: preamble from: sourceFile at: oldPos]			ifFalse:				[sourceFile position: oldPos].		"Copy the method chunk"		newPos := outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ClassDescriptionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:24'!testOrganization	| aClassOrganizer |	aClassOrganizer := ClassDescription organization.	self assert: (aClassOrganizer isKindOf: ClassOrganizer).! !!ClassDescriptionTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ClassDescription. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!ClassOrganizer methodsFor: 'accessing' stamp: 'ar 4/9/2007 11:43'!classComment: aString	"Guards against setting the comment in a metaclass which is invalid"	subject isMeta ifTrue:[^self error: 'Cannot set metaclass comments'].	^super classComment: aString! !!ClassOrganizer methodsFor: 'accessing' stamp: 'ar 4/9/2007 11:43'!classComment: aString  stamp: aStamp	"Guards against setting the comment in a metaclass which is invalid"	subject isMeta ifTrue:[^self error: 'Cannot set metaclass comments'].	^super classComment: aString  stamp: aStamp! !!ClassReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:33'!<= anotherMethodOrClassReference	classSymbol < anotherMethodOrClassReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodOrClassReference classSymbol ifTrue: [^false].	classIsMeta = anotherMethodOrClassReference classIsMeta ifFalse: [^classIsMeta not].	"i.e. if anotherMethodOrClassReference is a MethodReference then we're < it, and so <= to it"	^true! !!ClassReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:30'!= anotherMethodReference 	"Answer whether the receiver and the argument represent the 	 same object."	^ self species == anotherMethodReference species	   and: [self classSymbol = anotherMethodReference classSymbol	   and: [self classIsMeta = anotherMethodReference classIsMeta]]! !!ClassReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:27'!isClassReference	^true! !!ClassReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:27'!isMethodReference	^false! !!ClassReference methodsFor: 'accessing' stamp: 'eem 7/15/2010 17:00'!actualClass 	| actualClass |	actualClass := Smalltalk at: classSymbol ifAbsent: [^nil].	^classIsMeta ifTrue: [actualClass class] ifFalse: [actualClass]! !!ClassReference methodsFor: 'accessing' stamp: 'eem 5/7/2008 11:41'!asStringOrText	^stringVersion! !!ClassReference methodsFor: 'accessing' stamp: 'eem 5/7/2008 18:22'!classIsMeta	^classIsMeta! !!ClassReference methodsFor: 'accessing' stamp: 'eem 5/7/2008 16:31'!classSymbol	^classSymbol! !!ClassReference methodsFor: 'accessing' stamp: 'eem 5/8/2008 09:50'!compiledMethod	^nil! !!ClassReference methodsFor: 'accessing' stamp: 'eem 5/7/2008 11:41'!stringVersion	^stringVersion! !!ClassReference methodsFor: 'setting' stamp: 'eem 5/7/2008 11:42'!setClassAndSelectorIn: csBlock	^csBlock value: self actualClass value: #Definition! !!ClassReference methodsFor: 'initialize-release' stamp: 'eem 7/17/2008 10:42'!setClassSymbol: classSym classIsMeta: isMeta stringVersion: aString 	classSymbol := classSym.	classIsMeta := isMeta.	stringVersion := aString. ' (definition)'! !!ClassReference methodsFor: 'initialize-release' stamp: 'eem 5/7/2008 11:40'!setStandardClass: aClass	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	stringVersion := aClass name, ' (definition)'! !!ClassReference methodsFor: 'queries' stamp: 'eem 7/15/2010 17:34'!sourceString	^self actualClass definition! !!ClassReference commentStamp: '<historical>' prior: 0!A ClassReference is is a lightweight proxy for a Class's definition.  Allows class definitions to be viewed in MessageListsInstance Variables	classSymbol:		Symbol for method's class (without class keyword if meta)	stringVersion:		the class's definition!!ClassReference class methodsFor: 'instance creation' stamp: 'eem 5/7/2008 11:23'!class: aClass	^ self new setStandardClass: aClass! !!ClassRenameFixTest methodsFor: 'Private' stamp: 'md 9/6/2005 18:30'!newUniqueClassName	"Return a class name that is not used in the system."	"self new newClassName"	| baseName newName |	baseName := 'AutoGeneratedClassForTestingSystemChanges'.	1 to: 9999		do: 			[:number | 			newName := baseName , number printString.			(Smalltalk hasClassNamed: newName) ifFalse: [^newName asSymbol]].	^self 		error: 'Can no longer find a new and unique class name for the SystemChangeTest !!'! !!ClassRenameFixTest methodsFor: 'Private' stamp: 'md 9/6/2005 18:30'!removeEverythingInSetFromSystem: aChangeSet 	aChangeSet changedMessageList		do: [:methodRef | methodRef actualClass removeSelector: methodRef methodSymbol].	aChangeSet changedClasses		do: [:each | each isMeta				ifFalse: [each removeFromSystemUnlogged]]! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21'!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'md 9/6/2005 18:30'!testRenameClassUsingClass	"self run: #testRenameClassUsingClass"	self renameClassUsing: [:class :newName | class rename: newName].! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20'!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'pk 5/13/2007 14:16'!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangesOrganizer removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 19:04'!verifyRenameEvent: aRenamedEvent	| renamedClass |	self assert: aRenamedEvent isRenamed.	renamedClass :=  aRenamedEvent item.	self assert: (Smalltalk classNamed: newClassName) name = newClassName.	self assert: renamedClass name = newClassName! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05'!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08'!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'md 1/5/2004 14:59'!testAddInstVarName	"self run: #testAddInstVarName"			| tutu |	tutu := Smalltalk at: #TUTU.	tutu addInstVarName: 'x'.	self assert: (tutu instVarNames = #('x')).	tutu addInstVarName: 'y'.	self assert: (tutu instVarNames = #('x' 'y'))		! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13'!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !!ClassTest methodsFor: 'testing - compiling' stamp: 'sd 6/5/2005 08:25'!testCompileAll	self shouldnt: [ClassTest compileAll] raise: Error.! !!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:32'!categoriesForClass: aClass ^ aClass organization allMethodSelectors collect: 			[:each |  aClass organization categoryOfElement: each].! !!ClassTestCase methodsFor: 'private' stamp: 'md 1/28/2004 11:28'!targetClass  |className|  className := self class name asText copyFrom: 0 to: self class name size - 4.  ^ Smalltalk at: (className asString asSymbol).! !!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/27/2003 12:39'!classToBeTested		self subclassResponsibility! !!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/26/2003 16:35'!selectorsNotTested	^ self selectorsToBeTested difference: self selectorsTested.! !!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/26/2003 17:22'!selectorsToBeIgnored	^ #(#DoIt #DoItIn:)! !!ClassTestCase methodsFor: 'coverage' stamp: 'brp 7/27/2003 12:40'!selectorsToBeTested	^ ( { self classToBeTested. self classToBeTested class } gather: [:c | c selectors]) 			difference: self selectorsToBeIgnored! !!ClassTestCase methodsFor: 'Coverage' stamp: 'apb 4/15/2006 11:50'!selectorsTested	| literals |	literals := Set new.	self class		selectorsAndMethodsDo: [ :s :m | (s beginsWith: 'test')			ifTrue: [ literals addAll: (m messages)] ].	^ literals asSortedArray! !!ClassTestCase methodsFor: 'tests' stamp: 'md 3/26/2003 17:39'!testClassComment	self shouldnt: [self targetClass organization hasNoComment].! !!ClassTestCase methodsFor: 'tests' stamp: 'brp 12/14/2003 15:51'!testCoverage	| untested | 	self class mustTestCoverage ifTrue:		[ untested := self selectorsNotTested.		self assert: untested isEmpty 		description: untested size asString, ' selectors are not covered' ]! !!ClassTestCase methodsFor: 'tests' stamp: 'md 3/25/2003 23:07'!testNew	self shouldnt: [self targetClass new] raise: Error.! !!ClassTestCase methodsFor: 'tests' stamp: 'md 3/26/2003 17:24'!testUnCategorizedMethods	| categories slips  |	categories := self categoriesForClass: self targetClass.	slips := categories select: [:each | each = #'as yet unclassified'].	self should: [slips isEmpty].	! !!ClassTestCase commentStamp: 'brp 7/26/2003 16:57' prior: 0!This class is intended for unit tests of individual classes and their metaclasses.It provides methods to determine the coverage of the unit tests.Subclasses are expected to re-implement #classesToBeTested and #selectorsToBeIgnored.They should also implement to confirm that all methods have been tested.#testCoverage	super testCoverage.!!ClassTestCase class methodsFor: 'Testing' stamp: 'md 2/22/2006 14:21'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #ClassTestCase			! !!ClassTestCase class methodsFor: 'Testing' stamp: 'brp 12/14/2003 15:50'!mustTestCoverage	^ false! !!Clipboard class methodsFor: 'class initialization' stamp: 'ar 6/22/2010 18:43'!initialize	"We need this preference to exist."	Preferences 		addBooleanPreference: #usePrimitiveClipboard 		category: #general 		default: true		balloonHelp: 'If enabled, you can copy/paste back and forth between Squeak and other apps.  This preference exists because enabling this functionality causes crashes on unix Squeak'.! !!ClosureCompilerTest methodsFor: 'source' stamp: 'eem 7/1/2009 10:51'!closureCases	^#('| n |n := 1.^n + n''| i |i := 0.[i := i + 1. i <= 10] whileTrue.^i''[:c :s| | mn |mn := Compiler new		compile: (c sourceCodeAt: s)		in: c		notifying: nil		ifFail: [self halt].mn generate: #(0 0 0 0).{mn blockExtentsToTempsMap.  mn encoder schematicTempNames}]			value: AbstractInstructionTests			value: #runBinaryConditionalJumps:''inject: thisValue into: binaryBlock	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue''runBinaryConditionalJumps: assertPrintBar	"CogIA32CompilerTests new runBinaryConditionalJumps: false"	| mask reg1 reg2 reg3 |	mask := 1 << self processor bitsInWord - 1.	self concreteCompilerClass dataRegistersWithAccessorsDo:		[:n :get :set|		n = 0 ifTrue: [reg1 := get].		n = 1 ifTrue: [reg2 := set].		n = 2 ifTrue: [reg3 := set]].	#(	(JumpAbove > unsigned)			(JumpBelowOrEqual <= unsigned)		(JumpBelow < unsigned)			(JumpAboveOrEqual >= unsigned)		(JumpGreater > signed)			(JumpLessOrEqual <= signed)		(JumpLess < signed)				(JumpGreaterOrEqual >= signed)		(JumpZero = signed)				(JumpNonZero ~= signed)) do:		[:triple|		[:opName :relation :signednessOrResult| | opcode jumpNotTaken jumpTaken nop memory bogus |		self resetGen.		opcode := CogRTLOpcodes classPool at: opName.		self gen: CmpRR operand: 2 operand: 1.		jumpTaken := self gen: opcode.		self gen: MoveCqR operand: 0 operand: 0.		jumpNotTaken := self gen: Jump.		jumpTaken jmpTarget: (self gen: MoveCqR operand: 1 operand: 0).		jumpNotTaken jmpTarget: (nop := self gen: Nop).		memory := self generateInstructions.		bogus := false.		self pairs: (-2 to: 2)  do:			[:a :b| | taken |			self processor				reset;				perform: reg2 with: a signedIntToLong;				perform: reg3 with: b signedIntToLong.			[self processor singleStepIn: memory.			 self processor pc ~= nop address] whileTrue.			taken := (self processor perform: reg1) = 1.			assertPrintBar				ifTrue:					[self assert: taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b])]				ifFalse:					[Transcript						nextPutAll: reg2; nextPut: $(; print: a; nextPutAll: '') ''; nextPutAll: relation; space;						nextPutAll: reg3; nextPut: $(; print: b; nextPutAll: '') = '';						print: taken; cr; flush.					 taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b]) ifFalse:						[bogus := true]]].			 bogus ifTrue:				[self processor printRegistersOn: Transcript.				 Transcript show: (self processor disassembleInstructionAt: jumpTaken address In: memory); cr]]					valueWithArguments: triple]''mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asSortedCollection				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector| | subMap tempVector numTemps |		subMap := Dictionary new.		"Find how many temp slots there are (direct & indirect temp vectors)		 and for each indirect temp vector find how big it is."		tempNameTupleVector do:			[:tuple|			tuple last isArray				ifTrue:					[subMap at: tuple last first put: tuple last last.					 numTemps := tuple last first]				ifFalse:					[numTemps := tuple last]].		"create the temp vector for this scope level."		tempVector := Array new: numTemps.		"fill it in with any indirect temp vectors"		subMap keysAndValuesDo:			[:index :size|			tempVector at: index put: (Array new: size)].		"fill it in with temp nodes."		tempNameTupleVector do:			[:tuple| | itv |			tuple last isArray				ifTrue:					[itv := tempVector at: tuple last first.					 itv at: tuple last last						put: (aDecompilerConstructor								codeTemp: tuple last last - 1								named: tuple first)]				ifFalse:					[tempVector						at: tuple last						put: (aDecompilerConstructor								codeTemp: tuple last - 1								named: tuple first)]].		"replace any indirect temp vectors with proper RemoteTempVectorNodes"		subMap keysAndValuesDo:			[:index :size|			tempVector				at: index				put: (aDecompilerConstructor						codeRemoteTemp: index						remoteTemps: (tempVector at: index))].		"and update the entry in the map"		map at: startpc put: tempVector].	^map' 'gnuifyFrom: inFileStream to: outFileStream"convert interp.c to use GNU features"	| inData beforeInterpret inInterpret inInterpretVars beforePrimitiveResponse inPrimitiveResponse |	inData := inFileStream upToEnd withSqueakLineEndings.	inFileStream close.	"print a header"	outFileStream		nextPutAll: ''/* This file has been post-processed for GNU C */'';		cr; cr; cr.	beforeInterpret := true.    "whether we are before the beginning of interpret()"	inInterpret := false.     "whether we are in the middle of interpret"	inInterpretVars := false.    "whether we are in the variables of interpret"	beforePrimitiveResponse := true.  "whether we are before the beginning of primitiveResponse()"	inPrimitiveResponse := false.   "whether we are inside of primitiveResponse"	''Gnuifying''		displayProgressAt: Sensor cursorPoint		from: 1 to: (inData occurrencesOf: Character cr)		during:			[:bar | | lineNumber |			lineNumber := 0.			inData linesDo:				[ :inLine | | outLine extraOutLine caseLabel |				bar value: (lineNumber := lineNumber + 1).				outLine := inLine. 	"print out one line for each input line; by default, print out the line that was input, but some rules modify it"				extraOutLine := nil.   "occasionally print a second output line..."				beforeInterpret ifTrue: [					inLine = ''#include "sq.h"'' ifTrue: [						outLine := ''#include "sqGnu.h"'' ].					inLine = ''interpret(void) {'' ifTrue: [						"reached the beginning of interpret"						beforeInterpret := false.						inInterpret := true.						inInterpretVars := true ] ]				ifFalse: [				inInterpretVars ifTrue: [					(inLine findString: ''register struct foo * foo = &fum;'') > 0 ifTrue: [						outLine := ''register struct foo * foo FOO_REG = &fum;'' ].					(inLine findString: '' localIP;'') > 0 ifTrue: [						outLine := ''    char* localIP IP_REG;'' ].					(inLine findString: '' localFP;'') > 0 ifTrue: [						outLine := ''    char* localFP FP_REG;'' ].					(inLine findString: '' localSP;'') > 0 ifTrue: [						outLine := ''    char* localSP SP_REG;'' ].					(inLine findString: '' currentBytecode;'') > 0 ifTrue: [						outLine := ''    sqInt currentBytecode CB_REG;'' ].					inLine isEmpty ifTrue: [						"reached end of variables"						inInterpretVars := false.						outLine := ''    JUMP_TABLE;''.						extraOutLine := inLine ] ]				ifFalse: [				inInterpret ifTrue: [					"working inside interpret(); translate the switch statement"					(inLine beginsWith: ''		case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''		CASE('', caseLabel, '')'' ].					inLine = ''			break;'' ifTrue: [						outLine := ''			BREAK;'' ].					inLine = ''}'' ifTrue: [						"all finished with interpret()"						inInterpret := false ] ]				ifFalse: [				beforePrimitiveResponse ifTrue: [					(inLine beginsWith: ''primitiveResponse('') ifTrue: [						"into primitiveResponse we go"						beforePrimitiveResponse := false.						inPrimitiveResponse := true.						extraOutLine := ''    PRIM_TABLE;'' ] ]				ifFalse: [				inPrimitiveResponse ifTrue: [					inLine = ''	switch (primitiveIndex) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					inLine = ''	switch (GIV(primitiveIndex)) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					(inLine beginsWith: ''	case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''	CASE('', caseLabel, '')'' ].					inLine = ''}'' ifTrue: [						inPrimitiveResponse := false ] ]				] ] ] ].				outFileStream nextPutAll: outLine; cr.				extraOutLine ifNotNil: [					outFileStream nextPutAll: extraOutLine; cr ]]].	outFileStream close' )! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 12:28'!doTestDebuggerTempAccessWith: one with: two	"Test debugger access for temps"	| outerContext local1 remote1 |	outerContext := thisContext.	local1 := 3.	remote1 := 1/2.	self assert: (Compiler new evaluate: 'one' in: thisContext to: self) == one.	self assert: (Compiler new evaluate: 'two' in: thisContext to: self) == two.	self assert: (Compiler new evaluate: 'local1' in: thisContext to: self) == local1.	self assert: (Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.	Compiler new evaluate: 'local1 := -3.0' in: thisContext to: self.	self assert: local1 = -3.0.	(1 to: 2) do:		[:i| | local2 r1 r2 r3 r4 |		local2 := i * 3.		remote1 := local2 / 7.		self assert: thisContext ~~ outerContext.		self assert: (r1 := Compiler new evaluate: 'one' in: thisContext to: self) == one.		self assert: (r2 := Compiler new evaluate: 'two' in: thisContext to: self) == two.		self assert: (r3 := Compiler new evaluate: 'i' in: thisContext to: self) == i.		self assert: (r4 := Compiler new evaluate: 'local2' in: thisContext to: self) == local2.		self assert: (r4 := Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.		self assert: (r4 := Compiler new evaluate: 'remote1' in: outerContext to: self) == remote1.		Compiler new evaluate: 'local2 := 15' in: thisContext to: self.		self assert: local2 = 15.		Compiler new evaluate: 'local1 := 25' in: thisContext to: self.		self assert: local1 = 25.		{ r1. r2. r3. r4 } "placate the compiler"].	self assert: local1 = 25.	self assert: remote1 = (6/7)! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 16:58'!supportTestSourceRangeAccessForDecompiledInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= t1'								'do: [:t4 | t3 := t2 value: t3 value: t4]'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'^t3')! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 19:44'!supportTestSourceRangeAccessForDecompiledNoBytecodeInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	'at: 1 put: t1'								'do: [:t4 | t3 at: 1 put: (t2 value: (t3 at: 1) value: t4)]'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'^t3 at: 1')! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 20:53'!supportTestSourceRangeAccessForInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= thisValue'								'do: [:each | nextValue := binaryBlock value: nextValue value: each]'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'^nextValue')! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/29/2008 17:16'!supportTestSourceRangeAccessForInjectInto: method source: source selectionSequence: selections	"Test debugger source range selection for inject:into:"	| evaluationCount sourceMap debugTokenSequence debugCount |	DebuggerMethodMap voidMapCache.	evaluationCount := 0.	sourceMap := method debuggerMap abstractSourceMap.	debugTokenSequence := selections collect: [:string| Scanner new scanTokens: string].	debugCount := 0.	thisContext		runSimulated: [(1 to: 2)						withArgs:							{	0.								[:sum :each|								 evaluationCount := evaluationCount + 1.								 sum + each]}						executeMethod: method]		contextAtEachStep:			[:ctxt| | range debugTokens |			(ctxt method == method			and: ["Exclude the send of #blockCopy: or #closureCopy:copiedValues: and braceWith:with:				    to create the block, and the #new: and #at:'s for the indirect temp vector.				   This for compilation without closure bytecodes. (Note that at:put:'s correspond to stores)"				(ctxt willSend					and: [(#(closureCopy:copiedValues: blockCopy: new: at: braceWith:with:) includes: ctxt selectorToSendOrSelf) not])				"Exclude the store of the argument into the home context (for BlueBook blocks)				 and the store of an indirection vector into an initial temp"				or: [(ctxt willStore					and: [(ctxt isBlock and: [ctxt pc = ctxt startpc]) not					and: [(ctxt isBlock not						and: [(method usesClosureBytecodes and: [ctxt abstractPC = 2])]) not]])				or: [ctxt willReturn]]]) ifTrue:				[debugTokens := debugTokenSequence at: (debugCount := debugCount + 1) ifAbsent: [#(bogusToken)].				 self assert: (sourceMap includesKey: ctxt abstractPC).				 range := sourceMap at: ctxt abstractPC ifAbsent: [(1 to: 0)].				 self assert: (Scanner new scanTokens: (source copyFrom: range first to: range last)) = debugTokens]].	self assert: evaluationCount = 2! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/12/2010 15:12'!testBlockNumbering	"Test that the compiler and CompiledMethod agree on the block numbering of a substantial doit."	"self new testBlockNumbering"	| methodNode method tempRefs |	methodNode :=		Parser new			encoderClass: EncoderForV3PlusClosures;			parse: 'foo					| numCopiedValuesCounts |					numCopiedValuesCounts := Dictionary new.					0 to: 32 do: [:i| numCopiedValuesCounts at: i put: 0].					Transcript clear.					Smalltalk allClasses remove: GeniePlugin; do:						[:c|						{c. c class} do:							[:b|							Transcript nextPut: b name first; endEntry.							b selectorsAndMethodsDo:								[:s :m| | pn |								m isQuick not ifTrue:									[pn := b parserClass new												encoderClass: EncoderForV3PlusClosures;												parse: (b sourceCodeAt: s)												class: b.									 pn generate: #(0 0 0 0).									 [pn accept: nil]										on: MessageNotUnderstood										do: [:ex| | msg numCopied |											msg := ex message.											(msg selector == #visitBlockNode:											 and: [(msg argument instVarNamed: ''optimized'') not]) ifTrue:												[numCopied := (msg argument computeCopiedValues: pn) size.												 numCopiedValuesCounts													at: numCopied													put: (numCopiedValuesCounts at: numCopied) + 1].											msg setSelector: #==.											ex resume: nil]]]]].					numCopiedValuesCounts'			class: Object.	method := methodNode generate.	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys asSet = method startpcsToBlockExtents values asSet! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/12/2010 15:12'!testBlockNumberingForInjectInto	"Test that the compiler and CompiledMethod agree on the block numbering of Collection>>inject:into:	 and that temp names for inject:into: are recorded."	"self new testBlockNumberingForInjectInto"	| methodNode method tempRefs |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate.	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys asSet = method startpcsToBlockExtents values asSet.	self assert: ((tempRefs includesKey: (0 to: 6))				and: [(tempRefs at: (0 to: 6)) hasEqualElements: #(('thisValue' 1) ('binaryBlock' 2) ('nextValue' (3 1)))]).	self assert: ((tempRefs includesKey: (2 to: 4))				and: [(tempRefs at: (2 to: 4)) hasEqualElements: #(('each' 1) ('binaryBlock' 2) ('nextValue' (3 1)))])! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 11:03'!testDebuggerTempAccess	self doTestDebuggerTempAccessWith: 1 with: 2! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/11/2010 18:19'!testDecompiledDoitMethodTempNames	"self new testDecompiledDoitMethodTempNames"	"Test that a decompiled doit that has been copied with temps decompiles to the input"	| removeComments |	removeComments := [:n| n comment: nil].	self closureCases do:		[:source| | mns m mps mnps |		"Need to compare an ungenerated tree with the generated method's methodNode		 because generating code alters the tree when it introduces remote temp vectors."		mns := #(first last) collect:					[:ignored|					source first isLetter						ifTrue:							[self class compilerClass new								compile: source								in: self class								notifying: nil								ifFail: [self error: 'compilation error']]						ifFalse:							[self class compilerClass new								compileNoPattern: source								in: self class								context: nil								notifying: nil								ifFail: [self error: 'compilation error']]].		m := (mns last generate) copyWithTempsFromMethodNode: mns last.		removeComments value: mns first.		mns first nodesDo: removeComments.		self assert: (mnps := mns first printString) = (mps := m methodNode printString)]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/11/2010 18:19'!testInjectIntoDecompilations	"Test various compilations decompile to the same code for a method sufficiently	 simple that this is possible and sufficiently complex that the code generated	 varies between the compilations."	"self new testInjectIntoDecompilations"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3. EncoderForLongFormV3.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate.		self assert: (Scanner new scanTokens: method decompileString)					= #(inject: t1 into: t2							| t3 |							t3 ':=' t1 .							self do: [ ':t4' | t3 ':=' t2 value: t3 value: t4 ] .							^ t3)]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/11/2010 18:19'!testInjectIntoDecompiledDebugs	"Test various debugs of the decompiled form debug correctly."	"self new testInjectIntoDecompiledDebugs"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate.		self supportTestSourceRangeAccessForDecompiledInjectInto: method source: method decompileString]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 11:51'!testInlineBlockCollectionEM1	| a1 b1 i1 a2 b2 i2 we wb |	b1 := OrderedCollection new.	i1 := 1.	[a1 := i1.	 i1 <= 3] whileTrue:		[b1 add: [a1].		i1 := i1 + 1].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	i2 := 1.	we := [a2 := i2. i2 <= 3].	wb := [b2 add: [a2]. i2 := i2 + 1].	we whileTrue: wb. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:25'!testInlineBlockCollectionLR1	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | col add: [ each ] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:39'!testInlineBlockCollectionLR2	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/9/2009 11:00'!testInlineBlockCollectionLR3	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/22/2009 16:55'!testInlineBlockCollectionSD1	| a1 b1 a2 b2 |	b1 := OrderedCollection new.	1 to: 3 do:		[:i |		a1 := i.		b1 add: [a1]].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	1 to: 3 do:		[:i |		a2 := i.		b2 add: [a2]] yourself. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/11/2010 18:19'!testMethodAndNodeTempNames	"self new testMethodAndNodeTempNames"	"Test that BytecodeAgnosticMethodNode>>blockExtentsToTempRefs answers the same	 structure as CompiledMethod>>blockExtentsToTempRefs when the method has been	 copied with the appropriate temps.  This tests whether doit methods are debuggable	 since they carry their own temps."	self closureCases do:		[:source| | mn om m mbe obe |		mn := source first isLetter					ifTrue:						[self class compilerClass new							compile: source							in: self class							notifying: nil							ifFail: [self error: 'compilation error']]					ifFalse:						[self class compilerClass new							compileNoPattern: source							in: self class							context: nil							notifying: nil							ifFail: [self error: 'compilation error']].		m := (om := mn generate) copyWithTempsFromMethodNode: mn.		self assert: m holdsTempNames.		self assert: m endPC = om endPC.		mbe := m blockExtentsToTempsMap.		obe := mn blockExtentsToTempsMap.		self assert: mbe keys = obe keys.		(mbe keys intersection: obe keys) do:			[:interval|			self assert: (mbe at: interval) = (obe at: interval)]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:33'!testOptimizedBlockLocalNilling1	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 3 do: [:i| | j |		self assert: j isNil.		j := i + 1.		self assert: j isNil not]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:32'!testOptimizedBlockLocalNilling2	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 6 do: [:i| | j k |		self assert: j isNil.		self assert: k isNil.		i even			ifTrue: [j := i + 2]			ifFalse: [k := i + 1].		self assert: (j isNil or: [k isNil]).		self assert: (j isNil not or: [k isNil not])]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookLongFormInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookLongFormInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureLongFormBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureLongFormBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 11:40'!testSourceRangeAccessForInjectInto	"Test debugger source range selection for inject:into: for the current version of the method"	"self new testSourceRangeAccessForInjectInto"	self supportTestSourceRangeAccessForInjectInto: (Collection compiledMethodAt: #inject:into:)		source: (Collection sourceCodeAt: #inject:into:) asString! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'abc 2/11/2010 18:19'!testTempNameAccessForInjectInto	"self new testTempNameAccessForInjectInto"	| methodNode method evaluationCount block debuggerMap |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate.	debuggerMap := DebuggerMethodMap forMethod: method methodNode: methodNode.	evaluationCount := 0.	block := [:prev :each| | theContext tempNames |			evaluationCount := evaluationCount + 1.			theContext := thisContext sender.			tempNames := debuggerMap tempNamesForContext: theContext.			self assert: (tempNames hasEqualElements: tempNames).			#('thisValue' 'each' 'binaryBlock' 'nextValue')				with: { 0. each. block. prev}				do: [:tempName :value|					self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext) == value.					tempName ~= 'each' ifTrue:						[self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext home) == value]]].	(1 to: 10) withArgs: { 0. block } executeMethod: method.	self assert: evaluationCount = 10! !!ClosureCompilerTest methodsFor: 'failures' stamp: 'ar 4/5/2010 20:50'!expectedFailures	^#(testDebuggerTempAccess testInjectIntoDecompilations testInjectIntoDecompiledDebugs)! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/20/2008 09:40'!methodWithCopiedAndAssignedTemps	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |	a := 1. "1w"	b := 2. "1w"	c := 4. "1w"	t := 0. "1w"	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".	r1 "5w" := blk "5r" value.	b "5w" := -100.	r2 "5w" := blk "5r" value.	^r1 "5r" -> r2 "5r" -> t "5r"	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:45'!methodWithCopiedAndPostClosedOverAssignedTemps	| blk a b c r1 r2 |	a := 1.	b := 2.	c := 4.	blk := [a + b + c].	r1 := blk value.	b := nil.	r2 := blk value.	r1 -> r2	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:10'!methodWithCopiedTemps	| a b c r |	a := 1.	b := 2.	c := 4.	r := [a + b + c] value.	b := nil.	r	"Parser new		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocks	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| b | b := 'notNil'. b].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocks)		class: self class"! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocksA	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| a | a := 'notNil'. a].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocksA)		class: self class"! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:12'!methodWithVariousTemps	| classes total totalLength |	classes := self withAllSuperclasses.	total := totalLength := 0.	classes do: [:class| | className |		className := class name.		total := total + 1.		totalLength := totalLength + className size].	^total -> totalLength	"Parser new		parse: (self class sourceCodeAt: #methodWithVariousTemps)		class: self class"! !!ClosureTests methodsFor: 'utilities' stamp: 'lr 3/9/2009 16:48'!assertValues: anArray	| values |	values := collection collect: [ :each | each value ].	self 		assert: anArray asArray = values asArray		description: 'Expected: ' , anArray asArray printString , 			', but got ' , values asArray printString! !!ClosureTests methodsFor: 'utilities' stamp: 'cwp 11/16/2009 08:12'!evaluateCopyOf: aBlock	aBlock copy value! !!ClosureTests methodsFor: 'utilities' stamp: 'cwp 11/16/2009 08:12'!methodWithNonLocalReturn	self evaluateCopyOf: [^ self].	self signalFailure: 'Should never reach here'! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:35'!methodArgument: anObject	^ [ anObject ]	! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockArgument	| block block1 block2 |	block := [ :arg | | temp | temp := arg. [ temp ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockTemp	| block block1 block2 |	block := [ :arg | [ arg ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ClosureTests methodsFor: 'testing' stamp: 'cwp 11/16/2009 08:11'!testCopyNonLocalReturn	self		shouldnt: [self methodWithNonLocalReturn]		raise: Error! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodArgument	| temp block |	temp := 0.	block := [ [ temp ] ].	temp := 1.	block := block value.	temp := 2.	self assert: block value = 2! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodTemp	| block1 block2 |	block1 := self methodArgument: 1.	block2 := self methodArgument: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ClosureTests methodsFor: 'running' stamp: 'lr 3/9/2009 16:48'!setUp	super setUp.	collection := OrderedCollection new! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgument	1 to: 5 do: [ :index |		collection add: [ index ] ].	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgumentNotInlined	| block |	block := [ :index |		collection add: [ index ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTemp	1 to: 5 do: [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTempNotInlined	| block |	block := [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTemp	| temp |	1 to: 5 do: [ :index | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTempNotInlined	| block temp |	block := [ :index | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfter	| index |	index := 0.	[ index < 5 ] whileTrue: [		collection add: [ index ].		index := index + 1 ].	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfterNotInlined	| index block |	index := 0.	block := [ 		collection add: [ index ].		index := index + 1 ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBefore	| index |	index := 0.	[ index < 5 ] whileTrue: [ 		index := index + 1.		collection add: [ index ] ].	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBeforeNotInlined	| index block |	index := 0.	block := [ 		index := index + 1.		collection add: [ index ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:52'!testWhileWithTemp	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:53'!testWhileWithTempNotInlined	| index block |	index := 0.	block := [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(1 2 3 4 5)! !!CodeDiffBuilder methodsFor: 'initialize' stamp: 'eem 5/8/2008 15:50'!formatLine: aString	^aString! !!CodeDiffBuilder methodsFor: 'initialize' stamp: 'eem 5/8/2008 15:32'!split: aString	^self split: aString parser: (class ifNil: [Object] ifNotNil: [class]) parserClass new! !!CodeDiffBuilder methodsFor: 'initialize' stamp: 'eem 5/9/2008 09:15'!split: aString parser: aParserOrScanner	| tokens index |	tokens := OrderedCollection new.	index := 1.	aParserOrScanner scanTokenPositionsIn: aString into:		[:start :end|		index < start ifTrue:			[tokens add: (WhitespaceForCodeDiff new string: (aString copyFrom: index to: start - 1))].		tokens add: (aString copyFrom: start to: end).		index := end + 1].	index < aString size ifTrue:		[tokens add: (WhitespaceForCodeDiff new string: (aString copyFrom: index to: aString size))].	^tokens! !!CodeDiffBuilder commentStamp: '<historical>' prior: 0!I am a differencer that compares source in tokens tokenised by a parser.  I consider comments significant, but consider sequences of whitespace equivalent.  Depending on the definition of WhitespaceForCodeDiff>>at: sequences of whitespace containing carriage-returns may be considered different to sequences of whitespace lacking carriage-returns (which may result in better-formatted diffs).!!CodeHolder methodsFor: 'message list' stamp: 'abc 2/12/2010 15:07'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new									parse: method getSourceFromFile asString									in: class									notifying: nil) generateWithTempNames.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'eem 7/6/2010 11:54'!buildCodePaneWith: builder editString: aTextOrNil	| spec codePaneSpec |	spec := self buildCodePaneWith: builder.	aTextOrNil ifNotNil:		[codePaneSpec := spec class = builder pluggableCodePaneSpec								ifTrue: [spec]								ifFalse: [spec children detect: [:child| child class = builder pluggableCodePaneSpec]].		 codePaneSpec initialText: aTextOrNil].	^spec! !!CodeHolder methodsFor: 'what to show' stamp: 'ar 6/22/2010 15:23'!showingTiles	"Answer whether the receiver is currently showing tiles"	^ contentsSymbol == #tiles! !!CodeHolder methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 19:02'!multiWindowState: aSavedMultiWindowState	multiWindowState := aSavedMultiWindowState! !!CodeHolder commentStamp: '<historical>' prior: 0!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder class methodsFor: 'class initialization' stamp: 'ar 6/23/2010 14:40'!initialize	"CodeHolder initialize"	ContentsSymbolQuints := self defaultContentsSymbolQuints asOrderedCollection.	EditContentsOptions := Dictionary new.	self defaultEditContentsOptions		do: [:opt | EditContentsOptions at: opt key put: opt value]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	"This is a hook to allow browsers to control whether to respond to the muli-window preference.	 Currenty CodeHolder cannot usefully use multi-windows, but may be able to do so in the future."	^false! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 11:43'!useMultiWindowBrowsers	<preference: 'Multi-window browsers'		category: 'browsing'		description: 'When enabled, the browser uses a multi-window to conserve real-estate.  e.g. enable then click in the window label of a browser.'		type: #Boolean>	^MultiWindowBrowsers ifNil: [false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 6/30/2010 21:37'!useMultiWindowBrowsers: aBoolean	MultiWindowBrowsers := aBoolean! !!CodeLoader class methodsFor: 'utilities' stamp: 'eem 7/1/2009 13:51'!exportCodeSegment: exportName classes: aClassList keepSource: keepSources	"Code for writing out a specific category of classes as an external image segment.  Perhaps this should be a method."	| is oldMethods newMethods classList symbolHolder fileName |	keepSources		ifTrue: [			self confirm: 'We are going to abandon sources.Quit without saving after this has run.' orCancel: [^self]].	classList := aClassList asArray.	"Strong pointers to symbols"	symbolHolder := Symbol allInstances.	oldMethods := OrderedCollection new: classList size * 150.	newMethods := OrderedCollection new: classList size * 150.	keepSources		ifTrue: [			classList do: [:cl |				cl selectors do:					[:selector | | m oldCodeString methodNode |					m := cl compiledMethodAt: selector.					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						methodNode := cl compilerClass new											parse: oldCodeString in: cl notifying: nil.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempsFromMethodNode: methodNode)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	oldMethods := newMethods := nil.	Smalltalk garbageCollect.	is := ImageSegment new copyFromRootsForExport: classList.	"Classes and MetaClasses"	fileName := FileDirectory fileName: exportName extension: ImageSegment fileExtension.	is writeForExport: fileName.	self compressFileNamed: fileName! !!Collection methodsFor: 'accessing' stamp: 'eem 3/5/2009 12:56'!atAll: aCollection put: anObject 	"Put anObject at every index specified by the elements of aCollection."	aCollection do: [:index | self at: index put: anObject].	^anObject! !!Collection methodsFor: 'accessing' stamp: 'crl 6/25/2009 11:48'!only	^(self size = 1)		ifTrue: [self anyOne]		ifFalse: [self error: 'I do not consist of a single element.']! !!Collection methodsFor: 'enumerating' stamp: 'crl 7/25/2009 21:44'!elect: aBlockClosure	"Answer any element which emerges victorious against the others in the test posed by aBlockClosure."	^self		inject: self anyOne		into: [:winner :next |			(aBlockClosure value: winner value: next)				ifTrue: [winner]				ifFalse: [next]]! !!Collection methodsFor: 'enumerating' stamp: 'eem 1/11/2009 14:11'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	| firstValue nextValue |	firstValue := nextValue := Object new. "something that can't be in the receiver"	self do:		[:each |		nextValue := firstValue == nextValue						ifTrue: [each]						ifFalse: [binaryBlock value: nextValue value: each]].	^nextValue == firstValue		ifTrue: [self errorEmptyCollection]		ifFalse: [nextValue]! !!Collection methodsFor: 'enumerating' stamp: 'ar 5/4/2010 08:40'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	self emptyCheck.	first := true.	self do:[:each|		first ifTrue:[nextValue := each. first := false]			ifFalse:[nextValue := binaryBlock value: nextValue value: each]].	^nextValue! !!Collection class methodsFor: 'private' stamp: 'ar 3/7/2006 19:57'!randomForPicking	^RandomForPicking ifNil:[Processor activeIsland random]! !!Collection class methodsFor: 'private' stamp: 'ar 3/7/2006 19:57'!randomForPicking: aRandom	RandomForPicking := aRandom.! !!CollectionTest methodsFor: 'initialize-release' stamp: 'st 10/7/2004 16:23'!setUp	empty := Set new.	nonEmpty := OrderedCollection with: #x! !!CollectionTest methodsFor: 'testing' stamp: 'fbs 1/14/2005 10:19'!testAsCommaString	{OrderedCollection new. Set new.} do:		[ :coll |		self assert: coll asCommaString = ''.		coll add: 1.		self assert: coll asCommaString = '1'.		coll add: 2; add: 3.		self assert: coll asCommaString = '1, 2, 3'].! !!CollectionTest methodsFor: 'testing' stamp: 'fbs 1/14/2005 10:19'!testAsCommaStringAnd	{OrderedCollection new. Set new.} do:		[ :coll |		self assert: coll asCommaStringAnd = ''.		coll add: 1.		self assert: coll asCommaStringAnd = '1'.		coll add: 2; add: 3.		self assert: coll asCommaStringAnd = '1, 2 and 3'].! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAsStringOnDelimiter	| delim |	delim := ', '.	{OrderedCollection new. Set new.} do:		[ :coll | | oneItemStream emptyStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll asStringOn: emptyStream delimiter: delim.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll asStringOn: oneItemStream delimiter: delim.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll asStringOn: multiItemStream delimiter: ', '.		self assert: multiItemStream contents = '1, 2, 3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAsStringOnDelimiterLast	| delim last |	delim := ', '.	last := ' & '.	{OrderedCollection new. Set new.} do:		[ :coll | | multiItemStream emptyStream oneItemStream |		emptyStream := ReadWriteStream on: ''.		coll asStringOn: emptyStream delimiter: delim last: last.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll asStringOn: oneItemStream delimiter: delim last: last.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll asStringOn: multiItemStream delimiter: ', ' last: last.		self assert: multiItemStream contents = '1, 2 & 3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testPrintOnDelimiter	| delim |	delim := ', '.	{OrderedCollection new. Set new.} do:		[ :coll | | emptyStream oneItemStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll printOn: emptyStream delimiter: delim.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll printOn: oneItemStream delimiter: delim.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll printOn: multiItemStream delimiter: ', '.		self assert: multiItemStream contents = '1'', ''2'', ''3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testPrintOnDelimiterLast	| delim last |	delim := ', '.	last := ' & '.	{OrderedCollection new. Set new.} do:		[ :coll | | emptyStream oneItemStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll printOn: emptyStream delimiter: delim last: last.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll printOn: oneItemStream delimiter: delim last: last.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll printOn: multiItemStream delimiter: ', ' last: last.		self assert: multiItemStream contents = '1'', ''2'' & ''3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!testPrintingArrayWithMetaclass	self assert: {Array class} printString = '{Array class}'! !!CollectionTest methodsFor: 'tests' stamp: 'ar 11/21/2009 01:00'!testIfEmpty	nonEmpty ifEmpty: [self assert: false].	self assert: (empty ifEmpty: [self]) == self.	self assert: (nonEmpty ifEmpty: [self]) == nonEmpty.! !!CollectionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:12'!testIfEmptyifNotEmpty	self assert: (empty ifEmpty: [true] ifNotEmpty: [false]).	self assert: (nonEmpty ifEmpty: [false] ifNotEmpty: [true]).	self assert: (nonEmpty ifEmpty: [false] ifNotEmpty: [:s | s first = #x])! !!CollectionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:12'!testIfEmptyifNotEmptyDo	self assert: (empty ifEmpty: [true] ifNotEmptyDo: [:s | false]).	self assert: (nonEmpty ifEmpty: [false] ifNotEmptyDo: [:s | s first = #x])! !!CollectionTest methodsFor: 'tests' stamp: 'ar 11/21/2009 00:58'!testIfNotEmpty	empty ifNotEmpty: [self assert: false].	self assert: (nonEmpty ifNotEmpty: [self]) == self.	self assert: (nonEmpty ifNotEmpty: [:s | s first]) = #x.	self assert: (empty ifNotEmpty: [self]) == empty.! !!CollectionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:13'!testIfNotEmptyDo	empty ifNotEmptyDo: [:s | self assert: false].	self assert: (nonEmpty ifNotEmptyDo: [:s | s first]) = #x! !!CollectionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:13'!testIfNotEmptyDoifNotEmpty	self assert: (empty ifNotEmptyDo: [:s | false] ifEmpty: [true]).	self assert: (nonEmpty ifNotEmptyDo: [:s | s first = #x] ifEmpty: [false])! !!CollectionTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:13'!testIfNotEmptyifEmpty	self assert: (empty ifEmpty: [true] ifNotEmpty: [false]).	self assert: (nonEmpty ifEmpty: [false] ifNotEmpty: [true]).	self assert: (nonEmpty ifEmpty: [false] ifNotEmpty: [:s | s first = #x])! !!CollectionTest methodsFor: 'tests' stamp: 'klc 3/7/2010 18:31'!testMinMax	self assert: #(5 6 3 -3 2 1 0 4) minMax = #(-3 6).	self assert: #($f $g $a $g $u $z $s $t) minMax = #($a $z).	self assert: #(2834.83 -293482.28 99283 23 959323) minMax = #(-293482.28 959323).! !!CollectionTest commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!Color methodsFor: 'conversions' stamp: 'jdm 6/20/2008 17:27'!asColorref	"Convert the receiver into a colorref"	^(self red * 255) asInteger + ((self green * 255) asInteger << 8) + ((self blue * 255) asInteger << 16)! !!Color methodsFor: 'transformations' stamp: 'bgf 7/22/2006 00:37'!darker	"Answer a darker shade of this color."	^ self adjustSaturation: 0.04 brightness: -0.08! !!Color methodsFor: 'transformations' stamp: 'jcg 6/25/2010 14:21'!duller	"Answer a darker, desaturated color.  If the original color isn't very saturated, desaturate it by less (otherwise will just end up with grey)."	| sat adjust |	(sat := self saturation) > 0.3		ifTrue: [adjust := -0.1]		ifFalse: [adjust := 0.1 - sat max: 0.0].	^ self adjustSaturation: adjust brightness: -0.1! !!Color methodsFor: 'transformations' stamp: 'bgf 7/22/2006 00:37'!twiceDarker	"Answer a significantly darker shade of this color."	^ self adjustSaturation: 0.075 brightness: -0.15! !!Color methodsFor: '*Morphic' stamp: 'bgf 12/28/2008 12:19'!morphicItemSelectionGradient	"For Morphic lists...  		 use this color as the basis of a 3-entry gradient to highlight an item in a list.	 The gradient is a gentle strengthening of the color.	 For light base colors, a gentle lightening is done	 (very light colors look muddy when darkened.)"	self brightness > 0.8 ifTrue: [		^ { self slightlyLighter. self lighter . self} .	] ifFalse: [ 		^ { self . self darker . self slightlyDarker } .	].! !!Color methodsFor: '*Morphic' stamp: 'bgf 12/28/2008 13:33'!morphicMenuGradient	"For Morphic menu item selections....  		 return a pair of colors for the fill.	 The gradient is a gentle strengthening of the color.	 For light base colors, a more gentle lightening is done."	self luminance > 0.75 ifTrue: [		^ { self slightlyLighter. self slightlyDarker} .	] ifFalse: [ 		^ { self lighter . self darker } .	].! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!red	^Red! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!veryVeryDarkGray	^VeryVeryDarkGray! !!ColorForm methodsFor: 'copying' stamp: 'ar 6/22/2005 23:19'!deepCopy	^ self shallowCopy		bits: bits copy;		offset: offset copy;		colors: colors copy! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'bgf 5/26/2010 11:04'!scaledToSize: newExtent	"Super method did not seem to work so well on ColorForms"	^(self asFormOfDepth: 32) scaledToSize: newExtent! !!ColorSystemView methodsFor: 'as yet unclassified'!cacheBitsAsTwoTone	^ false! !!ColorSystemView methodsFor: 'as yet unclassified' stamp: 'di 2/26/98 08:58'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible."	bitsValid		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super displayDeEmphasized]! !!ColorTest methodsFor: 'testing' stamp: 'dg 2/19/2008 13:19'!testAsHTMLColor	| table aColorString |	table := #('0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A' 'B' 'C' 'D' 'E' 'F').	table do: [ :each |		aColorString := '#', each, each, '0000'.		self assert: ((Color fromString: aColorString) asHTMLColor sameAs: aColorString)].	table do: [ :each |		aColorString := '#', '00', each, each, '00'.		self assert: ((Color fromString: aColorString) asHTMLColor sameAs: aColorString)].	table do: [ :each |		aColorString := '#', '0000', each, each.		self assert: ((Color fromString: aColorString) asHTMLColor sameAs: aColorString)].	table do: [ :each |		aColorString := '#', each, each, each, each, each, each.		self assert: ((Color fromString: aColorString) asHTMLColor sameAs: aColorString)].! !!ColorTest methodsFor: 'testing' stamp: 'dg 2/19/2008 12:43'!testColorFrom	self assert: ((Color colorFrom: #white) asHTMLColor sameAs: '#ffffff').	self assert: ((Color colorFrom: #(1.0 0.5 0.0)) asHTMLColor sameAs: '#ff8000').	self assert: ((Color colorFrom: (Color white)) asHTMLColor sameAs: '#ffffff').	self assert: ((Color colorFrom: '#FF8800') asHTMLColor sameAs: '#ff8800').	self assert: ((Color colorFrom: '#222222') asHTMLColor sameAs: '#222222').! !!ColorTest methodsFor: 'testing' stamp: 'dg 2/19/2008 12:43'!testFromString	self assert: ((Color fromString: '#FF8800') asHTMLColor sameAs: '#ff8800').! !!ColorTest methodsFor: 'testing' stamp: 'nice 10/30/2009 21:09'!testHSV	"Test the color wheel modulo 360"		self assert: (Color h: 0 s: 1 v: 1) = Color red.	self assert: (Color h: 60 s: 1 v: 1) = Color yellow.	self assert: (Color h: 120 s: 1 v: 1) = Color green.	self assert: (Color h: 180 s: 1 v: 1) = Color cyan.	self assert: (Color h: 240 s: 1 v: 1) = Color blue.	self assert: (Color h: 300 s: 1 v: 1) = Color magenta.	self assert: (Color h: 0+360 s: 1 v: 1) = Color red.	self assert: (Color h: 120+720 s: 1 v: 1) = Color green.	self assert: (Color h: 180-360 s: 1 v: 1) = Color cyan.	self assert: (Color h: 240-720 s: 1 v: 1) = Color blue.! !!ColorTest methodsFor: 'testing' stamp: 'fbs 2/3/2005 13:13'!testMultiplyByArray	| newColor oldColor tolerance |	tolerance := 0.001.	oldColor := Color r: 0.75 g: 0.5 b: 0.25.	newColor := oldColor * #(0.1 2 3).	self assert: (0.075 - newColor red) abs < tolerance.	self assert: (1 - newColor green) abs < tolerance.	self assert: (0.75 - newColor blue) abs < tolerance.! !!ColorTest methodsFor: 'testing' stamp: 'fbs 2/3/2005 12:57'!testMultiplyByArrayIdentityTransform	| newColor oldColor tolerance |	tolerance := 0.001.	oldColor := Color r: 0.75 g: 0.5 b: 0.25.	newColor := oldColor * 2.	self assert: (1 - newColor red) abs < tolerance.	self assert: (1 - newColor green) abs < tolerance.	self assert: (0.5 - newColor blue) abs < tolerance.! !!ColorTest methodsFor: 'testing' stamp: 'fbs 2/3/2005 12:56'!testMultiplyByNumber	| newColor oldColor tolerance |	tolerance := 0.001.	oldColor := Color r: 0.75 g: 0.5 b: 0.25.	newColor := oldColor * 2.	self assert: (1 - newColor red) abs < tolerance.	self assert: (1 - newColor green) abs < tolerance.	self assert: (0.5 - newColor blue) abs < tolerance.! !!ColorTest methodsFor: 'tests' stamp: 'sd 6/16/2006 13:12'!testPrintHtmlString	"self debug: #testPrintHtmlString"		self shouldnt: [Color white printHtmlString ] raise: Error.	self assert: Color white printHtmlString = 'FFFFFF'.	self assert: Color red printHtmlString =  'FF0000'.	self assert: Color black printHtmlString = '000000'.! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCommentNode: self! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 2/16/2010 21:26'!scanForEndPC	"Answer the index of the last bytecode. This method scans the code to find the first return past the last jump target. It can be used to find or verify the endPC independent of knowledge about method trailer implementation."	| sz pc lastJump byte type offset jumpTarget |	self isQuick ifTrue:[^self initialPC-1].	sz := self size.	pc := lastJump := self initialPC.	[pc <= sz] whileTrue:[		byte := self at: pc.		type := byte // 16.		offset := byte \\ 16.  		"Return bytecodes (possible lastPC here)"		(type =7 and:[offset >= 8 and:[pc >= lastJump]]) ifTrue:[^pc].		"Short jumps (need to update last jump target"		type=9 ifTrue:[			offset < 8 				ifTrue: [jumpTarget := offset + pc + 2]				ifFalse:[jumpTarget := offset-8 + pc + 2].			jumpTarget > lastJump ifTrue:[lastJump := jumpTarget].		].		"Long jumps (need to update last jump target)"		type=10 ifTrue:[ | byte2 |			byte2 := self at: pc+1. 			offset < 8 				ifTrue: [jumpTarget := offset-4*256 + byte2 + pc + 2]				ifFalse:[jumpTarget := (offset bitAnd: 3)*256 + byte2 + pc + 2].			jumpTarget > lastJump ifTrue:[lastJump := jumpTarget].		].		"closure activation; update last jump target"		(type = 8 and:[offset = 15]) ifTrue:[ | byte3 byte4 |			byte3 := self at: pc + 2.			byte4 := self at: pc + 3.			jumpTarget := (byte3 * 256) + byte4 + pc + 4.			jumpTarget > lastJump ifTrue:[lastJump := jumpTarget].		].		"advance pc accordingly"		pc := type = 8 "extensions"					ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: offset + 1)]					ifFalse: [type = 10 "long jumps"								ifTrue: [pc + 2]								ifFalse: [pc + 1]].	].	self error: 'Unable to determine endPC'! !!CompiledMethod methodsFor: 'comparing' stamp: 'eem 6/4/2010 11:00'!= method	| numLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	"``Dont bother checking FFI and named primitives''	 (#(117 120) includes: self primitive) ifTrue: [^ true]."	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		lit1 = lit2 ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue: [lit1 isArray							ifTrue:								[(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:									[^false]]							ifFalse: "ExternalLibraryFunction"								[(lit1 analogousCodeTo: lit2) ifFalse:									[^false]]] ifFalse:			[i = (numLits - 1) ifTrue: "properties"				[(lit1 analogousCodeTo: lit2) ifFalse:					[^false]] ifFalse:			[i = numLits ifTrue: "methodClassAssociation"				[(lit1 isVariableBinding and: [lit2 isVariableBinding				  and: [lit1 key class == lit2 key class				  and: [lit1 value isBehavior and: [lit2 value isBehavior]]]]) ifFalse:					[^false]] ifFalse:			 [lit1 isFloat				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^false]. self flag: 'just checking'. self halt]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]]].	^true! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 5/18/2010 13:54'!decompile	"Return the decompiled parse tree that represents self"	|  class selector decompiler |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	decompiler := class decompilerClass new.	self holdsTempNames ifTrue:		[decompiler := decompiler withTempNames: self tempNamesString].	^decompiler decompile: selector in: class method: self.! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 8/12/2010 13:52'!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self)! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 6/3/2010 11:04'!fieldIndices	"Answer a Bag of the inst var field offsets (1-relative) read and/or written by the receiver."	| indices scanner |	self isReturnField ifTrue:		[^Bag with: self returnField + 1].	indices := Bag new.	(scanner := InstructionStream on: self) scanFor:		[:b|		b < 16			ifTrue: [indices add: b + 1]			ifFalse:				[b >= 96 ifTrue:					[b <= 103						ifTrue: [indices add: b - 95]						ifFalse:							[b = 128								ifTrue: [scanner followingByte <= 63 ifTrue: [indices add: scanner followingByte + 1]]								ifFalse:									[(b = 132									 and: [scanner followingByte between: 64 and: 95]) ifTrue:										[indices add: scanner thirdByte + 1]]]]].		false].	^indices! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 7/21/2009 13:26'!qCompress: string	"A very simple text compression routine designed for method temp names.	 Most common 11 chars get values 1-11 packed in one 4-bit nibble;	 the next most common get values 12-15 (2 bits) * 16 plus next nibble;	 unusual ones get three nibbles, the first being the escape nibble 0.	 CompiledMethod>>endPC determines the maximum length of encoded	 output, which means 1 to (251 - 128) * 128 + 127, or 15871 bytes"	string isEmpty ifTrue:		[^self qCompress: ' '].	^ ByteArray streamContents:		[:strm | | ix oddNibble sz |		oddNibble := nil.		string do:			[:char |			ix := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'					indexOf: char ifAbsent: 0.			(ix = 0				ifTrue:					[char asInteger > 255 ifTrue: [^nil]. "Could use UTF8 here; too lazy right now"					{ 0. char asInteger // 16. char asInteger \\ 16 }]				ifFalse:					[ix <= 11						ifTrue: [{ ix }]						ifFalse: [{ ix//16+12. ix\\16 }]])					do: [:nibble |						oddNibble							ifNotNil: [strm nextPut: oddNibble*16 + nibble. oddNibble := nil]							ifNil: [oddNibble := nibble]]].		oddNibble ifNotNil: "4 = 'ear tonsil' indexOf: Character space"			[strm nextPut: oddNibble * 16 + 4].		(sz := strm position) > ((251 - 128) * 128 + 127) ifTrue:			[^nil].		sz <= 127			ifTrue: [strm nextPut: sz]			ifFalse:				[strm nextPut: sz \\ 128; nextPut: sz // 128 + 128]]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/5/2009 18:07'!qDecompressFrom: input "<ReadStream on: ByteArray> ^<String>"	"Decompress strings compressed by qCompress:.	Most common 11 chars get values 0-10 packed in one 4-bit nibble;	next most common 52 get values 12-15 (2 bits) * 16 plus next nibble;	escaped chars get three nibbles"	^ String streamContents:		[:strm | | nextNibble nibble peek charTable char |		charTable :=  "Character encoding table must match qCompress:"		'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.		peek := true.		nextNibble := [peek						ifTrue: [peek := false. input peek ifNil: [0] ifNotNil: [:b| b // 16]]						ifFalse: [peek := true. input next ifNil: [0] ifNotNil: [:b| b \\ 16]]].		[input atEnd] whileFalse:			[(nibble := nextNibble value) = 0				ifTrue: [input atEnd ifFalse:						[strm nextPut: (Character value: nextNibble value * 16 + nextNibble value)]]				ifFalse:					[nibble <= 11						ifTrue:							[strm nextPut: (charTable at: nibble)]						ifFalse:							[strm nextPut: (charTable at: nibble-12 * 16 + nextNibble value)]]]]! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/23/2010 13:20'!hasReportableSlip	"Answer whether the receiver contains anything that should be brought to the attention of the author when filing out.   Customize the lists here to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'checkForSlips' is set to true."	#(doOnlyOnce: halt halt: hottest printDirectlyToDisplay toRemove personal urgent) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol |		(Smalltalk associationAt: aSymbol ifAbsent: [nil]) ifNotNil:			[:assoc| (self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 1/21/2010 09:31'!argumentCountForBlockAtPC: blockStartPC	"Answer the argument count of the block whose first bytecode is startpc."	(self pcPreviousTo: blockStartPC) ifNotNil:		[:closureCreationPC|		[(InstructionStream on: self)			pc: closureCreationPC;			interpretNextInstructionFor: nil]			on: MessageNotUnderstood			do: [:ex|				ex message selector == #pushClosureCopyNumCopiedValues:numArgs:blockSize: ifTrue:					[^ex message arguments at: 2]]].	self error: 'pc is not a block start pc'! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 1/21/2010 09:01'!blockRangesAndExtentsInto: aDictionary from: initialPC to: endPC scanner: scanner numberer: numbererBlock	"Support routine for blockpcsToBlockExtents"	| extentStart blockSizeOrLocator |	self flag: 'belongs in DebuggerMethodMap'.	extentStart := numbererBlock value.	[scanner pc <= endPC] whileTrue:		[blockSizeOrLocator := scanner interpretNextInstructionFor: BlockStartLocator new.		 blockSizeOrLocator isInteger ifTrue:			[self				blockRangesAndExtentsInto: aDictionary				from: scanner pc				to: scanner pc + blockSizeOrLocator - 1				scanner: scanner				numberer: numbererBlock]].	aDictionary at: (initialPC to: endPC) put: (extentStart to: numbererBlock value).	^aDictionary! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 1/21/2010 09:08'!blockpcsToBlockExtents	"Answer a Dictionary of (Interval from startpc to lastpc) to (Interval of blockExtent),	 for the method and any blocks within it, using the identical numbering scheme described	 in and orchestrated by BlockNode>>analyseArguments:temporaries:rootNode:.	 This is a variation on startpcsToBlockExtents whcih only answers startpc to interval."	| index |	self flag: 'arguably belongs in DebuggerMethodMap'.	index := 0.	^self		blockRangesAndExtentsInto: Dictionary new		from: self initialPC		to: self endPC		scanner: (InstructionStream on: self)		numberer: [| value | value := index. index := index + 2. value]! !!CompiledMethodTest methodsFor: 'examples' stamp: 'md 2/18/2006 20:09'!returnPlusOne: anInteger	^anInteger + 1. ! !!CompiledMethodTest methodsFor: 'examples' stamp: 'md 2/18/2006 20:09'!returnTrue	^true  ! !!CompiledMethodTest methodsFor: 'tests - decompiling' stamp: 'md 2/16/2006 20:29'!testDecompile	"self debug: #testDecompileTree"	| method  cls stream |	Smalltalk removeClassNamed: #TUTU.	cls := Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.	stream := ReadWriteStream on: String new.	method decompile printOn: stream.	self assert: stream contents = 'foo	^ 10'			! !!CompiledMethodTest methodsFor: 'tests - testing' stamp: 'md 2/19/2006 11:28'!testHasNewPropertyFormat		| method |		method := (self class)>>#returnTrue.		self assert: method hasNewPropertyFormat.! !!CompiledMethodTest methodsFor: 'tests - testing' stamp: 'md 2/18/2006 20:10'!testIsInstalled|  method cls |	method := (self class)>>#returnTrue.	self assert: method isInstalled.	"now make an orphaned method by just deleting the class."	Smalltalk removeClassNamed: #TUTU.	cls := Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.	self deny: method isInstalled. ! !!CompiledMethodTest methodsFor: 'tests - testing' stamp: 'md 4/16/2003 15:32'!testIsQuick	| method  |	method := self class compiledMethodAt: #returnTrue.	self assert: (method isQuick).	method := self class compiledMethodAt: #returnPlusOne:.	self deny: (method isQuick).	! !!CompiledMethodTest methodsFor: 'tests - accessing' stamp: 'md 2/18/2006 20:10'!testMethodClass	| method cls |	method := self class >> #returnTrue.	self assert: method selector = #returnTrue.	"now make an orphaned method by just deleting the class.	old: #unknown	new semantics: return Absolete class"	Smalltalk removeClassNamed: #TUTU.	cls := Object				subclass: #TUTU				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.	self assert: method methodClass = cls! !!CompiledMethodTest methodsFor: 'tests - accessing' stamp: 'md 2/15/2006 20:54'!testSearchForClass	|  method cls |	method := (self class)>>#returnTrue.	self assert: (method searchForClass = self class).		"now make an orphaned method. we want to get nil as the class"			Smalltalk removeClassNamed: #TUTU.	cls := Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.		self assert: method searchForClass = nil. ! !!CompiledMethodTest methodsFor: 'tests - accessing' stamp: 'md 2/15/2006 20:55'!testSearchForSelector	|  method cls |	method := (self class)>>#returnTrue.	self assert: (method searchForSelector = #returnTrue).	"now make an orphaned method. we want to get nil as the selector"			Smalltalk removeClassNamed: #TUTU.	cls := Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.		self assert: method searchForSelector = nil. ! !!CompiledMethodTest methodsFor: 'tests - accessing' stamp: 'md 2/16/2006 20:28'!testSelector	|  method cls |	method := (self class)>>#returnTrue.	self assert: (method selector = #returnTrue).	"now make an orphaned method. new semantics: return corrent name"			Smalltalk removeClassNamed: #TUTU.	cls := Object subclass: #TUTU		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Methods'.	cls compile: 'foo ^ 10'.	method := cls >> #foo.	Smalltalk removeClassNamed: #TUTU.	self assert: method selector = #foo. ! !!CompiledMethodTest methodsFor: 'tests - evaluating' stamp: 'md 4/16/2003 15:30'!testValueWithReceiverArguments		| method value |	method := self class compiledMethodAt: #returnTrue.	value := method valueWithReceiver: nil arguments: #().	self assert: (value = true).	method := self class compiledMethodAt: #returnPlusOne:.	value := method valueWithReceiver: nil arguments: #(1).	self assert: (value = 2).	! !!CompiledMethodTest commentStamp: '<historical>' prior: 0!This is the unit test for the class CompiledMethod. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20'!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'eem 7/2/2010 09:54'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into	 a method. If aContext is not nil, the text can refer to temporaries in that	 context (the Debugger uses this). If aRequestor is not nil, then it will receive	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 	 compiled method is invoked from here via withArgs:executeMethod:, hence	 the system no longer creates Doit method litter on errors."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := self interactive				ifTrue: [methodNode generateWithTempNames]				ifFalse: [methodNode generate].	value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!Compiler methodsFor: 'public access' stamp: 'eem 8/14/2010 20:23'!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	sourceStream := (textOrStream isKindOf: PositionableStream)						ifTrue: [textOrStream]						ifFalse: [ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req.	category := aCategory! !!Compiler methodsFor: 'private' stamp: 'eem 8/30/2010 17:57'!format: aStream noPattern: noPattern ifFail: failBlock	^(self parser		parse: aStream		class: class		noPattern: noPattern		context: context		notifying: requestor		ifFail: [^failBlock value]) preen! !!CompilerExceptionsTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/25/2009 20:27'!griffle | goo |! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:23'!select	! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:23'!selectFrom: start to: end 	! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:22'!selectionInterval	^ 1 to: 0! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:26'!text	^ self unusedVariableSource! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:22'!testUndeclaredVariable	self 		should: 			[self class 				compile: 'griffle ^ goo'				notifying: self]		raise: UndeclaredVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:24'!testUndefinedVariable	self 		should: 			[self class 				compile: 'griffle | goo | ^ goo'				notifying: self]		raise: UndefinedVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:25'!testUnknownSelector	self 		should: 			[self class 				compile: 'griffle self reallyHopeThisIsntImplementedAnywhere'				notifying: self]		raise: UnknownSelector! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:27'!testUnusedVariable	self 		should: 			[self class 				compile: self unusedVariableSource				notifying: self]		raise: UnusedVariable! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'cwp 8/25/2009 20:28'!unusedVariableSource	^ 'griffle 		| goo |		^ nil'! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 3/6/2010 22:45'!testBinarySelectorWithMinus	"Acknowledge the fact that $- is now allowed at any place in a binary selector"		| source tree |	source := '1 @- 2' readStream.	tree := (Compiler new)		from: source class: Object context: nil notifying: nil;		translate: source noPattern: true ifFail: [nil].	self assert: tree notNil.		"Hem, this test is really ugly..."	self assert: tree block statements first expr selector key = #'@-'.! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 3/6/2010 22:31'!testNegativeNumbers	"Acknowledge the fact that (-  2) which was accepted up to Squeak 3.10 is not valid anymore"		self assert: (Compiler evaluate: '-2') = 2 negated.	self should: [Compiler evaluate: '-  2'] raise: SyntaxErrorNotification description: 'A negative number literal shall not include any separator'! !!CompilerTest methodsFor: 'literals' stamp: 'nice 12/3/2007 22:20'!testScaledDecimalLiterals	"Equal ScaledDecimal with different scales should use different slots	This is related to http://bugs.squeak.org/view.php?id=6797"		"This correctly works when evaluated separately"	self deny: (Compiler evaluate: '0.5s1') scale = (Compiler evaluate: '0.5s2') scale.		"But not when evaluated together if literal reduction is too agressive"	self deny: (Compiler evaluate: '0.5s1 scale =  0.5s2 scale').! !!CompilerTest commentStamp: 'nice 12/3/2007 22:15' prior: 0!CompilerTest is a holder for SUnit test of Compiler!!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:13'!testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #EmbeddedSourceQCompress ).	self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).	code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer sourceCode: code.	self assert: (trailer kind == #EmbeddedSourceZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:13'!testEmbeddingTempNames	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer tempNames: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #TempsNamesQCompress ).	self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).		code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer tempNames: code.	self assert: (trailer kind == #TempsNamesZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:17'!testEncodingNoTrailer	| trailer |		trailer := CompiledMethodTrailer new.		"by default it should be a no-trailer"		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:14'!testEncodingSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.		CompiledMethod allInstancesDo: [:method | | ptr |		trailer method: method.		self assert: ( (ptr := method sourcePointer) == trailer sourcePointer).		"the last bytecode index must be at 0"		ptr ~= 0 ifTrue: [			self assert: (method endPC = trailer endPC) ].	 ].! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:15'!testEncodingVarLengthSourcePointer	| trailer newTrailer |		trailer := CompiledMethodTrailer new.		trailer sourcePointer: 1.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourcePointer = 1).		trailer sourcePointer: 16r100000000000000.	newTrailer := trailer testEncoding.	self assert: (newTrailer sourcePointer = 16r100000000000000).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:15'!testSourceByIdentifierEncoding	| trailer id |		trailer := CompiledMethodTrailer new.		id := UUID new asString.	trailer sourceIdentifier: id.		self assert: (trailer kind == #SourceByStringIdentifier ).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceByStringIdentifier ).	self assert: (trailer sourceIdentifier = id).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 21:49'!testSourceBySelectorEncoding	| trailer |		trailer := CompiledMethodTrailer new.		trailer setSourceBySelector.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:00'!testAbs	"self run: #testAbs"	"self debug: #testAbs"		| c |	c := (6 - 6 i).	self assert: c abs  = 72 sqrt.	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 13:59'!testAdding	"self run: #testAdding"		| c |	c := (5 - 6 i) + (-5 + 8 i).     "Complex with Complex"	self assert: (c =  (0 + 2 i)).! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:02'!testArg	"self run: #testArg"	"self debug: #testArg"		| c |	c := (0 + 5 i) .	self assert: c arg  = (Float pi/ 2).	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:13'!testComplexCollection	"self run: #testComplexCollection"	"self debug: #testComplexCollection"		| array array2 |	array := Array with: 1 + 2i with:  3 + 4i with: 5 + 6i.	array2 := 2 * array.	array with:  array2 do: [:one :two | self assert: (2 * one) = two ] ! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:16'!testConversion	"self run: #testConversion"	"self debug: #testConversion"		self assert: ((1 + 2i) + 1) =  (2 + 2 i).	self assert: (1 + (1 + 2i)) =  (2 + 2 i).	self assert: ((1 + 2i) + 1.0) =  (2.0 + 2 i).	self assert: (1.0 + (1 + 2i)) =  (2.0 + 2 i).	self assert: ((1 + 2i) + (2/3)) = ((5/3) + 2 i ).	self assert: ((2/3) + (1 + 2i)) = ((5/3) + 2 i )! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 13:59'!testCreation	"self run: #testCreation"		| c |	c := 5 i.	self assert: (c real = 0).	self assert: (c imaginary = 5).		c := 6 + 7 i.	self assert: (c real = 6).	self assert: ( c imaginary = 7).		c := 5.6 - 8 i.	self assert: (c real = 5.6).	self assert: (c imaginary = -8).		c := Complex real: 10 imaginary: 5.	self assert: (c real = 10).	self assert: (c imaginary = 5).		c := Complex abs: 5 arg: (Float pi/2).	self assert: (c real rounded = 0).	self assert: (c imaginary = 5).	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:29'!testDivision1	"self run: #testDivision1"	"self debug: #testDivision1"		| c1 c2 quotient |	c1 := 2.0e252 + 3.0e70 i.	c2 := c1.	quotient := c1 / c2. 	self deny: (quotient - 1) isZero.		"This test fails due to the wonders of floating point arithmetic. 	 Please have a look at Complex>>divideSecureBy: and #divideFastAndSecureBy:	how this can be avoided."	! !!ComplexTest methodsFor: 'tests' stamp: 'laza 9/26/2005 10:24'!testLn	self assert: (Float e + 0 i) ln = Float e ln "See Bug 1815 on Mantis"! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:03'!testNegated	"self run: #testNegated"	"self debug: #testNegated"		| c |	c := (2 + 5 i) .	self assert: c negated  = (-2 - 5i).	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:05'!testReciprocal	"self run: #testReciprocal"	"self debug: #testReciprocal"		| c |	c := (2 + 5 i).	self assert: c reciprocal  = ((2/29) - (5/29)i).	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 14:07'!testReciprocalError	"self run: #testReciprocalError"	"self debug: #testReciprocalError"		| c |	c := (0 i).	self should: [c reciprocal] raise: ZeroDivide	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:29'!testSecureDivision1	"self run: #testSecureDivision1"	"self debug: #testSecureDivision1"		| c1 c2 quotient |	c1 := 2.0e252 + 3.0e70 i.	c2 := c1.	quotient := c1 divideSecureBy: c2.	self assert: (quotient - 1) isZero.	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:29'!testSecureDivision2	"self run: #testSecureDivision2"	"self debug: #testSecureDivision2"		| c1 c2 quotient | 	c1 := 2.0e252 + 3.0e70 i. 	c2 := c1. 	quotient := c1 divideFastAndSecureBy: c2.	self assert: (quotient - 1) isZero.	! !!ComplexTest methodsFor: 'tests' stamp: 'sd 7/17/2004 13:24'!testSquared	"self run: #testSquared"	"self debug: #testSquared"		| c c2 |	c := (6 - 6 i).	c2 := (c squared).	self assert: c2 imaginary = -72.	self assert: c2 real = 0.! !!ComplexTest methodsFor: 'testing - bugs' stamp: 'md 2/18/2006 16:53'!testBug1	self assert: (0.5 * (2+0i) ln) exp = (0.5 * 2 ln) exp.! !!ComplexTest methodsFor: 'testing' stamp: 'nice 2/8/2006 22:09'!testEquality	"self run: #testEquality"	"self debug: #testEquality"		self assert: 0i = 0.	self assert: (2 - 5i) = ((1 -4 i) + (1 - 1i)).	self assert: 0i isZero.	self deny: (1 + 3 i) = 1.	self deny: (1 + 3 i) = (1 + 2i)."Some more stuff"	self deny: (1 i) = nil.	self deny: nil = (1 i).	self deny: (1 i) = #(1 2 3).	self deny: #(1 2 3) = (1 i).	self deny: (1 i) = 0.	self deny: 0 = (1 i).	self assert:  (1 + 0 i) = 1.	self assert:  1 = (1+ 0 i).	self assert:  (1 + 0 i) = 1.0.	self assert:  1.0 = (1+ 0 i).	self assert:  (1/2 + 0 i) = (1/2).	self assert:  (1/2) = (1/2+ 0 i).! !!CompressedSourceStream methodsFor: 'access' stamp: 'bgf 5/23/2008 18:06'!next	"<primitive: 65>   Doesn't pay its way."	position >= readLimit		ifTrue: [^ (self next: 1) at: 1]		ifFalse: [^ collection at: (position := position + 1)]! !!ContextCompilationTest methodsFor: 'tests' stamp: 'eem 6/19/2008 10:11'!testVariablesAndOffsetsDo	"ContextCompilationTest new testVariablesAndOffsetsDo"	| contextClasses |	contextClasses := ContextPart withAllSuperclasses, ContextPart allSubclasses asArray.	contextClasses do:		[:class|		class variablesAndOffsetsDo:			[:var :offset|			self assert: offset < 0.			self assert: (class instVarNameForIndex: offset negated) == var]].	InstructionStream withAllSuperclasses, InstructionStream allSubclasses asArray do:		[:class|		(contextClasses includes: class) ifFalse:			[class variablesAndOffsetsDo:				[:var :offset|				(InstructionStream instVarNames includes: var) ifFalse:					[self assert: offset > 0.					 self assert: (class instVarNameForIndex: offset) == var]]]]! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:24'!fieldList	"Answer the base field list plus an abbreviated list of indices."	^ self baseFieldList , (object tempNames collect:[:t| '[',t,']'])! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:21'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	| basicIndex |	selectionIndex = 0 ifTrue: [^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ object longPrintStringLimitedTo: 20000].	(selectionIndex - 2) <= object class instSize		ifTrue: [^ object instVarAt: selectionIndex - 2].	basicIndex := selectionIndex - 2 - object class instSize.	^object debuggerMap namedTempAt: basicIndex in: object! !!ContextPart methodsFor: 'accessing' stamp: 'eem 8/13/2009 14:26'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 212>	"The number of indexable fields of fixed-length objects is 0"	^self primitiveFailed! !!ContextPart methodsFor: 'accessing' stamp: 'eem 8/13/2009 14:26'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 212>	"The number of indexable fields of fixed-length objects is 0"	^self primitiveFailed! !!ContextPart methodsFor: 'controlling' stamp: 'eem 5/12/2009 21:23'!quickSend: selector to: receiver with: arguments super: superFlag	"Send the given selector with arguments in an environment which closely resembles	 the non-simulating environment, with an interjected unwind-protected block to catch	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."	| oldSender contextToReturnTo result lookupClass |	contextToReturnTo := self.	lookupClass := superFlag					ifTrue: [self method methodClassAssociation value superclass]					ifFalse: [self objectClass: self receiver].	[oldSender := thisContext sender swapSender: self.	result := self object: receiver perform: selector withArguments: arguments inClass: lookupClass.	thisContext sender swapSender: oldSender] ifCurtailed:		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"		contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"		contextToReturnTo nextByte = 16r7C ifTrue:			"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"			[contextToReturnTo push: (thisContext sender tempAt: 1)].		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"		contextToReturnTo].	contextToReturnTo push: result.	^contextToReturnTo! !!ContextPart methodsFor: 'controlling' stamp: 'eem 8/18/2009 17:02'!send: selector to: rcvr with: args startClass: startClassOrNil 	"Simulate the action of sending a message with selector, selector, and	 arguments, args, to receiver. The argument, startClassOrNil, tells whether	 the selector should be looked up in startClassOrNil or the class of the receiver."	| class meth val ctxt |	class := startClassOrNil ifNil: [self objectClass: rcvr].	meth := class lookupSelector: selector.	meth == nil ifTrue:		[^self			send: #doesNotUnderstand:			to: rcvr			with: (Array with: (Message selector: selector arguments: args))			startClass: class].	(args isArray	 and: [args size = meth numArgs]) ifFalse:		[^{PrimitiveFailToken. nil}].	val := self tryPrimitiveFor: meth receiver: rcvr args: args.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken]]) ifFalse:		[^val].	(selector == #doesNotUnderstand:	 and: [class == ProtoObject]) ifTrue:		[^self error: 'Simulated message ' , (args at: 1) selector, ' not understood'].	ctxt := self activateMethod: meth withArgs: args receiver: rcvr class: class.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken	 and: [val last notNil	 and: [(ctxt method at: ctxt pc) = 129 "long store temp"]]]]) ifTrue:		[ctxt at: ctxt stackPtr put: val last].	^ctxt! !!ContextPart methodsFor: 'controlling' stamp: 'eem 5/12/2009 13:19'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and	 arguments, args, to receiver. The argument, superFlag, tells whether the	 receiver of the message was specified with 'super' in the source method."	| class meth val ctxt |	class := superFlag				ifTrue: [self method methodClassAssociation value superclass]					ifFalse: [self objectClass: rcvr].	meth := class lookupSelector: selector.	meth == nil ifTrue:		[^self			send: #doesNotUnderstand:			to: rcvr			with: (Array with: (Message selector: selector arguments: args))			super: superFlag].	val := self tryPrimitiveFor: meth receiver: rcvr args: args.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken]]) ifFalse:		[^val].	(selector == #doesNotUnderstand:	 and: [class == ProtoObject]) ifTrue:		[^self error: 'Simulated message ' , (args at: 1) selector, ' not understood'].	ctxt := self activateMethod: meth withArgs: args receiver: rcvr class: class.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken	 and: [val last notNil	 and: [(ctxt method at: ctxt pc) = 129 "long store temp"]]]]) ifTrue:		[ctxt at: ctxt stackPtr put: val last].	^ctxt! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 3/12/2009 15:09'!defaultIntegerBase	"Answer the default base in which to print integers.	 Defer to the class the code is compiled in."	^[self method methodClass defaultIntegerBaseInDebugger]		on: MessageNotUnderstood		do: [:ex| 10]! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 3/12/2010 17:39'!mclass 	"Answer the class in which the receiver's method was found."	^self method methodClass! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 5/12/2009 13:17'!methodSelector	"Answer the selector of the method that created the receiver."	^self selector! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 7/13/2007 16:52'!print: anObject limitedTo: limit	"Safely print anObject in the face of direct ProtoObject subclasses"	| limitedString |	(anObject class canUnderstand: #printStringLimitedTo:) 		ifTrue:[^anObject printStringLimitedTo: limit].	limitedString := String streamContents: [:s | self print: anObject on: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 2/17/2009 09:18'!print: anObject on: aStream	"Safely print anObject in the face of direct ProtoObject subclasses"	| title |	((anObject class canUnderstand: #isInteger)	and: [anObject isInteger]) ifTrue:		[^anObject storeOn: aStream base: self defaultIntegerBase].	(anObject class canUnderstand: #printOn:) ifTrue:		[^anObject printOn: aStream].	title := anObject class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 3/12/2010 17:39'!selector	"Answer the selector of the method that created the receiver."	^self method selector! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 3/12/2010 17:39'!sourceCode	^self method getSourceFor: self method selector in: self method methodClass	"Note: The above is a bit safer than		^ methodClass sourceCodeAt: selector	which may fail if the receiver's method has been changed in	the debugger (e.g., the method is no longer in the methodDict	and thus the above selector is something like #Doit:with:with:with:)	but the source code is still available."! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 5/29/2009 16:39'!tempsAndValuesLimitedTo: sizeLimit indent: indent	"Return a string of the temporary variabls and their current values"	| aStream |	aStream := WriteStream on: (String new: 100).	self tempNames		doWithIndex: [:title :index |			indent timesRepeat: [aStream tab].			aStream nextPutAll: title; nextPut: $:; space; tab.			aStream nextPutAll: 				([self print: (self namedTempAt: index) limitedTo: (sizeLimit -3 -title size max: 1)]					ifError:['<<error during printing>>']).			aStream cr].	^aStream contents! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:58'!popIntoLiteralVariable: value 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into a literal variable of my method."	self object: value instVarAt: ValueIndex put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!popIntoReceiverVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into an instance variable of my receiver."	self object: self receiver instVarAt: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:07'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that removes the top of the stack and  stores	 it into an offset in one of my local variables being used as a remote temp vector."	self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:59'!pushLiteralVariable: value 	"Simulate the action of bytecode that pushes the contents of the literal 	variable whose index is the argument, index, on the top of the stack."	self push: (self object: value instVarAt: ValueIndex)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!pushReceiverVariable: offset 	"Simulate the action of bytecode that pushes the contents of the receiver's 	instance variable whose index is the argument, index, on the top of the 	stack."	self push: (self object: self receiver instVarAt: offset + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:07'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that pushes the value at remoteTempIndex	 in one of my local variables being used as a remote temp vector."	self push: (self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:58'!storeIntoLiteralVariable: value 	"Simulate the action of bytecode that stores the top of the stack into a 	literal variable of my method."	self object: value instVarAt: ValueIndex put: self top! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!storeIntoReceiverVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into an 	instance variable of my receiver."	self object: self receiver instVarAt: offset + 1 put: self top! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:05'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that stores the top of the stack at	 an offset in one of my local variables being used as a remote temp vector."	self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1 put: self top! !!ContextPart methodsFor: 'printing' stamp: 'ar 10/24/2007 16:12'!showStack: depth	"#showStack: will printout the current state of the stack from the caller's point on up. It does not include this call. This is useful when you want to see where a method is being called from dynamically, but don't want to (or simply can't) halt. DAS"	self showStack: depth label: '-------stack-------'.! !!ContextPart methodsFor: 'printing' stamp: 'ar 10/24/2007 16:11'!showStack: depth label: aString	"#showStack: will printout the current state of the stack from the caller's point on up. It does not include this call. This is useful when you want to see where a method is being called from dynamically, but don't want to (or simply can't) halt. DAS"	Transcript cr; show: aString.	(self stackOfSize: depth) do: [:context |  Transcript cr; print: context].	Transcript flush.! !!ContextPart methodsFor: 'query' stamp: 'eem 7/16/2009 12:42'!methodClass	^self method methodClass! !!ContextPart methodsFor: 'system simulation' stamp: 'eem 1/19/2009 10:08'!stepToSendOrReturn	"Simulate the execution of bytecodes until either sending a message or 	returning a value to the receiver (that is, until switching contexts)."	| ctxt |	[self willReallySend or: [self willReturn or: [self willStore]]] whileFalse:		[ctxt := self step.		 ctxt == self ifFalse:			[self halt. 			 "Caused by mustBeBoolean handling"			 ^ctxt]]! !!ContextPart methodsFor: 'private' stamp: 'eem 8/18/2009 17:05'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	 simulated receiver and arguments are given as arguments to this message.	 Any primitive which provikes execution needs to be intercepted and simulated	 to avoid execution running away."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	"ContextPart>>blockCopy:; simulated to get startpc right"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart]) 		ifTrue: [^self push: ((BlockContext newForMethod: receiver method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext]) "BlockContext>>value[:value:...]"		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext]) "BlockContext>>valueWithArguments:"		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		ifTrue: [^self send: arguments first					to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"		ifTrue: [^self send: arguments first					to: receiver					with: (arguments at: 2)					startClass: nil].	primitiveIndex = 100 "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"		ifTrue: [^self send: arguments first					to: receiver					with: (arguments at: 2)					startClass: (arguments at: 3)].	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"		[^MethodContext			sender: self			receiver: receiver			method: (arguments at: 2)			arguments: (arguments at: 1)].	"Closure primitives"	(primitiveIndex = 200 and: [receiver == self]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"	or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"		[^receiver simulateValueWithArguments: arguments caller: self].	primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"		[^receiver simulateValueWithArguments: arguments first caller: self].	primitiveIndex = 120 ifTrue:[ "FFI method"		value := meth literals first tryInvokeWithArguments: arguments.	] ifFalse:[		arguments size > 6 ifTrue: [^{PrimitiveFailToken. nil}].		value := primitiveIndex = 117 "named primitives"				ifTrue:[self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]				ifFalse:[receiver tryPrimitive: primitiveIndex withArgs: arguments].	].	^(value isArray	    and: [value size = 2	    and: [value first == PrimitiveFailToken]])		ifTrue: [value]		ifFalse: [self push: value]! !!ContextPart methodsFor: 'private' stamp: 'eem 5/12/2009 21:12'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	| selector theMethod spec receiverClass |	<primitive: 218 error: ec>	ec ifNotNil:		["If ec is an integer other than -1 there was a problem with primitive 218,		  not with the external primitive itself.  -1 indicates a generic failure (where		  ec should be nil) but ec = nil means primitive 218 is not implemented.  So		  interpret -1 to mean the external primitive failed with a nil error code."		 ec isInteger ifTrue:			[ec = -1				ifTrue: [ec := nil]				ifFalse: [self primitiveFailed]].		^{PrimitiveFailToken. ec}].	"Assume a nil error code implies the primitive is not implemented and fall back on the old code."	"Hack. Attempt to execute the named primitive from the given compiled method"	arguments size > 8 ifTrue:		[^{PrimitiveFailToken. nil}].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	receiverClass := self objectClass: aReceiver.	theMethod := receiverClass lookupSelector: selector.	theMethod == nil ifTrue:		[^{PrimitiveFailToken. nil}].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	Smalltalk unbindExternalPrimitives.	^self object: aReceiver perform: selector withArguments: arguments inClass: receiverClass! !!ContextPart methodsFor: 'private' stamp: 'eem 1/4/2009 09:54'!tryPrimitiveFor: method receiver: receiver args: arguments 	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."	| primIndex |	(primIndex := method primitive) = 0 ifTrue: [^{PrimitiveFailToken. nil}].	^ self doPrimitive: primIndex method: method receiver: receiver args: arguments! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index 	"Answer the value of an indexable element in the argument anObject without sending	 it a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable. This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index put: value 	"Store the last argument 	 value in the indexable element of the argument anObject indicated by index without sending	 anObject a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable, or if value is an inappropriate value for anObject's indexable slots.	 This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= (self objectSize: anObject)])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:23'!object: anObject eqeq: anOtherObject 	"Answer whether the first and second arguments are the same object (have the	 same object pointer) without sending a message to the first argument.  This	 mimics the action of the VM when it compares two object pointers.  Used to	 simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:27'!object: anObject instVarAt: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:30'!object: anObject instVarAt: anIndex put: aValue 	"Primitive. Store a value into a fixed variable in the argument anObject.	 The numbering of the variables corresponds to the named instance	 variables.  Fail if the index is not an Integer or is not the index of a	 fixed variable.  Answer the value stored as the result. Using this	 message violates the  principle that each object has sovereign control	 over the storing of values into its instance variables. Essential for the	 debugger. See Object documentation whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize put: aValue! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/12/2009 21:24'!object: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	(selector isMemberOf: Symbol) ifFalse:		[^self error: 'selector argument must be a Symbol'].	(argArray isMemberOf: Array) ifFalse:		[^self error: 'argArray must be an Array'].	(selector numArgs = argArray size)		ifFalse: [^self error: 'incorrect number of arguments'].	((self objectClass: anObject) == lookupClass	 or: [(self objectClass: anObject) inheritsFrom: lookupClass]) ifFalse:		[^self error: 'lookupClass is not in anObject''s inheritance chain'].	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!objectClass: anObject	"Answer the class of the argument anObject without sending it a message.	 This mimics the action of the VM when it fetches an object's class.  Used to	 simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!objectSize: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!ContextPart commentStamp: '<historical>' prior: 0!To the instruction parsing ability of InstructionStream I add the actual semantics for execution. The execution state is stored in the indexable fields of my subclasses. This includes temporary variables and a stack of values used in evaluating expressions. The actual semantics of execution can be found in my category "system simulation" and "instruction decode". These methods exactly parallel the operation of the Smalltalk machine itself.	The simulator is a group of my methods that do what the Smalltalk interpreter does: execute Smalltalk bytecodes. By adding code to the simulator, you may take statistics on the running of Smalltalk methods. For example,	Transcript show: (ContextPart runSimulated: [3 factorial]) printString.!!ContextPart class methodsFor: 'examples' stamp: 'eem 11/26/2008 20:45'!tallyMethods: aBlock	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. Results are given in order of decreasing counts."	| prev tallies |	prev := nil.	tallies := Bag new.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: "call or return"				[(prev notNil and: [prev sender notNil]) ifTrue: "call only"					[tallies add: current printString].				prev := current]].	^tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"! !!ContextPart class methodsFor: 'examples' stamp: 'eem 11/26/2008 20:50'!trace: aBlock on: aStream		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev |	prev := nil.	^thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			(current == prev or: [prev == nil]) ifFalse:				[prev sender ifNil:					[aStream space; nextPut: $^.					self carefullyPrint: current top on: aStream].				aStream cr.				(current depthBelow: aBlock) timesRepeat: [aStream space].				self carefullyPrint: current receiver on: aStream.				aStream space; nextPutAll: current selector; flush.				prev := current]]! !!ContextPart class methodsFor: 'simulation' stamp: 'eem 1/4/2009 09:32'!primitiveFailTokenFor: errorCode	^{PrimitiveFailToken. errorCode}! !!ContextPart class methodsFor: 'class initialization' stamp: 'eem 5/12/2009 11:36'!initialize	ValueIndex := 2.	self assert: (Association instVarNameForIndex:ValueIndex) = 'value'! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'eem 3/12/2009 15:09'!defaultIntegerBase	"Answer the default base in which to print integers.	 Defer to the class the code is compiled in."	^[object method methodClass defaultIntegerBaseInDebugger]		on: MessageNotUnderstood		do: [:ex| 10]! !!ControlManager methodsFor: 'scheduling'!activateController: aController	"Make aController, which must already be a scheduled controller, the active window.  5/8/96 sw"	self activeController: aController.	(activeController view labelDisplayBox		intersect: Display boundingBox) area < 200			ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling'!activateTranscript	"There is known to be a Transcript open in the current project; activate it.  2/5/96 sw"	| itsController |	itsController := scheduledControllers detect:			[:controller | controller model == Transcript]		ifNone:			[^ self].	self activeController: itsController.	(activeController view labelDisplayBox			intersect: Display boundingBox) area < 200				ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'di 5/19/1998 09:03'!findWindow	"Present a menu of window titles, and activate the one that gets chosen."	^ self findWindowSatisfying: [:c | true]! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:50'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling'!inActiveControllerProcess	"Answer whether the active scheduling process is the actual active 	process in the system."	^activeControllerProcess == Processor activeProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'dtl 4/4/2005 06:42'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	^ self interruptName: labelString preemptedProcess: nil! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 9/6/2009 11:09'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| newActiveController preemptedProcess |	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	preemptedProcess suspend.	"There is something wrong here. We suspend *two* processes, the interrupted	process and the activeControllerProcess (unless they are the same). How can	that possibly be right? However, it is what the code did before I added the comment	(it was merely hidden underneith another pile of code). Someone with more 	understanding about MVC fix this please."	preemptedProcess == activeControllerProcess 		ifFalse:[activeControllerProcess suspend].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController :=		(Debugger			openInterrupt: labelString			onProcess: preemptedProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling'!promote: aController	"Make aController be the first scheduled controller in the ordered 	collection."		scheduledControllers remove: aController.	scheduledControllers addFirst: aController! !!ControlManager methodsFor: 'scheduling' stamp: 'RAA 7/7/2000 09:22'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController := nil.	activeControllerProcess := Processor activeProcess.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling'!scheduleActiveNoTerminate: aController 	"Make aController be the active controller. Presumably the process that 	requested the new active controller wants to keep control to do more 	activites before the new controller can take control. Therefore, do not 	terminate the currently active process."	self schedulePassive: aController.	self scheduled: aController		from: Processor activeProcess! !!ControlManager methodsFor: 'scheduling'!scheduleOnBottom: aController 	"Make aController be scheduled as a scheduled controller, but not the 	active one. Put it at the end of the ordered collection of controllers."	scheduledControllers addLast: aController! !!ControlManager methodsFor: 'scheduling'!schedulePassive: aController 	"Make aController be scheduled as a scheduled controller, but not the 	active one. Put it at the beginning of the ordered collection of 	controllers."	scheduledControllers addFirst: aController! !!ControlManager methodsFor: 'scheduling'!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController := nil.	activeControllerProcess := Processor activeProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'ajh 12/31/2001 15:15'!spawnNewProcess	self activeController: self screenController! !!ControlManager methodsFor: 'scheduling'!unschedule: aController	"Remove the view, aController, from the collection of scheduled 	controllers."	scheduledControllers remove: aController ifAbsent: []! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:52'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!ControlManager methodsFor: 'accessing'!activeController	"Answer the currently active controller."	^activeController! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController := aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess := 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'accessing'!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController := aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess := aProcess.			activeControllerProcess resume]		ifFalse: 			[self error: 'New active controller process must be set from old one'] ! !!ControlManager methodsFor: 'accessing'!activeControllerProcess	"Answer the process that is currently handling controller scheduling 	activities in the system."	^activeControllerProcess! !!ControlManager methodsFor: 'accessing'!controllerSatisfying: aBlock	"Return the first scheduled controller which satisfies the 1-argument boolean-valued block, or nil if none.  7/25/96 sw"	scheduledControllers do:		[:aController | (aBlock value: aController) == true ifTrue: [^ aController]].	^ nil! !!ControlManager methodsFor: 'accessing'!controllerWhoseModelSatisfies: aBlock	"Return the first scheduled controller whose model satisfies the 1-argument boolean-valued block, or nil if none.  5/6/96 sw"	scheduledControllers do:		[:aController | (aBlock value: aController model) == true ifTrue: [^ aController]].	^ nil! !!ControlManager methodsFor: 'accessing' stamp: 'sw 5/4/2001 23:20'!controllersSatisfying: aBlock	"Return a list of scheduled controllers satisfying aBlock"	^ (scheduledControllers ifNil: [^ #()]) select:		[:aController | (aBlock value: aController) == true]! !!ControlManager methodsFor: 'accessing'!includes: aController	^ scheduledControllers includes: aController! !!ControlManager methodsFor: 'accessing'!noteNewTop	newTopClicked := true! !!ControlManager methodsFor: 'accessing'!scheduledControllers	"Answer a copy of the ordered collection of scheduled controllers."	^scheduledControllers copy! !!ControlManager methodsFor: 'accessing' stamp: 'di 10/4/97 09:05'!scheduledWindowControllers	"Same as scheduled controllers, but without ScreenController.	Avoids null views just after closing, eg, a debugger."	^ scheduledControllers select:		[:c | c ~~ screenController and: [c view ~~ nil]]! !!ControlManager methodsFor: 'accessing'!screenController	^ screenController! !!ControlManager methodsFor: 'accessing'!windowOriginsInUse	"Answer a collection of the origins of windows currently on the screen in the current project.  5/21/96 sw"	^ self scheduledWindowControllers collect: [:aController | aController view displayBox origin].! !!ControlManager methodsFor: 'displaying'!backgroundForm: aForm	screenController view model: aForm.	ScheduledControllers restore"	QDPen new mandala: 30 diameter: 640.	ScheduledControllers backgroundForm:		(Form fromDisplay: Display boundingBox).	ScheduledControllers backgroundForm:		(InfiniteForm with: Form gray)."! !!ControlManager methodsFor: 'displaying' stamp: 'di 2/26/98 08:58'!restore 	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."	scheduledControllers first view uncacheBits.  "assure refresh"	self unschedule: screenController; scheduleOnBottom: screenController.	screenController view window: Display boundingBox; displayDeEmphasized.	self scheduledWindowControllers reverseDo:		[:aController | aController view displayDeEmphasized].! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 1/5/2000 07:00'!restore: aRectangle	"Restore all windows visible in aRectangle"	^ self restore: aRectangle without: nil! !!ControlManager methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:06'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view := (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 12/30/1999 19:35'!restore: aRectangle without: aView	"Restore all windows visible in aRectangle"	Display deferUpdates: true.	self restore: aRectangle below: 1 without: aView.	Display deferUpdates: false; forceToScreen: aRectangle! !!ControlManager methodsFor: 'displaying'!updateGray	"From Georg Gollmann - 11/96.  tell the Screen Controller's model to use the currently-preferred desktop color."	"ScheduledControllers updateGray"	(screenController view model isMemberOf: InfiniteForm)		ifTrue: [screenController view model: (InfiniteForm with:Preferences desktopColor)]! !!ControlManager methodsFor: 'initialize-release'!initialize	"Initialize the receiver to refer to only the background controller."	| screenView |	screenController := ScreenController new.	screenView := FormView new.	screenView model: (InfiniteForm with: Color gray) controller: screenController.	screenView window: Display boundingBox.	scheduledControllers := OrderedCollection with: screenController! !!ControlManager methodsFor: 'initialize-release'!release 	"Refer to the comment in Object|release."	scheduledControllers == nil		ifFalse: 			[scheduledControllers 				do: [:controller | (controller isKindOf: Controller)								ifTrue: [controller view release]								ifFalse: [controller release]].			scheduledControllers := nil]! !!ControlManager methodsFor: 'private'!nextActiveController	"Answer the controller that would like control.  	If there was a click outside the active window, it's the top window	that now has the mouse, otherwise it's just the top window."	(newTopClicked notNil and: [newTopClicked])		ifTrue: [newTopClicked := false.				^ scheduledControllers 					detect: [:aController | aController isControlWanted]					ifNone: [scheduledControllers first]]		ifFalse: [^ scheduledControllers first]! !!ControlManager methodsFor: 'private'!scheduled: aController from: aProcess	activeControllerProcess==aProcess		ifTrue: 			[activeController ~~ nil					ifTrue: [activeController controlTerminate].			aController centerCursorInView.			self activeController: aController]! !!ControlManager methodsFor: 'private' stamp: 'sw 12/6/1999 23:40'!unCacheWindows	scheduledControllers ifNotNil: [scheduledControllers do:		[:aController | aController view uncacheBits]]! !!ControlManager commentStamp: '<historical>' prior: 0!I represent the top level control over scheduling which controller of a view on the screen the user is actively using. ScheduledControllers is the global reference to an instance of me, the one attached to the Project currently being used.!!ControlManager class methodsFor: 'exchange'!newScheduler: controlManager	"When switching projects, the control scheduler has to be exchanged. The 	active one is the one associated with the current project."	Smalltalk at: #ScheduledControllers put: controlManager.	ScheduledControllers restore.	controlManager searchForActiveController! !!ControlManager class methodsFor: 'snapshots' stamp: 'di 2/4/1999 15:16'!shutDown  "Saves space in snapshots"	Smalltalk isMorphic ifFalse: [ScheduledControllers unCacheWindows]! !!ControlManager class methodsFor: 'snapshots' stamp: 'di 2/4/1999 09:00'!startUp	Smalltalk isMorphic ifFalse: [ScheduledControllers restore]! !!Controller methodsFor: 'basic control sequence' stamp: 'dtl 4/19/2004 21:11'!addDeferredUIMessage: valuableObject 	"Arrange for valuableObject to be evaluated the next time the 	controlActivity for this controller becomes active."	self deferredActionQueue nextPut: valuableObject! !!Controller methodsFor: 'basic control sequence'!controlInitialize	"Sent by Controller|startUp as part of the standard control sequence, it 	provides a place in the standard control sequence for initializing the 	receiver (taking into account the current state of its model and view). It 	should be redefined in subclasses to perform some specific action."	^self! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence'!controlTerminate	"Provide a place in the standard control sequence for terminating the 	receiver (taking into account the current state of its model and view). It 	should be redefined in subclasses to perform some specific action."	^self! !!Controller methodsFor: 'basic control sequence' stamp: 'dtl 9/20/2009 18:37'!deferredActionQueue	^deferredActionQueue ifNil: [deferredActionQueue := SharedQueue new]! !!Controller methodsFor: 'basic control sequence' stamp: 'RAA 1/30/2001 19:06'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime := Time millisecondClockValue.			wait := lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							(Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime := Time millisecondClockValue.! !!Controller methodsFor: 'basic control sequence'!startUp	"Give control to the receiver. The default control sequence is to initialize 	(see Controller|controlInitialize), to loop (see Controller|controlLoop), and 	then to terminate (see Controller|controlTerminate). After this sequence, 	control is returned to the sender of Control|startUp. The receiver's control 	sequence is used to coordinate the interaction of its view and model. In 	general, this consists of polling the sensor for user input, testing the 	input with respect to the current display of the view, and updating the 	model to reflect intended changes."	self controlInitialize.	self controlLoop.	self controlTerminate! !!Controller methodsFor: 'basic control sequence'!terminateAndInitializeAround: aBlock	"1/12/96 sw"	self controlTerminate.	aBlock value.	self controlInitialize! !!Controller methodsFor: 'cursor'!centerCursorInView	"Position sensor's mousePoint (which is assumed to be connected to the 	cursor) to the center of its view's inset display box (see 	Sensor|mousePoint: and View|insetDisplayBox)."	^sensor cursorPoint: view insetDisplayBox center! !!Controller methodsFor: 'cursor' stamp: 'sw 7/13/1999 18:42'!viewHasCursor	"Answer whether the cursor point of the receiver's sensor lies within the 	inset display box of the receiver's view (see View|insetDisplayBox). 	Controller|viewHasCursor is normally used in internal methods."	^ view ifNotNil: [view containsPoint: sensor cursorPoint] ifNil: [false]! !!Controller methodsFor: 'control defaults' stamp: 'dtl 4/22/2004 22:58'!controlActivity	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. It is sent by 	Controller|controlLoop each time through the main control loop. It should 	be redefined in a subclass if some other action is needed."	[self deferredActionQueue isEmpty]		whileFalse: [deferredActionQueue next value].	self controlToNextLevel! !!Controller methodsFor: 'control defaults'!controlToNextLevel	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. The receiver finds the 	subView (if any) of its view whose inset display box (see 	View|insetDisplayBox) contains the sensor's cursor point. The Controller 	of this subView is then given control if it answers true in response to 	the message Controller|isControlWanted."	| aView |	aView := view subViewWantingControl.	aView ~~ nil ifTrue: [aView controller startUp]! !!Controller methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:23'!isControlActive	"Answer whether receiver wishes to continue evaluating its controlLoop 	method. It is sent by Controller|controlLoop in order to determine when 	the receiver's control loop should terminate, and should be redefined in 	a subclass if some special condition for terminating the main control loop 	is needed."	^ self viewHasCursor		and: [sensor blueButtonPressed not		and: [sensor yellowButtonPressed not]]! !!Controller methodsFor: 'control defaults'!isControlWanted	"Answer whether the cursor is inside the inset display box (see 	View|insetDisplayBox) of the receiver's view. It is sent by 	Controller|controlNextLevel in order to determine whether or not control 	should be passed to this receiver from the Controller of the superView of 	this receiver's view."	^self viewHasCursor! !!Controller methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	sensor := InputSensor default! !!Controller methodsFor: 'initialize-release'!release	"Breaks the cycle between the receiver and its view. It is usually not 	necessary to send release provided the receiver's view has been properly 	released independently."	model := nil.	view ~~ nil		ifTrue: 			[view controller: nil.			view := nil]! !!Controller methodsFor: 'view access' stamp: 'apb 7/14/2004 12:50'!inspectView	view notNil ifTrue: [^ view inspect; yourself]! !!Controller methodsFor: 'view access'!view	"Answer the receiver's view."	^view! !!Controller methodsFor: 'view access'!view: aView 	"Controller|view: and Controller|model: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: and the receiver's model and view links are set up 	automatically by the view."	view := aView! !!Controller methodsFor: 'model access'!model	"Answer the receiver's model which is the same as the model of the 	receiver's view."	^model! !!Controller methodsFor: 'model access'!model: aModel 	"Controller|model: and Controller|view: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: so that the receiver's model and view links can be set 	up by the view."	model := aModel! !!Controller methodsFor: 'sensor access'!sensor	"Answer the receiver's sensor. Subclasses may use other objects that are 	not instances of Sensor or its subclasses if more general kinds of 	input/output functions are required."	^sensor! !!Controller methodsFor: 'sensor access'!sensor: aSensor	"Set the receiver's sensor to aSensor."	sensor := aSensor! !!Controller commentStamp: '<historical>' prior: 0!A Controller coordinates a View, its model, and user actions. It provides scheduling (control) behavior to determine when the user wants to communicate with the model or view.!!Controller class methodsFor: 'initialization' stamp: 'laza 3/19/2010 14:05'!initialize	"Controller initialize"	self minActivityLapse: 10.! !!Controller class methodsFor: 'initialization' stamp: 'laza 3/19/2010 14:05'!minActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse := milliseconds ifNotNil: [ milliseconds rounded ].! !!Cursor class methodsFor: 'constants' stamp: 'bf 8/17/2009 12:55'!normal	"Answer the instance of me that is the shape of an arrow slanted left."	^Preferences biggerCursors		ifTrue: [CursorWithAlpha biggerNormal]		ifFalse: [NormalCursor]! !!CurveFitter methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| pa pb k s p1 p2 p3 line |	line := Line new.	line form: self form.	collectionOfPoints size < 3 ifTrue: [self error: 'Curve must have three points'].	p1 := self firstPoint.	p2 := self secondPoint.	p3 := self thirdPoint.	s := Path new.	s add: p1.	pa := p2 - p1.	pb := p3 - p2.	k := 5 max: pa x abs + pa y abs + pb x abs + pb y abs // 20.	"k is a guess as to how many line segments to use to approximate 	the curve."	1 to: k do: 		[:i | 		s add: pa * i // k + p1 * (k - i) + (pb * (i - 1) // k + p2 * (i - 1)) // (k - 1)].	s add: p3.	1 to: s size - 1 do: 		[:i | 		line beginPoint: (s at: i).		line endPoint: (s at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!CurveFitter methodsFor: 'displaying' stamp: '6/9/97 10:16 di'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| transformedPath newCurveFitter |	transformedPath := aTransformation applyTo: self.	newCurveFitter := CurveFitter new.	newCurveFitter firstPoint: transformedPath firstPoint.	newCurveFitter secondPoint: transformedPath secondPoint.	newCurveFitter thirdPoint: transformedPath thirdPoint.	newCurveFitter form: self form.	newCurveFitter		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!CurveFitter commentStamp: '<historical>' prior: 0!I represent a conic section determined by three points p1, p2 and p3. I interpolate p1 and p3 and am tangent to line p1, p2 at p1 and line p3, p2 at p3.!!CurveFitter class methodsFor: 'examples' stamp: '6/9/97 10:16 di'!example	"Designate three locations on the screen by clicking any button. The	curve determined by the points will be displayed with a long black form."	| aCurveFitter aForm |  	aForm := Form extent: 1@30.			"make a long thin Form for display "	aForm fillBlack.							"turn it black"	aCurveFitter := CurveFitter new.	aCurveFitter form: aForm.						"set the form for display"				"collect three Points and show them on the dispaly"	aCurveFitter firstPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter firstPoint.	aCurveFitter secondPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter secondPoint.	aCurveFitter thirdPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter thirdPoint.	aCurveFitter displayOn: Display					"display the CurveFitter"	"CurveFitter example"! !!CurveFitter class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 3.	newSelf add: 0@0.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!bypass	"Return my reference as is."	^self reference! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!forbidden	self error: 'Forbidden reference usage'! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:01'!include	"Return my expanded value."	^value ifNil: [SAXWarning signal: 'XML undefined entity ' , name printString]! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:06'!includedInLiteral	"Return my expanded value."	^self include! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!reference	"Return my reference as is."	^self class leadIn , self name , ';'! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/4/2002 19:40'!name	^name! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name := aString asSymbol! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata	^ndata! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata := aString! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:54'!value	^value! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value := aString! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/16/2000 21:23'!registerIn: aParser	aParser entity: self name put: self! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 1/15/2002 15:08'!valueForContext: aContext	^self perform: (self class behaviorForContext: aContext)! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:14'!behaviorForContext: aContext	^self contextBehavior at: aContext! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:15'!contextBehavior	^contextBehavior! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'&'! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDEntityDeclaration class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 20:13'!name: aString value: aValueString	^self new		name: aString;		value: aValueString! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!includePE	"Return my expanded value."	^self include! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 23:21'!notRecognized	SAXMalformedException signal: 'Malformed entity.'! !!DTDParameterEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/28/2000 17:26'!registerIn: aParser	aParser parameterEntity: self name put: self! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!DTDParameterEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'%'! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'bgf 10/22/2007 22:56'!asUTCSeconds	"Return the number of seconds since the Squeak epoch, 	 for a clock running at UTC."	^ (self - (self class epoch)) asSeconds - (self class localTimeZone offset asSeconds)! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'ar 8/12/2008 11:31'!utcString	"Print the receiver as UTC"	^self asUTC asString! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'bgf 8/10/2008 18:38'!utcSeconds	"Answer the total seconds since the epoch: 1 January 1901, in UTC time."	^ Time utcSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'bgf 10/22/2007 22:58'!fromUTCSeconds: seconds	"Answer a DateAndTime since the Squeak epoch: 1 January 1901,	 for an argument that is relative to UTC rather than my local time ."	| since |	since := Duration days: SqueakEpoch 					  hours: 0 					  minutes: 0 					  seconds:  (seconds + self localTimeZone offset asSeconds).	^ self basicNew		ticks: since ticks offset: self localTimeZone offset;		yourself.! !!DateAndTime class methodsFor: 'primitives' stamp: 'bgf 10/22/2007 21:47'!primTimezoneOffset	"If known, the UTC timezone offet (in minutes) of this VM; otherwise zero	 	DateAndTime tzOffset	 " 	<primitive: 'primitiveTimezoneOffset' module: 'LocalePlugin'>	^ 0! !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'tlk 1/2/2004 10:58'!setUp     localTimeZoneToRestore := DateAndTime localTimeZone.	aDateAndTime :=  DateAndTime localTimeZone: TimeZone default; epoch.	aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Epoch Test Time Zone' abbreviation: 'ETZ'.	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DateAndTimeEpochTest methodsFor: 'running' stamp: 'tlk 1/2/2004 11:04'!tearDown     DateAndTime localTimeZone: localTimeZoneToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testAsDate	self assert: aDateAndTime asDate =   'January 1, 1901' asDate.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:31'!testAsDateAndTime	self assert: aDateAndTime asDateAndTime =  aDateAndTime	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:34'!testAsDuration	self assert: aDateAndTime asDuration =  0 asDuration	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:06'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:27'!testAsMonth	self assert: aDateAndTime asMonth = (Month month: 'January' year: 1901). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  0 asDuration asNanoSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:01'!testAsSeconds	self assert: aDateAndTime asSeconds =  0 asDuration asSeconds	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:32'!testAsTime	self assert: aDateAndTime asTime =  Time midnight.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 14:51'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  TimeStamp new.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:07'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:43'!testAsWeek	self assert: aDateAndTime asWeek = (Week starting: '12-31-1900' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:43'!testAsYear	self assert: aDateAndTime asYear =   (Year starting: '01-01-1901' asDate). ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testCurrent	self deny: aDateAndTime =  (DateAndTime current).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:46'!testDateTime	self assert: aDateAndTime =  (DateAndTime date: '01-01-1901' asDate time: '00:00:00' asTime)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDay	self assert: aDateAndTime day =   DateAndTime new day! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 11:08'!testDayMonthYearDo	|iterations|	iterations := 0.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1])  = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 1901.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 1.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 15:45'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:47'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 3.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Tue'.	self assert: aDateAndTime dayOfWeekName = 'Tuesday'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:01'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 31.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysInYear	self assert: aDateAndTime daysInYear  = 365.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 364.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:24'!testDuration	self assert: aDateAndTime duration  = 0 asDuration.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:25'!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:44'!testFirstDayOfMonth	self assert: aDateAndTime firstDayOfMonth =   1! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:25'!testFromSeconds	self assert: aDateAndTime =  (DateAndTime fromSeconds: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:26'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00').	self assert: aDateAndTime =  (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 4/30/2006 22:20'!testHash	self assert: aDateAndTime hash =    DateAndTime new hash.	self assert: aDateAndTime hash =    32161486! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 16:59'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    0.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 3/12/2004 15:21'!testHour12	self assert: aDateAndTime hour12  = DateAndTime new hour12.	self assert: aDateAndTime hour12  = 12! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:02'!testIsLeapYear	self deny: aDateAndTime isLeapYear! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:18'!testJulianDayNumber	self assert: aDateAndTime =  (DateAndTime julianDayNumber: 2415386).	self assert: aDateAndTime julianDayNumber = 2415386.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 13:20'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:40'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'AM'.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:37'!testMiddleOf	self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) = 	 (Timespan starting: '12-31-1900' asDate duration: 2 days).	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:39'!testMidnight	self assert: aDateAndTime midnight =  aDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:03'!testMinus	self assert: aDateAndTime - aDateAndTime =  '0:00:00:00' asDuration.	self assert: aDateAndTime - '0:00:00:00' asDuration = aDateAndTime.	self assert: aDateAndTime - aDuration =  (DateAndTime year: 1900 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours ).	" I believe this Failure is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)" ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:35'!testMinute	self assert: aDateAndTime minute =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:41'!testMinutes	self assert: aDateAndTime minutes = 0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:46'!testMonth	self assert: aDateAndTime month  = 1.	self assert: aDateAndTime monthAbbreviation = 'Jan'.	self assert: aDateAndTime monthName = 'January'.	self assert: aDateAndTime monthIndex = 1.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:47'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:27'!testNew	self assert: aDateAndTime =  (DateAndTime new).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 19:49'!testNoon	self assert: aDateAndTime noon =  '1901-01-01T12:00:00+00:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:28'!testNow	self deny: aDateAndTime =  (DateAndTime now).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:41'!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 11:03'!testPlus	self assert: aDateAndTime + '0:00:00:00' = aDateAndTime.	self assert: aDateAndTime + 0 = aDateAndTime.	self assert: aDateAndTime + aDuration = (DateAndTime year: 1901 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours )	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nk 3/12/2004 10:16'!testPrintOn	| cs rw |	cs := ReadStream on: '1901-01-01T00:00:00+00:00'.	rw := ReadWriteStream on: ''.	aDateAndTime printOn: rw.	self assert: rw contents = cs contents.	cs  := ReadStream on: 'a TimeZone(ETZ)'.	rw := ReadWriteStream on: ''.	aTimeZone printOn:  rw.	self assert: rw contents = cs contents! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:22'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:25'!testTicks	self assert: aDateAndTime ticks =  (DateAndTime julianDayNumber: 2415386) ticks.	self assert: aDateAndTime ticks = #(2415386 0 0)! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:31'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2415386 0 0) offset: DateAndTime localOffset).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:42'!testTo	self assert: (aDateAndTime to: aDateAndTime) = (DateAndTime new to: DateAndTime new) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:43'!testToBy	self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) = 				(DateAndTime new to: DateAndTime new + 10 days by: 5 days ) 	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:53'!testToByDo	"self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days do: []) =  "	"MessageNotUnderstood: UndefinedObject>>starting:ending:  where UndefinedObject is Timespan "! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 17:35'!testToday	self deny: aDateAndTime =  (DateAndTime today).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:45'!testTommorrow	self assert: (DateAndTime today + 24 hours) =  (DateAndTime tomorrow).	self deny: aDateAndTime =  (DateAndTime tomorrow).     "MessageNotUnderstood: Date class>>starting:"! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 20:58'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00'.! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 21:00'!testYear	self assert: aDateAndTime year = 1901.	! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:30'!testYearDay	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDay	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/1/2004 12:31'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:23'!testYearMonthDayHourMinuteSecondNanosSecondOffset	self assert: aDateAndTime =  (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset:0 hours ).	self assert: ((DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours ) +				(Duration days: 1 hours: 2 minutes: 3 seconds: 4  nanoSeconds: 5) ) =  					(DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours ) 	" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"" I believe this is a bug in the nanosecond part of (DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset:)"   ! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 09:47'!testYesterday	self deny: aDateAndTime =  (DateAndTime yesterday).! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !!DateAndTimeEpochTest commentStamp: 'tlk 1/6/2004 18:27' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage  for the Chronology set of classes as part of the external testing. The other Chronology sunit test cases are: DateTestCase DateAndTimeLeapTestCase, DurationTestCase, ScheduleTestCase TimeStampTestCase TimespanDoTestCase,  TimespanDoSpanAYearTestCase,  TimespanTestCase,  YearMonthWeekTestCase.  These tests attempt to exercise all public and private methods.  Except, they do not explicitly depreciated methods. tlkMy fixtures are:aDateAndTime = January 01, 1901 midnight (the start of the Squeak epoch) with localTimeZone = Grenwhich Meridian (local offset = 0 hours)aDuration = 1 day, 2 hours, 3, minutes, 4 seconds and 5 nano seconds.aTimeZone =  'Epoch Test Time Zone', 'ETZ' , offset: 12 hours, 15 minutes. !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'nk 3/12/2004 11:00'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	aDateAndTime := (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours).	aTimeZone := TimeZone default.	aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0! !!DateAndTimeLeapTest methodsFor: 'running' stamp: 'tlk 1/2/2004 21:30'!tearDown     DateAndTime localTimeZone: localTimeZoneToRestore.     "wish I could remove the time zones I added earlier, tut there is no method for that"! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:00'!testAsDate	self assert: aDateAndTime asDate =   'February 29, 2004' asDate.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:55'!testAsDuration	self assert: aDateAndTime asDuration =  aDuration	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 14:00'!testAsLocal	self assert: aDateAndTime asLocal =  aDateAndTime.	self assert: aDateAndTime asLocal = (aDateAndTime utcOffset: aDateAndTime class localOffset)	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:24'!testAsMonth	self assert: aDateAndTime asMonth = (Month month: 'February' year: 2004).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:59'!testAsNanoSeconds	self assert: aDateAndTime asNanoSeconds =  aDuration asNanoSeconds.	self assert: aDateAndTime asNanoSeconds = 48780000000000	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:05'!testAsSeconds	self assert: aDuration asSeconds =  48780.	self assert: aDateAndTime asSeconds =  3255507180	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:26'!testAsTime	self assert: aDateAndTime asTime = (Time hour: 13 minute: 33 second: 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:31'!testAsTimeStamp	self assert: aDateAndTime asTimeStamp =  ((TimeStamp readFrom: '2-29-2004 1:33 pm' readStream) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testAsUTC	self assert: aDateAndTime asUTC =  aDateAndTime          ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:30'!testAsWeek	self assert: aDateAndTime asWeek =    (Week starting: '02-29-2004' asDate).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 12:36'!testAsYear	self assert: aDateAndTime asYear =   (Year starting: '02-29-2004' asDate).  	self deny: aDateAndTime asYear =   (Year starting: '01-01-2004' asDate)  ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:23'!testDay	self assert: aDateAndTime day =   60. 	self deny: aDateAndTime day =   29 ! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:16'!testDayMonthYearDo	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear])  = 2004.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth]) = 2.	self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay]) = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 22:17'!testDayOfMonth	self assert: aDateAndTime dayOfMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:34'!testDayOfWeek	self assert: aDateAndTime dayOfWeek  = 1.	self assert: aDateAndTime dayOfWeekAbbreviation = 'Sun'.	self assert: aDateAndTime dayOfWeekName = 'Sunday'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:59'!testDayOfYear	self assert: aDateAndTime dayOfYear  = 60.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInMonth	self assert: aDateAndTime daysInMonth  = 29.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysInYear	self assert: aDateAndTime daysInYear  = 366.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:58'!testDaysLeftInYear	self assert: aDateAndTime daysLeftInYear  = 306.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:38'!testFirstDayOfMonth	self deny: aDateAndTime firstDayOfMonth =  1.	self assert: aDateAndTime firstDayOfMonth = 32! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:43'!testFromString	self assert: aDateAndTime =  (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00').! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 4/30/2006 22:17'!testHash	self assert: aDateAndTime hash =     131156085! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 10:48'!testHour	self assert: aDateAndTime hour =    aDateAndTime hour24.	self assert: aDateAndTime hour =    13.	self assert: aDateAndTime hour =    aDateAndTime hours! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'brp 3/12/2004 15:19'!testHour12	self assert: aDateAndTime hour12  =   1.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:35'!testIsLeapYear	self assert: aDateAndTime isLeapYear! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testLessThan	self assert: aDateAndTime  < (aDateAndTime + '1:00:00:00').	self assert: aDateAndTime + -1 < aDateAndTime.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 10:42'!testMeridianAbbreviation	self assert: aDateAndTime meridianAbbreviation = 'PM'.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:12'!testMiddleOf	self assert: (aDateAndTime middleOf: aDuration)  = 	 (Timespan starting: (DateAndTime year: 2004 month: 2 day: 29 hour: 6 minute: 46 second: 30 offset: 2 hours)	duration: (Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0 ))	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:57'!testMidnight	self assert: aDateAndTime midnight =  '2004-02-29T00:00:00+00:00'.	self deny: aDateAndTime midnight =  '2004-02-29T00:00:00+02:00'! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:00'!testMinute	self assert: aDateAndTime minute =  33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:44'!testMinutes	self assert: aDateAndTime minutes = 33! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:02'!testMonth	self assert: aDateAndTime month  = 2.	self assert: aDateAndTime monthAbbreviation = 'Feb'.	self assert: aDateAndTime monthName = 'February'.	self assert: aDateAndTime monthIndex = 2.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testNanoSecond	self assert: aDateAndTime nanoSecond =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:03'!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:07'!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:27'!testPrintOn	| cs rw |	cs := ReadStream on: '2004-02-29T13:33:00+02:00'.	rw := ReadWriteStream on: ''.	aDateAndTime printOn: rw.	self assert: rw contents = cs contents.	cs  := ReadStream on: 'a TimeZone(UTC)'.	rw := ReadWriteStream on: ''.	aTimeZone printOn:  rw.	self assert: rw contents = cs contents	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSecond	self assert: aDateAndTime second =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/2/2004 21:30'!testSeconds	self assert: aDateAndTime seconds =  0! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:12'!testTicks	self assert: aDateAndTime ticks =  ((DateAndTime julianDayNumber: 2453065) + 48780 seconds) ticks.	self assert: aDateAndTime ticks =  #(2453065 48780 0)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:52'!testTicksOffset	self assert: aDateAndTime =  (aDateAndTime ticks:  #(2453065 48780 0) offset: DateAndTime localOffset).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/4/2004 13:51'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00'.! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:17'!testYear	self assert: aDateAndTime year = 2004.	! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:21'!testYearDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 day: 60 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 11:23'!testYearMonthDayHourMinuteSecond	self assert: aDateAndTime =  ((DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0) offset: 2 hours).! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'nk 3/12/2004 11:26'!testtimeZone	self assert: aDateAndTime timeZoneName	= 'Universal Time'.	self assert: aDateAndTime timeZoneAbbreviation	=  'UTC'! !!DateAndTimeLeapTest commentStamp: 'tlk 1/6/2004 17:54' prior: 0!I represent one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. tlk.My fixtures are:aDateAndTime = February 29, 2004 1:33 PM with offset: 2 hoursaDuration = 15 days, 14 hours, 13 minutes, 12 seconds and 11 nano seconds.aTimeZone =  Grenwhich Meridian (local offset = 0 hours) !!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!classToBeTested	^ DateAndTime! !!DateAndTimeTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 09:25'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 17:00'!testArithmeticAcrossDateBoundary	| t1 t2 |	t1 := '2004-01-07T11:55:00+00:00' asDateAndTime. 	t2 := t1 - ( (42900+1) seconds).  	self 		assert: t2 = ('2004-01-06T23:59:59+00:00' asDateAndTime)		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:00'!testDateTimeDenotation1  "DateAndTimeTest new testDateTimeDenotation1"		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests the correct interpretation of the DateAndTime denotation. "	| twoPmInLondon twoPmUTCInLocalTimeOfDetroit nineAmInDetroit |	twoPmInLondon := DateAndTime				year: 2004				month: 11				day: 2				hour: 14				minute: 0				second: 0				offset: 0 hours.	twoPmUTCInLocalTimeOfDetroit := twoPmInLondon utcOffset: -5 hours.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	self assert:  twoPmUTCInLocalTimeOfDetroit = nineAmInDetroit.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:01'!testDateTimeDenotation2  "DateAndTimeTest new testDateTimeDenotation2"		 " Moscow is 3 hours ahead UTC, this offset to UTC is therefore positive. This example tests the correct interpretation of the DateAndTime denotation. "	| lateEveningInLondon lateEveningInLocalTimeOfMoscow	 localMoscowTimeFromDenotation |	lateEveningInLondon := DateAndTime				year: 2004				month: 11				day: 30				hour: 23				minute: 30				second: 0				offset: 0 hours.	lateEveningInLocalTimeOfMoscow := lateEveningInLondon utcOffset: 3 hours.	localMoscowTimeFromDenotation  := '2004-12-01T02:30:00+03:00' asDateAndTime.	self assert:  lateEveningInLocalTimeOfMoscow = localMoscowTimeFromDenotation.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'bvs 9/29/2004 16:22'!testErrorWhenDayIsAfterMonthEnd	self		should:			[DateAndTime				year: 2004				month: 2				day: 30]		raise: Error.	self		shouldnt:			[DateAndTime				year: 2004				month: 2				day: 29]		raise: Error.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'bvs 9/29/2004 16:29'!testErrorWhenDayIsBeforeMonthStart	self		should:			[DateAndTime				year: 2004				month: 2				day: -1]		raise: Error.	self		should:			[DateAndTime				year: 2004				month: 2				day: 0]		raise: Error.			self		shouldnt:			[DateAndTime				year: 2004				month: 2				day: 1]		raise: Error.	! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:37'!testInstanceCreation	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t julianDayNumber = 1721427);		assert: (t offset = 6 hours);		assert: (t hour = 2);		assert: (t minute = 3);		assert: (t second = 4);		assert: (t nanoSecond = 5).		! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'nk 3/12/2004 11:06'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	(Delay forMilliseconds: 1000) wait.	t3 := DateAndTime now.	t4 := DateAndTime now.	self		assert: (	t1 <= t2);		assert: (	t2 < t3);		assert: (	t3 <= t4).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'KLC 5/9/2008 20:37'!testPrecision	"Verify that the clock is returning a value with accuracy of better than 1 second.  For now it seems sufficient to get two values and verify they are not the same."	self		assert: (DateAndTime now ~= DateAndTime now)! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/5/2004 05:45'!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'kph 12/19/2006 15:04'!testReadFromself assert: ('-1199-01-05T20:33:14.321-05:00' asDateAndTime printString = '-1199-01-05T20:33:14.321-05:00').self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').self assert: (' 2002-05-16T17:20' asDateAndTime printString = '2002-05-16T17:20:00+00:00').self assert: ('2002-05-16T17:20:45' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34').self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00').self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3').  	 ! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:43'!testSmalltalk80Accessors	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t hours = t hours);		assert: (t minutes = t minute);		assert: (t seconds = t second).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'BG 11/7/2004 12:18'!testTimeZoneEquivalence  "DateAndTimeTest new testTimeZoneEquivalence"	"When the clock on the wall in Detroit says 9:00am, the clock on the wall	in London says 2:00pm. The Duration difference between the corresponding	DateAndTime values should be zero."		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests both the correct interpretation of the DateAndTime denotation and correct DateAndTime arithmetics. "	| twoPmInLondon nineAmInDetroit durationDifference |	twoPmInLondon := '2004-11-02T14:00:00+00:00' asDateAndTime.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	durationDifference := twoPmInLondon - nineAmInDetroit.	self assert: durationDifference asSeconds = 0.	self assert: twoPmInLondon = nineAmInDetroit! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'BG 11/7/2004 12:17'!testTimeZoneEquivalence2  "DateAndTimeTest new testTimeZoneEquivalence2"	"This example demonstates the fact that        2004-05-24T22:40:00  UTC  is        2004-05-25T01:40:00  in Moscow     (Moscow is 3 hours ahead of UTC)  "	| thisMoment thisMomentInMoscow |    thisMoment := DateAndTime year: 2004 month: 5 day: 24 hour: 22 minute: 40.    thisMomentInMoscow := thisMoment utcOffset: 3 hours.	self assert: (thisMoment - thisMomentInMoscow) asSeconds = 0.	self assert: thisMoment = thisMomentInMoscow! !!DateTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:01'!classToBeTested	^ self dateClass! !!DateTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:03'!selectorsToBeIgnored	 | deprecated private special |	deprecated := #().	private := #().	special := #( #< #= #new #next #previous #printOn: #printOn:format: #storeOn: #fromString: ).	^ super selectorsToBeIgnored, deprecated, private, special! !!DateTest methodsFor: 'Private' stamp: 'brp 8/24/2003 00:10'!dateClass	^ Date! !!DateTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:46'!setUp	date := self dateClass newDay: 153 year: 1973.	"2 June 1973"	aDate := Date readFrom: '01-23-2004' readStream.	aTime := Time readFrom: '12:34:56 pm' readStream! !!DateTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:07'!testAccessing	self			assert: date day = 153;		assert: date julianDayNumber = 2441836;		assert: date leap = 0;		assert: date monthIndex = 6;		assert: date monthName = #June;		assert: date weekday = #Saturday;		assert: date weekdayIndex = 7;		assert: date year = 1973.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:10'!testArithmetic	| d |	d := date addDays: 32.		"4 July 1973"	self 		assert: d year = 1973;		assert: d monthIndex = 7;		assert: d dayOfMonth = 4.	self 		assert: (d subtractDate: date) = 32;		assert: (date subtractDate: d) = -32.	self	 		assert: (d subtractDays: 32) = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:54'!testComparing	| d1 d2 d3 |	d1 := self dateClass newDay: 2 month: #June year: 1973.	d2 := self dateClass newDay: 97 year: 2003. 		"7 April 2003"	d3 := self dateClass newDay: 250 year: 1865. 		"7 September 1865"	self		assert: date = d1;		assert: date = date copy;		assert: date hash = d1 hash.	self 		assert: date < d2;		deny: date < d3.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:15'!testConverting	self 		assert: date asDate = date;		assert: '2 June 1973' asDate = date;		assert: date asSeconds = 2285280000.	date dayMonthYearDo: [ :d :m :y | self assert: d = 2; assert: m = 6; assert: y = 1973 ].! !!DateTest methodsFor: 'Tests' stamp: 'tfel 9/1/2009 07:09'!testConvertingFromIso8601	self 		assert: '1973-06-02' asDate = date;		assert: '1973-JUN-02' asDate = date;		assert: '1973-June-02' asDate = date! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:47'!testFromDays	| epoch d0 d1 d2 |	epoch := self dateClass newDay: 1 year: 1901.	d0 := self dateClass fromDays: 0. 			"1 January 1901"	self assert: d0 = epoch.	d1 := self dateClass fromDays:  26450. 	"2 June 1973"	self assert: d1 = date.	d2 := self dateClass fromDays: -100000.	"18 March 1627"	self assert: d2 julianDayNumber = 2315386.	self assert: aDate  =  (Date fromDays:  37642).	self assert: aDate  =  (Date fromDays: 103*365 + 22 + 25 "leap days") .	! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testFromSeconds	| d |	d := self dateClass fromSeconds: 2285280000. 	self		assert: d = date.! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:37'!testGeneralInquiries	| shuffled indices names now | 	shuffled := #(#January #February #March #April #May #June #July 					#August #September #October #November #December) shuffled.	indices := shuffled collect: [ :m | self dateClass indexOfMonth: m ].	names := indices collect: [ :i | self dateClass nameOfMonth: i ].	self assert: names = shuffled.	shuffled := #(#Monday #Tuesday #Wednesday #Thursday #Friday #Saturday #Sunday) shuffled.	indices := shuffled collect: [ :m | self dateClass dayOfWeek: m ].	names := indices collect: [ :i | self dateClass nameOfDay: i ].	self assert: names = shuffled.		now  := self dateClass dateAndTimeNow.	self 		assert: now size = 2;		assert: now first = self dateClass today.	self assert: (self dateClass firstWeekdayOfMonth: #June year: 1973) = 6.	self		assert: (self dateClass leapYear: 1973) = 0;		assert: (self dateClass leapYear: 1972) = 1;		assert: (self dateClass daysInYear: 1973) = 365;		assert: (self dateClass daysInYear: 1972) = 366;		assert: (self dateClass daysInMonth: #February forYear: 1973) = 28;		assert: (self dateClass daysInMonth: #February forYear: 1972) = 29.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:17'!testInitialization	self should: [ self dateClass initialize. true ].! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:18'!testInquiries	self			assert: date dayOfMonth = 2;		assert: date dayOfYear = 153;		assert: date daysInMonth = 30;		assert: date daysInYear = 365;		assert: date daysLeftInYear = (365 - 153);		assert: date firstDayOfMonth = 152.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testNew	| epoch |	epoch := self dateClass newDay: 1 year: 1901.	self assert: (self dateClass new = epoch).! !!DateTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:33'!testPreviousNext	| n p pt ps |	n := date next.	p := date previous.	self		assert: n year = 1973;		assert: n dayOfYear = 154;		assert: p year = 1973;		assert: p dayOfYear = 152.	pt := date previous: #Thursday.		"31 May 1973"	self			assert: pt year = 1973;		assert: pt dayOfYear = 151.	ps := date previous: #Saturday.		" 26 May 1973"	self			assert: ps year = 1973;		assert: ps dayOfYear = (153-7).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:21'!testPrinting	self			assert: date mmddyyyy = '6/2/1973';		assert: date yyyymmdd = '1973-06-02';		assert: (date printFormat: #(3 1 2 $!! 2 1 1)) = '1973!!2!!Jun'.! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:23'!testReadFrom	| s1 s2 s3 s4 s5 | 	s1 := '2 June 1973'.	s2 := '2-JUN-73'.	s3 := 'June 2, 1973'.	s4 := '6/2/73'.	s5 := '2JUN73'.	self			assert: date = (self dateClass readFrom: s1 readStream);		assert: date = (self dateClass readFrom: s2 readStream);		assert: date = (self dateClass readFrom: s3 readStream);		assert: date = (self dateClass readFrom: s4 readStream);		assert: date = (self dateClass readFrom: s5 readStream).! !!DateTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:05'!testStoring	self			assert: date storeString = '''2 June 1973'' asDate';		assert: date = ('2 June 1973' asDate).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAddDays	self assert: (aDate addDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate addDays: 30) yyyymmdd =  '2004-02-22'.	self assert: (aDate addDays: 60) yyyymmdd =  '2004-03-23'.	self assert: (aDate addDays: 90) yyyymmdd =  '2004-04-22'.	self assert: (aDate addDays:120) yyyymmdd =  '2004-05-22'! !!DateTest methodsFor: 'testing' stamp: 'tbn 7/11/2006 10:37'!testAddMonths	self assert: (aDate addMonths: 0) yyyymmdd =  '2004-01-23'.		self assert: (aDate addMonths: 1) yyyymmdd =  '2004-02-23'.	self assert: (aDate addMonths: 2) yyyymmdd =  '2004-03-23'.	self assert: (aDate addMonths: 3) yyyymmdd =  '2004-04-23'.	self assert: (aDate addMonths: 12) yyyymmdd =  '2005-01-23'.		self assert: ((Date readFrom: '05-31-2017' readStream) addMonths: 1) yyyymmdd =  '2017-06-30'.	self assert: ((Date readFrom: '02-29-2000' readStream) addMonths: 12) yyyymmdd =  '2001-02-28'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsDate	self assert: (aDate asDate) = aDate! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testAsSeconds	self assert: (aDate asSeconds) =   3252268800.	self assert: (aDate asSeconds) =  ((103*365*24*60*60) + (22+25"leap days"*24*60*60)) .	self assert: aDate  =  (Date fromSeconds: 3252268800).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDateAndTimeNow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch time errors"	self assert: Date dateAndTimeNow first  = Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDayMonthYearDo	self assert: (aDate dayMonthYearDo: [:day :month :year | day asString , month asString, year asString]) = '2312004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInMonthForYear	self assert: (Date daysInMonth: 'February' forYear: 2008)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2000)  = 29.		self assert: (Date daysInMonth: 'February' forYear: 2100)  = 28.		self assert: (Date daysInMonth: 'July' forYear: 2100)  = 31.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDaysInYear	self assert: (Date daysInYear: 2008)  = 366.		self assert: (Date daysInYear: 2000)  = 366.		self assert: (Date daysInYear: 2100)  = 365	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testDuration	self assert: aDate duration = 24 hours! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testEqual	self assert: aDate = (Date readFrom: (ReadStream on: 'January 23, 2004')).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testFirstWeekdayOfMonthYear	self assert: (Date firstWeekdayOfMonth: 'January' year: 2004)  = 5.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testIndexOfMonth	self assert: (Date indexOfMonth: 'January')  = 1.		self assert: (Date indexOfMonth: 'December')  = 12.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testJulianDayNumber	self assert: aDate = (Date julianDayNumber: ((4713+2004)*365 +1323) ).  ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeap	self assert: aDate leap = 1.	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLeapNot	self assert: (aDate addDays: 365) leap = 0! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testLessThan	self assert: aDate < (Date readFrom: (ReadStream on: '01-24-2004')).! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testMmddyyyy	self assert: aDate mmddyyyy =  '1/23/2004'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNameOfMonth	self assert: (Date nameOfMonth: 5) = 'May'.		self assert: (Date nameOfMonth: 8) = 'August' ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayMonthYear	self assert: aDate = (Date newDay: 23 month: 1 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testNewDayYear	self assert: aDate = (Date newDay: 23 year: 2004)	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousFriday	self assert: (aDate previous: 'Friday') yyyymmdd = '2004-01-16'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPreviousThursday	self assert: (aDate previous: 'Thursday') yyyymmdd = '2004-01-22'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintFormat	self assert: (aDate printFormat: #(1 2 3 $? 2 2)) =  '23?Jan?04'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintOn	| cs rw |	cs := ReadStream on: '23 January 2004'.	rw := ReadWriteStream on: ''.	aDate printOn: rw.	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testPrintOnFormat	| cs rw |	cs := ReadStream on: '04*Jan*23'.	rw := ReadWriteStream on: ''.	aDate printOn: rw format: #(3 2 1 $* 2 2).	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testStarting	self assert: aDate = (Date starting: (DateAndTime fromString: '2004-01-23T12:12')).  ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testStoreOn	| cs rw |	cs := ReadStream on: '''23 January 2004'' asDate'.	rw := ReadWriteStream on: ''.	aDate storeOn: rw.	self assert: rw contents = cs contents! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDate	self assert: (aDate subtractDate:(aDate addDays: 30)) = -30.		self assert: (aDate subtractDate:(aDate subtractDays: 00)) = 0.		self assert: (aDate subtractDate:(aDate subtractDays: 30)) = 30.! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testSubtractDays	self assert: (aDate subtractDays: 00) yyyymmdd =  '2004-01-23'.		self assert: (aDate subtractDays: 30) yyyymmdd =  '2003-12-24'.	self assert: (aDate subtractDays: 60) yyyymmdd =  '2003-11-24'! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testTomorrow	"Not a great test: could falsely fail if midnight come in between the two executions and doesnt catch many errors"	self assert: Date tomorrow  > Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testWeekday	self assert: aDate weekday = 'Friday'.		self assert: aDate weekdayIndex = 6. 	self assert: (Date dayOfWeek: aDate weekday ) =6.	self assert: (Date nameOfDay: 6 ) = 'Friday'	! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYesterday	"Not a great test:  doesnt catch many errors"	self assert: Date yesterday  < Date today ! !!DateTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:48'!testYyyymmdd	self assert: aDate yyyymmdd =  '2004-01-23'! !!DateTest commentStamp: 'brp 7/26/2003 16:58' prior: 0!This is the unit test for the class Date. !!Debugger methodsFor: 'accessing' stamp: 'eem 4/9/2010 10:22'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		"N.B. Only reset the contents if the compilation succeeds.  If contents are reset		 when compilation fails both compiler error message and modifications are lost."		(result := self contents: aText notifying: aController) ifTrue:			[self contentsChanged].		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	contents := aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	Smalltalk isMorphic ifTrue:		[World			addAlarm: #changed:			withArguments: #(contentsSelection)			for: self			at: (Time millisecondClockValue + 200)].	^true! !!Debugger methodsFor: 'accessing' stamp: 'abc 2/12/2010 15:02'!debuggerMap	^self selectedContext debuggerMap! !!Debugger methodsFor: 'accessing' stamp: 'eem 5/27/2009 16:55'!selectedMethodOrNilFor: aSelector	^self selectedContext ifNotNil:		[:aContext| aContext method]! !!Debugger methodsFor: 'initialize' stamp: 'ar 6/22/2010 13:40'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| win oldContextStackIndex |	oldContextStackIndex := contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	win := ToolBuilder open: self label: aString.	self toggleContextStackIndex: oldContextStackIndex.	^win! !!Debugger methodsFor: 'private' stamp: 'eem 3/12/2009 14:54'!newStack: stack	| oldStack diff |	oldStack := contextStack.	contextStack := stack.	(oldStack == nil or: [oldStack last ~~ stack last])		ifTrue: [contextStackList := contextStack collect: [:ctx | ctx printString].				^ self].	"May be able to re-use some of previous list"	diff := stack size - oldStack size.	contextStackList := diff <= 0		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]		ifFalse: [diff > 1				ifTrue: [contextStack collect: [:ctx | ctx printString]]				ifFalse: [(Array with: stack first printString) , contextStackList]]! !!Debugger commentStamp: '<historical>' prior: 0!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!Debugger class methodsFor: 'opening' stamp: 'eem 7/26/2010 15:51'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess block |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]].	block := [ 		[	| debugger |			debugger := self new process: process controller: controller context: context.			Smalltalk isMorphic				ifTrue: ["schedule debugger in deferred UI message to address redraw						problems after opening a debugger e.g. from the testrunner."					"WorldState addDeferredUIMessage: ["bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]]				ifFalse: ["deferred UI message would require special controller in MVC"					bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			Smalltalk isMorphic				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	self ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess.	Project current addDeferredUIMessage: block.	process suspend! !!Debugger class methodsFor: 'private' stamp: 'eem 7/26/2010 18:01'!ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess	| sema |	errorWasInUIProcess ifTrue:		[^self].	self interruptUIProcessIfBlockedOnErrorInBackgroundProcess ifFalse:		[^self].	"Only interrupt the UI if it is unresponsive (and so is doing something that needs	 interrupting).  Test using addDeferredUIMessage: to see if it is running UI activities."	sema := Semaphore new.	Project current addDeferredUIMessage: [sema signal].	(sema waitTimeoutMSecs: 100) ifTrue:		[[Project current interruptName: 'Interrupt from Background Error'] fork]	"| s |	s := Semaphore new.	[self assert: 0 > 1000. s signal] fork.	s wait"! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:52'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess	<preference: 'Interrupt UI process on background error'		category: 'debug'		description: 'When enabled, the debugger will interrupt the UI process if an error occurs in a background process and the UI process is blocked.'		type: #Boolean>	^InterruptUIProcessIfBlockedOnErrorInBackgroundProcess ifNil: [false]! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:53'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess: aBoolean	InterruptUIProcessIfBlockedOnErrorInBackgroundProcess := aBoolean! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:38'!testUnwindBlock	"test if unwind blocks work properly"	| sema process |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	"deadlock on the semaphore"	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"terminate process"	process terminate.	self assert: sema isSignaled.! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:41'!testUnwindDebugger	"test if unwind blocks work properly when a debugger is closed"	| sema process debugger top |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"everything set up here - open a debug notifier"	debugger := Debugger openInterrupt: 'test' onProcess: process.	"get into the debugger"	debugger debug.	top := debugger topView.	"set top context"	debugger toggleContextStackIndex: 1.	"close debugger"	top delete.	"and see if unwind protection worked"	self assert: sema isSignaled.! !!DebuggerUnwindBug methodsFor: 'as yet unclassified' stamp: 'ar 3/7/2003 01:40'!testUnwindDebuggerWithStep	"test if unwind blocks work properly when a debugger is closed"	| sema process debugger top |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [sema critical:[sema wait]] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"everything set up here - open a debug notifier"	debugger := Debugger openInterrupt: 'test' onProcess: process.	"get into the debugger"	debugger debug.	top := debugger topView.	"set top context"	debugger toggleContextStackIndex: 1.	"do single step"	debugger doStep.	"close debugger"	top delete.	"and see if unwind protection worked"	self assert: sema isSignaled.! !!Decompiler methodsFor: 'control' stamp: 'eem 8/12/2010 13:25'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: ((constructor						codeArguments: (tempVars copyFrom: 1 to: numArgs)						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)						block: block)							pc: startpc;							yourself).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/12/2010 13:51'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/30/2010 17:57'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node preen! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/12/2010 13:46'!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	aBlock isClosure ifTrue:		[(methodNode := method decompileWithTemps)			ifNil: [^nil]			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].		 ^self error: 'cannot find block node matching aBlock'].	constructor := self constructorForMethod: aBlock method.		self withTempNames: method methodNode tempNames.	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock endPC.	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 8/15/2010 16:56'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := MethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:56'!assert: aBoolean description: aString resumable: resumableBoolean 	aBoolean ifFalse: 		[failures isNil ifTrue:			[failures := OrderedCollection new].		 failures addLast: (thisContext sender home tempAt: 1) methodReference]! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:51'!computeFailures	(DecompilerTests organization listAtCategoryNamed: #tests) do:		[:s|		(s beginsWith: 'testDecompilerInClasses') ifTrue:			[self perform: s]].	^failures! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 11/10/2008 15:47'!failures	^failures! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:49'!isFailure: cls sel: selector	^false! !!DecompilerTestFailuresCollector methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:56'!checkDecompileMethod: oldMethod		[^super checkDecompileMethod: oldMethod]		on: SyntaxErrorNotification		do: [:ex|			self assert: false 				description: 'syntax error'				resumable: true].! !!DecompilerTestFailuresCollector commentStamp: '<historical>' prior: 0!(| dtfc |dtfc := DecompilerTestFailuresCollector new.(dtfc class superclass organization listAtCategoryNamed: #tests) do:	[:s| dtfc perform: s].dtfc failures)(Transcript nextPut: ${.self do: [:mr| Transcript print: mr actualClass; nextPut: $.; space; store: mr methodSymbol; nextPut: $.; cr; flush].Transcript nextPut: $}; flush)eem 7/1/2009 16:13{AdditionalMethodState. #keysAndValuesDo:.AdditionalMethodState. #propertyKeysAndValuesDo:.AdditionalMethodState. #at:ifAbsent:.AdditionalMethodState. #removeKey:ifAbsent:.AdditionalMethodState. #at:ifAbsentPut:.AdditionalMethodState. #setMethod:.AdditionalMethodState. #at:put:.AdditionalMethodState. #pragmas.AdditionalMethodState. #includesProperty:.AdditionalMethodState. #properties.AdditionalMethodState. #hasLiteralSuchThat:.AdditionalMethodState. #propertyValueAt:ifAbsent:.AdditionalMethodState. #hasLiteralThorough:.Array. #hasLiteralSuchThat:.BitBltSimulation. #initDither8Lookup.BlockNode. #sizeCodeExceptLast:.BlockNode. #emitCodeExceptLast:encoder:.Categorizer. #changeFromCategorySpecs:.Categorizer. #elementCategoryDict.CColorPicker. #colors:.CCustomDrawListCostume. #drawListOn:in:.ChangeList. #browseCurrentVersionsOfSelections.ClosureTests. #testToDoInsideTemp.Cogit. #computeMaximumSizes.Cogit. #outputInstructionsAt:.Cogit. #generateMapAt:start:.CogVMSimulator. #printFrameThing:at:.CogVMSimulator. #str:n:cmp:.CoInterpreter. #validStackPageBaseFrames.CoInterpreter. #markAndTraceTraceLog.CoInterpreter. #mapTraceLog.CoInterpreter. #checkStackIntegrity.CoInterpreter. #mapStackPages.CoInterpreter. #updateStackZoneReferencesToCompiledCodePreCompaction.CoInterpreter. #ceActivateFailingPrimitiveMethod:.CoInterpreterStackPages. #initializeStack:numSlots:pageSize:stackLimitOffset:stackPageHeadroom:.CompiledMethod. #=.CompiledMethod. #getPreambleFrom:at:.CompiledMethod. #hasLiteralThorough:.CompiledMethod. #hasLiteralSuchThat:.CPopUpMenuCostume. #drawMenu:on:in:.CroquetParticipant. #dropFiles:.CTextParagraph. #selectionRectsFrom:to:.CWheelWidgetCostume. #drawOn:in:.Dictionary. #scanFor:.Float. #printPaddedWith:to:.FMSound. #mixSampleCount:into:startingAt:leftVol:rightVol:.Form. #transformColors:.FTPClient. #getDataInto:.GIFReadWriter. #nextImageWithPlugin.GraphMorph. #drawDataOn:.GZipReadStream. #on:from:to:.HTTPServiceDispatcher. #errorReportFor:stack:on:.HttpUrl. #checkAuthorization:retry:.Integer. #benchSwitch:.Interpreter. #primitiveClosureValueWithArgs.Interpreter. #primitivePerformAt:.Interpreter. #primitiveDoPrimitiveWithArgs.Interpreter. #primitiveNewMethod.InterpreterStackPages. #initializeStack:numSlots:pageSize:stackLimitOffset:stackPageHeadroom:.JPEGReadWriter. #decodeBlockInto:component:dcTable:acTable:.KeyedIdentitySet. #scanFor:.KeyedSet. #scanFor:.LargeIntegersPlugin. #isNormalized:.LargeIntegersPlugin. #cBytesCopyFrom:to:len:.LargeIntegersPlugin. #cDigitMultiply:len:with:len:into:.LiteralDictionary. #scanFor:.LoopedSampledSound. #mixSampleCount:into:startingAt:leftVol:rightVol:.MethodDictionary. #scanFor:.MP4BoxInfoParser. #parseMP4BoxOutput:.MP4BoxNHMLTrack. #computeDTSDeltas.MultiByteBinaryOrTextStream. #next:.MultiByteFileStream. #next:.MViewPane. #reconstructEnabledDocuments.MViewPane. #reconstructOpenDocuments.MViewPane. #reconstructSelectionList.NewParagraph. #selectionRectsFrom:to:.Object. #instanceFields.OldSocket. #getResponseNoLF.PasteUpMorph. #dropFiles:.PlotMorphGrid. #bestStep:.PluckedSound. #reset.PluggableDictionary. #scanFor:.PluggableSet. #scanFor:.PluggableTabButtonMorph. #calculateArcLengths.PluggableTabButtonMorph. #drawTabOn:.PNGReadWriter. #copyPixelsGray:.PNMReadWriter. #readPlainRGB.PNMReadWriter. #readBWreverse:.PNMReadWriter. #nextPutRGB:.PNMReadWriter. #nextPutBW:reverse:.PopUpMenu. #readKeyboard.QFloorFan. #initialize.QMinimalForum. #demoDesksUnused.QNetVidReorderingBuffer. #popFramesForCTS:.QNetVidTrackStreamer. #sampleIndexWithCTS:.QServiceProvider. #statusReport.QServicesPane. #forumMenuInto:.QUserListItem. #drawOn:in:.QVMProfiler. #computeHistograms:.QVMProfiler. #selectSymbolsInRange.QwaqParticipantUI. #onDropFiles:.RelativeInstructionPrinter. #print:.RemoteHandMorph. #appendNewDataToReceiveBuffer.SchizophrenicClosureFormatStackInterpreter. #primitiveClosureValueWithArgs.Set. #do:.Set. #scanFor:.SHParserST80. #isBinary.ShootoutMall. #processVisitors.ShortIntegerArray. #writeOn:.SparseLargeArray. #analyzeSpaceSaving.StackInterpreter. #validStackPageBaseFrames.StackInterpreter. #divorceAllFrames.StackInterpreter. #checkStackIntegrity.StackInterpreter. #primitiveDoPrimitiveWithArgs.StackInterpreter. #reverseDisplayFrom:to:.StackInterpreter. #printOop:.StackInterpreter. #mapStackPages.StackInterpreter. #primitiveNewMethod.StackInterpreter. #primitiveClosureValueWithArgs.StrikeFontSet. #displayStringR2L:on:from:to:at:kern:.String. #howManyMatch:.Text. #asHtmlFragmentTextStyle:useBreaks:.TextURL. #actOnClickFor:.TFractalTerrain. #heightAt:.TFractalTerrain. #makeFaces.TFractalTerrain. #makeVertices.TFractalTerrain. #makeTextureUV.TFractalTerrain. #makeVertexNormals.TFrame. #computeUnionSphere.TMethod. #emitCCommentOn:.TRFBStreamOutput. #handleRequest:.TTCFontReader. #processCharacterMappingTable:.TTContourConstruction. #segmentsDo:.TTensor. #projectionIntegrate:.TTFontReader. #processHorizontalMetricsTable:length:.TTFontReader. #processCharacterMappingTable:.TWaves. #step.Vector. #copyFrom:.Vector. #asVector3.VectorColor. #copyFrom:.WeakKeyDictionary. #scanForNil:.WeakKeyDictionary. #scanFor:.WeakSet. #scanFor:.WeakSet. #scanForLoadedSymbol:.}!!DecompilerTests methodsFor: 'utilities' stamp: 'sd 9/25/2004 15:30'!blockingClasses	^ #(CompiledMethod)! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:35'!checkDecompileMethod: oldMethod		^self newCheckDecompileMethod: oldMethod! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 15:10'!classNames	| base41packageCategories classNames |	"(SystemOrganization categories collect: [:ea| (ea copyUpTo: $-) asString]) asSet asSortedCollection asArray"	base41packageCategories :=		#(	'311Deprecated'			'Balloon'			'Collections' 'CollectionsTests' 'Compiler' 'Compression'			'Etoys' 'Exceptions'			'Files'			'Graphics' 'GraphicsTests'			'Help' 'HelpSystem'			'Installer'			'Kernel' 'KernelTests'			'Monticello' 'MonticelloConfigurations' 'Morphic' 'MorphicExtras' 'MorphicTests' 'Multilingual' 'MultilingualTests'			'Nebraska' 'Network' 'NetworkTests'			'PackageInfo' 'PreferenceBrowser' 'Protocols'			'ReleaseBuilder'			'SMBase' 'SMLoader' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'Services' 'ShoutCore' 'Simulation' 'Sound' 'System' 'SystemChangeNotification'			'Tests' 'ToolBuilder' 'Tools' 'ToolsTests' 'Traits' 'TraitsTests' 'TrueType'			'Universes'			'VersionNumber' 'VersionNumberTests'			'XML') asSet.	classNames := Set new.	SystemOrganization categories do:		[:cat|		(base41packageCategories includes: (cat copyUpTo: $-) asString) ifTrue:			[classNames addAll: (SystemOrganization listAtCategoryNamed: cat)]].	^classNames asSortedCollection! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 15:11'!decompileClassesSelect: aBlock	(self classNames select: aBlock) do:		[:cn | | cls |		cls := Smalltalk globals at: cn.		cls selectorsAndMethodsDo:			[:selector :meth |			(self isFailure: cls sel: selector) ifFalse:				[self checkDecompileMethod: meth]]]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:26'!decompileStringForParseTree: aMethodNode	"Renumber the temps in the tree in parse tree order to eliminate that as a source of extraneous difference."	| visited count counter |	visited := IdentitySet new.	count := 0.	counter := [:temp|				(visited includes: temp) ifFalse:					[temp name: 't', (count := count + 1) printString.					 visited add: temp]].	aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node arguments do: counter].		node isTemp ifTrue:			[counter value: node]].		aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node temporaries do: counter.			 node temporaries: (node temporaries asSortedCollection: ParseNode tempSortBlock) asArray]].	^aMethodNode decompileString! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 15:48'!decompilerFailures	"Here is the list of failures: either a syntax error, a hard error or some failure to decompile correctly.	 Collected via		DecompilerTestFailuresCollector new computeFailures collect:			[:mr| { mr classSymbol. mr selector }]) asArray"	^#(	(BrowserCommentTextMorph showPane)		(ClassDescription replaceSilently:to:)		(CodeHolder getSelectorAndSendQuery:to:with:)		(Date printOn:)		(FileDirectory checkForReadability)		(Float printPaddedWith:to:)		(GIFReadWriter nextImageWithPlugin)		(HttpUrl checkAuthorization:retry:)		(MCConfigurationBrowser post)		(MailComposition breakLinesInMessage:)		(ParagraphEditor inOutdent:delta:)		(PNGReadWriter copyPixelsGray:)		(SystemWindow convertAlignment)		(TextEditor inOutdent:delta:)		(TextURL actOnClickFor:)		(TTContourConstruction segmentsDo:) "Worth fixing; these two are mistaken conversion from a whileTrue: to a to:do: but the index is used outside the whileTrue:"		(TTFontReader processHorizontalMetricsTable:length:))! !!DecompilerTests methodsFor: 'utilities' stamp: 'ar 7/13/2010 17:20'!defaultTimeout	"Decompiler takes a long time"	^30 "seconds"! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 11/10/2008 16:52'!isFailure: cls sel: selector 	"self new isKnowProblem: PNMReaderWriter sel: #nextImage"	"#((PNMReadWriter nextImage)) includes: {PNMReadWriter	name asSymbol . #nextImage}."	^(#(#DoIt #DoItIn:) includes: selector)	   or: [self decompilerFailures includes: {cls name asSymbol. selector}]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:41'!newCheckDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := (cls decompilerClass new withTempNames: oldMethod methodNode schematicTempNamesString)						decompile: selector						in: cls						method: oldMethod.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate.		 newCodeString := ((cls decompilerClass new withTempNames: methodNode schematicTempNamesString)							decompile: selector							in: cls							method: newMethod) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:32'!oldCheckDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := cls decompilerClass new						decompile: selector						in: cls						method: oldMethod.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate.		 newCodeString := (cls decompilerClass new							decompile: selector							in: cls							method: newMethod) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesAAtoAM	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesANtoAZ	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBAtoBM	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBNtoBZ	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCAtoCM	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCNtoCZ	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDAtoDM	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDNtoDZ	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesEAtoEM	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesENtoEZ	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFAtoFM	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFNtoFZ	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGAtoGM	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGNtoGZ	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHAtoHM	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHNtoHZ	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesIAtoIM	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesINtoIZ	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJAtoJM	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJNtoJZ	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKAtoKM	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKNtoKZ	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLAtoLM	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLNtoLZ	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMAtoMM	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMNtoMZ	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNAtoNM	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNNtoNZ	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesOAtoOM	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesONtoOZ	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPAtoPM	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPNtoPZ	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQAtoQM	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQNtoQZ	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRAtoRM	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRNtoRZ	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSAtoSM	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSNtoSZ	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTAtoTM	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTNtoTZ	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUAtoUM	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUNtoUZ	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVAtoVM	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVNtoVZ	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWAtoWM	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWNtoWZ	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXAtoXM	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXNtoXZ	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYAtoYM	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYNtoYZ	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZAtoZM	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZNtoZZ	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'nice 3/4/2010 22:26'!testRemoteTemp	| aBlock |	aBlock := Compiler evaluate: '| x y |  [:a :b | x := a. y := b. x+y]'.	self shouldnt: [aBlock decompile] raise: Error	! !!DecompilerTests commentStamp: 'sd 9/26/2004 13:24' prior: 0!Apparently the decompiler does not really work totally.Here are a bunch of methods that can help improving the decompiler:	- blockingClasses return class for which it is impossible to decompile methods 	- failures are problems that lead to a DNU	- decompilerDiscrepancies are the results of running decompileTestHelper..as you see the pattern 		is quite present.!!DeepCopier methodsFor: 'like fullCopy' stamp: 'eem 6/11/2008 17:21'!checkDeep	"Write exceptions in the Transcript.  Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  This check is only run by hand once in a while to make sure nothing was forgotten.  (Please do not remove this method.)	DeepCopier new checkDeep 	"	Transcript		cr;		show: 'Instance variables shared with the original object when it is copied'.	(self systemNavigation allClassesImplementing: #veryDeepInner:) do: 		[:aClass | | mm |		(mm := aClass instVarNames size) > 0 ifTrue:			[aClass instSize - mm + 1 to: aClass instSize do: 				[:index | 				((aClass compiledMethodAt: #veryDeepInner:) writesField: index) ifFalse: 					[Transcript						cr;						show: aClass name;						space;						show: (aClass allInstVarNames at: index)]]]]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'eem 6/11/2008 17:21'!checkVariables	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	self checkBasicClasses.	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(self systemNavigation allClassesImplementing: #veryDeepInner:) do: 			[:aClass | 			((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) 				ifFalse: 					[aClass instSize > 0 						ifTrue: [self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(self systemNavigation allClassesImplementing: #veryDeepCopyWith:) do: 			[:aClass | | meth |			meth := aClass compiledMethodAt: #veryDeepCopyWith:.			meth size > 20 & (meth literals includes: #veryDeepCopyWith:) not 				ifTrue: 					[(meth writesField: aClass instSize) 						ifFalse: [self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'eem 6/11/2008 17:22'!fixDependents	"They are not used much, but need to be right"	DependentsFields associationsDo:		[:pair |		pair value do:			[:dep |			(references at: dep ifAbsent: [nil]) ifNotNil:				[:newDep| | newModel |				newModel := references at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'ar 6/21/2010 11:19'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp |	newUniClasses ifFalse: [^ self].	"All will be siblings.  uniClasses is empty""Uniclasses use class vars to hold onto siblings who are referred to in code"pp := (Smalltalk at: #Player ifAbsent:[^self]) class superclass instSize.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+1"	"(pp+2) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+3 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References keys "copy" do: [:playerName | | oldPlayer newKey |	oldPlayer := References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey := (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass | | oldSelList newSelList |	oldSelList := OrderedCollection new.   newSelList := OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc isVariableBinding ifTrue: [				(References associationAt: assoc key ifAbsent: [nil]) == assoc ifTrue: [					| newKey newAssoc |					newKey := (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc := References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						(newClass compiledMethodAt: sel)							literalAt: ((newClass compiledMethodAt: sel) literals indexOf: assoc)							put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!DeferredActionStandardSystemController commentStamp: 'dtl 9/20/2009 18:39' prior: 0!Deprecated (Sept 2009) - The DeferredActionStandardSystemController has been merged into Controller. This class remains as a stub to guard ensure that any external packages that depend on it remain functional.This is a StandardSystemController that can queue up objects to be evaluated before its control loop.!!Delay methodsFor: 'private' stamp: 'ar 3/30/2007 17:09'!beGuardianDelay	"see comment for class method guardianDelay"	beingWaitedOn := false.	resumptionTime := SmallInteger maxVal.	delaySemaphore := Semaphore new.! !!Delay class methodsFor: 'primitives' stamp: 'ar 3/30/2007 17:08'!guardianDelay	"Make a Delay with a resumption time far in the future but still a SmallInteger so that it can be used as a guardian for the active delay queue. No process will be waiting on this and when triggered it will do nothing. What it allows is very long Delays where the resumption time is a large integer; should such a delay get activated it will fail the primitive and we creat one of these guardians to make sure the delay timer keeps going and triggers the resumption time recalculations in save/restoreResumptionTime"	^self new beGuardianDelay! !!Delay class methodsFor: 'primitives' stamp: 'eem 9/28/2009 08:17'!primSignal: aSemaphore atUTCMicroseconds: anInteger	"Signal the semaphore when the microsecond clock reaches the value	 of the second argument. Fail if the first argument is neither a Semaphore	 nor nil. Essential. See Object documentation whatIsAPrimitive.	 N.B. At most one semaphore can be scheduled for signalling at a time.	 The most recent invocation is in effect.  This primitive shares mechanism	 with primitive 136, primSignal:atMilliseconds:"	<primitive: 242>	^self primitiveFailed! !!Delay class methodsFor: 'timer process' stamp: 'ar 6/14/2010 14:20'!handleTimerEvent	"Handle a timer event; which can be either:		- a schedule request (ScheduledDelay notNil)		- an unschedule request (FinishedDelay notNil)		- a timer signal (not explicitly specified)	We check for timer expiry every time we get a signal."	| nowTick nextTick |	"Wait until there is work to do."	TimingSemaphore wait.	"Process any schedule requests"	ScheduledDelay ifNotNil:[		"Schedule the given delay"		self scheduleDelay: ScheduledDelay.		ScheduledDelay := nil.	].	"Process any unschedule requests"	FinishedDelay ifNotNil:[		self unscheduleDelay: FinishedDelay.		FinishedDelay := nil.	].	"Check for clock wrap-around."	nowTick := Time millisecondClockValue.	Time jiffyUpdate: nowTick.	nowTick < ActiveDelayStartTime ifTrue: [		"clock wrapped"		self saveResumptionTimes.		self restoreResumptionTimes.	].	ActiveDelayStartTime := nowTick.	"Signal any expired delays"	[ActiveDelay notNil and:[nowTick >= ActiveDelay resumptionTime]] whileTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty 			ifTrue: [ActiveDelay := nil] 			ifFalse:[ActiveDelay := SuspendedDelays removeFirst].	].	"And signal when the next request is due. We sleep at most 1sec here	as a soft busy-loop so that we don't accidentally miss signals."	nextTick := nowTick + Time jiffyGranularity.	ActiveDelay ifNotNil:[nextTick := nextTick min: ActiveDelay resumptionTime].	nextTick := nextTick min: SmallInteger maxVal.	"Since we have processed all outstanding requests, reset the timing semaphore so	that only new work will wake us up again. Do this RIGHT BEFORE setting the next	wakeup call from the VM because it is only signaled once so we mustn't miss it."	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.	"This last test is necessary for the obscure case that the msecs clock rolls over	after nowTick has been computed (unlikely but not impossible). In this case we'd	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets	scheduled (which may not be any time soon). In any case, since handling the	condition is easy, let's just deal with it"	Time millisecondClockValue < nowTick ifTrue:[TimingSemaphore signal]. "retry"! !!DelayTest methodsFor: 'testing-limits' stamp: 'laza 9/5/2009 08:49'!testBounds	"self run: #testBounds"		self should: [Delay forMilliseconds: -1] raise: Error.	self shouldnt: [Delay forMilliseconds: SmallInteger maxVal + 1] raise: Error.	self shouldnt: [(Delay forMilliseconds: Float pi) wait] raise: Error. "Wait 3ms"! !!DelayTest methodsFor: 'testing-limits' stamp: 'ar 9/21/2009 22:14'!testMultiProcessWaitOnSameDelay	"Ensure that waiting on the same delay from multiple processes raises an error"	| delay p1 p2 wasRun |	delay := Delay forSeconds: 1.	wasRun := false.	p1 := [delay wait] forkAt: Processor activePriority+1.	p2 := [		self should:[delay wait] raise: Error.		wasRun := true.	] forkAt: Processor activePriority+1.	p1 terminate.	p2 terminate.	self assert: wasRun.! !!DelayTest methodsFor: 'testing-limits' stamp: 'ar 9/21/2009 22:12'!testMultiSchedule	"Ensure that scheduling the same delay twice raises an error"	| delay |	delay := Delay forSeconds: 1.	delay schedule.	self should:[delay schedule] raise: Error.! !!DependentsArrayTest methodsFor: 'testing' stamp: 'nice 2/21/2007 23:11'!testAddingTwice		| test dep2 deps |	test := Object new.	dep2 := String with: $z with: $u with: $t.		test addDependent: String new.	test addDependent: dep2.		Smalltalk garbageCollect. "this will make first dependent vanish, replaced by nil"		test addDependent: dep2.		deps := test dependents.	self should: [deps asIdentitySet size = deps size] description: 'No object should be added twice in dependents'! !!DependentsArrayTest methodsFor: 'testing' stamp: 'ar 7/13/2010 10:21'!testCanDiscardEdits	"self debug: #testCanDiscardEdits."	| anObject aView  |	anObject := Object new.	(Smalltalk hasClassNamed: #StringHolderView)		ifTrue: ["Use MVC view if available"			aView := (Smalltalk at: #StringHolderView) new				model: Transcript;				window: (0@0 extent: 60@60);				borderWidth: 1.]		ifFalse: ["Otherwise use a Morphic view"			aView := (Smalltalk at: #PluggableTextMorph) new model: Transcript].	self assert: aView notNil. "require either a StringHolderView or PluggableTextMorph"	aView := PluggableTextMorph new model: Transcript.	aView hasUnacceptedEdits: true.	anObject addDependent: Object new. "this entry should be garbage collected"	anObject addDependent: aView.	Smalltalk garbageCollect. "force garbage collection"	self		should: [anObject dependents size = 1]		description: 'first dependent of anObject should have been collected, second should not'.	self		shouldnt: [anObject canDiscardEdits]		description: 'anObject cannot discard edits because aView is a dependent of anObject and aView has unaccepted edits'.	"Transcript output can cause problems otherwise"	anObject removeDependent: aView.! !!DependentsArrayTest commentStamp: '<historical>' prior: 0!This class is to test the special implementation of DependentsArray.DependentsArray size will not count nil elements (the ones reclaimed by garbage collector).Consequently, any message implemented with a construction like (1 to: self size do: [:i | ]) and sent to the dependents of any object might not behave as supposed to.!!Dictionary methodsFor: 'removing' stamp: 'eem 10/28/2008 11:14'!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: Smalltalk classNames size * 2		during: 			[:bar | | currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			self systemNavigation allSelect:				[:m|				m methodClass ~~ currentClass ifTrue:					[currentClass := m methodClass.					 bar value: (n := n + 1)].				m literalsDo:					[:l|					(l isVariableBinding and: [associations includes: l]) ifTrue:						[referencedAssociations add: l]].				false].			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !!Dictionary methodsFor: 'private' stamp: 'ar 11/20/2007 14:52'!errorKeyNotFound: key	"Signal KeyNotFound error"	^(KeyNotFound key: key) signal! !!DictionaryInspector methodsFor: 'menu' stamp: 'eem 3/13/2009 14:52'!fieldListMenu: aMenu	^ aMenu labels:'inspectinspect keycopy namereferencesobjects pointing to this valuesenders of this keyrefresh viewadd keyrename keyremovebasic inspect'	lines: #(7 10)	selections: #(inspectSelection inspectSelectionKey copyName selectionReferences objectReferencesToSelection sendersOfSelectedKey refreshView addEntry renameEntry removeSelection inspectBasic)! !!DictionaryInspector methodsFor: 'menu' stamp: 'eem 3/13/2009 14:53'!inspectSelectionKey	"Create and schedule an Inspector on the currently selected key."	| aKey |	self selectionIndex = 0 ifTrue:		[^self changed: #flash].	aKey := keyArray at: selectionIndex - self numberOfFixedFields.	aKey inspect.	^aKey! !!DictionaryIntegrityTest methodsFor: 'tests' stamp: 'ul 2/28/2010 19:20'!testDictionaries	#(		Dictionary		IdentityDictionary		SystemDictionary		LiteralDictionary		PluggableDictionary		WeakValueDictionary) do: [ :dictionaryClassName |			Smalltalk at: dictionaryClassName ifPresent: [ :dictionaryClass |				dictionaryClass allInstancesDo: [ :dictionary |					dictionary keysAndValuesDo: [ :key :value |						self assert: (dictionary at: key) == value ].					dictionary array doWithIndex: [ :association :index |		                        association ifNotNil: [	 	                               self assert: (dictionary scanFor: association key) = index ] ] ] ] ]! !!DictionaryIntegrityTest methodsFor: 'tests' stamp: 'ul 2/28/2010 19:17'!testMethodDictionaries	MethodDictionary allInstancesDo: [ :dictionary |		dictionary keysAndValuesDo: [ :key :value |			self assert: (dictionary at: key) == value ].		1 to: dictionary basicSize do: [ :index |			(dictionary basicAt: index)				ifNil: [ self assert: (dictionary array at: index) isNil ]				ifNotNil: [ :key |					self assert: (dictionary scanFor: key) = index ] ] ]! !!DictionaryTest methodsFor: 'tests' stamp: 'zz 12/7/2005 19:59'!testAdd		| dict |	dict := Dictionary new.	dict add: #a -> 1.	dict add: #b -> 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2! !!DictionaryTest methodsFor: 'tests' stamp: 'zz 12/7/2005 19:55'!testAddAll		| dict1 dict2 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!DictionaryTest methodsFor: 'tests' stamp: 'nice 10/6/2009 14:21'!testAsSet	"Non regression test for http://bugs.squeak.org/view.php?id=7258"		| aDictionary aSet assoc0 assoc1 |		"Create a dictionary"	aDictionary := Dictionary new.		"Convert it to a Set"	aSet := aDictionary asSet.	"Add two associations to it"		assoc0 := #first -> 0.	assoc1 := #first -> 1.	aSet add: assoc0 copy; add: assoc1.		"Check if the two associations were added (that should happen if they are different)"	self		assert: (assoc0 copy ~= assoc1) ==> (aSet size > 1)		description:  			'When adding two different elements, the set size should be greater than one'! !!DictionaryTest methodsFor: 'tests' stamp: 'zz 12/7/2005 19:57'!testComma		| dict1 dict2 dict3 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict3 := dict1, dict2.	self assert: (dict3 at: #a) = 3.	self assert: (dict3 at: #b) = 2.	self assert: (dict3 at: #c) = 4.! !!DictionaryTest methodsFor: 'tests' stamp: 'ar 11/12/2009 21:58'!testNilHashCollision	"Ensures that fixCollisionsFrom: does the right thing in the presence of a nil key"	| dict key |	dict := Dictionary new.	key := nil hash. "any key with same hash as nil"	dict at: key hash put: 1.	dict at: nil put: 2.	self assert: (dict includesKey: nil).	dict removeKey: key.	self assert: (dict includesKey: nil).! !!DictionaryTest methodsFor: 'tests' stamp: 'stephaneducasse 9/18/2005 10:45'!testPseudo	"(self run: #testPseudo)"	"true and false are valid keys"		| dict1  |	dict1 := Dictionary new.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!DictionaryTest methodsFor: 'tests' stamp: 'nice 9/14/2009 21:07'!testRemoveAll	"Allows one to remove all elements of a collection" 		| dict1 dict2 s2 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := dict1 copy.	s2 := dict2 size.		dict1 removeAll.		self assert: dict1 size = 0.	self assert: dict2 size = s2 description: 'the copy has not been modified'.! !!DictionaryTest methodsFor: 'association tests' stamp: 'NDCC 3/8/2006 08:14'!testAddAssociation	"self run:#testAddAssociation"	"self debug:#testAddAssociation"		| dict |	dict := Dictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict at: #a) = 1.	self assert: (dict at: #b) = 2.		dict at: #a put: 10.	dict at: #c put: 2.		self assert: (dict at: #a) = 10.	self assert: (dict at: #b) = 2.	self assert: (dict at: #c) = 2		! !!DictionaryTest methodsFor: 'association tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:30'!testAssociationsSelect	| answer d |	d := Dictionary new.	d at: (Array with: #hello with: #world)	  put: #fooBar.	d at: Smalltalk put: #'Smalltalk is the key'.	d at: #Smalltalk put: Smalltalk.	answer := d				associationsSelect: [:assoc | assoc key == #Smalltalk						and: [assoc value == Smalltalk]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size == 1].	self		should: [(answer at: #Smalltalk)				== Smalltalk].	answer := d				associationsSelect: [:assoc | assoc key == #NoSuchKey						and: [assoc value == #NoSuchValue]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size == 0]! !!DictionaryTest methodsFor: 'association tests' stamp: 'NDCC 3/8/2006 09:20'!testIncludesAssociation	"self run:#testIncludesAssociation"		| dict |	dict := Dictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	self assert: (dict includesAssociation: (#a -> 1)).	self assert: (dict includesAssociation: (#b -> 2)).		! !!DictionaryTest methodsFor: 'association tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:25'!testIncludesAssociationNoValue	"self run:#testIncludesAssociationNoValue"	"self debug:#testIncludesAssociationNoValue"		| dict a1 a3 |	a1 := Association key: #Italie.	a3 := Association key: #France value: 'Paris'.		self assert: (a1 key = #Italie).	self assert: (a1 value isNil).		dict := Dictionary new.	dict add: a1.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: #Italie).	self assert: (dict at: #Italie) isNil.	self assert: (dict at: #France) = 'Paris'			! !!DictionaryTest methodsFor: 'basic tests' stamp: 'ar 3/9/2010 22:10'!testAtError	"self run: #testAtError"		| dict |	dict := Dictionary new.	dict at: #a put: 666.	self shouldnt: [ dict at: #a ] raise: KeyNotFound.	self should: [ dict at: #b ] raise: KeyNotFound.		! !!DictionaryTest methodsFor: 'basic tests' stamp: 'NDCC 3/1/2006 14:27'!testAtIfAbsent	"self run: #testAtIfAbsent"		| dict |	dict := Dictionary new.	dict at: #a put: 666.		self assert: (dict at: #a ifAbsent: [nil]) = 666.		self assert: (dict at: #b ifAbsent: [nil]) isNil.	! !!DictionaryTest methodsFor: 'basic tests' stamp: 'ar 3/4/2010 20:31'!testAtIfPresentIfAbsent	"Test at:ifPresent:ifAbsent:"	| dict present absent |	dict := Dictionary new.	present := absent := false.	dict at: #foo ifPresent:[:v| present := true] ifAbsent:[absent := true].	self deny: present.	self assert: absent.	dict at: #foo put: #bar.	present := absent := false.	dict at: #foo ifPresent:[:v| present := true] ifAbsent:[absent := true].	self assert: present.	self deny: absent.	present := absent := false.	dict at: #foo ifPresent:[:v| present := true. nil] ifAbsent:[absent := true].	self assert: present.	self deny: absent.! !!DictionaryTest methodsFor: 'basic tests' stamp: 'NDCC 3/8/2006 09:28'!testAtPut	"self run: #testAtPut"	"self debug: #testAtPut"		| adictionary |	adictionary := Dictionary new.	adictionary at: #a put: 3.	self assert: (adictionary at: #a) = 3.	adictionary at: #a put: 3.	adictionary at: #a put: 4.	self assert: (adictionary at: #a) = 4.	adictionary at: nil put: 666.	self assert: (adictionary at: nil) = 666! !!DictionaryTest methodsFor: 'basic tests' stamp: 'NDCC 3/8/2006 09:53'!testAtPutNil	"self run: #testAtPut"	"self debug: #testAtPut"		| dict |	dict := Dictionary new.	dict at: nil put: 1.	self assert: (dict at: nil) = 1.	dict at: #a put: nil.	self assert: (dict at: #a) = nil.	dict at: nil put: nil.	self assert: (dict at: nil) = nil.			! !!DictionaryTest methodsFor: 'basic tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:24'!testIncludesKey	"self run:#testIncludesKey"	"self debug:#testIncludesKey"		| dict a1 a2 a3 |	a1 := Association key: 'Italie'.	a2 := Association new.	a3 := Association key: 'France' value: 'Paris'.		dict := Dictionary new.	dict add: a1 .	dict add: a2.	dict add: a3.	self assert: (dict includesKey: #France).	self assert: (dict includesKey: 'France').	self assert: (dict includesKey: #Italie).	self assert: (dict includesKey: nil).				self assert: (dict at: 'France' ) = 'Paris'.! !!DictionaryTest methodsFor: 'basic tests' stamp: 'NDCC 3/8/2006 09:41'!testOccurrencesOf	"self run:#testOccurrencesOf"		| dict |	dict := Dictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	dict at: #c put: 1.	dict at: #d put: 3.	dict at: nil put: nil.	dict at: #z put: nil.			self assert: (dict occurrencesOf: 1 ) = 2.	self assert: (dict occurrencesOf: nil ) = 2.				! !!DictionaryTest methodsFor: 'implementation tests' stamp: 'stephaneducasse 9/18/2005 10:48'!testAtNil	"(self run: #testAtNil)"	"nil is a valid key in squeak. In VW nil is not a valid key"	"Ansi 1.9 p, 168    		5.7.2.5 Message: at: key put: newElement    		Synopsis    			Store newElement at key in the receiver. Answer newElement.    		Definition: <abstractDictionary>    		If lookup succeeds for key, then newElement replaces the element previously stored at key.    		Otherwise, the newElement is stored at the new key. In either case, subsequent successful    		lookups for key will answer newElement.  Answer newElement.    		The result is undefined if the key is nil.		This clearly indicates that different smalltalks where doing different assumptions."				| dict1  |	dict1 := Dictionary new.	self shouldnt: [ dict1 at: nil put: #none] raise: Error.	self assert: (dict1 at: nil) = #none. 	! !!DictionaryTest methodsFor: 'implementation tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:29'!testPseudoVariablesAreValidKeys	"(self run: #testPseudoVariablesAreValidKeys)"	"true and false are valid keys"		| dict1  |	dict1 := Dictionary new.	self shouldnt: [dict1 at: true put: #true] raise: Error.	self assert: (dict1 at: true) = #true.			self shouldnt: [dict1 at: false put: #false] raise: Error.	self assert: (dict1 at: false) = #false.! !!DictionaryTest methodsFor: 'testing' stamp: 'ar 6/13/2008 00:14'!testCollect	"Ensure that Dictionary>>collect: answers a dictionary not something else"	| dict expected result |	dict := Dictionary newFromPairs:{		#first.		1.		#second.	2.		#third.		3.		#fourth.	4.		#fifth.		5.	}.	result := dict collect:[:each| each asWords].	expected := Dictionary newFromPairs:{		#first.		'one'.		#second.	'two'.		#third.		'three'.		#fourth.	'four'.		#fifth.		'five'.	}.	self assert: result = expected.! !!DictionaryTest methodsFor: 'testing' stamp: 'ar 6/13/2008 00:13'!testReject	"Ensure that Dictionary>>reject: answers a dictionary not something else"	| dict expected result |	dict := Dictionary newFromPairs:{		#first.		1.		#second.	2.		#third.		3.		#fourth.	4.		#fifth.		5.	}.	result := dict reject:[:each| each odd].	expected := Dictionary newFromPairs:{		#second.	2.		#fourth.	4.	}.	self assert: result = expected.! !!DictionaryTest methodsFor: 'testing' stamp: 'ul 9/30/2009 14:29'!testSelect	"Ensure that Dictionary>>select: answers a dictionary not something else"	| dict expected result |	dict := Dictionary newFromPairs:{		#first.		1.		#second.	2.		#third.		3.		#fourth.	4.		#fifth.		5.	}.	result := dict select:[:each| each odd].	expected := Dictionary newFromPairs:{		#first.		1.		#third.		3.		#fifth.		5.	}.	self assert: result = expected.	result at: #first put: 0.	self assert: (dict at: #first) = 1 "No side effects"! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'NDCC 3/8/2006 08:16'!testDictionaryConcatenation	"self run: #testDictionaryConcatenation"			| dict1 dict2 dict3 |	dict1 := Dictionary new.	dict1 at: #a put: 'Nicolas' ; at: #b put: 'Damien'. 		dict2 := Dictionary new.	dict2 at: #a put: 'Christophe' ; at: #c put: 'Anthony'.	dict3 := dict1, dict2.		self assert: (dict3 at: #a) = 'Christophe'.	self assert: (dict3 at: #b) = 'Damien'.	self assert: (dict3 at: #c) = 'Anthony'.		! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:24'!testKeyAtValue	"self run: #testKeyAtValue"	"self debug: #testKeyAtValue"		| dict |	dict := Dictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	dict at: #c put: 1.		self assert: (dict keyAtValue: 2) = #b.	self assert: (dict keyAtValue: 1) = #c.	"ugly may be a bug, why not having a set #a and #c"		self should: [dict keyAtValue: 0] raise: Error		! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:23'!testKeys	"self run:#testKeys "		| a1 a2  dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := Dictionary new.	dict add: a1.	dict add: a2.	 			self assert: (dict keys size) = 2.		self assert: (dict keys includes: #France)				! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'NDCC 3/8/2006 09:13'!testKeysDo	"self run: #testKeysDo"	"self debug: #testKeysDo"		| dict res |	dict := Dictionary new.		dict at: #a put: 33.	dict at: #b put: 66.		res := OrderedCollection new.	dict keysDo: [ :each | res add: each].		self assert: res asSet = #(a b) asSet.		! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'NDCC 3/8/2006 08:56'!testRemoveKey		"self run:#testRemoveKey "	| dict | 	dict := Dictionary new.	dict at: #a put: 1.	dict at: #b put: 2.	 	self assert: (dict keys size) = 2.	dict removeKey: #a.	self assert: dict keys size  = 1.	self should: [dict at: #a] raise: Error.	self assert: (dict at: #b) = 2		! !!DictionaryTest methodsFor: 'keys and value tests' stamp: 'ndCollectionsTests-Unordered 3/16/2006 10:23'!testValues	"self run:#testValues "		| a1 a2 a3 dict | 	a1 := Association key: 'France' value: 'Paris'.	a2 := Association key: 'Italie' value: 'Rome'.	dict := Dictionary new.	dict add: a1.	dict add: a2.	 	self assert: (dict values size ) = 2.	self assert: (dict values includes: 'Paris').		a3 := Association new.	dict add: a3.	self assert: (dict values size ) = 3.	self assert: (dict values includes: nil).								! !!DirectoryEntry methodsFor: 'comparing' stamp: 'ar 6/22/2010 15:35'!= aDirectoryEntry	"Compare the receiver and aDirectoryEntry"	^aDirectoryEntry class == self class 		and:[self fullName = aDirectoryEntry fullName]! !!DirectoryEntry methodsFor: 'comparing' stamp: 'ar 6/22/2010 15:36'!hash	"Reimplemented because #= is reimplemented"	^self fullName hash! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'bgf 12/26/2008 17:37'!shutDown 	"Minimize Display memory saved in image"	self setExtent: 32@32 depth: depth! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'abc 2/12/2010 15:15'!actualScreenDepth	<primitive: 'primitiveScreenDepth'>	^ Display depth! !!DisplayText methodsFor: '*ST80-Support' stamp: 'tk 10/21/97 12:28'!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para := Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor isTransparent ifTrue: [para rule: Form paint].	^ para! !!DisplayTextView methodsFor: 'private'!centerText	self isCentered		ifTrue: 			[editParagraph				align: editParagraph boundingBox center				with: self getWindow center]! !!DisplayTextView methodsFor: 'private'!defaultRule	^Form over! !!DisplayTextView methodsFor: 'private'!positionText	| box |	box := (self displayBox insetBy: 6@6) origin extent: editParagraph boundingBox extent.	editParagraph wrappingBox: box clippingBox: box.	self centerText! !!DisplayTextView methodsFor: 'accessing'!centered	centered := true.	self centerText! !!DisplayTextView methodsFor: 'accessing'!fillColor	"Answer an instance of class Form that is to be used as the mask when 	displaying the receiver's model (a DisplayText)."	^ mask! !!DisplayTextView methodsFor: 'accessing'!fillColor: aForm 	"Set aForm to be the mask used when displaying the receiver's model."	mask := aForm! !!DisplayTextView methodsFor: 'accessing'!isCentered	^centered! !!DisplayTextView methodsFor: 'accessing'!mask	"Answer an instance of class Form that is to be used as the mask when 	displaying the receiver's model (a DisplayText)."	^ mask! !!DisplayTextView methodsFor: 'accessing'!rule	"Answer a number from 0 to 15 that indicates which of the sixteen 	display rules is to be used when copying the receiver's model (a 	DisplayText) onto the display screen."	rule == nil		ifTrue: [^self defaultRule]		ifFalse: [^rule]! !!DisplayTextView methodsFor: 'accessing'!rule: anInteger 	"Set anInteger to be the rule used when displaying the receiver's model."	rule := anInteger! !!DisplayTextView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	(self controller isKindOf: ParagraphEditor)	 	ifTrue: [controller deselect]! !!DisplayTextView methodsFor: 'controller access'!defaultController 	"Refer to the comment in View|defaultController."	^self defaultControllerClass newParagraph: editParagraph! !!DisplayTextView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^ParagraphEditor! !!DisplayTextView methodsFor: 'window access'!defaultWindow 	"Refer to the comment in View|defaultWindow."	^self inverseDisplayTransform: (editParagraph boundingBox expandBy: 6 @ 6)! !!DisplayTextView methodsFor: 'window access'!window: aWindow 	"Refer to the comment in View|window:."	super window: aWindow.	self centerText! !!DisplayTextView methodsFor: 'displaying'!display 	"Refer to the comment in View|display."	self isUnlocked ifTrue: [self positionText].	super display! !!DisplayTextView methodsFor: 'displaying'!displayView 	"Refer to the comment in View|displayView."	self clearInside.	(self controller isKindOf: ParagraphEditor )		ifTrue: [controller changeParagraph: editParagraph].	editParagraph foregroundColor: self foregroundColor				backgroundColor: self backgroundColor.	self isCentered		ifTrue: 			[editParagraph displayOn: Display				transformation: self displayTransformation				clippingBox: self insetDisplayBox				fixedPoint: editParagraph boundingBox center]		ifFalse: 			[editParagraph displayOn: Display]! !!DisplayTextView methodsFor: 'displaying'!uncacheBits	"Normally only sent to a StandardSystemView, but for casees where a DisplayTextView is used alone, without a superview, in which we make this a no-op, put in so that the Character Recognizer doesn't fail.  8/9/96 sw"! !!DisplayTextView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	centered := false! !!DisplayTextView methodsFor: 'lock access'!lock 	"Refer to the comment in View|lock.  Must do what would be done by displaying..."	self isUnlocked ifTrue: [self positionText].	super lock! !!DisplayTextView methodsFor: 'model access'!model: aDisplayText 	"Refer to the comment in View|model:."	super model: aDisplayText.	editParagraph := model asParagraph.	self centerText! !!DisplayTextView commentStamp: '<historical>' prior: 0!I represent a view of an instance of DisplayText.!!DisplayTextView class methodsFor: 'examples'!example2		"Create a standarad system view with two parts, one editable, the other not."	| topView aDisplayTextView |	topView := StandardSystemView new.	topView label: 'Text Editor'.	aDisplayTextView := self new model: 'test string label' asDisplayText.	aDisplayTextView controller: NoController new.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	topView addSubView: aDisplayTextView.	aDisplayTextView := self new model: 'test string' asDisplayText.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidth: 2.	topView		addSubView: aDisplayTextView		align: aDisplayTextView viewport topLeft		with: topView lastSubView viewport topRight.	topView controller open	"DisplayTextView example2"! !!DisplayTextView class methodsFor: 'examples'!example3		"Create a passive view of some text on the screen."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 2.	view display.	view release	"DisplayTextView example3"! !!DisplayTextView class methodsFor: 'examples'!example4		"Create four passive views of some text on the screen with fat borders."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 5.	view display.	3 timesRepeat: [view translateBy: 100@100. view display].	view release	"DisplayTextView example4"! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 12/8/2002 02:20'!transformedBy: aTransform	^self composedWithGlobal: aTransform! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 12/8/2002 02:20'!invertPoint: aPoint	^self globalPointToLocal: aPoint! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!invertRect: aRectangle	^self globalBoundsToLocal: aRectangle! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!transformRect: aRectangle	^self localBoundsToGlobal: aRectangle! !!DosFileDirectory methodsFor: 'path access' stamp: 'ar 3/7/2006 11:21'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	fileName ifNil:[^fileName].	(self class isDrive: fileName) ifTrue:[^fileName].	^super fullNameFor: fileName! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:03'!testFileDirectoryContainingDirectory	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd containingDirectory pathName = ''.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:05'!testFileDirectoryContainingDirectoryExistence	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: (fd containingDirectory fileOrDirectoryExists: 'C:').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryContainingEntry	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: (fd containingDirectory entryAt: fd localName) notNil.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryDirectoryEntry	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd directoryEntry notNil.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:28'!testFileDirectoryEntryFor	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory root directoryEntryFor: 'C:'.	self assert: (fd name sameAs: 'C:').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:21'!testFileDirectoryExists	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory root directoryExists: 'C:').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryLocalName	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd localName = 'C:'.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:19'!testFileDirectoryNamed	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory root directoryNamed: 'C:'.	self assert: fd pathName = 'C:'.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'DF 5/26/2006 11:57'!testFileDirectoryNonExistence	| inexistentFileName |		"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].		inexistentFileName := DosFileDirectory default nextNameFor: 'DosFileDirectoryTest' extension: 'temp'.		"This test can fail if another process creates a file with the same name as inexistentFileName	(the probability of that is very very remote)"	self deny: (DosFileDirectory default fileOrDirectoryExists: inexistentFileName)! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:13'!testFileDirectoryRootExistence	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory root fileOrDirectoryExists: 'C:').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:28'!testFullNameFor	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory default fullNameFor: 'C:') = 'C:'.	self assert: (FileDirectory default fullNameFor: 'C:\test') = 'C:\test'.	self assert: (FileDirectory default fullNameFor: '\\share') = '\\share'.	self assert: (FileDirectory default fullNameFor: '\\share\test') = '\\share\test'.	self assert: (FileDirectory default fullNameFor: '\test') = (FileDirectory default pathParts first, '\test').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:17'!testIsDriveForDrive	self assert: (DosFileDirectory isDrive: 'C:').	self deny: (DosFileDirectory isDrive: 'C:\').	self deny: (DosFileDirectory isDrive: 'C:\foo').	self deny: (DosFileDirectory isDrive: 'C:foo').! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:17'!testIsDriveForShare	self assert: (DosFileDirectory isDrive: '\\server').	self deny: (DosFileDirectory isDrive: '\\server\').	self deny: (DosFileDirectory isDrive: '\\server\foo').! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'eem 10/21/2008 13:18'!cr	"do nothing"! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'eem 10/30/2008 10:54'!printContentsOn: stream! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'eem 10/21/2008 16:28'!space	"do nothing"! !!DummyStream methodsFor: 'as yet unclassified' stamp: 'eem 10/21/2008 15:10'!tab	"do nothing"! !!DummyStream class methodsFor: 'as yet unclassified' stamp: 'eem 10/21/2008 13:18'!new	"Return a new DummyStream instance."	^ self basicNew! !!DummyToolWorkingWithFileList commentStamp: '<historical>' prior: 0!I'm a dummy class for testing that the registration of the tool to the FileList of actually happens.In the future the tests should cover that the class register when loaded in memory and unregister when unloaded.!!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/6/2002 21:29'!fileReaderServicesForFile: fullName suffix: suffix	^ (suffix = 'kkk')		ifTrue: [ self services]		ifFalse: [#()] ! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/6/2002 21:46'!initialize	"self initialize"	FileList registerFileReader: self! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/14/2001 22:12'!loadAFileForTheDummyTool: aFileListOrAPath		"attention. if the file list selects a file the argument will be a fullpath of the selected file else it will pass the filelist itself"! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sw 2/17/2002 02:36'!serviceLoadAFilForDummyTool	"Answer a service for opening the Dummy tool"	^ SimpleServiceEntry 		provider: self 		label: 'menu label'		selector: #loadAFileForTheDummyTool:		description: 'Menu label for dummy tool'		buttonLabel: 'test'! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'sd 2/1/2002 22:32'!services 	^ Array with: self serviceLoadAFilForDummyTool! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/15/2001 22:21'!unload	FileList unregisterFileReader: self ! !!DummyToolWorkingWithFileList class methodsFor: 'class initialization' stamp: 'SD 11/10/2001 21:49'!unregister	FileList unregisterFileReader: self.	! !!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!classToBeTested	^ Duration! !!DurationTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 14:30'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!DurationTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:36'!setUp	aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5 ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAbs	self assert: aDuration abs = aDuration. 	self assert: (Duration nanoSeconds: -5)  abs =  (Duration nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDelay	self deny: aDuration asDelay =   aDuration.	"want to come up with a more meaningful test"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsDuration	self assert: aDuration asDuration =  aDuration	! !!DurationTest methodsFor: 'testing' stamp: 'cmm 4/8/2010 12:19'!testAsMilliSeconds	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: (Duration seconds: 1) asMilliSeconds = 1000.	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: (Duration nanoSeconds: 1000000) asMilliSeconds = 1.	self assert: aDuration asMilliSeconds = 93784000.	self assert: (Duration milliSeconds: 3775) asSeconds = 3.	self assert: (Duration milliSeconds: 3775) nanoSeconds = 775000000! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsNanoSeconds	self assert: (Duration nanoSeconds: 1)  asNanoSeconds = 1.	self assert: (Duration seconds: 1)  asNanoSeconds = 1000000000.		self assert: aDuration   asNanoSeconds = 93784000000005.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testAsSeconds	self assert: (Duration nanoSeconds: 1000000000)  asSeconds = 1.	self assert: (Duration seconds: 1)  asSeconds = 1.		self assert: aDuration   asSeconds = 93784.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDays	self assert: aDuration   days = 1.	self assert: (Duration   days: 1) days= 1.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testDivide	self assert: aDuration / aDuration = 1. 	self assert: aDuration / 2 = (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2). 	self assert: aDuration / (1/2) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10).! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testFromString	self assert: aDuration = (Duration fromString: '1:02:03:04.000000005').! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHash	self assert: aDuration hash =    	(Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) hash.	self assert: aDuration hash =     93789	"must be a more meaningful test?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testHours	self assert: aDuration   hours = 2.	self assert: (Duration   hours: 2) hours = 2.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testIntegerDivision	self assert: aDuration // aDuration = 1. 	self assert: aDuration // 2 =  (aDuration / 2). 	"is there ever a case where this is not true, since precision is always to the nano second?"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testLessThan	self assert: aDuration  < (aDuration + 1 day ).	self deny: aDuration < aDuration.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMilliSeconds	self assert: (Duration milliSeconds: 5) nanoSeconds = 5000000.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinus	self assert: aDuration - aDuration = (Duration seconds: 0).	self assert: aDuration - (Duration days: -1 hours: -2 minutes: -3 seconds: -4 nanoSeconds: -5) = 						    (Duration days: 2  hours: 4  minutes: 6  seconds: 8  nanoSeconds: 10). 	self assert: aDuration - (Duration days: 0  hours: 1  minutes: 2  seconds: 3  nanoSeconds: 4) = 						    (Duration days: 1  hours: 1  minutes: 1  seconds: 1  nanoSeconds: 1). 	self assert: aDuration - (Duration days: 0  hours: 3   minutes: 0  seconds: 5  nanoSeconds: 0) = 						    (Duration days: 0  hours: 23  minutes: 2  seconds: 59  nanoSeconds: 5). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMinutes	self assert: aDuration   minutes = 3.	self assert: (Duration minutes: 3) minutes = 3.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testMultiply	self assert: aDuration * 2 = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNanoSeconds	self assert: aDuration nanoSeconds = 5.	self assert: (Duration nanoSeconds: 5) nanoSeconds = 5.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegated	self assert: aDuration + aDuration negated = (Duration seconds: 0). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNegative	self deny: aDuration negative.	self assert: aDuration negated negative! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testNew	"self assert: Duration new =  (Duration seconds: 0)."    "new is not valid as a creation method: MessageNotUnderstood: UndefinedObject>>quo:, where Duration seconds is nil"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPlus	self assert: (aDuration + 0 hours) = aDuration.	self assert: (aDuration + aDuration) = (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPositive	self assert: (Duration nanoSeconds: 0) positive.	self assert: aDuration positive.	self deny: aDuration negated positive! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPrintOn    	|cs rw |	cs := ReadStream on: '1:02:03:04.000000005'.	rw := ReadWriteStream on: ''.     aDuration printOn: rw.     self assert: rw contents = cs contents.! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testReadFrom	self assert: aDuration =  (Duration readFrom: (ReadStream on: '1:02:03:04.000000005'))! !!DurationTest methodsFor: 'testing' stamp: 'KLC 5/12/2008 13:41'!testSeconds	self assert: aDuration seconds =   4.	self assert: (Duration  nanoSeconds: 2) seconds = 0.	self assert: (Duration nanoSeconds: 999999999) seconds = 0.	self assert: (Duration nanoSeconds: 1000000001) seconds = 1.	self assert: (Duration  seconds: 2) seconds = 2.		self assert: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = 4.	self deny: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (1*24*60*60+(2*60*60)+(3*60)+4).	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testSecondsNanoSeconds 	self assert: (Duration   seconds: 0 nanoSeconds: 5)  = (Duration  nanoSeconds: 5).		"not sure I should include in sunit since its Private "	self assert: (aDuration seconds: 0 nanoSeconds: 1) = (Duration nanoSeconds: 1). ! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testStoreOn     self assert: (aDuration storeOn: (WriteStream on:'')) asString ='1:02:03:04.000000005'.      "storeOn: returns a duration (self) not a stream"! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testTicks	self assert: aDuration ticks =  #(1 7384 5)! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testWeeks	self assert: (Duration  weeks: 1) days= 7.	! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testZero	self assert: (Duration zero) = (Duration seconds: 0).	! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:32'!testComparing	| d1 d2 d3 |	d1 := Duration seconds: 10 nanoSeconds: 1.	d2 := Duration seconds: 10 nanoSeconds: 1.	d3 := Duration seconds: 10 nanoSeconds: 2.		self		assert: (d1 = d1);		assert: (d1 = d2);		deny: (d1 = d3);		assert: (d1 < d3)! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:36'!testModulo	| d1 d2 d3 |	d1 := 11.5 seconds.	d2 := d1 \\ 3.	self assert: d2 = (Duration nanoSeconds: 1).	d3 := d1 \\ (3 seconds).	self assert: d3 =  (Duration seconds: 2 nanoSeconds: 500000000).	self assert: aDuration \\ aDuration = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0). 	self assert: aDuration \\ 2 = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1).	! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/16/2004 14:17'!testMonthDurations	| jan feb dec |	jan := Duration month: #January.	feb := Duration month: #February.	dec := Duration month: #December.		self 		assert: jan = (Year current months first duration);		assert: feb = (Year current months second duration);		assert: dec = (Year current months last duration)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:28'!testNumberConvenienceMethods	self		assert: 1 week = (Duration days: 7);		assert: -1 week = (Duration days: -7);		assert: 1 day = (Duration days: 1);		assert: -1 day = (Duration days: -1);		assert: 1 hours = (Duration hours: 1);		assert: -1 hour = (Duration hours: -1);		assert: 1 minute = (Duration seconds: 60);		assert: -1 minute = (Duration seconds: -60);		assert: 1 second = (Duration seconds: 1);		assert: -1 second = (Duration seconds: -1);		assert: 1 milliSecond = (Duration milliSeconds: 1);		assert: -1 milliSecond = (Duration milliSeconds: -1);		assert: 1 nanoSecond = (Duration nanoSeconds: 1);		assert: -1 nanoSecond = (Duration nanoSeconds: -1)		! !!DurationTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 14:57'!testQuotient	| d1 d2 q |	d1 := 11.5 seconds.	d2 := d1 // 3.	self assert: d2 = (Duration seconds: 3 nanoSeconds: 833333333).	q := d1 // (3 seconds).	self assert: q = 3.! !!DurationTest methodsFor: 'Tests' stamp: 'ar 9/2/2009 19:57'!testReadFromTrailingDigits	"http://bugs.squeak.org/view.php?id=6764"	self should:  (Duration readFrom: '0:00:00:00.001 ' readStream) nanoSeconds = 1000000.! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:38'!testRoundTo	self assert: ((5 minutes + 37 seconds) roundTo: (2 minutes)) = (6 minutes).		self assert:  (aDuration roundTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration roundTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration roundTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:37'!testTruncateTo	self assert: ((5 minutes + 37 seconds) truncateTo: (2 minutes)) = (4 minutes).	self assert:  (aDuration truncateTo: (Duration days: 1)) =	               (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).	self assert:  (aDuration truncateTo: (Duration hours: 1)) =	               (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).		self assert:  (aDuration truncateTo: (Duration minutes: 1)) =	               (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0).! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!Encoder methodsFor: 'encoding' stamp: 'eem 8/15/2010 08:29'!lookupVariable: name ifAbsent: aBlock	"Answer the binding of name in the scope table or aBlock's vaue if none.	 Do not bind and do not lookup in pools.  Used for correction, explanation etc"	^scopeTable at: name ifAbsent: aBlock! !!Encoder methodsFor: 'results' stamp: 'eem 8/13/2010 16:51'!undeclaredTemps 	^(scopeTable select: [:var | var isVariableNode and: [var isUndeclared]]) values! !!Encoder methodsFor: 'temps' stamp: 'eem 8/14/2010 19:35'!newUndeclaredTemp: name	^UndeclaredVariableNode new name: name! !!Encoder methodsFor: 'private' stamp: 'eem 8/13/2010 16:06'!bindUndeclaredTemp: name	^scopeTable at: name put: (self newUndeclaredTemp: name)! !!Encoder methodsFor: 'private' stamp: 'Lukas Renggli 11/2/2009 00:29'!name: name key: key class: leafNodeClass type: type set: dict 	^dict at: key		ifAbsentPut: 			[leafNodeClass new 				name: name				key: key				index: nil				type: type]! !!EqualityTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!resultFor: runs 	"Test that equality is the same over runs and answer the result"	1		to: runs		do: [:i | self prototype = self prototype				ifFalse: [^ false]]. 	^ true! !!EqualityTester commentStamp: 'mjr 8/20/2003 13:04' prior: 0!I provide a simple way to test the equality properties of any object.!!Error methodsFor: 'testing' stamp: 'eem 5/16/2008 14:28'!isError	^true! !!EventManagerTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!addArg1: arg1addArg2: arg2	eventListener		add: arg1;		add: arg2! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse	^false! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse: anArg	^false! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue	^true! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue: anArg	^true! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:20'!heardEvent	succeeded := true! !!EventManagerTest methodsFor: 'running' stamp: 'JWS 9/7/2000 17:19'!setUp	super setUp.	eventSource := EventManager new.	eventListener := Bag new.	succeeded := false! !!EventManagerTest methodsFor: 'running' stamp: 'jws 11/28/2000 16:25'!tearDown	eventSource releaseActionMap.	eventSource := nil.	eventListener := nil.	super tearDown.! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:37'!testBlockReceiverNoArgs	eventSource when: #anEvent evaluate:[self heardEvent].	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:37'!testBlockReceiverOneArg	eventSource when: #anEvent: evaluate:[:arg1| eventListener add: arg1].	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:38'!testBlockReceiverTwoArgs	eventSource when: #anEvent:info: evaluate:[:arg1 :arg2| self addArg1: arg1 addArg2: arg2].	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testNoArgumentEvent	eventSource when: #anEvent send: #heardEvent to: self.	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testOneArgumentEvent	eventSource when: #anEvent: send: #add: to: eventListener.	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testTwoArgumentEvent	eventSource when: #anEvent:info: send: #addArg1:addArg2: to: self.	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!EventManagerTest methodsFor: 'running-copying' stamp: 'SqR 11/12/2000 19:38'!testCopy	"Ensure that the actionMap is zapped when	you make a copy of anEventManager"	eventSource when: #blah send: #yourself to: eventListener.	self assert: eventSource actionMap keys isEmpty not.	self assert: eventSource copy actionMap keys isEmpty! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliers	eventSource		when: #needsValue		send: #getFalse		to: self.	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliersEventHasArguments	eventSource		when: #needsValue:		send: #getFalse:		to: self.	eventSource		when: #needsValue:		send: #getTrue:		to: self.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplier	succeeded := eventSource 		triggerEvent: #needsValue		ifNotHandled: [true].	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplierHasArguments	succeeded := eventSource 		triggerEvent: #needsValue:		with: 'nelja'		ifNotHandled: [true].	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'jws 11/28/2000 15:52'!testSingleValueSupplier	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:20'!testNoArgumentEventDependentSuppliedArgument	eventSource when: #anEvent send: #add: to: eventListener with: 'boundValue'.	eventSource triggerEvent: #anEvent.	self should: [eventListener includes: 'boundValue']! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:21'!testNoArgumentEventDependentSuppliedArguments	eventSource 		when: #anEvent 		send: #addArg1:addArg2: 		to: self 		withArguments: #('hello' 'world').	eventSource triggerEvent: #anEvent.	self should: [(eventListener includes: 'hello') and: [eventListener includes: 'world']]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self shouldnt: [eventSource hasActionForEvent: #anEvent]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsTwiceForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:10'!testRemoveActionsWithReceiver	| action |	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsWithReceiver: self.	action := eventSource actionForEvent: #anEvent.	self assert: (action respondsTo: #receiver).	self assert: ((action receiver == self) not)! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithManyListeners	| value newListener |	newListener := 'busybody'.	eventSource		when: #needsValue		send: #yourself		to: eventListener.	eventSource		when: #needsValue		send: #yourself		to: newListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == newListener]! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithNoListeners	| value |	value := eventSource triggerEvent: #needsValue.	self should: [value == nil]! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithOneListener	| value |	eventSource		when: #needsValue		send: #yourself		to: eventListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == eventListener]! !!EventSensor methodsFor: 'private' stamp: 'bgf 9/27/2007 14:56'!flushNonKbdEvents	eventQueue ifNil: [^ self].	"We do NOT use 'isKeyCharEvent: ' here,	 as that would have us flush key press-release events,	 which is not appropriate when flushing non-keyboard events."	eventQueue flushAllSuchThat:		[:buf |  (buf at: 1) ~= EventTypeKeyboard]! !!EventSensor methodsFor: 'private' stamp: 'bgf 9/27/2007 14:55'!isKeyCharEvent: buf	"For peeking: does this event bear a keyboard character code?"	^ (buf at: 1) = EventTypeKeyboard and: [(buf at: 4) = EventKeyChar]! !!EventSensor methodsFor: 'private' stamp: 'bgf 9/27/2007 14:55'!primKbdNext	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| evtBuf |	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse:[^ keyboardBuffer next].	eventQueue ifNotNil:		[evtBuf := eventQueue nextOrNilSuchThat: [:buf | self isKeyCharEvent: buf].		self flushNonKbdEvents].	^ evtBuf ifNotNil: [evtBuf at: 3]! !!EventSensor methodsFor: 'private' stamp: 'bgf 9/27/2007 14:55'!primKbdPeek	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| char |	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse: [^ keyboardBuffer peek].	char := nil.	eventQueue ifNotNil:		[eventQueue nextOrNilSuchThat:  "NOTE: must not return out of this block, so loop to end"			[:buf | (self isKeyCharEvent: buf) ifTrue: [char ifNil: [char := buf at: 3]].			false  "NOTE: block value must be false so Queue won't advance"]].	^ char! !!EventSensorConstants class methodsFor: 'pool initialization' stamp: 'bobw 7/29/2010 14:22'!initialize	"EventSensorConstants initialize"	RedButtonBit := 4.	BlueButtonBit := 2.	YellowButtonBit := 1.	ShiftKeyBit := 1.	CtrlKeyBit := 2.	OptionKeyBit := 4.	CommandKeyBit := 8.	"Types of events"	EventTypeNone := 0.	EventTypeMouse := 1.	EventTypeKeyboard := 2.	EventTypeDragDropFiles := 3.	EventTypeMenu := 4.	EventTypeWindow := 5.	EventTypePlugin := 6.  "Currently used for sending events up from an ActiveX Control."	"Press codes for keyboard events"	EventKeyChar := 0.	EventKeyDown := 1.	EventKeyUp := 2.	"Window event constants"	WindowEventMetricChange := 1.	WindowEventClose := 2.	WindowEventIconize := 3.	WindowEventActivate := 4.	WindowEventPaint := 5.! !!Exception methodsFor: 'signaling' stamp: 'das 4/14/2008 09:14'!signal: signalerText tag: signalerTag	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	self tag: signalerTag.	^ self signal! !!Exception methodsFor: 'testing' stamp: 'eem 5/16/2008 14:28'!isError	^false! !!Exception methodsFor: 'testing' stamp: 'eem 5/16/2008 14:28'!isHalt	^false! !!Exception methodsFor: 'testing' stamp: 'eem 5/16/2008 14:28'!isNotification	^false! !!ExceptionTester methodsFor: 'accessing' stamp: 'dtl 6/1/2004 21:53'!basicANSISignaledExceptionTestSelectors	^#( simpleIsNestedTest simpleOuterTest doubleOuterTest doubleOuterPassTest doublePassOuterTest simplePassTest simpleResignalAsTest simpleResumeTest simpleRetryTest simpleRetryUsingTest simpleReturnTest)! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:54'!basicTestSelectors	^ #(#simpleEnsureTest #simpleEnsureTestWithNotification #simpleEnsureTestWithUparrow #simpleEnsureTestWithError #signalFromHandlerActionTest #resumableFallOffTheEndHandler #nonResumableFallOffTheEndHandler #doubleResumeTest #simpleTimeoutWithZeroDurationTest #simpleTimeoutTest simpleNoTimeoutTest)! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingElseString	^'Do something else.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptionalString	^'Do something exceptional.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:13'!doSomethingString	^'Do something.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThingString	^'Do yet another thing.'! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:15'!iterationsBeforeTimeout	^ iterationsBeforeTimeout! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:16'!iterationsBeforeTimeout: anInteger	iterationsBeforeTimeout := anInteger! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/7/1999 15:03'!log	log == nil		ifTrue: [log := OrderedCollection new].	^log! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:30'!suiteLog	suiteLog == nil		ifTrue: [suiteLog := OrderedCollection new].	^suiteLog! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!testString	^'This is only a test.'! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:17'!clearLog	log := nil! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:16'!contents	^( self log		inject: (WriteStream on: (String new: 80))		into: 			[:result :item |			result 				cr; 				nextPutAll: item;				yourself] ) contents! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:03'!log: aString	self log add: aString! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/12/1999 23:07'!logTest: aSelector	self suiteLog add: aSelector! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:38'!logTestResult: aString	| index |	index := self suiteLog size.	self suiteLog 		at: index		put: ((self suiteLog at: index), ' ', aString)! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:13'!doSomething	self log: self doSomethingString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingElse	self log: self doSomethingElseString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptional	self log: self doSomethingExceptionalString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThing	self log: self doYetAnotherThingString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithError	MyTestError signal: self testString! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithNotification	MyTestNotification signal: self testString! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:51'!doubleOuterPassTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer.			self doSomethingElse]]			on: MyTestNotification			do: [:ex | ex pass.				self doSomethingExceptional]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:49'!doubleOuterTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer.			self doSomethingExceptional]]			on: MyTestNotification			do: [:ex | ex outer.				self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:52'!doublePassOuterTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex pass.			self doSomethingExceptional]]			on: MyTestNotification			do: [:ex | ex outer.				self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:27'!simpleIsNestedTest	"uses resignalAs:"	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			ex isNested "expecting to detect handler in #runTest:"				ifTrue:					[self doYetAnotherThing.					ex resignalAs: MyTestNotification new]]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tpr 5/27/2004 21:50'!simpleOuterTest	"uses #resume"	[[self doSomething.	MyTestNotification signal.	"self doSomethingElse"	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer. self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:37'!simplePassTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			self doYetAnotherThing.			ex pass "expecting handler in #runTest:"]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 02:12'!simpleResignalAsTest	"ExceptionTester new simpleResignalAsTest"	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do:			[:ex | ex resignalAs: MyTestError new]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'nice 12/27/2009 21:06'!simpleResumeTest	"see if we can resume twice"		[ | it |	self doSomething.	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	]		on: MyResumableTestError		do:			[:ex |			self doYetAnotherThing.			ex resume: 3]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:02'!simpleRetryTest	| theMeaningOfLife |	theMeaningOfLife := nil.	[self doSomething.	theMeaningOfLife == nil		ifTrue: [MyTestError signal]		ifFalse: [self doSomethingElse]]			on: MyTestError			do:				[:ex |				theMeaningOfLife := 42.				self doYetAnotherThing.				ex retry]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:03'!simpleRetryUsingTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex | ex retryUsing: [self doYetAnotherThing]]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:59'!simpleReturnTest	| it |	it :=		[self doSomething.		MyTestError signal.		self doSomethingElse]			on: MyTestError			do: [:ex | ex return: 3].	it = 3 ifTrue: [self doYetAnotherThing]! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'dtl 6/1/2004 21:56'!doubleOuterPassTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'dtl 6/1/2004 21:56'!doublePassOuterTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:09'!simpleIsNestedTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simpleOuterTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simplePassTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:11'!simpleResignalAsTestResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'RAA 12/8/2000 12:59'!simpleResumeTestResults	"see if we can resume twice"	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingString;			add: self doSomethingElseString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryUsingTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			yourself! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 02:22'!simpleReturnTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 11/14/1999 17:26'!doubleResumeTest       [self doSomething.       MyResumableTestError signal.       self doSomethingElse.       MyResumableTestError signal.       self doYetAnotherThing]               on: MyResumableTestError               do: [:ex | ex resume].! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 13:43'!nonResumableFallOffTheEndHandler		[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:07'!resumableFallOffTheEndHandler	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 8/19/1999 01:39'!signalFromHandlerActionTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[self doYetAnotherThing.			MyTestError signal]! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 09:44'!simpleEnsureTest	[self doSomething.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 12:50'!simpleEnsureTestWithError	[self doSomething.	MyTestError signal.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 10:15'!simpleEnsureTestWithNotification	[self doSomething.	self methodWithNotification.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:04'!simpleEnsureTestWithUparrow	[self doSomething.	true ifTrue: [^nil].	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleNoTimeoutTest	[ self doSomething ]		valueWithin: 1 day onTimeout:			[ self doSomethingElse ].	! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutTest	| n |	[1 to: 1000000 do: [ :i | n := i. self doSomething ] ]		valueWithin: 50 milliSeconds onTimeout:			[ self iterationsBeforeTimeout: n.			self doSomethingElse ]! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutWithZeroDurationTest	[ self doSomething ]		valueWithin: 0 seconds onTimeout:			[ self doSomethingElse ].	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 14:28'!warningTest	self log: 'About to signal warning.'.	Warning signal: 'Ouch'.	self log: 'Warning signal handled and resumed.'! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 11/14/1999 17:29'!doubleResumeTestResults       ^OrderedCollection new               add: self doSomethingString;               add: self doSomethingElseString;               add: self doYetAnotherThingString;               yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:21'!nonResumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 02:39'!resumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 01:51'!signalFromHandlerActionTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:47'!simpleEnsureTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/9/1999 17:44'!simpleEnsureTestWithErrorResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 10:13'!simpleEnsureTestWithNotificationResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 18:55'!simpleEnsureTestWithUparrowResults	^OrderedCollection new		add: self doSomethingString;"		add: self doSomethingElseString;"		add: self doYetAnotherThingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:54'!simpleNoTimeoutTestResults	^OrderedCollection new		add: self doSomethingString;		yourself! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 17:44'!simpleTimeoutTestResults	| things |	things := OrderedCollection new: self iterationsBeforeTimeout.	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].	things add: self doSomethingElseString.	^ things! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:52'!simpleTimeoutWithZeroDurationTestResults	^OrderedCollection new		add: self doSomethingElseString;		yourself! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/13/1999 01:25'!runAllTests	"ExceptionTester new runAllTests"	self		runBasicTests;		runBasicANSISignaledExceptionTests! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/12/1999 23:54'!runBasicANSISignaledExceptionTests	self basicANSISignaledExceptionTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/9/1999 16:06'!runBasicTests	self basicTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!ExceptionTester methodsFor: 'testing' stamp: 'brp 10/21/2004 17:40'!runTest: aSelector	| actualResult expectedResult |	[ self 		logTest: aSelector;		clearLog;		perform: aSelector ]			on: MyTestError do: 				[ :ex | self log: 'Unhandled Exception'.					ex return: nil ].	actualResult	:= self log.	expectedResult := self perform: (aSelector, #Results) asSymbol.	actualResult = expectedResult		ifTrue: [self logTestResult: 'succeeded']		ifFalse: [self logTestResult: 'failed' ].! !!ExceptionTests methodsFor: 'private' stamp: 'md 3/25/2003 23:40'!assertSuccess: anExceptionTester	self should: [ ( anExceptionTester suiteLog first) endsWith:  'succeeded'].! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'dtl 6/1/2004 21:54'!testDoubleOuterPass	self assertSuccess: (ExceptionTester new runTest: #doubleOuterPassTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'dtl 6/1/2004 21:54'!testDoublePassOuter	self assertSuccess: (ExceptionTester new runTest: #doublePassOuterTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:43'!testDoubleResume	self assertSuccess: (ExceptionTester new runTest: #doubleResumeTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testNonResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #nonResumableFallOffTheEndHandler ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #resumableFallOffTheEndHandler ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testSignalFromHandlerActionTest	self assertSuccess: (ExceptionTester new runTest: #signalFromHandlerActionTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleEnsure	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithError	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithError ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:46'!testSimpleEnsureTestWithNotification	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithNotification ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithUparrow	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:46'!testSimpleIsNested	self assertSuccess: (ExceptionTester new runTest: #simpleIsNestedTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:41'!testSimpleOuter	self assertSuccess: (ExceptionTester new runTest: #simpleOuterTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:42'!testSimplePass	self assertSuccess: (ExceptionTester new runTest: #simplePassTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:43'!testSimpleResignalAs	self assertSuccess: (ExceptionTester new runTest: #simpleResignalAsTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleResume	self assertSuccess: (ExceptionTester new runTest: #simpleResumeTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleRetry	self assertSuccess: (ExceptionTester new runTest: #simpleRetryTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:47'!testSimpleRetryUsing	self assertSuccess: (ExceptionTester new runTest: #simpleRetryUsingTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleReturn	self assertSuccess: (ExceptionTester new runTest: #simpleReturnTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:42'!testNoTimeout	self assertSuccess: (ExceptionTester new runTest: #simpleNoTimeoutTest ) ! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:41'!testTimeoutWithZeroDuration	self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutWithZeroDurationTest ) ! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 21:59'!testNonResumableOuter	self should: [		[Error signal. 4] 			on: Error 			do: [:ex | ex outer. ex return: 5]		] raise: Error! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testNonResumablePass	self should: [		[Error signal. 4] 			on: Error 			do: [:ex | ex pass. ex return: 5]		] raise: Error! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testResumableOuter	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex outer. ex return: 5].	self assert: result == 5! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testResumablePass	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex pass. ex return: 5].	self assert: result == 4! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 1/16/2010 20:55'!testAddressRange	"Test source pointer to file position address translation across a wide address range"		| sf i p a |	sf := ExpandedSourceFileArray new.	16r1000000 to: 16r10000000 by: 4093 do: [:e |		i := sf fileIndexFromSourcePointer: e.		p := sf filePositionFromSourcePointer: e.		a := sf sourcePointerFromFileIndex: i andPosition: p.		self assert: a = e]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 1/16/2010 20:56'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r6000000 and: 16r6FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r8000000 and: 16r8FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rA000000 and: 16rAFFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rC000000 and: 16rCFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rE000000 and: 16rEFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r10000000 and: 16r10FFFFFF)]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 1/16/2010 20:56'!testCompatibilityWithStandardSourceFileArray	"Test compatibility with StandardSourceFileArray across the address range of	StandardSourceFileArray, including the unused address space below 16r1000000"		| ssf esf i1 i2 p1 p2 a1 a2 |	ssf := StandardSourceFileArray new.	esf := ExpandedSourceFileArray new.	0 to: 16rFFFFFF by: 811 do: [:e |		i1 := ssf fileIndexFromSourcePointer: e.		i2 := esf fileIndexFromSourcePointer: e.		self assert: i1 = i2.		self assert: i1 = 0. "This is unused address space"		p1 := ssf filePositionFromSourcePointer: e.		p2 := esf filePositionFromSourcePointer: e.		self assert: p1 = p2].	16r4FFFFFF to: 16r4FFFFFF by: 811 do: [:e |		i1 := ssf fileIndexFromSourcePointer: e.		i2 := esf fileIndexFromSourcePointer: e.		self assert: i1 = i2.		p1 := ssf filePositionFromSourcePointer: e.		p2 := esf filePositionFromSourcePointer: e.		self assert: p1 = p2.		a1 := ssf sourcePointerFromFileIndex: i1 andPosition: p1.		a2 := esf sourcePointerFromFileIndex: i2 andPosition: p2.		self assert: a1 = a2.		self assert: a1= e]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/26/2009 14:56'!testFileIndexFromSourcePointer	"Test derivation of file index for sources or changes file from source pointers"	| sf |	sf := ExpandedSourceFileArray new.	"sources file mapping"	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5FFFFFF).	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	"changes file mapping"	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6FFFFFF).	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000000).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000013).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0FFFFFF)! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/26/2009 14:56'!testFilePositionFromSourcePointer	"Test derivation of file position for sources or changes file from source pointers"	| sf |	sf := ExpandedSourceFileArray new.	"sources file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r1000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r1000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r1FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r3000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r3000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r3FFFFFF).	"changes file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r2000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r2000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r2FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r4000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r4000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r4FFFFFF).	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf filePositionFromSourcePointer: 16r0000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r0000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r0FFFFFF)! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/22/2009 23:05'!testSourcePointerFromFileIndexAndPosition	"Test valid input ranges"	| sf |	sf := ExpandedSourceFileArray new.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 2 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 3] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: -1] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r2000000] raise: Error.	self should: [sf sourcePointerFromFileIndex: 3 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 4 andPosition: 0] raise: Error.		self assert: 16r1000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 0).	self assert: 16r1000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r13).	self assert: 16r1FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16rFFFFFF).	self assert: 16r2000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 0).	self assert: 16r2000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r13).	self assert: 16r2FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16rFFFFFF).	self assert: 16r3000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000000).	self assert: 16r3000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000013).	self assert: 16r3FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF).	self assert: 16r4000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000000).	self assert: 16r4000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000013).	self assert: 16r4FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1FFFFFF)! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 1/16/2010 20:57'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r5000000 and: 16r5FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r7000000 and: 16r7FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r9000000 and: 16r9FFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rB000000 and: 16rBFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rD000000 and: 16rDFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rF000000 and: 16rFFFFFFF)]! !!ExpandedSourceFileArrayTest commentStamp: 'dtl 12/22/2009 23:10' prior: 0!This test documents the source pointer address conversion methods for ExpandedSourceFileArray.The available address space for source pointers in a traditional CompiledMethod is 16r1000000 through 16r4FFFFFF. StandardSourceFileArray maps positions in the sources file to address range 16r1000000 through 16r1FFFFFF and 16r3000000 through 16r3FFFFFF, and positions in the changes file to address range 16r2000000 through 16r2FFFFFF and 16r4000000 through 16r4FFFFFF. This permits a maximum file size of 16r2000000 (32MB) for both the sources file and the changes file. ExpandedSourceFileArray extends the source pointer address space using bit 25 of the source pointer to identify the external sources and changes files, with the remaining high order bits treated as address extension. This limits the number of external file references to two (the traditional sources and changes files). If additional external file references are needed in the future, some higher order bits in the source pointer address space should be allocated for that purpose.The use of bit 25 of the source pointer for file references permits backward compatibility with StandardSourceFileArray, with essentially unlimited address space expansion for the sources and changes files.!!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:25'!testFractionPartWithoutIntegerPart	"The integer part before the decimal is optional"		self assert: (ExtendedNumberParser parse: '.5') = (1/2).	self assert: (ExtendedNumberParser parse: '.5') isFloat.		self assert: (ExtendedNumberParser parse: '.3e2') = 30.	self assert: (ExtendedNumberParser parse: '.3e2') isFloat.		self assert: (ExtendedNumberParser parse: '-.4e2') = -40.	self assert: (ExtendedNumberParser parse: '-.4e2') isFloat.		self assert: (ExtendedNumberParser parse: '+.5e2') = 50.	self assert: (ExtendedNumberParser parse: '+.5e2') isFloat.	self assert: (ExtendedNumberParser parse: '+.6e+2') = 60.	self assert: (ExtendedNumberParser parse: '+.6e+2') isFloat.	self assert: (ExtendedNumberParser parse: '-.7e+2') = -70.	self assert: (ExtendedNumberParser parse: '-.7e+2') isFloat.		self assert: (ExtendedNumberParser parse: '+2r.1e-2') = (1/8).	self assert: (ExtendedNumberParser parse: '+2r.1e-2') isFloat.		self assert: (ExtendedNumberParser parse: '-4r.1e-2') = (-1/64).	self assert: (ExtendedNumberParser parse: '-4r.1e-2') isFloat.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:25'!testIntegerPartWithoutFraction	"The fraction part after the decimal is optional"		self assert: (ExtendedNumberParser parse: '1.') = 1.	self assert: (ExtendedNumberParser parse: '1.') isFloat.		self assert: (ExtendedNumberParser parse: '3.e2') = 300.	self assert: (ExtendedNumberParser parse: '3.e2') isFloat.		self assert: (ExtendedNumberParser parse: '-4.e2') = -400.	self assert: (ExtendedNumberParser parse: '-4.e2') isFloat.		self assert: (ExtendedNumberParser parse: '+5.e2') = 500.	self assert: (ExtendedNumberParser parse: '+5.e2') isFloat.	self assert: (ExtendedNumberParser parse: '+6.e+2') = 600.	self assert: (ExtendedNumberParser parse: '+6.e+2') isFloat.	self assert: (ExtendedNumberParser parse: '-7.e+2') = -700.	self assert: (ExtendedNumberParser parse: '-7.e+2') isFloat.		self assert: (ExtendedNumberParser parse: '+2r1.e-2') = (1/4).	self assert: (ExtendedNumberParser parse: '+2r1.e-2') isFloat.		self assert: (ExtendedNumberParser parse: '-4r1.e-2') = (-1/16).	self assert: (ExtendedNumberParser parse: '-4r1.e-2') isFloat.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:23'!testInvalidExponent	"The leading number is returned, the invalid part is ignored"		self assert: (ExtendedNumberParser parse: '1e') = 1.	self assert: (ExtendedNumberParser parse: '1eZ') = 1.	self assert: (ExtendedNumberParser parse: '+1eW') = 1.	self assert: (ExtendedNumberParser parse: '-1eX') = -1.		self assert: (ExtendedNumberParser parse: '2e-') = 2.	self assert: (ExtendedNumberParser parse: '2e--1') = 2.	self assert: (ExtendedNumberParser parse: '2e-+1') = 2.	self assert: (ExtendedNumberParser parse: '2e-Z') = 2.	self assert: (ExtendedNumberParser parse: '+2e-W') = 2.	self assert: (ExtendedNumberParser parse: '-2e-X') = -2.		self assert: (ExtendedNumberParser parse: '3e+') = 3.	self assert: (ExtendedNumberParser parse: '3e+-') = 3.	self assert: (ExtendedNumberParser parse: '3e+-1') = 3.	self assert: (ExtendedNumberParser parse: '+3e+W') = 3.	self assert: (ExtendedNumberParser parse: '-3e+Z') = -3.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:08'!testInvalidRadix	"The leading number is returned, the invalid part is ignored"		self assert: (ExtendedNumberParser parse: '1r') = 1.	self assert: (ExtendedNumberParser parse: '+1r') = 1.	self assert: (ExtendedNumberParser parse: '-1r') = -1.	self assert: (ExtendedNumberParser parse: '-1r+') = -1.	self assert: (ExtendedNumberParser parse: '-1r-') = -1.		self assert: (ExtendedNumberParser parse: '-2r.') = -2.	self assert: (ExtendedNumberParser parse: '-2r-.') = -2.	self assert: (ExtendedNumberParser parse: '+2r-.') = 2.		self assert: (ExtendedNumberParser parse: '+2r3.') = 2.	self assert: (ExtendedNumberParser parse: '+2r.3') = 2.	self assert: (ExtendedNumberParser parse: '+2r-.3') = 2.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:24'!testInvalidScale	"The leading number is returned, the invalid part is ignored"		self assert: (ExtendedNumberParser parse: '1s') = 1.	self assert: (ExtendedNumberParser parse: '1sZ') = 1.	self assert: (ExtendedNumberParser parse: '+1sW') = 1.	self assert: (ExtendedNumberParser parse: '-1sX') = -1.		self assert: (ExtendedNumberParser parse: '2s-') = 2.	self assert: (ExtendedNumberParser parse: '2s--1') = 2.	self assert: (ExtendedNumberParser parse: '2s-+1') = 2.	self assert: (ExtendedNumberParser parse: '2s-1') = 2.	self assert: (ExtendedNumberParser parse: '+2s-2') = 2.	self assert: (ExtendedNumberParser parse: '-2s-3') = -2.		self assert: (ExtendedNumberParser parse: '3s+') = 3.	self assert: (ExtendedNumberParser parse: '3s+-') = 3.	self assert: (ExtendedNumberParser parse: '3s+-1') = 3.	self assert: (ExtendedNumberParser parse: '+3s+2') = 3.	self assert: (ExtendedNumberParser parse: '-3s+3') = -3.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:26'!testPositive	"A leading + sign is allowed"		self assert: (ExtendedNumberParser parse: '+1') = 1.	self assert: (ExtendedNumberParser parse: '+22') = 22.	self assert: (ExtendedNumberParser parse: '+2r11') = 3.	self assert: (ExtendedNumberParser parse: '+2r+101') = 5.	self assert: (ExtendedNumberParser parse: '+2r-101') = -5.	self assert: (ExtendedNumberParser parse: '-2r+101') = -5.		self assert: (ExtendedNumberParser parse: '+1.') isFloat.	self assert: (ExtendedNumberParser parse: '+1.') = 1.	self assert: (ExtendedNumberParser parse: '+21.') = 21.	self assert: (ExtendedNumberParser parse: '+3r21.') = 7.	self assert: (ExtendedNumberParser parse: '+3r+201.') = 19.	self assert: (ExtendedNumberParser parse: '+3r-201.') = -19.	self assert: (ExtendedNumberParser parse: '-3r+201.') = -19.! !!ExtendedNumberParserTest methodsFor: 'testing' stamp: 'nice 2/13/2010 02:27'!testPositiveExponent	"A leading + sign is allowed in exponent"		self assert: (ExtendedNumberParser parse: '1e+2') = 100.	self assert: (ExtendedNumberParser parse: '1e+2') isInteger.	self assert: (ExtendedNumberParser parse: '-1e+2') = -100.	self assert: (ExtendedNumberParser parse: '1.e+2') = 100.	self assert: (ExtendedNumberParser parse: '1.e+2') isFloat.	self assert: (ExtendedNumberParser parse: '-1.0e+2') = -100.! !!FMSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:22'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #waveTable declareC: 'short int *waveTable'>	doingFM := (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample := (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset := normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex := (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex := scaledOffsetIndex + scaledWaveTableSize].				scaledIndex := (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex := scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex := (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	count := count - n.! !!False methodsFor: 'printing' stamp: 'ajh 7/1/2004 10:36'!printOn: aStream 	aStream nextPutAll: 'false'! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:02'!testAND	self assert: (false & true) = false.	self assert: (false & false) = false.! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:02'!testAnd	self assert: (false and: ['alternativeBlock']) = false.! !!FalseTest methodsFor: 'tests' stamp: 'it 7/13/2009 22:24'!testAsBit	self assert: (false asBit = 0).! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testIfFalse		self assert: ((false ifFalse: ['alternativeBlock']) = 'alternativeBlock'). ! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testIfFalseIfTrue	self assert: (false ifFalse: ['falseAlternativeBlock']                       ifTrue: ['trueAlternativeBlock']) = 'falseAlternativeBlock'. ! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testIfTrue	self assert: (false ifTrue: ['alternativeBlock']) = nil. ! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testIfTrueIfFalse	self assert: (false ifTrue: ['trueAlternativeBlock']                       ifFalse: ['falseAlternativeBlock']) = 'falseAlternativeBlock'. ! !!FalseTest methodsFor: 'tests' stamp: 'it 7/13/2009 22:22'!testInMemory	self assert: (false isInMemory = true).! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testNew	self should: [False new] raise: TestResult error. ! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:03'!testNot	self assert: (false not = true).! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:04'!testOR	self assert: (false | true) =  true.	self assert: (false | false) = false.! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:04'!testOr	self assert: (false or: ['alternativeBlock']) = 'alternativeBlock'.! !!FalseTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:04'!testPrintOn	self assert: (String streamContents: [:stream | false printOn: stream]) = 'false'. ! !!FalseTest methodsFor: 'tests' stamp: 'nice 10/14/2009 23:07'!testXor	self assert: (false xor: true) = true.	self assert: (false xor: false) = false.	self		should: [(false xor: [false])			ifTrue: ["This should never be true, do not signal an Error and let the test fail"]			ifFalse: [self error: 'OK, this should be false, raise an Error']]		raise: Error		description: 'a Block argument is not allowed. If it were, answer would be false'.! !!FalseTest commentStamp: '<historical>' prior: 0!This is the unit test for the class False. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitFieldNode: self! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:18'!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:17'!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!FileDirectory methodsFor: 'enumeration' stamp: 'bgf 6/13/2007 23:40'!directoryEntryFor: filenameOrPath	"Answer the directory entry for the given file or path. Sorta like a poor man's stat()."	| fName dir |	DirectoryClass splitName: filenameOrPath to:[:filePath :name |		fName := name.		filePath isEmpty			ifTrue: [dir := self]			ifFalse: [dir := FileDirectory on: filePath]].	^ dir exists ifTrue: [		dir directoryEntryForName: fName	] ifFalse: [ 		nil 	].! !!FileDirectory methodsFor: 'file directory' stamp: 'jcg 5/10/2010 14:44'!assureExistenceOfPath: lPath	"Make sure the local directory exists. If necessary, create all parts in between"	| localPath |	localPath := lPath.	localPath isEmpty ifTrue: [ ^self ]. "Assumed to exist"	(self directoryExists: localPath) ifTrue: [^ self]. "exists"	"otherwise check parent first and then create local dir"	[self containingDirectory assureExistenceOfPath: self localName.	 self createDirectory: localPath]		on: Error		do: [:err |			"Check if the directory now exists (maybe there were two actors trying			 to create the directory at the same time).  If so, there's no problem.			 Otherwise, pass the error on for someone else to handle."			(self directoryExists: localPath) ifTrue: [^self].			err pass.					].		! !!FileDirectory methodsFor: 'file name utilities' stamp: 'ar 5/28/2007 18:08'!fileAndDirectoryNamesMatching: pat	"	FileDirectory default fileNamesMatching: '*'	FileDirectory default fileNamesMatching: '*.image;*.changes'	"		| files |	files := OrderedCollection new.		(pat findTokens: ';', String crlf) do: [ :tok | 		files addAll: (self fileAndDirectoryNames select: [:name | tok match: name]) ].		^files! !!FileDirectory methodsFor: 'file name utilities' stamp: 'RJT 6/2/2007 23:04'!nextNameFor: baseFileName extension: extension	"Assumes a file name includes a version number encoded as '.' followed by digits 	preceding the file extension.  Increment the version number and answer the new file name.	If a version number is not found, set the version to 1 and answer a new file name"	| files splits version |	files := self fileAndDirectoryNamesMatching: (baseFileName,'*', self class dot, extension).	splits := files 			collect: [:file | self splitNameVersionExtensionFor: file]			thenSelect: [:split | self isCaseSensitive 							ifTrue:[(split at: 1) = baseFileName]							ifFalse:[(split at: 1) match: baseFileName]].	splits := splits asSortedCollection: [:a :b | (a at: 2) < (b at: 2)].	splits isEmpty 			ifTrue: [version := 1]			ifFalse: [version := (splits last at: 2) + 1].	^ (baseFileName, '.', version asString, self class dot, extension) asFileName! !!FileDirectory methodsFor: 'file operations' stamp: 'jcg 2/18/2009 14:18'!copyFile: fileStream1 toFile: fileStream2	| buffer fS1isBinary fS2isBinary |		fS1isBinary := fileStream1 isBinary.	fS2isBinary := fileStream2 isBinary.	[		fileStream1 binary.		fileStream2 binary.		buffer := ByteArray new: 50000.		[fileStream1 atEnd] whileFalse:			[fileStream2 nextPutAll: (fileStream1 nextInto: buffer)].	] ensure: [		fS1isBinary ifFalse: [fileStream1 ascii].		fS2isBinary ifFalse: [fileStream2 ascii].	].! !!FileDirectory methodsFor: 'file operations' stamp: 'das 10/1/2009 16:54'!recursiveCopy: toDirectoryPath	"Recursively copy this directory contents to toDirectory. Create toDirectory if it does not exist."	| toDir file1 file2 |	toDir := (FileDirectory on: toDirectoryPath).	toDir assureExistence.	self fileNames do:		[:fn | 			file1 := (self readOnlyFileNamed: fn)binary.			file2 := (toDir forceNewFileNamed: fn).			self copyFile: file1 toFile: file2.			file1 close.			file2 close.		].	self directoryNames do:		[:dn | (self directoryNamed: dn) recursiveCopy: toDirectoryPath,FileDirectory pathNameDelimiter , dn].! !!FileDirectory methodsFor: 'file operations' stamp: 'eem 7/12/2008 16:44'!recursiveDeleteContents	"Delete the this directory's contents, recursing down its tree."	self directoryNames do:		[:dn | (self directoryNamed: dn) recursiveDelete].	self deleteLocalFiles! !!FileDirectory methodsFor: 'file status' stamp: 'bgf 6/13/2007 14:39'!entryAt: fileName ifAbsent: aBlock	"Find the entry with local name fileName and answer it.	If not found, answer the result of evaluating aBlock."	| |	self exists ifFalse: [ ^ aBlock value ].	^(self directoryEntryForName: fileName) ifNil: [ aBlock value ]! !!FileDirectory methodsFor: 'school support' stamp: 'ar 12/31/2007 10:51'!eToyUserName: aString	"Set the default directory from the given user name"	| dirName |	dirName := self eToyBaseFolderSpec. "something like 'U:\Squeak\users\*-Squeak'"	dirName ifNil:[^self].	dirName := dirName copyReplaceAll:'*' with: aString."	dirName last = self class pathNameDelimiter ifFalse:[dirName := dirName, self slash].	FileDirectory setDefaultDirectoryFrom: dirName.	dirName := dirName copyFrom: 1 to: dirName size - 1."	pathName := dirName.! !!FileDirectory methodsFor: 'testing' stamp: 'bgf 6/13/2007 16:51'!directoryExists: filenameOrPath	"Answer true if a directory of the given name exists. The given name may be either a full path name or a local directory within this directory."	"FileDirectory default directoryExists: FileDirectory default pathName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName := name.			filePath isEmpty				ifTrue: [dir := self]				ifFalse: [dir := self directoryNamed: filePath]].	^dir exists and: [		(dir directoryEntryForName: fName) ifNotNilDo: [ :e | e isDirectory ] ifNil: [false]	].		! !!FileDirectory methodsFor: 'testing' stamp: 'ar 7/14/2009 17:38'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	"FileDirectory default fileExists: Smalltalk sourcesName"	| fName dir |	DirectoryClass splitName: filenameOrPath to:		[:filePath :name |			fName := name.			filePath isEmpty				ifTrue: [dir := self]				ifFalse: [dir := FileDirectory on: filePath]].		^(dir directoryEntryForName: fName) ifNotNilDo: [ :e | e isDirectory not ] ifNil: [false]		! !!FileDirectory methodsFor: 'private' stamp: 'ar 9/3/2010 16:20'!directoryEntryForName: aFileName	"Return a single DirectoryEntry for the given (non-path) entry name,	 or nil if the entry could not be found.	 Raises InvalidDirectoryError if this directory's path does not identify a directory."	| entryArray sysPath sysName |	sysPath := pathName asVmPathName.	sysName := aFileName asVmPathName.	"New linear-time primitive."	entryArray := self primLookupEntryIn: sysPath name: sysName.	entryArray == #primFailed ifFalse:[		^ entryArray ifNotNil: [(DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]	].	"If the new primitive fails, use the old slow method. 	 (This fallback can be changed to signal InvalidDirectoryError once	  VM's with FilePlugin #primitiveDirectoryEntry have been distributed everywhere;	  the new primitive was introduced 6/13/2007."	^self isCaseSensitive ifTrue: [		self entries detect: [:entry | entry name = aFileName ] ifNone: [ nil ]	] ifFalse: [		self entries detect: [:entry | entry name sameAs: aFileName ] ifNone: [ nil ]	]! !!FileDirectory methodsFor: 'private' stamp: 'bgf 6/13/2007 23:33'!primLookupEntryIn: fullPath name: fName	"Look up <fName> (a simple file name) in the directory identified by <fullPath> 	 and return an array containing:	<fName> <creationTime> <modificationTime> <dirFlag> <fileSize>	On Unix, the empty path denotes '/'.       On Macs and PCs, it is the container of the system volumes.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 'primitiveDirectoryEntry' module: 'FilePlugin'>	^ #primFailed		"to distinguish from nil"! !!FileDirectory methodsFor: 'private' stamp: 'ar 12/31/2007 10:51'!setPathName: pathString	pathName := pathString.! !!FileDirectory class methodsFor: 'name utilities' stamp: 'ar 12/9/2008 16:09'!isDirectory: fullPath	"Answer whether the given full path represents a directory"	"FileDirectory isDirectory: 'C:\Windows'"	self splitName: fullPath to:[:dir :fName| 		^fName isEmpty or:[((self on: dir) directoryEntryForName: fName) isDirectory]].! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 12/31/2007 10:52'!setDefaultDirectory: directoryName	"Initialize the default directory to the directory supplied. This method is called when the image starts up."	| dirName |	DirectoryClass := self activeDirectoryClass.	dirName := directoryName.	[dirName endsWith: self slash] whileTrue:[		dirName := dirName copyFrom: 1 to: dirName size - self slash size.	].	DefaultDirectory := self on: dirName.! !!FileDirectory class methodsFor: 'system start up' stamp: 'ar 12/31/2007 10:51'!setDefaultDirectoryFrom: imageName	"Initialize the default directory to the directory containing the Squeak image file. This method is called when the image starts up."	DirectoryClass := self activeDirectoryClass.	DefaultDirectory := self on: (self dirPathFor: imageName).! !!FileDirectory class methodsFor: 'utilities' stamp: 'ar 12/3/2009 23:36'!copy: srcName to: dstName	"Copies either files or entire directories"	| srcDir dstDir srcFile entry dstFile |	FileDirectory splitName: srcName to:[:srcPath :srcLocal|		srcDir := FileDirectory on: srcPath.		srcDir exists ifFalse:[^self]. "no source dir"		FileDirectory splitName: dstName to:[:dstPath :dstLocal|			[				dstDir := FileDirectory on: dstPath.				"Figure out whether to copy a single file or directory"				(srcDir entryAt: srcLocal ifAbsent:[^nil]) isDirectory ifTrue:[					"Source is directory so must be dest"					srcDir := srcDir directoryNamed: srcLocal.					dstDir := dstDir directoryNamed: dstLocal.				] ifFalse:[					"Source is file, dest might be file or directory"					srcFile := srcDir readOnlyFileNamed: srcLocal.					dstDir assureExistence.					entry := dstDir entryAt: dstLocal ifAbsent:[nil].					(entry notNil and:[entry isDirectory])						ifTrue:[dstDir := dstDir directoryNamed: dstLocal]						ifFalse:[dstFile := dstDir forceNewFileNamed: dstLocal]].				srcFile ifNil:["directory copy"					self copyDirectory: srcDir to: dstDir.				] ifNotNil:["single file copy"					"If destination is directory, create new file based on source name"					dstFile ifNil:[dstFile := dstDir forceNewFileNamed: srcFile localName].					srcFile binary.					dstFile binary.					srcDir copyFile: srcFile toFile: dstFile.				].			] ensure:[				srcFile ifNotNil:[srcFile close].				dstFile ifNotNil:[dstFile close].			].		].	].! !!FileDirectory class methodsFor: 'utilities' stamp: 'ar 12/3/2009 23:31'!copyDirectory: srcDirectory to: dstDirectory	"Recursively copy the contents of srcDirectory to dstDirectory."	| file1 file2 |	srcDirectory exists ifFalse:[^nil]. "nothing to be copied"	dstDirectory assureExistence.	srcDirectory entries do:[:entry|		entry isDirectory ifTrue:[			self copyDirectory: (srcDirectory directoryNamed: entry name)				to: (dstDirectory directoryNamed: entry name).		] ifFalse:[			[			file1 := srcDirectory readOnlyFileNamed: entry name.			file2 := dstDirectory forceNewFileNamed: entry name.			file1 binary. file2 binary.			srcDirectory copyFile: file1 toFile: file2] ensure:[				file1 ifNotNil:[file1 close].				file2 ifNotNil:[file2 close].			].		].	].! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'nk 11/13/2002 19:39'!deleteDirectory		(self myDirectory exists) ifTrue:		[self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName]! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'stephaneducasse 2/4/2006 20:31'!testDeleteDirectory	"Test deletion of a directory"		| aContainingDirectory preTestItems |	aContainingDirectory := self myDirectory containingDirectory.	preTestItems := aContainingDirectory fileAndDirectoryNames.		self assert: self myAssuredDirectory exists.	aContainingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: 		[aContainingDirectory directoryNames 			includes: self myLocalDirectoryName ]		description: 'Should successfully delete directory.'.	self should: 		[preTestItems = aContainingDirectory fileAndDirectoryNames]		description: 'Should only delete the indicated directory.'.		! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:44'!myAssuredDirectory	^self myDirectory assureExistence! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myDirectory	^FileDirectory default directoryNamed: self myLocalDirectoryName! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myLocalDirectoryName	^'zTestDir'! !!FileDirectoryTest methodsFor: 'resources' stamp: 'nk 11/13/2002 19:56'!tearDown	[ self deleteDirectory ] on: Error do: [ :ex | ]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'mha 7/30/2009 11:24'!testAttemptExistenceCheckWhenFile	"How should a FileDirectory instance respond with an existent file name?"		| directory filename |		filename := 'aTestFile'.	FileDirectory default forceNewFileNamed: filename.	directory := FileDirectory default directoryNamed: filename.	self shouldnt: [directory exists] description: 'Files are not directories.'.		"clean up disk"	FileDirectory default deleteFileNamed: filename ifAbsent: [ ]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'aka 5/20/2003 23:33'!testDirectoryExists	self assert: self myAssuredDirectory exists.	self should: [self myDirectory containingDirectory 					directoryExists: self myLocalDirectoryName].	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [self myDirectory containingDirectory 						directoryExists: self myLocalDirectoryName]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'nice 12/27/2009 20:37'!testDirectoryExistsWhenLikeNamedFileExists[ | testFileName |testFileName := self myAssuredDirectory fullNameFor: 'zDirExistsTest.testing'.(FileStream newFileNamed: testFileName) close.self should: [FileStream isAFileNamed: testFileName].self shouldnt: [(FileDirectory on: testFileName) exists]]ensure: [self myAssuredDirectory deleteFileNamed: 'zDirExistsTest.testing']! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'hg 2/2/2002 16:44'!testDirectoryNamed	self should: [(self myDirectory containingDirectory 					directoryNamed: self myLocalDirectoryName) pathName 						= self myDirectory pathName]! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'tpr 8/15/2003 16:30'!testExists	self should: [FileDirectory default exists]		description: 'Should know default directory exists.'.	self should: [self myAssuredDirectory exists]		description: 'Should know created directory exists.'.	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [(self myDirectory containingDirectory directoryNamed: self myLocalDirectoryName) exists]		description: 'Should know that recently deleted directory no longer exists.'.! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'stephaneducasse 2/4/2006 20:31'!testNonExistentDirectory	| directory parentDirectory |	directory :=FileDirectory default				directoryNamed: 'nonExistentFolder'.	self shouldnt: [directory exists] 		description: 'A FileDirectory instance should know if it points to a non-existent directory.'.	parentDirectory :=FileDirectory default.	self shouldnt: [parentDirectory directoryExists: 'nonExistentFolder'] 		description: 'A FileDirectory instance should know when a directory of the given name doesn''t exist'.! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'CdG 10/19/2005 22:41'!testOldFileOrNoneNamed	| file |	file := self myAssuredDirectory oldFileOrNoneNamed: 'test.txt'.	[self assert: file isNil.		"Reproduction of Mantis #1049"	(self myAssuredDirectory fileNamed: 'test.txt')		nextPutAll: 'foo';		close.			file := self myAssuredDirectory oldFileOrNoneNamed: 'test.txt'.	self assert: file notNil]		ensure: [			file ifNotNil: [file close].			self myAssuredDirectory deleteFileNamed: 'test.txt' ifAbsent: nil]	! !!FileDirectoryTest methodsFor: 'tests' stamp: 'ul 2/28/2010 22:16'!testEquality	self assert: FileDirectory default = FileDirectory default.	self deny: FileDirectory default = FileDirectory default containingDirectory.	self deny: FileDirectory default = nil! !!FileDirectoryTest methodsFor: 'tests' stamp: 'ar 9/7/2010 11:10'!testNonLatinFileName	"Ensure that we can deal with non-latin file names properly"	| bytes ee fd file wideName |	fd := FileDirectory default.	bytes := #[208 157 208 190 208 178 208 190 209 129 209 130 208 184 46 111 100 116].	wideName := bytes asString utf8ToSqueak.	[		fd deleteFileNamed: wideName ifAbsent:[].		self shouldnt:[fd newFileNamed: wideName] raise: Error.		self assert: (fd entries anySatisfy:[:entry| entry name = wideName]).		self assert: (ee := fd directoryEntryForName: wideName) notNil.		self assert: (ee name = wideName).		self shouldnt:[file := fd readOnlyFileNamed: wideName] raise: Error.		self assert: (file localName = wideName).		self shouldnt:[FileDirectory default deleteFileNamed: wideName] raise: Error.	] ensure:[		file ifNotNil:[file close].		FileDirectory default deleteFileNamed: wideName ifAbsent:[].	].! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'sd 11/20/2005 21:27'!testModalFileSelector	| window fileList2 |	window := FileList2 morphicViewFileSelector.	window openCenteredInWorld.	fileList2 := window valueOfProperty: #fileListModel.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedFile isNil.	fileList2 okHit.	self deny: fileList2 getSelectedFile isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'sd 11/20/2005 21:27'!testModalFileSelectorForSuffixes	| window fileList2 |	window := FileList2 morphicViewFileSelectorForSuffixes: nil.	window openCenteredInWorld.	fileList2 := window valueOfProperty: #fileListModel.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedFile isNil.	fileList2 okHit.	self deny: fileList2 getSelectedFile isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'sd 11/20/2005 21:27'!testModalFolderSelector	| window fileList2 |	window := FileList2 morphicViewFolderSelector.	fileList2 := window model.	window openInWorld: self currentWorld extent: 300@400.	fileList2 fileListIndex: 1.	window delete.	self assert: fileList2 getSelectedDirectory withoutListWrapper isNil.	fileList2 okHit.	self deny: fileList2 getSelectedDirectory withoutListWrapper isNil! !!FileList2ModalDialogsTest methodsFor: 'running' stamp: 'sd 11/20/2005 21:27'!testModalFolderSelectorForProjectLoad	| window fileList2 w |	window := FileList2		morphicViewProjectLoader2InWorld: self currentWorld		reallyLoad: false.	fileList2 := window valueOfProperty: #FileList.	w := self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	window delete.	self assert: fileList2 getSelectedDirectory withoutListWrapper isNil.	fileList2 okHit.	self deny: fileList2 getSelectedDirectory withoutListWrapper isNil! !!FileList2ModalDialogsTest commentStamp: '<historical>' prior: 0!TestRunner open!!FileListTest methodsFor: 'private' stamp: 'ul 1/11/2010 07:08'!checkIsServiceIsFromDummyTool: service		^ (service instVarNamed: #provider) = DummyToolWorkingWithFileList and: [		service label = 'menu label' and: [		(service instVarNamed: #selector) = #loadAFileForTheDummyTool: ] ]! !!FileListTest methodsFor: 'initialize' stamp: 'SD 11/10/2001 21:48'!setUp	DummyToolWorkingWithFileList initialize.! !!FileListTest methodsFor: 'initialize' stamp: 'SD 11/10/2001 21:49'!tearDown	DummyToolWorkingWithFileList unregister.! !!FileListTest methodsFor: 'test' stamp: 'stephaneducasse 10/9/2005 20:52'!testAllRegisteredServices	"(self selector: #testAllRegisteredServices) debug"	self shouldnt: [FileList allRegisteredServices] raise: Error! !!FileListTest methodsFor: 'test' stamp: 'SD 11/10/2001 21:53'!testMenuReturned	"(self selector: #testToolRegistered) debug"	self assert: (FileList registeredFileReaderClasses includes: DummyToolWorkingWithFileList)! !!FileListTest methodsFor: 'test' stamp: 'stephaneducasse 10/9/2005 20:50'!testService	"a stupid test to check that the class returns a service"	"(self selector: #testService) debug"		| service |	service := (DummyToolWorkingWithFileList fileReaderServicesForFile: 'abab.kkk' suffix: 'kkk') first.	self assert: (self checkIsServiceIsFromDummyTool: service).	service := (DummyToolWorkingWithFileList fileReaderServicesForFile: 'zkk.gz' suffix: 'gz').	self assert: service isEmpty! !!FileListTest methodsFor: 'test' stamp: 'nk 11/30/2002 14:55'!testServicesForFileEnding	"(self selector: #testServicesForFileEnding) debug"	self assert: (((FileList new directory: FileDirectory default; yourself) itemsForFile: 'aaa.kkk') anySatisfy: [ :ea | self checkIsServiceIsFromDummyTool: ea ]).! !!FileListTest methodsFor: 'test' stamp: 'SD 11/10/2001 21:52'!testToolRegistered	"(self selector: #testToolRegistered) debug"	self assert: (FileList registeredFileReaderClasses includes: DummyToolWorkingWithFileList)! !!FileListTest methodsFor: 'test' stamp: 'SD 11/11/2001 13:54'!testToolRegisteredUsingInterface	"(self selector: #testToolRegisteredUsingInterface) debug"	self assert: (FileList isReaderNamedRegistered: #DummyToolWorkingWithFileList)! !!FilePath commentStamp: '<historical>' prior: 0!DEPRECATED. The file interface in the VM uses UTF-8, always.This class absorb the difference of internal and external representation of the file path.  The idea is to keep the internal one as much as possible, and only when it goes to a primitive, the encoded file path, i.e. the native platform representation is passsed to the primitive.	The converter used is obtained by "LanguageEnvironment defaultFileNameConverter".!!FileStream class methodsFor: 'dnd requests' stamp: 'ar 12/9/2008 16:16'!requestDropName: dropIndex	"Request the name for some file that was dropped onto Squeak"	^self concreteStream new requestDropName: dropIndex.! !!FileStream class methodsFor: 'file reader services' stamp: 'eem 6/2/2010 09:42'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := FileDirectory default checkName: fileName fixErrors: true.	f := FileStream newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!FileStream class methodsFor: 'instance creation' stamp: 'eem 6/4/2010 15:10'!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!FileStream class methodsFor: 'standard io' stamp: 'ar 7/20/2010 10:32'!stderr	"Return a FileStream for stderr"	^(self concreteStream new)		handle: self stdioHandles third name: 'stderr' forWrite: true! !!FileStream class methodsFor: 'standard io' stamp: 'ar 7/20/2010 10:26'!stdin	"Return a FileStream for stdin"	^(self concreteStream new)		handle: self stdioHandles first name: 'stdin' forWrite: false! !!FileStream class methodsFor: 'standard io' stamp: 'ar 7/20/2010 10:20'!stdioHandles	"Returns an array of stdin, stdout, and stderr handles"	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin'>	^self primitiveFailed! !!FileStream class methodsFor: 'standard io' stamp: 'ar 7/20/2010 10:32'!stdout	"Return a FileStream for stdout"	^(self concreteStream new)		handle: self stdioHandles second name: 'stdout' forWrite: true! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'ar 3/29/2010 20:56'!testCachingNextChunkPut	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file text read |	[file := FileStream forceNewFileNamed: 'testCachingNextChunkPut'.	text := 'this is a chunkful of text'.	file nextChunkPut: text.	read := [file position: 0; nextChunkText] valueWithin: 1 seconds onTimeout:[''].	self assert: read = text.	] ensure:[file close. FileDirectory default deleteFileNamed: file name ifAbsent:[]].! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'mha 7/30/2009 11:25'!testDetectFileDo	"Mantis #1838"		| filename |	filename := 'filestream.tst'.		[(FileDirectory default forceNewFileNamed: filename)		nextPutAll: '42';		close.			FileStream 		detectFile: [FileDirectory default oldFileNamed: filename]		do: [:file |			self assert: file notNil.			self deny: file closed.			self assert: file contentsOfEntireFile = '42']]			ensure: [FileDirectory default deleteFileNamed: filename ifAbsent: [] ]! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'jcg 4/15/2010 16:28'!testFileTruncation	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file |	file := nil.	[			file := FileDirectory default forceNewFileNamed: 'TruncationTest.txt'.		file nextPutAll: '1234567890'.	] ensure: [file close].	[		file := FileDirectory default oldFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234567890'].		file truncate: 4.	] ensure: [file close].	[		file := FileDirectory default readOnlyFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234'].	] ensure: [		file close.		FileDirectory default deleteFileNamed: file name ifAbsent:[]	].! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'ar 3/29/2010 20:56'!testNextChunkOutOfBounds	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file text read |	[file := FileStream forceNewFileNamed: 'testNextChunkOutOfBounds'.	text := 'this is a chunkful of text'.	file nextChunkPut: text.	read := [file position: 999999; nextChunkText] valueWithin: 1 seconds onTimeout:[nil].	self assert: read = ''.	] ensure:[file close. FileDirectory default deleteFileNamed: file name ifAbsent:[]].! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 20:37'!testNextLine	| filename lines text |	filename := 'filestream.tst'.	lines := #('line 1' ' and line 2' '' 'fourth').	text := lines first , String cr , lines second , String crlf , lines third , String lf , lines fourth.		[ | file |	(StandardFileStream forceNewFileNamed: filename)		nextPutAll: text;		close.			file := StandardFileStream readOnlyFileNamed: filename.	lines do: [:e |		self assert: file nextLine = e].	self assert: file nextLine = nil.	file close]		ensure: [FileDirectory default deleteFileNamed: filename ifAbsent: [] ]! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'ar 4/2/2010 00:43'!testPositionPastEndIsAtEnd	"Tests that a file positioned after its end responds true to #atEnd"	| filename file |	filename := 'filestream.tst'.	file := StandardFileStream forceNewFileNamed: filename.	[		file position: 1000.		self assert: file atEnd.	] ensure:[		file close.		FileDirectory default deleteFileNamed: filename ifAbsent:[].	].! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'nice 3/15/2010 20:37'!testReadIntoStartingAtCount	| filename file |	filename := 'filestream.tst'.	[ | writeBuffer readBuffer bytesRead |	writeBuffer := (ByteArray new: 2500)		 atAllPut: 1 ;		 yourself.	(StandardFileStream forceNewFileNamed: filename)		 binary ;		 nextPutAll: writeBuffer ;		 close.	file := StandardFileStream readOnlyFileNamed: filename.	readBuffer := ByteArray new: 400.	bytesRead := file		readInto: readBuffer		startingAt: 10		count: 100.	self assert: bytesRead = 100.	"quick test"	self assert: (readBuffer occurrencesOf: 1) = 100.	"compare test"	1 to: readBuffer size do:		[ : n | self assert:			(readBuffer at: n) = ((n between: 10 	and: 10 + 100 - 1)				ifTrue: [ writeBuffer at: n ]				ifFalse: [ 0 ]) ] ]	ensure:		[ file ifNotNil: [ file close ].		FileDirectory default			deleteFileNamed: filename			ifAbsent: [ "ok" ] ]! !!FileUrlTest methodsFor: 'testing' stamp: 'fbs 2/2/2005 12:43'!testAsString	| target url |	target := 'file://localhost/etc/rc.conf'.	url := target asUrl.	self assert: url asString = target.		! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR	"Answer whether a carriage return should cause input to be accepted."	^ acceptOnCR! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR: aBoolean	acceptOnCR := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done	"Answer whether the user has ended the interaction."	^ done! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done: aBoolean	done := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:45'!responseUponCancel: resp	responseUponCancel := resp! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:47'!setResponseForCancel	self contents: responseUponCancel! !!FillInTheBlank methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel := ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FillInTheBlank methodsFor: 'initialize-release' stamp: 'sw 1/31/2000 14:42'!initialize	super initialize.	acceptOnCR := false.	done := false.	responseUponCancel := ''! !!FillInTheBlank methodsFor: 'private' stamp: 'sma 6/18/2000 10:54'!show: fillInView	| savedArea |	savedArea := Form fromDisplay: fillInView displayBox.	fillInView display.	contents isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: contents size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ contents! !!FillInTheBlank commentStamp: '<historical>' prior: 0!I represent a prompt for string input from the user. The user is asked to type in and edit a string. The resulting string is supplied as the argument to a client-supplied action block.!!FillInTheBlank class methodsFor: 'private' stamp: 'dtl 2/12/2010 19:36'!fillInTheBlankMorphClass	"By factoring out this class references, it becomes possible to discard 	morphic by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ Smalltalk		at: #FillInTheBlankMorph		ifAbsent: [self notify: 'Morphic class FillInTheBlankMorph not present']! !!FillInTheBlank class methodsFor: 'private' stamp: 'sma 6/18/2000 10:47'!fillInTheBlankViewClass	"By factoring out this class references, it becomes possible to discard 	MVC by simply removing this class.  All calls to this method needs	to be protected by 'Smalltalk isMorphic' tests."	^ FillInTheBlankView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'dtl 2/12/2010 19:39'!multiLineRequest: queryString centerAt: aPoint initialAnswer: defaultAnswer answerHeight: answerHeight 	"Create a multi-line instance of me whose question is queryString with	the given initial answer. Invoke it centered at the given point, and	answer the string the user accepts.  Answer nil if the user cancels.  An	empty string returned means that the ussr cleared the editing area and	then hit 'accept'.  Because multiple lines are invited, we ask that the user	use the ENTER key, or (in morphic anyway) hit the 'accept' button, to 	submit; that way, the return key can be typed to move to the next line.	NOTE: The ENTER key does not work on Windows platforms."	"UIManager default		multiLineRequest:'Enter several lines; end input by acceptingor canceling via menu or press Alt+s/Alt+l'		centerAt: Display center		initialAnswer: 'Once upon a time...'		answerHeight: 200"	| model fillInView |	Smalltalk isMorphic 		ifTrue: 			[^self fillInTheBlankMorphClass 				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint				inWorld: self currentWorld				onCancelReturn: nil				acceptOnCR: false].	model := self new.	model contents: defaultAnswer.	model responseUponCancel: nil.	model acceptOnCR: false.	fillInView := self fillInTheBlankViewClass 				multiLineOn: model				message: queryString				centerAt: aPoint				answerHeight: answerHeight.	^model show: fillInView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'dtl 2/12/2010 19:53'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	"UIManager default request: 'Your name?'"	^ self		request: queryString		initialAnswer: ''		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'dtl 2/12/2010 19:52'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	"UIManager default 		request: 'What is your favorite color?' 		initialAnswer: 'red, no blue. Ahhh!!'"	^ self		request: queryString		initialAnswer: defaultAnswer		centerAt: (ActiveHand ifNil:[Sensor]) cursorPoint! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'dtl 2/12/2010 19:52'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint 	"Create an instance of me whose question is queryString with the given	initial answer. Invoke it centered at the given point, and answer the	string the user accepts. Answer the empty string if the user cancels."	"UIManager default		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView |	Smalltalk isMorphic 		ifTrue: 			[^self fillInTheBlankMorphClass 				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint].	model := self new.	model contents: defaultAnswer.	fillInView := self fillInTheBlankViewClass 				on: model				message: queryString				centerAt: aPoint.	^model show: fillInView! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'dtl 2/12/2010 19:53'!requestPassword: queryString 	"Create an instance of me whose question is queryString. Invoke it centered	at the cursor, and answer the string the user accepts. Answer the empty 	string if the user cancels."	"UIManager default requestPassword: 'POP password'"	| model fillInView |	Smalltalk isMorphic 		ifTrue: [^self fillInTheBlankMorphClass requestPassword: queryString].	model := self new.	model contents: ''.	fillInView := self fillInTheBlankViewClass 				requestPassword: model				message: queryString				centerAt: Sensor cursorPoint				answerHeight: 40.	^model show: fillInView! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 5/6/1998 15:13'!accept	super accept.	model done: true.! !!FillInTheBlankController methodsFor: 'other' stamp: 'sw 1/31/2000 14:47'!cancel	model setResponseForCancel.	super cancel.	model done: true.! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 4/28/1998 06:25'!dispatchOnCharacter: char with: typeAheadStream	"Accept the current input if the user hits the carriage return or the enter key."	(model acceptOnCR and:	 [(char = Character cr) | (char = Character enter)])		ifTrue: [			sensor keyboard.  "absorb the character"			self accept.			^ true]		ifFalse: [			^ super dispatchOnCharacter: char with: typeAheadStream].! !!FillInTheBlankController methodsFor: 'other' stamp: 'jm 4/28/1998 08:01'!processYellowButton	"Suppress yellow-button menu if acceptOnCR is true."	model acceptOnCR ifFalse: [^ super processYellowButton].! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'th 9/17/2002 16:46'!controlInitialize	model acceptOnCR ifFalse: [^ super controlInitialize].	self setMark: self markBlock stringIndex.	self setPoint: self pointBlock stringIndex.	self initializeSelection.	beginTypeInBlock := nil.! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'jm 5/6/1998 15:11'!controlTerminate	| topController |	super controlTerminate.	topController := view topView controller.	topController ifNotNil: [topController close].! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlActive	^ self isControlWanted! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlWanted	^ model done not! !!FillInTheBlankController commentStamp: '<historical>' prior: 0!I am the controller for a FillInTheBlankView. Based on a flag in the view, I can either accept the input string when a carriage return is typed, or I can allow multiple lines of input that is accepted by either typing enter or by invoking the 'accept' command.!!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'ar 7/13/2010 16:22'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w := self world.	w ifNil: [^ response].		(ProvideAnswerNotification signal:		(self submorphOfClass: TextMorph) userString) ifNotNil:		[:answer |		self delete.		w doOneCycle.		^ response := (answer == #default) ifTrue: [response] ifFalse: [answer]].	done := false.	w activeHand newKeyboardFocus: textPane.	[[done] whileFalse: [w doOneCycle]] ensure:[self delete].	w doOneCycle.	^ response! !!FillInTheBlankView methodsFor: 'controller access' stamp: 'jm 4/28/1998 06:37'!defaultControllerClass	^ FillInTheBlankController! !!FillInTheBlankView commentStamp: '<historical>' prior: 0!I am a view of a FillInTheBlank. I display a query and an editable view of the user's reply string.!!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:35'!multiLineOn: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView |	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:22'!on: aFillInTheBlank message: queryString centerAt: aPoint	"Answer an instance of me on aFillInTheBlank for a single line of input in response to the question queryString."	aFillInTheBlank acceptOnCR: true.	^ self		multiLineOn: aFillInTheBlank		message: queryString		centerAt: aPoint		answerHeight: 40! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jdr 6/4/2000 15:03'!requestPassword: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView myPar pwdFont myArray myStyle |	aFillInTheBlank acceptOnCR: true.	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	" now answerView to use the password font"	myPar := answerView displayContents.	pwdFont := (StrikeFont passwordFontSize: 12).	myArray := Array new: 1.	myArray at: 1 put: pwdFont.	myStyle := TextStyle fontArray: myArray.	myPar setWithText: (myPar text) style: myStyle.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FlapTabTests methodsFor: 'tests' stamp: 'laza 4/8/2010 11:09'!testFlapTabRecusion	| a b tab |	"Create a float close to 466.700581395349"	a := 1.1		at: 1 put: 1081944885;		at: 2 put: 2497074009;		yourself.	b := 105.	self deny: a + b - a = b.	tab := Flaps newFlapTitled: 'Test' onEdge: #top.	tab left: a.	self		should: [tab extent: b asPoint]		notTakeMoreThanMilliseconds: 10! !!FlapTabTests commentStamp: 'wiz 6/11/2007 17:58' prior: 0!A FlapTabTests is here to test infinite recursion bug when extent: message is sent to some flap tabs see http://bugs.squeak.org/view.php?id=6486 for report.Instance VariablesWe inherit cases which can be filled with morphs that need to be deleted at the end of the test.!!Float methodsFor: 'comparing' stamp: 'jdm 8/22/2007 19:23'!closeTo: num within: epsilon	"Are these two numbers within epsilon of each other?	Compare to #closeTo: which compares to within a percentage (0.01%);	we compare to an absolute number.  Useful for comparing floats in 3D	graphics matrices and vectors."	^((self - num) abs <= epsilon).! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:16'!arcCos	"Answer the angle in radians."	<primitive: 'primitiveArcCos' module: 'FloatMathPlugin'>	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/30/2007 06:11'!arcCosClamped	"This arcCos is protected against violations of the domain restriction 	by clamping the receiver's value to -1.0 ... +1.0. It is used for	dealing with rounding uncertainties in normalization and assumes that	the domain variances are tiny.  The primary use of the function is appled 	to dot products of normalized vectors, which can be trivially larger than 1."	<primitive: 'primitiveArcCos' module: 'FloatMathPlugin'>	(self >= 1.0) ifTrue:[ ^ 0.0 ].	(self <= -1.0) ifTrue:[ ^ Float pi ].	^ self arcCos.! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:20'!arcCosH	<primitive: 'primitiveArcCosH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:17'!arcSin	"Answer the angle in radians."	<primitive: 'primitiveArcSin' module: 'FloatMathPlugin'>	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:20'!arcSinH	<primitive: 'primitiveArcSinH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:44'!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveArcTan' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'arcTan is undefined for NaN'].	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	^self primitiveArcTan! !!Float methodsFor: 'mathematical functions' stamp: 'abc 2/12/2010 15:30'!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveArcTan2' module: 'FloatMathPlugin'>	^(self = 0.0) ifTrue: [		denominator sign >= 0			ifTrue: [ 0 ]			ifFalse: [ self sign >= 0				ifTrue: [ Pi ]				ifFalse: [ Pi negated ]]	] ifFalse: [		(denominator = 0.0) ifTrue: [ 			(self > 0.0) 				ifTrue: [ Halfpi ]				ifFalse: [ Halfpi negated ]		] ifFalse: [			denominator > 0				ifTrue: [ (self / denominator) arcTan ]				ifFalse: [self > 0					ifTrue: [ ((self / denominator) arcTan) + Pi ]					ifFalse: [ ((self / denominator) arcTan) - Pi ]]		].	].! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:20'!arcTanH	<primitive: 'primitiveArcTanH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:50'!cos	"Answer the cosine of the receiver taken as an angle in radians."	<primitive: 'primitiveCos' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'cos is undefined for NaN'].	self abs = Float infinity ifTrue:[^self error: 'cos is undefined for Infinity'].	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:21'!cosH	"Answer the cosine of the receiver taken as an angle in radians."	<primitive: 'primitiveCosH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:45'!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	<primitive: 'primitiveExp' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'exp is undefined for NaN'].	"For now, fall back to the Squeak version of exp if FloatMathPlugin is absent"	^self primitiveExp! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:23'!hypot: arg	"hypot(x,y) returns sqrt(x^2+y^2) with error less  than 1 ulps"	<primitive: 'primitiveHypot' module: 'FloatMathPlugin'>	arg isFloat ifFalse:[^self hypot: arg asFloat].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:24'!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveLogN' module: 'FloatMathPlugin'>	self <= 0.0 ifTrue: [^self error: 'ln is only defined for x > 0.0'].	^self primitiveLn! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:23'!log	"Answer the base 10 logarithm of the receiver."	<primitive: 'primitiveLog10' module: 'FloatMathPlugin'>	^ self ln / Ln10! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:50'!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveSin' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'sin is undefined for NaN'].	self abs = Float infinity ifTrue:[^self error: 'sin is undefined for Infinity'].	^self primitiveSin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:25'!sinH	<primitive: 'primitiveSinH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:27'!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	"ar 3/26/2006: sqrt is the ONE primitive that we really don't want to use from FloatMathPlugin - it's several times slower and we use it often enough that this can make a noticable difference"	<primitive: 55> "instead of: <primitive: 'primitiveSqrt' module: 'FloatMathPlugin'>"	^self primitiveSqrt! !!Float methodsFor: 'mathematical functions' stamp: 'ar 4/18/2006 10:47'!tan	"Answer the tangent of the receiver taken as an angle in radians."	<primitive: 'primitiveTan' module: 'FloatMathPlugin'>	self = self ifFalse:[^self error: 'tan is undefined for NaN'].	^ self sin / self cos! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:28'!tanH	<primitive: 'primitiveTanH' module: 'FloatMathPlugin'>	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:29'!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveTimesTwoPower' module: 'FloatMathPlugin'>	^self primitiveTimesTwoPower: anInteger! !!Float methodsFor: 'testing' stamp: 'bf 8/20/1999 12:56'!isFloat	^ true! !!Float methodsFor: 'truncation and round off' stamp: 'ar 3/26/2006 17:13'!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 'primitiveFractionalPart' module: 'FloatMathPlugin'>	^self - self truncated asFloat! !!Float methodsFor: 'accessing' stamp: 'eem 4/19/2009 18:03'!at: index 	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'eem 4/19/2009 18:03'!at: index put: value 	^self basicAt: index put: value! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:34'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 38 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index].	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:35'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 39 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index put: value].	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:18'!primitiveArcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta := (self * Halfpi) / (self + 1.0).	"iterate"	eps := Halfpi * Epsilon.	step := theta.	[(step * step) > eps] whileTrue: [		sinTheta := theta sin.		cosTheta := theta cos.		step := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta := theta - step].	^ theta! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:07'!primitiveExp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base := E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract := self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction := 1.0 + fract.	delta := fract * fract / 2.0.	div := 2.0.	[delta > Epsilon] whileTrue: [		correction := correction + delta.		div := div + 1.0.		delta := delta * fract / div].	correction := correction + delta.	^ base * correction! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:07'!primitiveFractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:15'!primitiveLn	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:08'!primitiveSin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum := delta := self.	self2 := 0.0 - (self * self).	i := 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta.		"twice"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta].	^ sum! !!Float methodsFor: 'primitives' stamp: 'ar 11/13/2007 16:00'!primitiveSqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: [^FloatingPointException signal: 'sqrt is undefined for ', self]].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:08'!primitiveTimesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float class methodsFor: 'constants' stamp: 'tao 4/23/98 12:05'!pi	"Answer the constant, Pi."	^Pi! !!Float class methodsFor: 'constants' stamp: 'jjl 1/14/2008 18:49'!sqrt2	^ Sqrt2! !!Float class methodsFor: 'constants' stamp: 'jjl 12/10/2007 12:19'!twoPi	^ 2 * self pi.! !!FloatArray methodsFor: 'accessing' stamp: 'bgf 3/21/2008 15:52'!length	"Return the length of the receiver"	<primitive: 'primitiveLength' module: 'FloatArrayPlugin'>	^ self squaredLength sqrt! !!FloatArray methodsFor: 'accessing' stamp: 'bgf 3/21/2008 16:53'!normalize	"Unsafely normalize the receiver in-place (become a unit vector). 	 Div-by-Zero raised if len 0."	<primitive: 'primitiveNormalize' module: 'FloatArrayPlugin'>	self /= self length.! !!FloatArray methodsFor: 'accessing' stamp: 'bgf 3/21/2008 16:54'!normalized	"Return a new unit vector in the same direction as the original.	 If the original has len 0, a div-zero exception is raised."	^ self clone normalize! !!FloatArray methodsFor: 'accessing' stamp: 'bgf 3/21/2008 16:53'!safelyNormalize	| length |	"Safely normalize the receiver (even if len 0) in-place."	<primitive: 'primitiveNormalize' module: 'FloatArrayPlugin'>	length := self length.	length = 1.0 ifTrue:[^self].	length = 0.0 ifFalse:[self /= length].! !!FloatArray methodsFor: 'accessing' stamp: 'bgf 3/21/2008 16:51'!safelyNormalized	"Return a new unit vector in the same direction as the original.	 If the original has len 0, its copy is returned."	^ self clone safelyNormalize! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 6/16/2002 21:52'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	<primitive:'primitiveDotProduct' module: 'FloatArrayPlugin'>	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result := 0.0.	1 to: self size do:[:i|		result := result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 6/23/2002 16:23'!*= anObject	<primitive: 'primitiveMulScalar' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 6/23/2002 16:22'!+= anObject	<primitive: 'primitiveAddFloatArray' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 6/23/2002 16:22'!-= anObject	<primitive: 'primitiveSubFloatArray' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 6/23/2002 16:23'!/= anObject	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'comparing' stamp: 'jdm 10/9/2007 15:31'!closeTo: aFloatArray	^self closeTo: aFloatArray within: 1.0e-3.! !!FloatArray methodsFor: 'comparing' stamp: 'jdm 8/22/2007 19:24'!closeTo: aFloatArray within: epsilon	| length |"	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>"	aFloatArray class = self class ifFalse: [^ false].	length := self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | 		((self at: i) closeTo: (aFloatArray at: i) within: epsilon) 			ifFalse: [^ false]	].	^ true! !!FloatArray methodsFor: 'testing' stamp: 'bgf 3/1/2008 22:24'!isFloatArray	^ true! !!FloatArrayTest methodsFor: 'testing' stamp: 'nice 11/23/2007 23:53'!testArithmeticCoercion	"This test is related to http://bugs.squeak.org/view.php?id=6782"		self should: [3.0 / (FloatArray with: 2.0) = (FloatArray with: 1.5)].	self should: [3.0 * (FloatArray with: 2.0) = (FloatArray with: 6.0)].	self should: [3.0 + (FloatArray with: 2.0) = (FloatArray with: 5.0)].	self should: [3.0 - (FloatArray with: 2.0) = (FloatArray with: 1.0)].! !!FloatArrayTest methodsFor: 'testing' stamp: 'nice 5/30/2006 03:17'!testFloatArrayPluginPrimitiveAt	"if FloatArrayPlugin primitive are not here, this test is dumb.	Otherwise, it will compare primitive and #fromIEEE32Bit:"		#(		"regular numbers no truncation or rounding"		2r0.0 2r1.0 2r1.1 2r1.00000000000000000000001		2r1.0e-10 2r1.1e-10 2r1.00000000000000000000001e-10		2r1.0e10 2r1.1e10 2r1.00000000000000000000001e10				"smallest float32 before gradual underflow"		2r1.0e-126				"biggest float32"		2r1.11111111111111111111111e127				"overflow"		2r1.11111111111111111111111e128				"gradual underflow"		2r0.11111111111111111111111e-126		2r0.00000000000000000000001e-126				"with rounding mode : tests on 25 bits"				2r1.0000000000000000000000001		2r1.0000000000000000000000010		2r1.0000000000000000000000011		2r1.0000000000000000000000100		2r1.0000000000000000000000101		2r1.0000000000000000000000110		2r1.0000000000000000000000111		2r1.1111111111111111111111001		2r1.1111111111111111111111010		2r1.1111111111111111111111011		2r1.1111111111111111111111101		2r1.1111111111111111111111110		2r1.1111111111111111111111111				"overflow"		2r1.1111111111111111111111110e127				"gradual underflow"		2r0.1111111111111111111111111e-126		2r0.1111111111111111111111110e-126		2r0.1111111111111111111111101e-126		2r0.1111111111111111111111011e-126		2r0.1111111111111111111111010e-126		2r0.1111111111111111111111001e-126		2r0.0000000000000000000000111e-126		2r0.0000000000000000000000110e-126		2r0.0000000000000000000000101e-126		2r0.0000000000000000000000011e-126		2r0.0000000000000000000000010e-126		2r0.0000000000000000000000001e-126		2r0.0000000000000000000000010000000000000000000000000001e-126		) do: [:e |			self assert: ((FloatArray with: e) at: 1) = (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1)).			self assert: ((FloatArray with: e negated) at: 1) = (Float fromIEEE32Bit: ((FloatArray with: e negated) basicAt: 1))].			"special cases"	(Array with: Float infinity with: Float infinity negated with: Float negativeZero)		do: [:e | self assert: ((FloatArray with: e) at: 1) = (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1))].			"Cannot compare NaN"	(Array with: Float nan)		do: [:e | self assert: (Float fromIEEE32Bit: ((FloatArray with: e) basicAt: 1)) isNaN].! !!FloatArrayTest methodsFor: 'testing' stamp: 'nice 5/30/2006 03:17'!testFloatArrayPluginPrimitiveAtPut	"if FloatArrayPlugin primitive are not here, this test is dumb.	Otherwise, it will compare primitive and #asIEEE32BitWord"		#(		"regular numbers no truncation or rounding"		2r0.0 2r1.0 2r1.1 2r1.00000000000000000000001		2r1.0e-10 2r1.1e-10 2r1.00000000000000000000001e-10		2r1.0e10 2r1.1e10 2r1.00000000000000000000001e10				"smallest float32 before gradual underflow"		2r1.0e-126				"biggest float32"		2r1.11111111111111111111111e127				"overflow"		2r1.11111111111111111111111e128				"gradual underflow"		2r0.11111111111111111111111e-126		2r0.00000000000000000000001e-126				"with rounding mode : tests on 25 bits"				2r1.0000000000000000000000001		2r1.0000000000000000000000010		2r1.0000000000000000000000011		2r1.0000000000000000000000100		2r1.0000000000000000000000101		2r1.0000000000000000000000110		2r1.0000000000000000000000111		2r1.1111111111111111111111001		2r1.1111111111111111111111010		2r1.1111111111111111111111011		2r1.1111111111111111111111101		2r1.1111111111111111111111110		2r1.1111111111111111111111111				"overflow"		2r1.1111111111111111111111110e127				"gradual underflow"		2r0.1111111111111111111111111e-126		2r0.1111111111111111111111110e-126		2r0.1111111111111111111111101e-126		2r0.1111111111111111111111011e-126		2r0.1111111111111111111111010e-126		2r0.1111111111111111111111001e-126		2r0.0000000000000000000000111e-126		2r0.0000000000000000000000110e-126		2r0.0000000000000000000000101e-126		2r0.0000000000000000000000011e-126		2r0.0000000000000000000000010e-126		2r0.0000000000000000000000001e-126		2r0.0000000000000000000000010000000000000000000000000001e-126		) do: [:e |			self assert: ((FloatArray with: e) basicAt: 1) = e asIEEE32BitWord.			self assert: ((FloatArray with: e negated) basicAt: 1) = e negated asIEEE32BitWord].			"special cases"	(Array with: Float infinity with: Float infinity negated with: Float negativeZero with: Float nan)		do: [:e | self assert: ((FloatArray with: e) basicAt: 1) = e asIEEE32BitWord].		! !!FloatArrayTest commentStamp: 'nice 5/30/2006 01:24' prior: 0!These tests are used to assert that FloatArrayPlugin has same results as Float asIEEE32BitWord!!FloatTest methodsFor: 'failures' stamp: 'ar 7/27/2010 12:11'!expectedFailures	"Issues with Cogit"	^Smalltalk isRunningCogit ifTrue:[		#(testCloseTo testDivide testHugeIntegerCloseTo		testInfinityCloseTo testNaNCompare testRaisedTo		testReciprocal)	] ifFalse:[#()]! !!FloatTest methodsFor: 'IEEE 754' stamp: 'nice 5/30/2006 02:34'!test32bitGradualUnderflow	"method asIEEE32BitWord did not respect IEEE gradual underflow"		| conv expected exponentPart |		"IEEE 32 bits Float have 1 bit sign/8 bit exponent/23 bits of mantissa after leading 1	2r1.mmmmmmmmmmmmmmmmmmmmmmm * (2 raisedTo: 2reeeeeeee-127) * sign	except when 2reeeeeeee isZero, which is a gradual underflow:	2r0.mmmmmmmmmmmmmmmmmmmmmmm * (2 raisedTo: 2r00000000-126) * sign	and when 2reeeeeeee = 255, which is infinity if mantissa all zero or nan otherwise"		"case 1: This example is the first gradual underflow case"	conv := 2r0.11111111111111111111111e-126 asIEEE32BitWord.		"expected float encoded as sign/exponent/mantissa (whithout leading 1 or 0)"	exponentPart := 0.	expected := exponentPart bitOr: 2r11111111111111111111111.	self assert: expected = conv.		"case 2: smallest number"	conv := 2r0.00000000000000000000001e-126 asIEEE32BitWord.	expected := exponentPart bitOr: 2r1.	self assert: expected = conv.		"case 3: round to nearest even also in underflow cases... here round to upper"	conv := 2r0.000000000000000000000011e-126 asIEEE32BitWord.	expected := exponentPart bitOr: 2r10.	self assert: expected = conv.		"case 4: round to nearest even also in underflow cases... here round to lower"	conv := 2r0.000000000000000000000101e-126 asIEEE32BitWord.	expected := exponentPart bitOr: 2r10.	self assert: expected = conv.		"case 5: round to nearest even also in underflow cases... here round to upper"	conv := 2r0.0000000000000000000001011e-126 asIEEE32BitWord.	expected := exponentPart bitOr: 2r11.	self assert: expected = conv.	! !!FloatTest methodsFor: 'IEEE 754' stamp: 'nice 5/30/2006 00:07'!test32bitRoundingMode	"method asIEEE32BitWord did not respect IEEE default rounding mode"		| conv expected exponentPart |		"IEEE 32 bits Float have 1 bit sign/8 bit exponent/23 bits of mantissa after leading 1	2r1.mmmmmmmmmmmmmmmmmmmmmmm * (2 raisedTo: 2reeeeeeee-127) * sign	except when 2reeeeeeee isZero, which is a gradual underflow:	2r0.mmmmmmmmmmmmmmmmmmmmmmm * (2 raisedTo: 2r00000000-127) * sign	and when 2reeeeeeee = 255, which is infinity if mantissa all zero or nan otherwise"		"This example has two extra bits in mantissa for testing rounding mode	case 1: should obviously round to upper"	conv := 2r1.0000000000000000000000111e25 asIEEE32BitWord.		"expected float encoded as sign/exponent/mantissa (whithout leading 1)"	exponentPart := 25+127 bitShift: 23. "127 is 2r01111111 or 16r7F"	expected := exponentPart bitOr: 2r10.	self assert: expected = conv.		"case 2: exactly in the mid point of two 32 bit float: round toward nearest even (to upper)"	conv := 2r1.0000000000000000000000110e25 asIEEE32BitWord.	expected := exponentPart bitOr: 2r10.	self assert: expected = conv.		"case 3: exactly in the mid point of two 32 bit float: round toward nearest even (to lower)"	conv := 2r1.0000000000000000000000010e25 asIEEE32BitWord.	expected := exponentPart bitOr: 2r0.	self assert: expected = conv.		"case 4: obviously round to upper"	conv := 2r1.0000000000000000000000011e25 asIEEE32BitWord.	expected := exponentPart bitOr: 2r1.	self assert: expected = conv.! !!FloatTest methodsFor: 'IEEE 754' stamp: 'pmm 2/27/2006 10:49'!testInfinity3	self assert: (Float infinity negated asIEEE32BitWord printPaddedWith: $0 to: 32 base: 2) =		'11111111100000000000000000000000'.	self assert: (Float fromIEEE32Bit:		(Integer readFrom: '11111111100000000000000000000000' readStream base: 2))			= Float infinity negated! !!FloatTest methodsFor: 'IEEE 754' stamp: 'mha 7/30/2009 16:15'!testNaN5	| nanstr |		"check the NaN string representation conforms to IEEE 754"	nanstr := Float nan asIEEE32BitWord printPaddedWith: $0 to: 32 base: 2.	self		assert: (#($0 $1) includes: (nanstr at: 1));		assert: (nanstr copyFrom: 2 to: 9) = '11111111';		assert: (#($0 $1) includes: (nanstr at: 10)); "accept both quiet and signalled NaNs"		assert: ((nanstr copyFrom: 11 to: 32) reject: [ :c | #($0 $1) includes: c ]) isEmpty.		"check a correct quiet NaN is created from a string"	self assert: (Float fromIEEE32Bit:		(Integer readFrom: '01111111110000000000000000000000' readStream base: 2)) isNaN! !!FloatTest methodsFor: 'IEEE 754' stamp: 'pmm 2/27/2006 10:49'!testZero2	self assert: (Float negativeZero asIEEE32BitWord printPaddedWith: $0 to: 32 base: 2) =		'10000000000000000000000000000000'.	self assert: (Float fromIEEE32Bit:		(Integer readFrom: '10000000000000000000000000000000' readStream base: 2))			= Float negativeZero! !!FloatTest methodsFor: 'testing' stamp: 'nice 10/30/2009 22:23'!testArcTan	self assert: ((100 arcTan: 100) closeTo: Float pi / 4).	self assert: ((-100 arcTan: 100) closeTo: Float pi / -4).	self assert: ((100 arcTan: -100) closeTo: Float pi * 3 / 4).	self assert: ((-100 arcTan: -100) closeTo: Float pi * -3 / 4).	self assert: ((0 arcTan: 100) closeTo: 0).	self assert: ((0 arcTan: -100) closeTo: Float pi).	self assert: ((100 arcTan: 0) closeTo: Float pi / 2).	self assert: ((-100 arcTan: 0) closeTo: Float pi / -2).		self assert: ((Float negativeZero arcTan: 100) closeTo: 0).	self assert: ((Float negativeZero arcTan: -100) closeTo: Float pi * -1).		self assert: (0 arcTan: 0) = 0.	self assert: (Float negativeZero arcTan: 0) = 0.	self assert: ((0 arcTan: Float negativeZero) closeTo: Float pi).	self assert: ((Float negativeZero arcTan: Float negativeZero) closeTo: Float pi negated). ! !!FloatTest methodsFor: 'testing' stamp: 'nice 10/4/2009 23:13'!testCopy	"Elementary tests"	self assert: 2.0 copy = 2.0.	self assert: -0.5 copy = -0.5.		"Are exceptional Floats preserved by the copy ?"	self assert: Float nan copy isNaN.	self assert: Float infinity copy = Float infinity.	self assert: Float infinity negated copy = Float infinity negated.		"Is the sign of zero preserved by the copy ?"	self assert: 0.0 copy hex = 0.0 hex.	self assert: Float negativeZero copy hex = Float negativeZero hex.! !!FloatTest methodsFor: 'testing' stamp: 'nice 2/13/2010 04:15'!testSetOfFloat	"Classical disagreement between hash and = did lead to a bug.	This is a non regression test from http://bugs.squeak.org/view.php?id=3360"	| size3 size4 |	size3 := (Set new: 3) add: 3; add: 3.0; size.	size4 := (Set new: 4) add: 3; add: 3.0; size.	self assert: size3 = size4 description: 'The size of a Set should not depend on its capacity.'! !!FloatTest methodsFor: 'testing' stamp: 'nice 11/1/2009 18:58'!testStoreOn	"If storeOn: prints exactly and the parser avoid cumulating round off Errors,	then Float should be read back exactly.	Note: there is no guarantee to restore the bit pattern of NaN though"		self assert: (Compiler evaluate: Float halfPi storeString) = Float halfPi.	self assert: (Compiler evaluate: Float halfPi negated storeString) = Float halfPi negated.	self assert: (Compiler evaluate: Float infinity storeString) = Float infinity.	self assert: (Compiler evaluate: Float infinity negated storeString) = Float infinity negated.	self assert: (Compiler evaluate: Float nan storeString) isNaN.! !!FloatTest methodsFor: 'characterization' stamp: 'nice 6/11/2009 20:47'!testCharacterization	"Test the largest finite representable floating point value"	self assert: Float fmax successor = Float infinity.	self assert: Float infinity predecessor = Float fmax.	self assert: Float fmax negated predecessor = Float infinity negated.	self assert: Float infinity negated successor = Float fmax negated.		"Test the smallest positive representable floating point value"	self assert: Float fmin predecessor = 0.0.	self assert: 0.0 successor = Float fmin.	self assert: Float fmin negated successor = 0.0.	self assert: 0.0 predecessor = Float fmin negated.		"Test the relative precision"	self assert: Float one + Float epsilon > Float one.	self assert: Float one + Float epsilon = Float one successor.	self assert: Float one + (Float epsilon / Float radix) = Float one.		"Test maximum and minimum exponent"	self assert: Float fmax exponent = Float emax.	self assert: Float fminNormalized exponent = Float emin.	Float denormalized ifTrue: [		self assert: Float fminDenormalized exponent = (Float emin + 1 - Float precision)].		"Alternative tests for maximum and minimum"	self assert: (Float radix - Float epsilon) * (Float radix raisedTo: Float emax) = Float fmax.	self assert: Float epsilon * (Float radix raisedTo: Float emin) = Float fmin.		"Test sucessors and predecessors"	self assert: Float one predecessor successor = Float one.	self assert: Float one successor predecessor = Float one.	self assert: Float one negated predecessor successor = Float one negated.	self assert: Float one negated successor predecessor = Float one negated.	self assert: Float infinity successor = Float infinity.	self assert: Float infinity negated predecessor = Float infinity negated.	self assert: Float nan predecessor isNaN.	self assert: Float nan successor isNaN.		"SPECIFIC FOR IEEE 754 double precision - 64 bits"	self assert: Float fmax hex = '7FEFFFFFFFFFFFFF'.	self assert: Float fminDenormalized hex = '0000000000000001'.	self assert: Float fminNormalized hex = '0010000000000000'.	self assert: 0.0 hex = '0000000000000000'.	self assert: Float negativeZero hex = '8000000000000000'.	self assert: Float one hex = '3FF0000000000000'.	self assert: Float infinity hex = '7FF0000000000000'.	self assert: Float infinity negated hex = 'FFF0000000000000'.! !!FloatTest methodsFor: 'testing compare' stamp: 'nice 7/19/2009 19:24'!testCloseTo	self deny: (Float nan closeTo: Float nan) description: 'NaN isn''t close to anything'.	self deny: (Float nan closeTo: 1.0) description: 'NaN isn''t close to anything'.	self deny: (1.0 closeTo: Float nan) description: 'NaN isn''t close to anything'.		self deny: (-1.0 closeTo: 1.0).	self deny: (1.0 closeTo: Float infinity).	self assert: (Float infinity closeTo: Float infinity) description: 'since they are =, they also are closeTo:'.		self assert: (1.0/3.0 closeTo: 1/3).	self assert: (1.0e-8 closeTo: 0).	self assert: (0 closeTo: 1.0e-8).	self assert: (1+1.0e-8 closeTo: 1.0).		self assert: (1000000001.0 closeTo: 1000000000.0).	self deny: (1000000001 closeTo: 1000000000) description: 'exact representation are considered closeTo: only if equal'.! !!FloatTest methodsFor: 'testing compare' stamp: 'nice 5/30/2008 01:23'!testComparison		"test equality when Float conversion loose bits"	| a b c |	a := 16r1FFFFFFFFFFFFF1.	b := 16r1FFFFFFFFFFFFF3.	c := a asFloat.	self assert: ((a = c) & (b = c)) ==> (a = b).		"Test equality when Float conversion exact"	self assert: 16r1FFFFFFFFFFFFF = 16r1FFFFFFFFFFFFF asFloat.	self assert: 16r1FFFFFFFFFFFFF = 16r1FFFFFFFFFFFFF asFloat asInteger.		"Test inequality when Float conversion loose bits"	self assert: (((1 bitShift: 54)+1)/(1 bitShift: 54)) > 1.	self assert: (((1 bitShift: 54)+1)/(1 bitShift: 54)) > 1.0.		self assert: (((1 bitShift: 54)-1)/(1 bitShift: 54)) < 1.	self assert: (((1 bitShift: 54)-1)/(1 bitShift: 54)) < 1.0.		"Test exact vs inexact arithmetic"	(1 to: 100) do: [:i |		i isPowerOfTwo			ifTrue: [self assert: (1/i) = (1/i) asFloat]			ifFalse: [self deny: (1/i) = (1/i) asFloat]].		"Test overflow (compare to infinity)"	a := (11 raisedTo: 400) / 2.	b := (13 raisedTo: 400) / 2.	c := a asFloat.	self assert: ((a = c) & (b = c)) ==> (a = b).		"every integer is smaller than infinity"	self assert: a < Float infinity.	self assert: a > Float infinity negated.		"Test underflow"	self deny: 1 / (11 raisedTo: 400) = 0.	self deny: 1 / (11 raisedTo: 400) = 0.0.		"Test hash code"	self assert:		((Set new: 3) add: 3; add: 3.0; size) =		((Set new: 4) add: 3; add: 3.0; size).! !!FloatTest methodsFor: 'testing compare' stamp: 'nice 7/10/2009 22:27'!testComparisonWhenPrimitiveFails	"This is related to http://bugs.squeak.org/view.php?id=7361"	self deny: 0.5 < (1/4).	self deny: 0.5 < (1/2).	self assert: 0.5 < (3/4).		self deny: 0.5 <= (1/4).	self assert: 0.5 <= (1/2).	self assert: 0.5 <= (3/4).		self assert: 0.5 > (1/4).	self deny: 0.5 > (1/2).	self deny: 0.5 > (3/4).		self assert: 0.5 >= (1/4).	self assert: 0.5 >= (1/2).	self deny: 0.5 >= (3/4).		self deny: 0.5 = (1/4).	self assert: 0.5 = (1/2).	self deny: 0.5 = (3/4).		self assert: 0.5 ~= (1/4).	self deny: 0.5 ~= (1/2).	self assert: 0.5 ~= (3/4).! !!FloatTest methodsFor: 'testing - arithmetic' stamp: 'st 9/20/2004 17:04'!testContinuedFractions	self assert: (Float pi asApproximateFractionAtOrder: 1) = (22/7).	self assert: (Float pi asApproximateFractionAtOrder: 3) = (355/113)! !!FloatTest methodsFor: 'testing - arithmetic' stamp: 'GabrielOmarCotelli 6/6/2009 17:14'!testDivide	self assert: 1.5 / 2.0 = 0.75.		self assert: 2.0 / 1 = 2.0.		self should: [ 2.0 / 0 ] raise: ZeroDivide.	self should: [ 2.0 / 0.0 ] raise: ZeroDivide.	self should: [ 1.2 / Float negativeZero ] raise: ZeroDivide.	self should: [ 1.2 / (1.3 - 1.3) ] raise: ZeroDivide	! !!FloatTest methodsFor: 'testing - arithmetic' stamp: 'nice 12/1/2007 17:59'!testRaisedTo	"this is a test related to http://bugs.squeak.org/view.php?id=6781"		self should: [0.0 raisedTo: -1] raise: ZeroDivide.	self should: [0.0 raisedTo: -1.0] raise: ZeroDivide.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 7/24/2008 02:04'!testFloatRounded	"5000000000000001 asFloat has an exact representation (no round off error).	It should round to nearest integer without loosing bits.	This is a no regression test on http://bugs.squeak.org/view.php?id=7134"		| x y int r |		"This is a preamble asserting exactness of representation	and quality of various conversions"	int := 5000000000000001.	x := int asFloat.	y := (5 asFloat squared squared squared squared timesTwoPower: 15) + 1.	self assert: x = y.	self assert: x asTrueFraction = int.		"this one should be true for any float	in order to conform to ISO/IEC 10967-2"	self assert: x rounded = x asTrueFraction rounded.	self assert: x negated rounded = x negated asTrueFraction rounded.	"a random test"	r := Random new.	10000 timesRepeat: [		x := r next * 1.9999e16 + 1.0e12 .		self assert: x rounded = x asTrueFraction rounded.		self assert: x negated rounded = x negated asTrueFraction rounded]! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 4/26/2006 05:21'!testFloatTruncated	"(10 raisedTo: 16) asFloat has an exact representation (no round off error).	It should convert back to integer without loosing bits.	This is a no regression test on http://bugs.impara.de/view.php?id=3504"		| x y int r |	int := 10 raisedTo: 16.	x := int asFloat.	y := (5 raisedTo: 16) asFloat timesTwoPower: 16.	self assert: x = y.		self assert: x asInteger = int.		"this one should be true for any float"	self assert: x asInteger = x asTrueFraction asInteger.	"a random test"	r := Random new.	10000 timesRepeat: [		x := r next * 1.9999e16 + 1.0e12 .		self assert: x truncated = x asTrueFraction truncated]! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 5/7/2006 16:22'!testFractionAsFloat	"use a random test"		| r m frac err collec |	r := Random new seed: 1234567.	m := (2 raisedTo: 54) - 1.	200 timesRepeat: [		frac := ((r nextInt: m) * (r nextInt: m) + 1) / ((r nextInt: m) * (r nextInt: m) + 1).		err := (frac - frac asFloat asTrueFraction) * frac reciprocal * (1 bitShift: 52).		self assert: err < (1/2)].		collec := #(16r10000000000000 16r1FFFFFFFFFFFFF 1 2 16r20000000000000 16r20000000000001 16r3FFFFFFFFFFFFF 16r3FFFFFFFFFFFFE 16r3FFFFFFFFFFFFD).	collec do: [:num |		collec do: [:den |			frac := Fraction numerator: num denominator: den.			err := (frac - frac asFloat asTrueFraction) * frac reciprocal * (1 bitShift: 52).			self assert: err <= (1/2)]].! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 1/10/2007 02:29'!testFractionAsFloat2	"test rounding to nearest even"			self assert: ((1<<52)+0+(1/4)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(1/2)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(3/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/2)) asFloat asTrueFraction = ((1<<52)+2).	self assert: ((1<<52)+1+(3/4)) asFloat asTrueFraction = ((1<<52)+2).! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 5/6/2006 22:13'!testIntegerAsFloat	"assert IEEE 754 round to nearest even mode is honoured"		self deny: 16r1FFFFFFFFFFFF0801 asFloat = 16r1FFFFFFFFFFFF0800 asFloat. "this test is on 65 bits"	self deny: 16r1FFFFFFFFFFFF0802 asFloat = 16r1FFFFFFFFFFFF0800 asFloat. "this test is on 64 bits"	self assert: 16r1FFFFFFFFFFF1F800 asFloat = 16r1FFFFFFFFFFF20000 asFloat. "nearest even is upper"	self assert: 16r1FFFFFFFFFFFF0800 asFloat = 16r1FFFFFFFFFFFF0000 asFloat. "nearest even is lower"! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 3/14/2008 23:59'!testReadFromManyDigits	"A naive algorithm may interpret these representations as Infinity or NaN.	This is http://bugs.squeak.org/view.php?id=6982"		| s1 s2 |	s1 := '1' , (String new: 321 withAll: $0) , '.0e-321'.	s2 := '0.' , (String new: 320 withAll: $0) , '1e321'.	self assert: (Number readFrom: s1) = 1.	self assert: (Number readFrom: s2) = 1.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'dtl 9/18/2004 12:40'!testStringAsNumber	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '10r-12.3456' asNumber.	self assert: -12.3456 = aFloat.	aFloat := '10r-12.3456e2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456d2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '12.3456q2' asNumber.	self assert: 1234.56 = aFloat.! !!FloatTest methodsFor: 'infinity behavior' stamp: 'nice 7/14/2009 09:32'!testHugeIntegerCloseTo	"This is a test for bug http://bugs.squeak.org/view.php?id=7368"	 	"FloatTest new testHugeIntegerCloseTo"	self deny: (1.0 closeTo: 200 factorial).	self deny: (200 factorial closeTo: 1.0).	self assert: (Float infinity closeTo: 200 factorial) = (200 factorial closeTo: Float infinity).! !!FloatTest methodsFor: 'infinity behavior' stamp: 'sd 6/5/2005 08:30'!testInfinity1   "FloatTest new testInfinity1"	| i1  i2 |	i1 := 10000 exp.	i2 := 1000000000 exp.	self assert: i1 isInfinite & i2 isInfinite & (i1 = i2).	"All infinities are equal. (This is a very substantial difference to NaN's, which are never equal."! !!FloatTest methodsFor: 'infinity behavior' stamp: 'sd 6/5/2005 08:30'!testInfinity2   "FloatTest new testInfinity2"	| i1  i2 |	i1 := 10000 exp.	i2 := 1000000000 exp.	i2 := 0 - i2. " this is entirely ok. You can compute with infinite values."	self assert: i1 isInfinite & i2 isInfinite & i1 positive & i2 negative.	self deny: i1 = i2.  	"All infinities are signed. Negative infinity is not equal to Infinity"! !!FloatTest methodsFor: 'infinity behavior' stamp: 'nice 10/17/2007 23:54'!testInfinityCloseTo	"This is a test for bug http://bugs.squeak.org/view.php?id=6729:"	 	"FloatTest new testInfinityCloseTo"	self deny: (Float infinity closeTo: Float infinity negated).	self deny: (Float infinity negated closeTo: Float infinity).! !!FloatTest methodsFor: 'zero behavior' stamp: 'md 4/16/2003 15:02'!testIsZero	self assert: 0.0 isZero.	self deny:  0.1 isZero.! !!FloatTest methodsFor: 'zero behavior' stamp: 'sd 6/5/2005 08:33'!testZero1	"FloatTest new testZero1"	self assert: Float negativeZero = 0 asFloat.	self assert: (Float negativeZero at: 1) ~= (0 asFloat at: 1).	"The negative zero has a bit representation that is different from the bit representation of the positive zero. Nevertheless, both values are defined to be equal."! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 3/23/2008 16:00'!testZeroSignificandAsInteger	"This is about http://bugs.squeak.org/view.php?id=6990"		self assert: 0.0 significandAsInteger = 0! !!FloatTest methodsFor: 'NaN behavior' stamp: 'sd 6/5/2005 08:31'!testNaN1   	"FloatTest new testNaN1"	self assert: Float nan == Float nan.	self deny: Float nan = Float nan.	"a NaN is not equal to itself."! !!FloatTest methodsFor: 'NaN behavior' stamp: 'rej 10/7/2007 20:40'!testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size = 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!FloatTest methodsFor: 'NaN behavior' stamp: 'sd 6/5/2005 08:32'!testNaN3   "FloatTest new testNaN3"   	| set item identitySet |	set := Set new.	set add: (item := Float nan).	self deny: (set includes: item).	identitySet := IdentitySet new.	identitySet add: (item := Float nan).	self assert: (identitySet includes: item).	"as a NaN is not equal to itself, it can not be retrieved from a set"! !!FloatTest methodsFor: 'NaN behavior' stamp: 'sd 6/5/2005 08:32'!testNaN4   	"FloatTest new testNaN4"	| dict |	dict := Dictionary new.	dict at: Float nan put: #NaN.	self deny: (dict includes: Float nan).	"as a NaN is not equal to itself, it can not be retrieved when it is used as a dictionary key"! !!FloatTest methodsFor: 'NaN behavior' stamp: 'nice 10/11/2007 00:09'!testNaNCompare	"IEEE 754 states that NaN cannot be ordered.	As a consequence, every arithmetic comparison involving a NaN SHOULD return false.	Except the is different test (~=).	This test does verify this rule"		| compareSelectors theNaN anotherNaN comparand brokenMethods warningMessage |	compareSelectors := #(#< #<= #> #>= #=).	theNaN := Float nan.	anotherNaN := Float infinity - Float infinity.	comparand := {1. 2.3. Float infinity. 2/3. 1.25s2. 2 raisedTo: 50}.	comparand := comparand , (comparand collect: [:e | e negated]).	comparand := comparand , {theNaN. anotherNaN}."do a first pass to collect all broken methods"	brokenMethods := Set new.	comparand do: [:comp |		compareSelectors do: [:op |			(theNaN perform: op with: comp) ifTrue: [brokenMethods add: (theNaN class lookupSelector: op)].			(comp perform: op with: theNaN) ifTrue: [brokenMethods add: (comp class lookupSelector: op)]].		(theNaN ~= comp) ifFalse: [brokenMethods add: (theNaN class lookupSelector: #~=)].		(comp ~= theNaN) ifFalse: [brokenMethods add: (comp class lookupSelector: #~=)]].	"build a warning message to tell about all broken methods at once"	warningMessage := String streamContents: [:s |			s nextPutAll: 'According to IEEE 754 comparing with a NaN should always return false, except ~= that should return true.'; cr.			s nextPutAll: 'All these methods failed to do so. They are either broken or call a broken one'.			brokenMethods do: [:e | s cr; print: e methodClass; nextPutAll: '>>'; print: e selector]].		"Redo the tests so as to eventually open a debugger on one of the failures"	brokenMethods := Set new.	comparand do: [:comp2 |		compareSelectors do: [:op2 |			self deny: (theNaN perform: op2 with: comp2) description: warningMessage.			self deny: (comp2 perform: op2 with: theNaN) description: warningMessage].		self assert: (theNaN ~= comp2) description: warningMessage.		self assert: (comp2 ~= theNaN) description: warningMessage].! !!FloatTest methodsFor: 'NaN behavior' stamp: 'nice 3/14/2008 23:42'!testNaNisLiteral	self deny: Float nan isLiteral description: 'there is no literal representation of NaN'! !!FloatTest methodsFor: 'NaN behavior' stamp: 'GabrielOmarCotelli 5/23/2009 20:38'!testReciprocal	self 		assert: 1.0 reciprocal = 1.0;		assert: 2.0 reciprocal = 0.5;		assert: -1.0 reciprocal = -1.0;		assert: -2.0 reciprocal = -0.5.			self should: [ 0.0 reciprocal ] raise: ZeroDivide! !!FloatTest methodsFor: 'printing' stamp: 'nice 10/11/2008 21:45'!testStoreBase16	"This bug was reported in mantis http://bugs.squeak.org/view.php?id=6695"	self		assert: (20.0 storeStringBase: 16) = '16r14.0'		description: 'the radix prefix should not be omitted, except in base 10'! !!FloatTest commentStamp: 'fbs 3/8/2004 22:13' prior: 0!I provide a test suite for Float values. Examine my tests to see how Floats should behave, and see how to use them.!!FontTest methodsFor: 'failures' stamp: 'ar 7/27/2010 12:13'!expectedFailures	"Currently broken due to NativeFonts"	^#(testFallback)! !!FontTest methodsFor: 'testing' stamp: 'ar 8/15/2009 10:46'!testDisplay	"self debug: #testDisplay"	| text font bb destPoint width |	text := 'test' asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text asString on: bb from: 1 to: 4 at: 0@0 kern: 1.	width := text inject: 0 into: [:max :char | max + (font widthOf: char)].	self assert: destPoint x = (width + 4).	"bb destForm asMorph openInHand."! !!FontTest methodsFor: 'testing' stamp: 'ar 8/15/2009 10:39'!testFallback	"self debug: #testFallback"	| text font bb destPoint |	text := (Character value: 257) asString asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text asString on: bb from: 1 to: 1 at: 0@0 kern: 1.	"bb destForm asMorph openInHand."	self assert: destPoint x = ((font widthOf: $?) + 1).! !!FontTest methodsFor: 'testing' stamp: 'tak 12/22/2004 00:56'!testMultistringFallbackFont	"self debug: #testMultistringFallbackFont"	| text p style height width |	[(TextStyle default fontArray at: JapaneseEnvironment leadingChar)		ifNil: [^ self]]		ifError: [:err :rcvr | ^ self].	text := ((#(20983874 20983876 20983878 )				collect: [:e | e asCharacter])				as: String) asText.	p := MultiNewParagraph new.	style := TextStyle new leading: 0; newFontArray: {Preferences standardFlapFont}.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 18:02'!testMultistringFont	"self debug: #testMultistringFont"	| text p style height width |	[(TextStyle default fontArray at: JapaneseEnvironment leadingChar)		ifNil: [^ self]]		ifError: [:err :rcvr | ^ self].	text := ((#(20983874 20983876 20983878 )				collect: [:e | e asCharacter])				as: String) asText.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 14:50'!testParagraph	"self debug: #testParagraph"	| text p style height width |	text := 'test' asText.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := text				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height)! !!FontTest methodsFor: 'testing' stamp: 'tak 12/21/2004 17:19'!testParagraphFallback	"self debug: #testParagraphFallback"	| text p style height width e expect |	e := (Character value: 257) asString.	text := ('test' , e , e , e , e , 'test') asText.	expect := 'test????test'.	p := MultiNewParagraph new.	style := TextStyle default.	p		compose: text		style: style		from: 1		in: (0 @ 0 corner: 100 @ 100).	"See CompositionScanner>>setActualFont: &  	CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:"	height := style defaultFont height + style leading.	width := expect				inject: 0				into: [:tally :next | tally						+ (style defaultFont widthOf: next)].	p adjustRightX.	self assert: p extent = (width @ height).	"Display getCanvas		paragraph: p		bounds: (10 @ 10 extent: 100 @ 100)		color: Color black"! !!FontTest methodsFor: 'testing' stamp: 'ar 8/29/2009 23:10'!testResetAfterEmphasized	"self debug: #testResetAfterEmphasized"	| normal derivative |	normal := TextStyle defaultFont.	derivative := normal emphasized: 3.	self assert: (normal derivativeFonts at: 3) == derivative.	normal reset.	self assert: (normal derivativeFonts select:[:any| any isSynthetic]) isEmpty! !!FontTest commentStamp: 'tak 3/11/2005 14:31' prior: 0!I am mainly a test for fallback font.FontTest buildSuite run!!Form methodsFor: 'accessing' stamp: 'ar 2/16/2000 22:00'!size	"Should no longer be used -- use bitsSize instead.  length of variable part of instance."	^ super size! !!Form methodsFor: 'display box access' stamp: 'ar 2/5/2009 16:54'!offsetBox	"Like #boundingBox except that it includes the offset."	^ Rectangle origin: self offset			extent: width @ height! !!Form methodsFor: 'displaying' stamp: 'jcg 4/5/2008 11:08'!displayScaledOn: aForm	"Display the receiver on aForm, scaling if necessary.		Form fromUser displayScaledOn: Display.	"	self displayScaledOn: aForm cellSize: 2.! !!Form methodsFor: 'displaying' stamp: 'jcg 4/5/2008 11:07'!displayScaledOn: aForm cellSize: cellSize	"Display the receiver on aForm, scaling if necessary.  'cellSize' specifies how much smoothing.		Form fromUser displayScaledOn: Display.	"	self extent = aForm extent ifTrue:[^self displayOn: aForm].	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form paint;		cellSize: cellSize;		warpBits.! !!Form methodsFor: 'pixel access' stamp: 'jcg 12/17/2008 14:43'!transformColors: transformBlock	"Replaces the color of each pixel with the result of evaluating 'replaceBlock' on that pixel.  'replaceBlock' takes two arguments: the pixel's color and coordinates.  Slow, very slow."	1 to: width do: [:x |		1 to: height do: [:y |			| pt |			pt := x@y.			self colorAt: pt put: (transformBlock value: (self colorAt: pt) value: pt).		]	].! !!Form methodsFor: 'scaling, rotation' stamp: 'jcg 3/27/2008 18:36'!scaledToSize: newExtent	| newForm |	newExtent = self extent ifTrue: [^self].	newForm := Form extent: newExtent depth: self depth.	self displayScaledOn: newForm.	^newForm	! !!FormButtonCache methodsFor: 'accessing'!form	"Answer the receiver's form, the image of the button on the screen."	^form! !!FormButtonCache methodsFor: 'accessing'!form: aForm	"Set the receiver's form to be the argument."	form := aForm! !!FormButtonCache methodsFor: 'accessing'!initialState	"Answer the receiver's initial state, on or off."	^initialState! !!FormButtonCache methodsFor: 'accessing'!initialState: aBoolean	"Set the receiver's initial state, on or off, to be the argument."	initialState := aBoolean! !!FormButtonCache methodsFor: 'accessing'!offset	"Answer the receiver's offset, its relative position for displaying the 	button."	^offset! !!FormButtonCache methodsFor: 'accessing'!offset: anInteger	"Set the receiver's offset."	offset := anInteger! !!FormButtonCache methodsFor: 'accessing'!value	"Answer the receiver's value, the keyboard key that selects the button."	^value! !!FormButtonCache methodsFor: 'accessing'!value: aCharacter	"Set the receiver's key character."	value := aCharacter! !!FormButtonCache commentStamp: '<historical>' prior: 0!My instances are used to save information needed to construct the switch in a menu for a FormEditor. A collection of my instances is stored as a class variable of FormMenuView.!!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 8/10/2007 16:58'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!FormCanvasTest methodsFor: 'tests' stamp: 'rkrk 9/24/2009 03:34'!testFrameAndFillDegenerateRoundRect01	| fill canvas smallRect |	fill := GradientFillStyle sample.	canvas := FormCanvas extent: 100@100.	canvas fillColor: Color black.	smallRect := 0@0 corner: 20@20.	self shouldnt: [		canvas			frameAndFillRoundRect: smallRect			radius: smallRect width / 2 + 1			fillStyle: fill			borderWidth: 0			borderColor: Color lightGray]		raise: Error.! !!FormCanvasTest methodsFor: 'tests' stamp: 'rkrk 9/24/2009 03:35'!testFrameAndFillDegenerateRoundRect02	| fill canvas smallRect |	fill := GradientFillStyle sample.	canvas := FormCanvas extent: 100@100.	canvas fillColor: Color black.	smallRect := 0@0 corner: 20@20.	self shouldnt: [		canvas			frameAndFillRoundRect: smallRect			radius: 0			fillStyle: fill			borderWidth: 0			borderColor: Color lightGray]		raise: Error.! !!FormEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 22:59'!accept	"The edited information should now be accepted by the view."	view updateDisplay.	view accept.	hasUnsavedChanges contents: false.! !!FormEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 22:59'!cancel	"The edited information should be forgotten by the view."	view cancel.	hasUnsavedChanges contents: false.! !!FormEditor methodsFor: 'menu messages'!edit	model edit! !!FormEditor methodsFor: 'menu messages' stamp: 'CdG 10/17/2005 20:52'!fileOut	| fileName |	fileName := UIManager default		request: 'File name?' translated		initialAnswer: 'Filename.form'.	fileName isEmpty ifTrue: [^ self].	Cursor normal		showWhile: [model writeOnFileNamed: fileName].! !!FormEditor methodsFor: 'menu messages'!redButtonActivity 	"Refer to the comment in MouseMenuController|redButtonActivity."	self perform: tool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/5/2003 23:00'!block	"Allow the user to fill a rectangle with the gray tone and mode currently 	selected."	| rectangle originRect |	originRect := (Sensor cursorPoint grid: grid) extent: 2 @ 2. 	rectangle := Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: (Sensor cursorPoint grid: grid)]].	rectangle isNil 		ifFalse:		  [sensor waitNoButton.		   Display					fill: (rectangle intersect: view insetDisplayBox)					rule: mode					fillColor: color.		   hasUnsavedChanges contents: true.]! !!FormEditor methodsFor: 'editing tools' stamp: 'rbb 3/1/2005 11:21'!changeGridding	"Allow the user to change the values of the horizontal and/or vertical 	grid modules. Does not change the primary tool."	| response gridInteger gridX gridY |	gridX := togglegrid x.	gridY := togglegrid y.	response := UIManager default		request:'Current horizontal gridding is: ', gridX printString, '.Type new horizontal gridding.'.	response isEmpty		ifFalse: 			[gridInteger := Integer readFromString: response.			gridX := ((gridInteger max: 1) min: Display extent x)].	response := UIManager default		request:'Current vertical gridding is: ', gridY printString, '.Type new vertical gridding.'.	response isEmpty		ifFalse: 			[gridInteger := Integer readFromString: response.			gridY := ((gridInteger max: 1) min: Display extent y)].	xgridOn ifTrue: [grid := gridX @ grid y].	ygridOn ifTrue: [grid := grid x @ gridY].	togglegrid := gridX @ gridY.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!changeTool: aCharacter 	"Change the value of the instance variable tool to be the tool 	corresponding to aCharacter. Typically sent from a Switch in a 	FormMenuView."	previousTool := tool.	tool := self selectTool: aCharacter.	(#(singleCopy repeatCopy line curve block) includes: tool)		ifFalse:			[self perform: tool]! !!FormEditor methodsFor: 'editing tools'!colorBlack	"Set the mask (color) to black. Leaves the tool set in its previous state."	self setColor: Color black! !!FormEditor methodsFor: 'editing tools'!colorDarkGray	"Set the mask (color) to dark gray. Leaves the tool set in its previous 	state."	self setColor: Color darkGray! !!FormEditor methodsFor: 'editing tools'!colorGray	"Set the color to gray. Leaves the tool set in its previous state."	self setColor: Color gray.! !!FormEditor methodsFor: 'editing tools'!colorLightGray	"Set the mask (color) to light gray. Leaves the tool set in its previous 	state."	self setColor: Color lightGray! !!FormEditor methodsFor: 'editing tools'!colorWhite	"Set the color to white. Leaves the tool set in its previous state."	self setColor: Color white! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/10/2003 16:21'!curve	"Conic-section specified by three points designated by: first point--press 	red button second point--release red button third point--click red button. 	The resultant curve on the display is displayed according to the current 	form and mode."	| firstPoint secondPoint thirdPoint curve drawForm |	"sensor noButtonPressed ifTrue: [^self]."	firstPoint := self cursorPoint.	secondPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	thirdPoint :=  self rubberBandFrom: secondPoint until: [sensor redButtonPressed].	Display depth > 1	  ifTrue:	    [self deleteRubberBandFrom: secondPoint to: thirdPoint.	     self deleteRubberBandFrom: firstPoint to: secondPoint].	curve := CurveFitter new.	curve firstPoint: firstPoint.	curve secondPoint: secondPoint.	curve thirdPoint: thirdPoint.	drawForm := form asFormOfDepth: Display depth.	Display depth > 1 ifTrue:	  [drawForm mapColor: Color white to: Color transparent; 	               mapColor: Color black to: color].	curve form: drawForm.	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]										ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]). 	sensor waitNoButton.	hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!eraseMode	"Set the mode for the tools that copy the form onto the display to erase. 	Leaves the tool set in its previous state."	mode := 4.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'CdG 10/17/2005 20:51'!fileInForm	"Ask the user for a file name and then recalls the Form in that file as the current source Form (form). Does not change the tool."	| fileName |	fileName := UIManager default		request: 'File name?' translated		initialAnswer: 'Filename.form'.	fileName isEmpty ifTrue: [^ self].	form := Form fromFileNamed: fileName.	tool := previousTool.! !!FormEditor methodsFor: 'editing tools' stamp: 'CdG 10/17/2005 20:52'!fileOutForm	"Ask the user for a file name and save the current source form under that name. Does not change the tool."	| fileName |	fileName := UIManager default		request: 'File name?' translated		initialAnswer: 'Filename.form'.	fileName isEmpty ifTrue: [^ self].	Cursor normal		showWhile: [form writeOnFileNamed: fileName].	tool := previousTool.! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/12/2003 15:51'!line	"Line is specified by two points from the mouse: first point--press red 	button; second point--release red button. The resultant line is displayed 	according to the current form and mode."	| firstPoint endPoint drawForm |	drawForm := form asFormOfDepth: Display depth.		 Display depth > 1 	  ifTrue:	    [drawForm mapColor: Color white to: Color transparent; 	                 mapColor: Color black to: color].	           	firstPoint := self cursorPoint.	endPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	endPoint isNil ifTrue: [^self].	Display depth > 1 ifTrue: [self deleteRubberBandFrom: firstPoint to: endPoint.].	(Line from: firstPoint to: endPoint withForm: drawForm)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]								ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]).  		hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools' stamp: 'dtl 1/23/2010 18:12'!magnify	"Allow for bit editing of an area of the Form. The user designates a 	rectangular area that is scaled by 5 to allow individual screens dots to be 	modified. Red button is used to set a bit to black, and yellow button is 	used to set a bit to white. Editing continues until the user depresses any 	key on the keyboard."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8@8.	smallRect := (Rectangle fromUser: grid) intersect: view insetDisplayBox.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	"Do this computation here in order to be able to save the existing display screen."	tempRect := Rectangle locateMagnifiedView: smallForm scale: scaleFactor.	BitEditor		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'jm 6/30/1999 15:46'!newSourceForm	"Allow the user to define a new source form for the FormEditor. Copying 	the source form onto the display is the primary graphical operation. 	Resets the tool to be repeatCopy."	| dForm interiorPoint interiorColor |	dForm := Form fromUser: grid.	"sourceForm must be only 1 bit deep"	interiorPoint := dForm extent // 2.	interiorColor := dForm colorAt: interiorPoint.	form := (dForm makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:f | f pixelValueAt: interiorPoint put: 1].	form := form trimBordersOfColor: Color white.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!overMode	"Set the mode for the tools that copy the form onto the display to over. 	Leaves the tool set in its previous state."	mode := Form over.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/10/2003 15:59'!repeatCopy	"As long as the red button is pressed, copy the source form onto the 	display screen."  | drawingWasChanged |	drawingWasChanged := false.	[sensor redButtonPressed]		whileTrue: 		[(BitBlt current destForm: Display sourceForm: form halftoneForm: color			combinationRule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]										ifFalse: [mode])			destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent			clipRect: view insetDisplayBox)			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);			copyBits.		  drawingWasChanged := true.		].	drawingWasChanged	  ifTrue: [hasUnsavedChanges contents: true.]! !!FormEditor methodsFor: 'editing tools'!reverseMode	"Set the mode for the tools that copy the form onto the display to reverse. 	Leaves the tool set in its previous state."	mode := Form reverse.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 2/25/2001 21:36'!setColor: aColor	"Set the mask (color) to aColor.	Hacked to invoke color chooser if not B/W screen.	Leaves the tool set in its previous state."	self normalizeColor:  (unNormalizedColor := Display depth > 1							ifTrue: [Color fromUser]							ifFalse: [aColor]).	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/10/2003 16:00'!singleCopy 	"If the red button is clicked, copy the source form onto the display 	screen."   (BitBlt destForm: Display           sourceForm: form halftoneForm: color           combinationRule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]                                                     ifFalse: [mode])           destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent           clipRect: view insetDisplayBox)           colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);	copyBits.	sensor waitNoButton.	hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!togglexGridding	"Turn x (horizontal) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	xgridOn		ifTrue: 			[grid := 1 @ grid y.			xgridOn := false]		ifFalse: 			[grid := togglegrid x @ grid y.			xgridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!toggleyGridding	"Turn y (vertical) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	ygridOn		ifTrue: 			[grid := grid x @ 1.			ygridOn := false]		ifFalse: 			[grid := grid x @ togglegrid y.			ygridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!underMode	"Set the mode for the tools that copy the form onto the display to under. 	Leaves the tool set in its previous state."	mode := Form under.	tool := previousTool! !!FormEditor methodsFor: 'control defaults'!controlActivity	super controlActivity.	self dragForm! !!FormEditor methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:07'!isControlActive	^ super isControlActive and: [sensor keyboardPressed not]! !!FormEditor methodsFor: 'basic control sequence' stamp: 'sma 4/22/2000 12:56'!controlInitialize	Cursor crossHair show.	self normalizeColor: unNormalizedColor.	sensor waitNoButton! !!FormEditor methodsFor: 'basic control sequence'!controlTerminate	"Resets the cursor to be the normal Smalltalk cursor."	Cursor normal show.	view updateDisplay! !!FormEditor methodsFor: 'cursor'!cursorPoint	"Answer the mouse coordinate data gridded according to the receiver's 	grid."	^sensor cursorPoint grid: grid! !!FormEditor methodsFor: 'private' stamp: 'BG 12/10/2003 17:02'!deleteRubberBandFrom: startPoint to: endPoint	(Line from: startPoint to: endPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: (Display depth = 1 ifTrue: [Color black] ifFalse: [Color gray]).! !!FormEditor methodsFor: 'private'!dragForm	tool = #block		ifTrue:			[Cursor origin show.			[sensor anyButtonPressed				or: [sensor keyboardPressed				or: [self viewHasCursor not]]]				whileFalse: [].			^self cursorPoint]		ifFalse:			[^self trackFormUntil:				[sensor anyButtonPressed					or: [sensor keyboardPressed					or: [self viewHasCursor not]]]]! !!FormEditor methodsFor: 'private' stamp: 'jm 12/4/97 10:22'!normalizeColor: aColor	color := aColor.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/10/2003 16:47'!rubberBandFrom: startPoint until: aBlock	| endPoint previousEndPoint |	previousEndPoint := startPoint.	[aBlock value] whileFalse:		[(endPoint := self cursorPoint) = previousEndPoint 			ifFalse:			[(Line from: startPoint to: previousEndPoint withForm: form) 				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			(Line from: startPoint to: endPoint withForm: form)				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			previousEndPoint  := endPoint]].	(Line from: startPoint to: previousEndPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: (Display depth = 1 ifTrue: [Color gray] ifFalse: [Color black]).	^endPoint! !!FormEditor methodsFor: 'private'!selectTool: aCharacter	"A new tool has been selected. It is denoted by aCharacter. Set the tool.	This code is written out in long hand (i.e., rather than dispatching on a	table of options) so that it is obvious what is happening."		aCharacter =  SingleCopyKey	ifTrue: [^#singleCopy].	aCharacter =  RepeatCopyKey	ifTrue: [^#repeatCopy].	aCharacter =  LineKey			ifTrue: [^#line].						aCharacter =  CurveKey			ifTrue: [^#curve].					aCharacter =  BlockKey			ifTrue: [^#block].			aCharacter =  SelectKey			ifTrue: [^#newSourceForm].			aCharacter =  OverKey			ifTrue: [^#overMode].	aCharacter =  UnderKey			ifTrue: [^#underMode].	aCharacter =  ReverseKey		ifTrue: [^#reverseMode].	aCharacter =  EraseKey			ifTrue: [^#eraseMode].	aCharacter =  ChangeGridsKey	ifTrue: [^#changeGridding].	aCharacter =  TogglexGridKey	ifTrue: [^#togglexGridding].	aCharacter =  ToggleyGridKey	ifTrue: [^#toggleyGridding].	aCharacter =  BitEditKey			ifTrue: [^#magnify].				aCharacter =  WhiteKey			ifTrue: [^#colorWhite].				aCharacter =  LightGrayKey		ifTrue: [^#colorLightGray].				aCharacter =  GrayKey			ifTrue: [^#colorGray].					aCharacter =  DarkGrayKey		ifTrue: [^#colorDarkGray].				aCharacter =  BlackKey			ifTrue: [^#colorBlack].					aCharacter =  OutKey			ifTrue: [^#fileOutForm].				aCharacter =  InKey				ifTrue: [^#fileInForm]! !!FormEditor methodsFor: 'private' stamp: 'BG 12/5/2003 22:58'!setVariables	tool := #repeatCopy.	previousTool := tool.	grid := 1 @ 1.	togglegrid := 8 @ 8.	xgridOn := false.	ygridOn := false.	mode := Form over.	form := Form extent: 8 @ 8.	form fillBlack.	unNormalizedColor := color := Color black.	hasUnsavedChanges := ValueHolder new contents: false.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/12/2003 15:50'!trackFormUntil: aBlock	| previousPoint cursorPoint displayForm |	previousPoint := self cursorPoint.	displayForm := Form extent: form extent depth: form depth.	displayForm copy: (0 @ 0 extent: form extent)	               from: form	               to: 0 @ 0	               rule: Form over.	Display depth > 1 ifTrue: [displayForm reverse]. 	displayForm displayOn: Display at: previousPoint rule: Form reverse.	[aBlock value] whileFalse:		[cursorPoint := self cursorPoint.		(FlashCursor or: [cursorPoint ~= previousPoint])			ifTrue:			[displayForm displayOn: Display at: previousPoint rule: Form reverse.			displayForm displayOn: Display at: cursorPoint rule: Form reverse.			previousPoint := cursorPoint]].	displayForm displayOn: Display at: previousPoint rule: Form reverse.	^previousPoint! !!FormEditor methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:08'!getPluggableYellowButtonMenu: shiftKeyState	^ YellowButtonMenu! !!FormEditor methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:07'!initialize	super initialize.	self setVariables! !!FormEditor methodsFor: 'initialize-release'!release	"Break the cycle between the Controller and its view. It is usually not 	necessary to send release provided the Controller's view has been properly 	released independently."	super release.	form := nil! !!FormEditor methodsFor: 'window support' stamp: 'rbb 2/16/2005 16:49'!okToChange  ^hasUnsavedChanges contents not	ifFalse:	  [self confirm:		'This drawing was not saved.\Is it OK to close this window?' withCRs	  ]	ifTrue:	  [true]! !!FormEditor commentStamp: 'BG 12/5/2003 22:40' prior: 0!I represent the basic editor for creating and modifying Forms. This is intended to be an easy to use general-purpose picture (bitMap) editor. I am a kind of MouseMenuController that creates a yellow button menu for accepting and canceling edits. My instances give up control if the cursor is outside the FormView or if a key on the keyboard is pressed.The form to be edited is stored in instance variable model.The instance variable form references the paint brush.!!FormEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:46'!createFullScreenForm	"Create a StandardSystemView for a FormEditor on the form whole screen."	| formView formEditor menuView topView extent aForm |	aForm := Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.	formView := FormHolderView new model: aForm.	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: menuView controller.	topView := StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView model: aForm.	topView addSubView: formView.	topView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	topView window: 		(formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).	topView label: 'Form Editor'.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 23:18'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder := 2.	formView := FormHolderView new model: aForm.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView := View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView := "ColorSystemView" FormEditorView new.	topView model: formEditor.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private'!setKeyboardMap	"Keyboard Mapping."	SelectKey:=$a.	SingleCopyKey:=$s.			"tools"	RepeatCopyKey:=$d.	LineKey:=$f.	CurveKey:=$g.	BlockKey:=$h.	OverKey:=$j.				"modes"	UnderKey:=$k.	ReverseKey:=$l.	EraseKey:=$;.	InKey:=$'.					"file In"	BitEditKey:=$z.	WhiteKey:=$x.				"colors"	LightGrayKey:=$c.	GrayKey:=$v.	DarkGrayKey:=$b.	BlackKey:=$n.	TogglexGridKey:=$m.		"gridding"	ToggleyGridKey:=$,.	ChangeGridsKey:=$..	OutKey:=$/					"file Out"! !!FormEditor class methodsFor: 'class initialization'!flashCursor: aBoolean	FlashCursor := aBoolean	"FormEditor flashCursor: true"! !!FormEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 15:06'!initialize	FlashCursor := false.	self setKeyboardMap.	YellowButtonMenu := SelectionMenu 		labels:'acceptcanceleditfile out'		lines: #(2)		selections: #(accept cancel edit fileOut).	"FormEditor initialize"! !!FormEditor class methodsFor: 'examples'!formFromDisplay	"Create an instance of me on a new form designated by the user at a	location designated by the user."	Form fromUser edit	"FormEditor formFromDisplay"! !!FormEditor class methodsFor: 'examples'!fullScreen	"Create an instance of me on a new form that fills the full size of the	display screen."	FormEditor openFullScreenForm	"FormEditor fullScreen"! !!FormEditor class methodsFor: 'examples' stamp: 'BG 12/5/2003 22:39'!newForm	"Create an instance of me on a new form at a location designated by the user. "	(Form extent: 400 @ 200 depth: Display depth)	    fillWhite;	    edit	"FormEditor newForm"! !!FormEditor class methodsFor: 'instance creation'!openFullScreenForm	"Create and schedule an instance of me on the form whose extent is the 	extent of the display screen."	| topView |	topView := self createFullScreenForm.	topView controller 		openDisplayAt: (topView viewport extent//2)	"FormEditor openFullScreenForm."! !!FormEditor class methodsFor: 'instance creation'!openOnForm: aForm	"Create and schedule an instance of me on the form aForm."	| topView |	topView := self createOnForm: aForm.	topView controller open! !!FormEditorView methodsFor: 'as yet unclassified'!cacheBitsAsTwoTone	^ false! !!FormHolderView methodsFor: 'menu messages'!accept 	"Refer to the comment in FormView|accept."	model		copyBits: displayedForm boundingBox		from: displayedForm		at: 0 @ 0		clippingBox: model boundingBox		rule: Form over		fillColor: nil.	model changed: self! !!FormHolderView methodsFor: 'menu messages'!cancel 	"Refer to the comment in FormView|cancel."	displayedForm become: model deepCopy.	displayedForm changed: self.	self display! !!FormHolderView methodsFor: 'model access'!changeValueAt: location put: anInteger 	"Refer to the comment in FormView|changeValueAt:put:."	displayedForm pixelValueAt: location put: anInteger.	displayedForm changed: self! !!FormHolderView methodsFor: 'model access'!model: aForm	super model: aForm.	displayedForm := aForm deepCopy! !!FormHolderView methodsFor: 'model access'!workingForm	"Answer the form that is currently being displayed--the working version 	in which edits are carried out."	^displayedForm! !!FormHolderView methodsFor: 'displaying'!displayView 	"Display the Form associated with this View according to the rule and	fillColor specifed by this class."	| oldOffset |	oldOffset := displayedForm offset.	displayedForm offset: 0@0.	displayedForm		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	displayedForm offset: oldOffset! !!FormHolderView methodsFor: 'displaying'!updateDisplay	"The working version is redefined by copying the bits displayed in the 	receiver's display area."	displayedForm fromDisplay: self displayBox.	displayedForm changed: self! !!FormHolderView methodsFor: 'initialize-release'!release	super release.	displayedForm release.	displayedForm := nil! !!FormHolderView commentStamp: '<historical>' prior: 0!I represent a view of a Form. Editing takes place by modifying a working version of the Form. The message accept is used to copy the working version into the Form; the message cancel copies the Form into the working version.!!FormInspectView methodsFor: 'as yet unclassified'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^  NoController! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale := self insetDisplayBox extent / model selection extent.	scale := (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormInspectView class methodsFor: 'instance creation' stamp: 'ar 8/7/2009 23:44'!openOn: aFormDictionary withLabel: aLabel	"open a graphical dictionary in a window having the label aLabel.      aFormDictionary should be a dictionary containing as value a form."     ^ DictionaryInspector                openOn: aFormDictionary                withEvalPane: true                withLabel: aLabel! !!FormMenuController methodsFor: 'control defaults'!controlActivity	"Pass control to a subView corresponding to a pressed keyboard key or to	a mouse button pressed, if any."	sensor keyboardPressed		ifTrue: [self processMenuKey]		ifFalse: [self controlToNextLevel]! !!FormMenuController methodsFor: 'control defaults'!isControlActive	"Answer false if the blue mouse button is pressed and the cursor is	outside of the inset display box of the Controller's view; answer true,	otherwise."	^sensor keyboardPressed |		(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not! !!FormMenuController methodsFor: 'control defaults'!isControlWanted	"Answer true if the cursor is inside the inset display box (see 	View|insetDisplayBox) of the receiver's view, and answer false, 	otherwise. It is sent by Controller|controlNextLevel in order to determine 	whether or not control should be passed to this receiver from the	Controller of the superView of this receiver's view."	^sensor keyboardPressed | self viewHasCursor! !!FormMenuController methodsFor: 'control defaults' stamp: 'jm 4/7/98 20:59'!processMenuKey	"The user typed a key on the keyboard. Perform the action of the button whose shortcut is that key, if any."	| aView |	aView := view subViewContainingCharacter: sensor keyboard.	aView ~~ nil ifTrue: [aView performAction].! !!FormMenuController commentStamp: '<historical>' prior: 0!I represent a Controller that takes control if a key on the keyboard is depressed or if the cursor is within my rectangular area.!!FormMenuView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^FormMenuController! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:22'!makeButton: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	button := Button newOff.	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!makeColorConnections: indexInterval	| connector aSwitchView |	connector := Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index | | button buttonCache |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!makeConnections: indexInterval	| connector aSwitchView |	connector := Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index | | button buttonCache |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 15:24'!makeGridSwitch: index	| buttonCache button |	buttonCache := FormButtons at: index.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	button offAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeSwitch: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'jm 4/7/98 20:24'!makeViews: cache for: aSwitch	| form aSwitchView |	form := cache form.	aSwitchView := PluggableButtonView		on: aSwitch		getState: #isOn		action: #switch.	aSwitchView		label: form;		shortcutCharacter: cache value;		window: (0@0 extent: form extent);		translateBy: cache offset;		borderWidth: 1.	self addSubView: aSwitchView.	^ aSwitchView! !!FormMenuView methodsFor: 'initialize-release'!makeFormEditorMenu	| button buttonCache form aSwitchView aSwitchController|	"Now get those forms into the subviews"	self makeButton: 1.					"form source"	self makeConnections: (2 to: 6).		"tools"	self makeConnections: (7 to: 10).		"modes"	self makeButton: 11.					"filing in"	self makeButton: 12.					"bit editing"	self makeColorConnections: (13 to: 17).		"colors"	self makeGridSwitch: 18.					"toggle x"	self makeGridSwitch: 19.					"toggle y"	self makeButton: 20.					"setting grid"	self makeButton: 21					"filing out"! !!FormMenuView methodsFor: 'subView access' stamp: 'jm 4/2/98 17:29'!subViewContainingCharacter: aCharacter	"Answer the receiver's subView that corresponds to the key, aCharacter. 	Answer nil if no subView is selected by aCharacter."	self subViews reverseDo: 		[:aSubView |		(aSubView shortcutCharacter = aCharacter) ifTrue: [^aSubView]].	^nil	! !!FormMenuView commentStamp: '<historical>' prior: 0!I represent a View whose subViews are Switches (and Buttons and OneOnSwitches) whose actions set the mode, color, and tool for editing a Form on the screen. The default controller of my instances is FormMenuController.!!FormMenuView class methodsFor: 'class initialization' stamp: 'jm 3/27/98 14:54'!fileOut	"Save the FormEditor button icons."	"FormMenuView fileOut"	| names |	names := 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').	1 to: FormButtons size do: [:i |		(FormButtons at: i) form writeOnFileNamed: (names at: i)].	SpecialBorderForm writeOnFileNamed: 'specialborderform.form'.	BorderForm writeOnFileNamed: 'borderform.form'.! !!FormMenuView class methodsFor: 'class initialization' stamp: 'md 7/23/2006 16:41'!initialize2	"The icons for the menu are typically stored on files. In order to avoid reading them every time, they are stored in a collection in a class variable, along with their offset, tool value, and initial visual state (on or off)."	"FormMenuView initialize"	| offsets keys states names button |	offsets := OrderedCollection new: 21.	#(0 64 96 128 160 192 256 288 320 352 420) do: [:i | offsets addLast: i@0].  "First row"	#(0 64 96 128 160 192 256 304 352 420) do: [:i | offsets addLast: i@48].  "Second row"	offsets := offsets asArray.	keys := #($a $s $d $f $g $h $j $k $l $; $' $z $x $c $v $b $n $m $, $. $/ ).  "Keyboard"	states := #(		#false #false #true #false #false #false #true #false #false #false #false		#false #false #false #false #false #true #false #false #false #false).  "Initial button states"	names := 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').  "Files of button images"	FormButtons := OrderedCollection new.	1 to: 21 do: [:index |		button := FormButtonCache new.		button form: (Form fromFileNamed: (names at: index)).		button offset: (offsets at: index).		button value: (keys at: index).		button initialState: (states at: index).		FormButtons addLast: button].	SpecialBorderForm  := Form fromFileNamed: 'specialborderform.form'.	BorderForm := Form fromFileNamed: 'borderform.form'.! !!FormMenuView class methodsFor: 'accessing' stamp: 'BG 12/4/2003 12:11'!formButtons  ^FormButtons! !!FormTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testIsAllWhite	"self run: #testIsAllWhite"	"Make sure #isAllWhite works for all bit depths"		#(-32 -16 -8 -4 -2 -1 1 2 4 8 16 32) do:[:d| | form |		form := Form extent: 16@16 depth: d.		form fillBlack.		self deny: form isAllWhite.		form fillWhite.		self assert: form isAllWhite.	].! !!FormTest commentStamp: 'ar 7/21/2007 21:39' prior: 0!Various tests for class form.!!FormView methodsFor: 'menu messages'!accept	"The receiver's model is set to the working version, the one in which 	edits are carried out."	^self! !!FormView methodsFor: 'menu messages'!cancel	"Set the working form to be a copy of the model."	^self! !!FormView methodsFor: 'model access'!changeValueAt: location put: anInteger	"The receiver's model is a form which has an array of bits. Change the 	bit at index, location, to be anInteger (either 1 or 0). Inform all objects 	that depend on the model that it has changed."	model pixelValueAt: location put: anInteger.	model changed: self! !!FormView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^  FormEditor! !!FormView methodsFor: 'private'!defaultRule 	"The default display rule is 3=over or storing."	^Form over! !!FormView methodsFor: 'window access'!defaultWindow 	"Refer to the comment in View|defaultWindow."	^(Rectangle origin: 0 @ 0 extent: model extent)		expandBy: borderWidth! !!FormView methodsFor: 'window access'!windowBox	"For comaptibility with Control manager (see senders)"	^ self insetDisplayBox! !!FormView methodsFor: 'displaying'!displayOn: aPort	model displayOnPort: aPort at: self displayBox origin! !!FormView methodsFor: 'displaying' stamp: 'hmm 7/21/97 20:45'!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset := model offset.	model offset: "borderWidth origin" 0@0.	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset! !!FormView methodsFor: 'displaying'!uncacheBits	"Placed vacuously here so that when ControlManager>>restore calls uncacheBits for a project with no windows, we don't hang.  1/24/96 sw"! !!FormView methodsFor: 'displaying'!updateDisplay	"overridden by subclass"! !!FormView methodsFor: 'accessing'!fillColor	"Answer an instance of class Form that is the mask used when displaying 	the receiver's model (a Form) on the display screen (see BitBlt for the 	meaning of this mask)."	^ mask! !!FormView methodsFor: 'accessing'!fillColor: aForm 	"Set the display mask for displaying the receiver's model to be the 	argument, aForm."	mask := aForm! !!FormView methodsFor: 'accessing'!mask	"Answer an instance of class Form that is the mask used when displaying 	the receiver's model (a Form) on the display screen (see BitBlt for the 	meaning of this mask)."	^ mask! !!FormView methodsFor: 'accessing'!rule	"Answer a number from 0 to 15 that indicates which of the sixteen 	display rules (logical function of two boolean values) is to be used when 	copying the receiver's model (a Form) onto the display screen."	rule == nil		ifTrue: [^self defaultRule]		ifFalse: [^rule]! !!FormView methodsFor: 'accessing'!rule: anInteger 	"Set the display rule for the receiver to be the argument, anInteger."	rule := anInteger! !!FormView methodsFor: 'updating'!update: aFormView 	"Refer to the comment in View|update:."	self == aFormView ifFalse: [self display]! !!FormView commentStamp: '<historical>' prior: 0!I represent a view of a Form.!!FormView class methodsFor: 'examples'!exampleOne	"Frame a Form (specified by the user) with a border of 2 bits in width and display it offset 60 x 40 from the cornor of the display screen. "	| f view |	f := Form fromUser.	view := self new model: f.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleOne"! !!FormView class methodsFor: 'examples'!exampleTwo	"Frame a Form (specified by the user) that is scaled by 2. The border is 2 bits in width. Displays at location 60, 40."	| f view |	f := Form fromUser.	view := self new model: f.	view scaleBy: 2.0.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleTwo"! !!FormView class methodsFor: 'examples' stamp: 'BG 12/5/2003 14:45'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView := StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: aForm extent;	          maximumSize: aForm extent.	aView := FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!FractionTest methodsFor: 'tests - sinuses' stamp: 'sd 3/4/2004 21:13'!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ (4/3) degreeCos] raise: Error.	self assert: (1/3) degreeCos printString =  '0.999983076857744'! !!FractionTest methodsFor: 'tests - sinuses' stamp: 'sd 3/5/2004 14:54'!testDegreeSin	"self run: #testDegreeSin"		self shouldnt: [ (4/3) degreeSin] raise: Error.	self assert: (1/3) degreeSin printString =  '0.005817731354993834'.! !!FractionTest methodsFor: 'tests - sinuses' stamp: 'GabrielOmarCotelli 5/23/2009 20:19'!testReciprocal	self 		assert: (1/2) reciprocal = 2;		assert: (3/4) reciprocal = (4/3);		assert: (-1/3) reciprocal = -3;		assert: (-3/5) reciprocal = (-5/3)! !!FractionTest methodsFor: 'tests - printing' stamp: 'laza 3/30/2004 09:28'!testFractionPrinting	self assert: (353/359) printString = '(353/359)'.	self assert: ((2/3) printStringBase: 2) = '(10/11)'.	self assert: ((2/3) storeStringBase: 2) = '(2r10/2r11)'.	self assert: ((5/7) printStringBase: 3) = '(12/21)'.	self assert: ((5/7) storeStringBase: 3) = '(3r12/3r21)'.	self assert: ((11/13) printStringBase: 4) = '(23/31)'.	self assert: ((11/13) storeStringBase: 4) = '(4r23/4r31)'.	self assert: ((17/19) printStringBase: 5) = '(32/34)'.	self assert: ((17/19) storeStringBase: 5) = '(5r32/5r34)'.	self assert: ((23/29) printStringBase: 6) = '(35/45)'.	self assert: ((23/29) storeStringBase: 6) = '(6r35/6r45)'.	self assert: ((31/37) printStringBase: 7) = '(43/52)'.	self assert: ((31/37) storeStringBase: 7) = '(7r43/7r52)'.	self assert: ((41/43) printStringBase: 8) = '(51/53)'.	self assert: ((41/43) storeStringBase: 8) = '(8r51/8r53)'.	self assert: ((47/53) printStringBase: 9) = '(52/58)'.	self assert: ((47/53) storeStringBase: 9) = '(9r52/9r58)'.	self assert: ((59/61) printStringBase: 10) = '(59/61)'.	self assert: ((59/61) storeStringBase: 10) = '(59/61)'.	self assert: ((67/71) printStringBase: 11) = '(61/65)'.	self assert: ((67/71) storeStringBase: 11) = '(11r61/11r65)'.	self assert: ((73/79) printStringBase: 12) = '(61/67)'.	self assert: ((73/79) storeStringBase: 12) = '(12r61/12r67)'.	self assert: ((83/89) printStringBase: 13) = '(65/6B)'.	self assert: ((83/89) storeStringBase: 13) = '(13r65/13r6B)'.	self assert: ((97/101) printStringBase: 14) = '(6D/73)'.	self assert: ((97/101) storeStringBase: 14) = '(14r6D/14r73)'.	self assert: ((103/107) printStringBase: 15) = '(6D/72)'.	self assert: ((103/107) storeStringBase: 15) = '(15r6D/15r72)'.	self assert: ((109/113) printStringBase: 16) = '(6D/71)'.	self assert: ((109/113) storeStringBase: 16) = '(16r6D/16r71)'.	self assert: ((127/131) printStringBase: 17) = '(78/7C)'.	self assert: ((127/131) storeStringBase: 17) = '(17r78/17r7C)'.	self assert: ((137/139) printStringBase: 18) = '(7B/7D)'.	self assert: ((137/139) storeStringBase: 18) = '(18r7B/18r7D)'.	self assert: ((149/151) printStringBase: 19) = '(7G/7I)'.	self assert: ((149/151) storeStringBase: 19) = '(19r7G/19r7I)'.	self assert: ((157/163) printStringBase: 20) = '(7H/83)'.	self assert: ((157/163) storeStringBase: 20) = '(20r7H/20r83)'.	self assert: ((167/173) printStringBase: 21) = '(7K/85)'.	self assert: ((167/173) storeStringBase: 21) = '(21r7K/21r85)'.	self assert: ((179/181) printStringBase: 22) = '(83/85)'.	self assert: ((179/181) storeStringBase: 22) = '(22r83/22r85)'.	self assert: ((191/193) printStringBase: 23) = '(87/89)'.	self assert: ((191/193) storeStringBase: 23) = '(23r87/23r89)'.	self assert: ((197/199) printStringBase: 24) = '(85/87)'.	self assert: ((197/199) storeStringBase: 24) = '(24r85/24r87)'.	self assert: ((211/223) printStringBase: 25) = '(8B/8N)'.	self assert: ((211/223) storeStringBase: 25) = '(25r8B/25r8N)'.	self assert: ((227/229) printStringBase: 26) = '(8J/8L)'.	self assert: ((227/229) storeStringBase: 26) = '(26r8J/26r8L)'.	self assert: ((233/239) printStringBase: 27) = '(8H/8N)'.	self assert: ((233/239) storeStringBase: 27) = '(27r8H/27r8N)'.	self assert: ((241/251) printStringBase: 28) = '(8H/8R)'.	self assert: ((241/251) storeStringBase: 28) = '(28r8H/28r8R)'.	self assert: ((257/263) printStringBase: 29) = '(8P/92)'.	self assert: ((257/263) storeStringBase: 29) = '(29r8P/29r92)'.	self assert: ((269/271) printStringBase: 30) = '(8T/91)'.	self assert: ((269/271) storeStringBase: 30) = '(30r8T/30r91)'.	self assert: ((277/281) printStringBase: 31) = '(8T/92)'.	self assert: ((277/281) storeStringBase: 31) = '(31r8T/31r92)'.	self assert: ((283/293) printStringBase: 32) = '(8R/95)'.	self assert: ((283/293) storeStringBase: 32) = '(32r8R/32r95)'.	self assert: ((307/311) printStringBase: 33) = '(9A/9E)'.	self assert: ((307/311) storeStringBase: 33) = '(33r9A/33r9E)'.	self assert: ((313/317) printStringBase: 34) = '(97/9B)'.	self assert: ((313/317) storeStringBase: 34) = '(34r97/34r9B)'.	self assert: ((331/337) printStringBase: 35) = '(9G/9M)'.	self assert: ((331/337) storeStringBase: 35) = '(35r9G/35r9M)'.	self assert: ((347/349) printStringBase: 36) = '(9N/9P)'.	self assert: ((347/349) storeStringBase: 36) = '(36r9N/36r9P)'.	self assert: ((-2/3) printStringBase: 2) = '(-10/11)'.	self assert: ((-2/3) storeStringBase: 2) = '(-2r10/2r11)'.	self assert: ((5/-7) printStringBase: 3) = '(-12/21)'.	self assert: ((5/-7) storeStringBase: 3) = '(-3r12/3r21)'.! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:27'!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!GIFReadWriter methodsFor: 'accessing' stamp: 'bgf 10/12/2008 16:23'!nextImage	"Read in the next GIF image from the stream. Read it all intomemory first for speed."	| f thisImageColorTable |	((stream isMemberOf: ReadWriteStream) 		or:[(stream isMemberOf: ReadStream)		or:[(stream isMemberOf: RWBinaryOrTextStream)]]) ifFalse: [			stream binary.			self on: (ReadWriteStream with: (stream contentsOfEntireFile))	].	self gifPluginVersion ifNotNil:[		f := self nextImageWithPlugin.		f ifNotNil:[^f].		(stream isKindOf: WriteStream) ifTrue: [			stream resetToStart. "rewind in case we read some stuff"		] ifFalse: [			stream reset.		].	].	localColorTable := nil.	self readHeader.	f := self readBody.	self close.	f == nil ifTrue: [^ self error: 'corrupt GIF file'].	thisImageColorTable := localColorTable ifNil: [colorPalette].	transparentIndex ifNotNil: [		transparentIndex + 1 > thisImageColorTable size ifTrue: [			thisImageColorTable := thisImageColorTable 				forceTo: transparentIndex + 1 				paddingWith: Color white		].		thisImageColorTable at: transparentIndex + 1 put: Color transparent	].	f colors: thisImageColorTable.	^ f! !!GIFReadWriter methodsFor: 'accessing' stamp: 'ar 10/10/2008 17:01'!nextPutImage: aForm	| f newF |	writing := true.	aForm unhibernate.	f := aForm colorReduced.  "minimize depth"	f depth > 8 ifTrue: [		"Not enough color space; do it the hard way."		f := f asFormOfDepth: 8].	f depth < 8 ifTrue: [		"writeBitData: expects depth of 8"		newF := f class extent: f extent depth: 8.		(f isColorForm)			ifTrue: [				newF					copyBits: f boundingBox					from: f at: 0@0					clippingBox: f boundingBox					rule: Form over					fillColor: nil					map: nil.				newF colors: f colors]			ifFalse: [f displayOn: newF].		f := newF].	(f isColorForm)		ifTrue: [			(f colorsUsed includes: Color transparent) ifTrue: [				transparentIndex := (f colors indexOf: Color transparent) - 1]]		ifFalse: [transparentIndex := nil].	width := f width.	height := f height.	bitsPerPixel := f depth.	colorPalette := f colormapIfNeededForDepth: 32.	interlace := false.	self writeHeader.	self writeBitData: f bits.! !!GIFReadWriter methodsFor: 'stream access' stamp: 'ar 10/10/2008 17:02'!close	"Write terminator"	writing ifTrue:[self nextPut: Terminator].	^super close! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'ar 9/3/2009 15:48'!readBody	"Read the GIF blocks. Modified to return a form.  "	| form extype block blocksize packedFields delay1 |	form := nil.	[stream atEnd] whileFalse: [		block := self next.		block = Terminator ifTrue: [^ form].		block = ImageSeparator ifTrue: [			form isNil				ifTrue: [form := self readBitData]				ifFalse: [self skipBitData].		] ifFalse: [			block = Extension				ifFalse: [^ form "^ self error: 'Unknown block type'"].			"Extension block"			extype := self next.	"extension type"			extype = 16rF9 ifTrue: [  "graphics control"				self next = 4 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].				"====				Reserved                      3 Bits				Disposal Method               3 Bits				User Input Flag               1 Bit				Transparent Color Flag        1 Bit				===" 				packedFields := self next.				delay1 := self next.	"delay time 1"				delay := (self next*256 + delay1) *10.	 "delay time 2"				transparentIndex := self next.				(packedFields bitAnd: 1) = 0 ifTrue: [transparentIndex := nil].				self next = 0 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].			] ifFalse: [				"Skip blocks"				[(blocksize := self next) > 0]					whileTrue: [						"Read the block and ignore it and eat the block terminator"						self next: blocksize]]]].	^form! !!GIFReadWriter methodsFor: 'primitives' stamp: 'ar 10/9/2008 20:18'!gifPluginRead: data into: form	"Answer the plugin version, nil if not available"	<primitive: 'primitiveReadImage' module: 'GIFLibPlugin'>	^nil! !!GIFReadWriter methodsFor: 'primitives' stamp: 'ar 10/10/2008 16:29'!gifPluginVersion	"Answer the plugin version, nil if not available"	<primitive: 'primitivePluginVersion' module: 'GIFLibPlugin'>	^nil! !!GIFReadWriter methodsFor: 'primitives' stamp: 'ar 10/10/2008 16:27'!nextImageWithPlugin	"Read the data via primitive"	| blocksize form block |	self readHeader. 	form := nil.	[stream atEnd] whileFalse: [		block := self next.		block = Terminator ifTrue: [^ form].		block = ImageSeparator ifTrue:[			offset := self readWord@self readWord. "Image Left@Image Top"			width := self readWord.			height := self readWord.			^self gifPluginRead: stream originalContents 				into: (Form extent: width@height depth: 32).		] ifFalse: [			block = Extension ifFalse: [^nil "^ self error: 'Unknown block type'"].			"Skip extension blocks"			self next.	"extension type"			[(blocksize := self next) > 0] whileTrue: [				"Read the block and ignore it and eat the block terminator"				self next: blocksize]]].	^nil! !!GIFReadWriter methodsFor: 'initialize' stamp: 'ar 10/10/2008 17:01'!initialize	writing := false.! !!GIFReadWriter commentStamp: '<historical>' prior: 0!Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.Used with permission.  Modified for use in Squeak.!!GeneratorTest methodsFor: 'generators' stamp: 'lr 1/8/2009 16:29'!fibonacciSequence	"Yields an infinite sequence of fibonacci numbers."		^ Generator on: [ :generator |		| a b |		a := 0. b := 1.		[ a := b + (b := a).		  generator yield: a ]			repeat ]! !!GeneratorTest methodsFor: 'generators' stamp: 'lr 1/8/2009 15:49'!numbersBetween: aStartInteger and: aStopInteger	"Yields the nubmers between aStartInteger and aStopInteger."		^ Generator on: [ :generator |		aStartInteger to: aStopInteger 			do: [ :value | generator yield: value ] ]! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:33'!testAtEnd	| generator |	generator := self numbersBetween: 1 and: 3.	self deny: generator atEnd.	generator next.	self deny: generator atEnd.	generator next.	self deny: generator atEnd.	generator next.	self assert: generator atEnd! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 2/10/2010 09:18'!testClose	| generator doEnsure notEnsure |	doEnsure := notEnsure := 0.	[ generator := Generator on: [ :g |		[ g yield: 1; yield: 2 ]			ensure: [ doEnsure := doEnsure + 1 ] ].	self assert: doEnsure = 0; assert: notEnsure = 0.	self assert: generator peek = 1.	self assert: doEnsure = 0; assert: notEnsure = 0.	generator close.	self assert: doEnsure = 1; assert: notEnsure = 0 ]		ensure: [ notEnsure := notEnsure + 1 ].	self assert: doEnsure = 1; assert: notEnsure = 1! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 4/26/2009 11:51'!testContents	| generator |	generator := self numbersBetween: 1 and: 3.	self assert: generator contents = #(1 2 3)! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:45'!testEmpty	| generator |	generator := Generator on: [ :g | ].	self assert: generator atEnd.	self assert: generator peek isNil.	self assert: generator next isNil! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 2/10/2010 09:02'!testEnsure	| generator |	generator := Generator on: [ :g |		[ g yield: 1; yield: 2 ]			ensure: [ g yield: 3 ] ].	self assert: generator upToEnd asArray = #( 1 2 3 )! !!GeneratorTest methodsFor: 'testing' stamp: 'ar 2/10/2010 21:01'!testErrorPropagation	"Ensure that errors in the generator block are properly propagated"	| generator |	self shouldnt:[generator := Generator on: [ :g | g yield: 1. g error: 'yo']] raise: Error.	self should:[generator next] raise: Error.! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:50'!testFibonacci	| generator |	generator := self fibonacciSequence.	self assert: (generator next: 10) asArray = #( 1 1 2 3 5 8 13 21 34 55 )! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:33'!testNext	| generator |	generator := self numbersBetween: 1 and: 3.	self assert: generator next = 1.	self assert: generator next = 2.	self assert: generator next = 3.	self assert: generator next isNil! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:45'!testPeek	| generator |	generator := self numbersBetween: 1 and: 3.	self assert: generator peek = 1.	self assert: generator peek = 1.	generator next.	self assert: generator peek = 2! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:35'!testReset	| generator |	generator := self numbersBetween: 1 and: 3.	self assert: generator next = 1.	self assert: generator next = 2.	generator reset.	self assert: generator next = 1.	self assert: generator next = 2.	self assert: generator next = 3.	self assert: generator next = nil.	generator reset.	self assert: generator next = 1! !!GeneratorTest methodsFor: 'testing' stamp: 'ar 2/10/2010 21:03'!testResetUnwind	"Just like close, just using reset"	| generator doEnsure notEnsure |	doEnsure := notEnsure := 0.	[ generator := Generator on: [ :g |		[ g yield: 1; yield: 2 ]			ensure: [ doEnsure := doEnsure + 1 ] ].	self assert: doEnsure = 0; assert: notEnsure = 0.	self assert: generator peek = 1.	self assert: doEnsure = 0; assert: notEnsure = 0.	generator reset.	self assert: doEnsure = 1; assert: notEnsure = 0 ]		ensure: [ notEnsure := notEnsure + 1 ].	self assert: doEnsure = 1; assert: notEnsure = 1! !!GeneratorTest methodsFor: 'testing' stamp: 'lr 1/8/2009 16:46'!testSimple	| generator |	generator := Generator on: [ :g | g yield: 1; yield: 2 ].	self assert: generator upToEnd asArray = #( 1 2 )! !!GeneratorTest class methodsFor: 'accessing' stamp: 'lr 2/10/2010 08:34'!packageNamesUnderTest	^ #('Generator')! !!GenericUrlTest methodsFor: 'testing' stamp: 'fbs 2/2/2005 12:56'!testAsString	| url |	url := GenericUrl new schemeName: 'sip' locator: 'foo@bar'.	self assert: url asString = 'sip:foo@bar'.! !!GrafPort methodsFor: 'private' stamp: 'dvd 4/14/2009 14:18'!installNativeFont: aNativeFont	^self installNativeFont: aNativeFont foregroundColor: (lastFontForegroundColor ifNil: [Color black]) backgroundColor: (lastFontBackgroundColor ifNil: [Color transparent]).! !!GrafPort methodsFor: 'private' stamp: 'dvd 4/15/2009 14:46'!installNativeFont: aNativeFont foregroundColor: fgColor backgroundColor: bgColor	super installNativeFont: aNativeFont foregroundColor: fgColor backgroundColor: bgColor.	alpha := nil.	lastFont := aNativeFont.	lastFontForegroundColor := fgColor.	lastFontBackgroundColor := bgColor.! !!GraphicSymbol methodsFor: 'accessing' stamp: 'jrm 2/6/2000 11:01'!computeBoundingBox	"Compute a boundingBox that encloses all of the Paths in this symbol"	^Rectangle merging: (self collect: [:each | each computeBoundingBox])! !!GraphicSymbol methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver on the Display where aTransformation is provided 	as an argument, rule is anInteger and mask is aForm. No translation. 	Information to be displayed must be confined to the area that intersects 	with clipRect."	self do: 		[:element | 		element			displayOn: aDisplayMedium			transformation: aTransformation			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!GraphicSymbol methodsFor: 'displaying'!displayTransformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	"Display the receiver where aTransformation is provided as an argument, 	rule is anInteger and mask is aForm. No translation. Information to be 	displayed must be confined to the area that intersects with clipRect."	self displayOn: Display transformation: aTransformation clippingBox: clipRect		rule: anInteger fillColor: aForm! !!GraphicSymbol commentStamp: '<historical>' prior: 0!I represent a structured picture built from primitive display objects and other instances of me.!!GraphicSymbolInstance methodsFor: 'displaying' stamp: 'jrm 2/13/2000 10:02'!displayOn: aDisplayMedium transformation: aTransformation clippingBox:clipRect rule: anInteger fillColor: aForm 	"Display the graphic symbol on the Display according to the arguments 	of this message."	graphicSymbol		displayOn: aDisplayMedium		transformation: aTransformation 		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!GraphicSymbolInstance methodsFor: 'displaying'!displayTransformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	"Display the graphic symbol according to the arguments of this message."	self displayOn: Display transformation: aTransformation clippingBox: clipRect		rule: anInteger fillColor: aForm! !!GraphicSymbolInstance methodsFor: 'accessing'!graphicSymbol	"Answer the graphic symbol that the receiver displays."	^graphicSymbol! !!GraphicSymbolInstance methodsFor: 'accessing'!graphicSymbol: aGraphicSymbol 	"Set the argument, aGraphicSymbol, to be the graphic symbol that the 	receiver displays."	graphicSymbol := aGraphicSymbol! !!GraphicSymbolInstance methodsFor: 'transforming'!transformation	"Answer the receiver's display transformation."	^transformation! !!GraphicSymbolInstance methodsFor: 'transforming'!transformation: aWindowingTransformation 	"Set the argument, aWindowingTransformation, to be the receiver's 	display transformation."	transformation := aWindowingTransformation! !!GraphicSymbolInstance commentStamp: '<historical>' prior: 0!I represent a display transformation of a GraphicSymbol. Multiple copies of a GraphicSymbol can be displayed at different positions and scales on the screen by making appropriate, multiple, instances of me.!!GraphicSymbolInstance class methodsFor: 'examples'!example	"Simply evaluate the method and two GraphicSymbolInstances, each	displaying a transformation of the same graphic symbol, will be	presented on the screen. Clears the screen to white."	| gate instance1 instance2 trans1 trans2 line arc f|	Display fillWhite.			"clear the Screen."	f := Form extent: 2@2.	f fillBlack.	gate:= GraphicSymbol new.		"make a logic gate out of lines and arcs."	line:=Line new.  line beginPoint: -20@-20.  line endPoint: 0@-20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: -20@20.  line endPoint: 0@20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: 0@-40.  line endPoint: 0@40. line form: f.	gate add: line.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 1.	arc form: f.	gate add: arc.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 4.	arc form: f.	gate add: arc.			"one instance at 1/2 scale."	trans1:=WindowingTransformation identity.		trans1:= trans1 scaleBy: 0.5@0.5.	trans1:= trans1 translateBy: 100@100.			"the other instance at 2 times scale"	trans2:=WindowingTransformation identity.		trans2:= trans2 scaleBy: 2.0@2.0.	trans2:= trans2 translateBy: 200@200.	instance1 := GraphicSymbolInstance new.	instance1 transformation: trans1.	instance1 graphicSymbol: gate.	instance2 := GraphicSymbolInstance new.	instance2 transformation: trans2.	instance2 graphicSymbol: gate.			"display both instances of the logic gate"	instance1 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil.	instance2 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil	"GraphicSymbolInstance example"! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/23/2010 17:34'!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	" by Bolot Kerimbaev, 1998 "	" this version is a memory hog: puts the whole file in memory "	"bolot 12/14/2000 18:28 -- minor fixes to make it comply with RFC 1867"	| serverName serverAddr s header length bare page list firstData aStream port argsStream specifiedServer type newUrl mimeBorder |	Socket initializeNetwork.	"parse url"	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName := bare copyUpTo: $/.	specifiedServer := serverName.	(serverName includes: $:) ifFalse: [ port := self defaultPort ] ifTrue: [		port := (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName := serverName copyUpTo: $:.	].	page := bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page := '/'].	(self shouldUseProxy: serverName) ifTrue: [ 		page := 'http://', serverName, ':', port printString, page.		"put back together"		serverName := self httpProxyServer.		port := self httpProxyPort].	mimeBorder := '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, CrLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: multipart/form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', CrLf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: CrLf, CrLf, fieldValue, CrLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.  	"make the request"		serverAddr := NetNameResolver addressForName: serverName timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', serverName].	s := HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName, ':', port asString; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPProxyCredentials,		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, CrLf,		'Content-type: multipart/form-data; boundary=', mimeBorder, CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list := s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData := list at: 3.	"dig out some headers"	s header: header.	length := s getHeader: 'content-length'.	length ifNotNil: [ length := length asNumber ].	type := s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		"redirected - don't re-post automatically"		"for now, just do a GET, without discriminating between 301/302 codes"		newUrl := s getHeader: 'location'.		newUrl ifNotNil: [			(newUrl beginsWith: 'http://')				ifFalse: [					(newUrl beginsWith: '/')						ifTrue: [newUrl := (bare copyUpTo: $/), newUrl]						ifFalse: [newUrl := url, newUrl. self flag: #todo							"should do a relative URL"]				].			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpGetDocument: newUrl			"for some codes, may do:			^self httpPostMultipart: newUrl args: argsDict  accept: mimeType request: requestString"] ].	aStream := s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!Halt methodsFor: 'testing' stamp: 'eem 5/16/2008 14:29'!isHalt	^true! !!HandBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testTargetPoint"self new testTargetPoint""self run: #testTargetPoint"self shouldnt: [ ActiveHand targetPoint ] raise: Error .! !!HandMorph methodsFor: 'cursor' stamp: 'ar 6/17/2010 17:01'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.			(cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed;		showHardwareCursor: (temporaryCursor isNil).! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 17:00'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ (temporaryCursor notNil and: [hardwareCursor isNil])				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:28'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			(temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			self showHardwareCursor: true.			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:52'!showHardwareCursor: aBool	"Show/hide the current hardware cursor as indicated."	| cursor |	cursor :=  hardwareCursor ifNil:[aBool ifTrue:[Cursor normal] ifFalse:[Cursor blank]].	Sensor currentCursor == cursor ifFalse: [cursor show].! !!HandMorph methodsFor: 'event handling' stamp: 'bobw 7/29/2010 15:01'!processEvents	"Process user input events from the local input devices."	| evt evtBuf type hadAny |	ActiveEvent ifNotNil: 			["Meaning that we were invoked from within an event response.		Make sure z-order is up to date"			self mouseOverHandler processMouseOver: lastMouseEvent].	hadAny := false.	[(evtBuf := Sensor nextEvent) isNil] whileFalse: 			[evt := nil.	"for unknown event types"			type := evtBuf first.			type = EventTypeMouse 				ifTrue: [evt := self generateMouseEvent: evtBuf].			type = EventTypeKeyboard 				ifTrue: [evt := self generateKeyboardEvent: evtBuf].			type = EventTypeDragDropFiles 				ifTrue: [evt := self generateDropFilesEvent: evtBuf].			type = EventTypeMenu				ifTrue: [evt := self generateMenuEvent: evtBuf].			type = EventTypeWindow				ifTrue: [evt := self generateWindowEvent: evtBuf].			type = EventTypePlugin				ifTrue: [evt := self generatePluginEvent: evtBuf].			"All other events are ignored"			(type ~= EventTypeDragDropFiles and: [evt isNil]) ifTrue: [^self].			evt isNil 				ifFalse: 					["Finally, handle it"					self handleEvent: evt.					hadAny := true.					"For better user feedback, return immediately after a mouse event has been processed."					evt isMouse ifTrue: [^self]]].	"note: if we come here we didn't have any mouse events"	mouseClickState notNil 		ifTrue: 			["No mouse events during this cycle. Make sure click states time out accordingly"			mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].	hadAny 		ifFalse: 			["No pending events. Make sure z-order is up to date"			self mouseOverHandler processMouseOver: lastMouseEvent]! !!HandMorph methodsFor: 'private events' stamp: 'ar 8/1/2008 19:12'!generateMenuEvent: buffer	"Not supported; just a stub"	^nil! !!HandMorph methodsFor: 'private events' stamp: 'abc 2/11/2010 22:11'!generateMouseEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| position buttons modifiers type trail stamp oldButtons evtChanged nrClicks |	evtBuf first = lastEventBuffer first 		ifTrue: 			["Workaround for Mac VM bug, *always* generating 3 events on clicks"			evtChanged := false.			3 to: evtBuf size				do: [:i | (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [evtChanged := true]].			evtChanged ifFalse: [^nil]].	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	position := evtBuf third @ evtBuf fourth.	buttons := evtBuf fifth.	modifiers := evtBuf sixth.	type := buttons = 0 		ifTrue: 			[lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]		ifFalse: 			[lastEventBuffer fifth = 0 						ifTrue: [#mouseDown]						ifFalse: [#mouseMove]].	buttons := buttons bitOr: (modifiers bitShift: 3).	oldButtons := lastEventBuffer fifth 				bitOr: (lastEventBuffer sixth bitShift: 3).	lastEventBuffer := evtBuf.	type == #mouseMove 		ifTrue: 			[trail := self mouseTrailFrom: evtBuf.			^MouseMoveEvent new 				setType: type				startPoint: (self position)				endPoint: trail last				trail: trail				buttons: buttons				hand: self				stamp: stamp].	nrClicks := evtBuf seventh.	nrClicks ifNil: [ nrClicks := 0 ].	^MouseButtonEvent new 		setType: type		position: position		which: (oldButtons bitXor: buttons)		buttons: buttons		nrClicks: nrClicks		hand: self		stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'bobw 7/30/2010 15:27'!generatePluginEvent: currentlyIgnored 	SystemEventHandler default handleSystemEvent: #pluginEvent.	^nil! !!HandMorph methodsFor: 'private events' stamp: 'ar 8/2/2008 00:22'!generateWindowEvent: buffer	"Stub implementation only; deals just with main window close event"	| windowEvent windowIndex |	windowEvent := buffer at: 3.	windowIndex := buffer at: 8.	(windowEvent == WindowEventClose and:[windowIndex == 1]) ifTrue:[		"Main window close request"		SystemEventHandler default handleSystemEvent: #mainWindowCloseRequest.	].	^nil! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/3/2006 22:39'!setUp	"subclasses will add their prototypes into this collection"	prototypes := OrderedCollection new ! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testEquality	"Check that TextFontChanges report equality correctly"	prototypes		do: [:p | self				should: [(EqualityTester with: p) result]] ! !!HashAndEqualsTestCase methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testHash	"test that TextFontChanges hash correctly"	prototypes		do: [:p | self				should: [(HashTester with: p) result]] ! !!HashAndEqualsTestCase commentStamp: 'mjr 8/20/2003 17:37' prior: 0!I am a simple TestCase that tests for correct operation of #hash and #=.Subclasses of me need to fill my prototypes with suitable objects to be tested.!!HashTester methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/3/2006 22:39'!resultFor: runs 	"Test that the hash is the same over runs and answer the result"	| hash |	hash := self prototype hash.	1		to: runs		do: [:i | hash = self prototype hash				ifFalse: [^ false]].	^ true ! !!HashTester commentStamp: 'mjr 8/20/2003 12:48' prior: 0!I provide a simple way to test the hash properties of any object.  I am given an object that should be tested and I treat it like a prototype.  I take a copy of it when I am given it so that it can't change whilst I am holding on to it.  I can then test that multiple copies of this object all hash to the same value.!!HashTesterTest methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!testBasicBehaviour	self		should: [(HashTester with: 1)				resultFor: 100].	self		should: [(HashTester with: 'fred')				resultFor: 100].	self		shouldnt: [(HashTester with: BadHasher new)				resultFor: 100] ! !!HashTesterTest commentStamp: 'mjr 8/20/2003 12:48' prior: 0!I am a simple test case to check that HashTester works correctly!!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 11/25/2009 03:55'!testGoodPrimeAtLeast	| primes |	primes := HashedCollection goodPrimes.	primes do: [ :each |		self assert: (HashedCollection goodPrimeAtLeast: each) = each.		self assert: (HashedCollection goodPrimeAtLeast: each - 1) = each.		self assert: (HashedCollection goodPrimeAtLeast: each + 1) > each ].	(0 to: 1000) do: [ :each |		| goodPrime |		goodPrime := HashedCollection goodPrimeAtLeast: each.		self assert: goodPrime isPrime.		self assert: goodPrime >= each.		self assert: (primes detect: [ :ea | ea >= each ] ifNone: [ each + 1 ]) = goodPrime ].	self assert: (HashedCollection goodPrimeAtLeast: primes last + 1) odd! !!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 3/19/2010 14:20'!testGoodPrimes	self testPrimes: HashedCollection goodPrimes! !!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 3/19/2010 14:22'!testGoodPrimesForIdentityBasedHashedCollections 	self testPrimes: HashedCollection goodPrimesForIdentityBasedHashedCollections! !!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 3/19/2010 14:20'!testPrimes: primes	self assert: primes isSorted.	primes do: [ :each | self assert: each isPrime ].	self assert: (		primes select: [ :p |			| result |			result := false.			p > 2069 ifTrue: [			1 to: 8 do: [ :k |				1 to: 32 do: [ :a |					(p gcd: (256 raisedTo: k) + a) = 1 ifFalse: [						result := true ].					(p gcd: (256 raisedTo: k) - a) = 1 ifFalse: [						result := true ] ] ] ].			result ]) isEmpty.! !!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 11/25/2009 04:23'!testSizeFor	#(		0 1 5 10 30 57 89 578 1234 1912 2411 2591 5627 7849		10999 61356 68602 73189 79868 86789 239984 239985 501175 661865 841558		9669391 15207345 19827345 23469817 27858432 65223175 106650047		157687845 190892299 234947087 264782114 269617510 270995400 		392236508 456647275 468699153 606865011 606997796 617927086		837938371 880614337 989233852 1000473294 1060034095) do: [ :each |			| size |			size := HashedCollection sizeFor: each.			size <= HashedCollection goodPrimes last ifTrue: [				self assert: size isPrime ].			self assert: size odd.			self assert: size * 3 // 4 >= each ]! !!Heap methodsFor: 'removing' stamp: 'ar 6/5/2008 12:12'!removeAllSuchThat: aBlock	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| cursor element found |	found := false.	cursor := 0.	[(cursor := cursor + 1) <= tally] whileTrue:[		element := array at: cursor.		(aBlock value: element) ifTrue:[			array at: cursor put: (array at: tally).	"swap with last entry"			array at: tally put: nil.				"clean up"			tally := tally - 1.			cursor := cursor - 1.					"check cursor again"			found := true.		].	].	found ifTrue:[self reSort].	^self! !!Heap methodsFor: 'private-heap' stamp: 'ar 4/1/2008 21:15'!isValidHeap	"Verify the correctness of the heap"	2 to: tally do:[:i|		(self sorts: (array at: i // 2) before: (array at: i)) ifFalse:[^false].	].	^true! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:33'!heapExample	"HeapTest new heapExample"	"Create a sorted collection of numbers, remove the elements	sequentially and add new objects randomly.	Note: This is the kind of benchmark a heap is designed for."	| n rnd array time sorted |	n := 5000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for Heap: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for SortedCollection: ', time printString,' msecs'.! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:34'!heapSortExample	"HeapTest new heapSortExample"	"Sort a random collection of Floats and compare the results with	SortedCollection (using the quick-sort algorithm) and 	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."	| n rnd array  time sorted |	n := 10000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| sorted removeFirst].	].	Transcript cr; show:'Time for heap-sort: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.	].	Transcript cr; show:'Time for quick-sort: ', time printString,' msecs'.	"The merge-sort version"	time := Time millisecondsToRun:[		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].	].	Transcript cr; show:'Time for merge-sort: ', time printString,' msecs'.! !!HeapTest methodsFor: 'tests' stamp: 'ar 4/1/2008 21:34'!removeAllSuchThat: testBlock from: input	"Work-horse for testRemoveAllSuchThat"	| heap any |	heap := Heap withAll: input.	self assert: (heap isValidHeap).	heap removeAllSuchThat: testBlock.	self assert: (heap isValidHeap).	any := heap detect: testBlock ifNone:[nil].	self assert: (any == nil).	^heap! !!HeapTest methodsFor: 'tests' stamp: 'ar 4/1/2008 20:57'!testRemoveAllSuchThat	"	| count result |		count := 0.		[Sensor anyButtonPressed] whileFalse:[			(count := count + 1) \\ 100 = 0 ifTrue:[count printString, '   ' displayAt: 0@0].			result := HeapTest run: #testRemoveAllSuchThat.			(result failures isEmpty and:[result errors isEmpty]) ifFalse:[self halt].		].	"	| set h |	"Remove range from sorted input"	h := self removeAllSuchThat:[:i| i <= 10 or:[i > 90]] from: (1 to: 100) asArray.	self assert: (h size = 80).	h := self removeAllSuchThat:[:i| i between: 20 and: 79] from: (1 to: 100) asArray.	self assert: (h size = 40).	"Remove range from randomized input"	h := self removeAllSuchThat:[:i| i <= 10 or:[i > 90]] from: (1 to: 100) asArray shuffled.	self assert: (h size = 80).	h := self removeAllSuchThat:[:i| i between: 20 and: 79] from: (1 to: 100) asArray shuffled.	self assert: (h size = 40).	"Remove a small random set from sorted/random input"	set := ((1 to: 100) asArray shuffled first: 10) asSet.	h := self removeAllSuchThat:[:i| set includes: i] from: (1 to: 100) asArray.	self assert: (h size = 90).	h := self removeAllSuchThat:[:i| set includes: i] from: (1 to: 100) asArray shuffled.	self assert: (h size = 90).	"Remove a large random set from sorted/random input"	set := ((1 to: 100) asArray shuffled first: 90) asSet.	h := self removeAllSuchThat:[:i| set includes: i] from: (1 to: 100) asArray.	self assert: (h size = 10).	h := self removeAllSuchThat:[:i| set includes: i] from: (1 to: 100) asArray shuffled.	self assert: (h size = 10).	"Remove none/all"	h := self removeAllSuchThat:[:i| false] from: (1 to: 100) asArray.	self assert: (h size = 100).	h := self removeAllSuchThat:[:i| true] from: (1 to: 100) asArray.	self assert: (h size = 0).! !!HeapTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!test1	| data |	"The first element of each array is the sort value, and the second will be updated by the heap with the index of the element within the heap."	data :=  (1 to: 8) collect: [:i | {i*2. 0}].	"Repeat with different data ordering."	5 timesRepeat: [ | h |		h := Heap new sortBlock: [:e1 :e2 | e1 first < e2 first].		h indexUpdateBlock: [:array :index | array at: 2 put: index].		data shuffled do: [:d | h add: d].		data do: [:d | self should: (h at: d second) == d].	]! !!HeapTest methodsFor: 'testing' stamp: 'md 2/12/2006 15:35'!testExamples	self shouldnt: [self heapExample] raise: Error.	self shouldnt: [self heapSortExample] raise: Error.! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 2/28/2006 09:37'!testAdd	"self run: #testAdd"	| heap |	heap := Heap new.	self assert: heap size = 0.	heap add: 3.	self assert: heap size = 1.	self assert: heap isEmpty not.	self assert: heap first = 3.	self assert: (heap at: 1) = 3.	heap add: 2.	self assert: heap size = 2.	self assert: heap first = 2.	self assert: (heap at: 2) = 3.	! !!HeapTest methodsFor: 'basic tests' stamp: 'sd 4/8/2006 21:37'!testAt	"self run: #testAt"	| heap |	heap := Heap new.	heap add: 3.	self assert: (heap at: 1) = 3.	self should: [heap at: 2] raise: Error.	heap add: 4.	self assert: (heap at: 1) = 3.	self assert: (heap at: 2) = 4.	! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 4/3/2006 11:22'!testDo	"self run: #testDo"	| heap coll |	heap := Heap withAll: #(1 3 5).	coll := OrderedCollection new.		heap do: [:each | coll add: each].		self assert: coll = #(1 3 5) asOrderedCollection.! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 2/28/2006 09:36'!testFirst	"self run: #testFirst"	| heap |	heap := Heap new.	heap add: 5.	heap add: 12.	heap add: 1.	self assert: heap first = 1.	heap removeFirst.	self assert: heap first = 5.! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 4/3/2006 11:27'!testHeap	"self run: #testHeap"	| heap |	heap := Heap new.	self assert: heap isHeap.		self assert: heap isEmpty.	heap add: 1.	self assert: heap isEmpty not	! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 2/15/2006 09:55'!testRemove	"self run: #testRemove"		| heap |	heap := Heap new.	self should: [heap removeFirst] raise: Error.	heap add: 5.	self shouldnt: [heap removeFirst] raise: Error.	self assert: heap size = 0.	heap add: 5.	self should: [heap removeAt: 2] raise: Error.! !!HeapTest methodsFor: 'basic tests' stamp: 'nm 4/3/2006 11:17'!testSortBlock	"self run: #testSortBlock"	| heap |	heap := Heap withAll: #(1 3 5).	self assert: heap = #(1 3 5).		heap sortBlock: [ :e1 :e2 | e1 >= e2 ].	self assert: heap = #(5 3 1)! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:26'!testCharacterHex| result |result _ $a hex.self assert: result = '61'.result _ $A hex.self assert: result = '41'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:39'!testColorPrintHtmlStringself assert: (Color red printHtmlString ) = ( Color red asHTMLColor allButFirst asUppercase).! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:21'!testIntegerHex| result |result _ 15 asInteger hex.self assert: result = '0F'.result _ 0 asInteger hex.self assert: result = '00'.result _ 255 asInteger hex.self assert: result = 'FF'.result _ 90 asInteger hex.self assert: result = '5A'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:44'!testStringAsHex| result |result _ 'abc' asHex.self assert: result = '616263'.! !!HexTest commentStamp: 'JPF 6/26/2007 10:15' prior: 0!Rather than testing a single class, this set of tests looks at the interactions between Character, String, Integer and Color using hex and printStringHex!!HierarchicalURI methodsFor: 'accessing' stamp: 'hrs 12/17/2009 09:12'!absoluteReference	"Answer the path, query, and fragment parts. 	See sections 3 and 4.2 of http://tools.ietf.org/html/rfc3986"	| reference |	reference := self schemeSpecificPart.	"Despite what #printSchemeSpecificPartOn: does, the RFC says to do query first and the fragment."	self query ifNotNil: [:q | reference := reference, q].	"#query includes the $?, but #fragment does not include the $#.  Go figure."	self fragment ifNotNil: [:f | reference := reference, '#', f].	^reference! !!HierarchicalURI methodsFor: 'directory operations' stamp: 'mir 7/22/2005 11:38'!assureExistence	(self clientClass uri: self) assureExistence! !!HierarchicalURI methodsFor: 'printing' stamp: 'ar 9/1/2010 15:24'!allButScheme	"Answer the entire url except its scheme"	^String streamContents:[:s|		authority ifNotNil:[self authority printOn: s].		s nextPutAll: super allButScheme.		query ifNotNil:[s nextPutAll: query].	].! !!HierarchicalUrlTest methodsFor: 'testing' stamp: 'fbs 2/2/2005 13:03'!testAsString	| url |	url := HierarchicalUrl new		schemeName: 'ftp'		authority: 'localhost'		path: #('path' 'to' 'file')		query: 'aQuery'.	self assert: url asString = 'ftp://localhost/path/to/file?aQuery'.! !!HierarchyBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^true! !!ICMPSocket methodsFor: 'ping' stamp: 'ar 1/5/2009 18:55'!ping: hostAddr	"Ping the given host. Useful for checking network connectivity."	"ICMPSocket ping: 'www.qwaq.com'"	^self ping: hostAddr timeout: 1000! !!ICMPSocket methodsFor: 'ping' stamp: 'ar 1/7/2009 14:43'!ping: serverAddr at: interval do: timeBlock until: doneBlock	"Continuously ping the given server address every interval msecs.	Evaluate aBlock with the ping times."	| icmp data dgram id buffer word1 ipHdrLen type trip deadline |	id := self identityHash.	icmp := ByteArray new: 64 withAll: $Q asciiValue.	icmp byteAt: 1 put: 8. "type = ICMP_ECHO"	icmp byteAt: 2 put: 0. "code = 0"	icmp unsignedShortAt: 3 put: 0 bigEndian: true."chksum = 0"	icmp unsignedShortAt: 5 put: id bigEndian: true."id = 0"	icmp unsignedShortAt: 7 put: 0 bigEndian: true."seq = 0"	"user data"	icmp unsignedLongAt: 9 put: Time millisecondClockValue bigEndian: true.	buffer := ByteArray new: 128.	[doneBlock value] whileFalse:[		"Send a new ping request"		icmp unsignedLongAt: 9 put: Time millisecondClockValue bigEndian: true.		self sendUDPData: icmp toHost: serverAddr port: 53.		"Process incoming echo responses until its time to send another ping"		deadline := Time millisecondClockValue + interval.		[Time millisecondClockValue < deadline] whileTrue:[			self dataAvailable ifFalse:[				self readSemaphore waitTimeoutMSecs: deadline - Time millisecondClockValue.			].			dgram := self receiveUDPDataInto: buffer.			(dgram at: 1) = 0 ifFalse:[				word1 := buffer unsignedLongAt: 1 bigEndian: true.			"	ipVer := (word1 >> 28) bitAnd: 15.	"				ipHdrLen := (word1 >> 24) bitAnd: 15.			"	ipTos := (word1 >> 16) bitAnd: 255.	"			"	ipPkgLen := word1 bitAnd: 16rFFFF.	"				data := buffer copyFrom: (ipHdrLen * 4) + 1 to: (dgram at: 1).				type := data byteAt: 1.				id := data unsignedShortAt: 5 bigEndian: true.				(type = 0 and:[id = self identityHash]) ifTrue:[					trip := Time millisecondClockValue - (data unsignedLongAt: 9 bigEndian: true).					timeBlock value: trip.				].			].		].	].! !!ICMPSocket methodsFor: 'ping' stamp: 'ar 1/6/2009 15:51'!ping: serverAddr timeout: msecs	"Ping the given host. Useful for checking network connectivity."	"ICMPSocket ping: 'www.qwaq.com'"	| icmp data dgram id buffer word1 ipHdrLen type trip timeout delta |	id := self identityHash.	icmp := ByteArray new: 64 withAll: $Q asciiValue.	icmp byteAt: 1 put: 8. "type = ICMP_ECHO"	icmp byteAt: 2 put: 0. "code = 0"	icmp unsignedShortAt: 3 put: 0 bigEndian: true."chksum = 0"	icmp unsignedShortAt: 5 put: id bigEndian: true."id = 0"	icmp unsignedShortAt: 7 put: 0 bigEndian: true."seq = 0"	"user data"	icmp unsignedLongAt: 9 put: Time millisecondClockValue bigEndian: true.	buffer := ByteArray new: 128.	self sendUDPData: icmp toHost: serverAddr port: 53.	timeout := Time millisecondClockValue + msecs.	[self dataAvailable ifFalse:[		delta := timeout - Time millisecondClockValue.		delta > 0 ifTrue:[self readSemaphore waitTimeoutMSecs: delta].	].	dgram := self receiveUDPDataInto: buffer.	"Extract IP header from raw ip datagram"	(dgram at: 1) = 0] whileFalse:[		word1 := buffer unsignedLongAt: 1 bigEndian: true.	"	ipVer := (word1 >> 28) bitAnd: 15.	"		ipHdrLen := (word1 >> 24) bitAnd: 15.	"	ipTos := (word1 >> 16) bitAnd: 255.	"	"	ipPkgLen := word1 bitAnd: 16rFFFF.	"		data := buffer copyFrom: (ipHdrLen * 4) + 1 to: (dgram at: 1).		type := data byteAt: 1.		id := icmp unsignedShortAt: 5 bigEndian: true.		(type = 0 and:[id = self identityHash]) ifTrue:[			trip := Time millisecondClockValue - (icmp unsignedLongAt: 9 bigEndian: true).			^trip		].	].	^nil! !!ICMPSocket class methodsFor: 'utilities' stamp: 'ar 1/5/2009 19:10'!examplePing: serverName	"ICMPSocket examplePing: 'www.qwaq.com'"	| bag |	'Pinging ', serverName displayProgressAt: Sensor cursorPoint from: 1 to: 10 during:[:bar|		bag := self ping: serverName for: 10 informing: bar.	].	Transcript cr; show: 'Ping statistics for: ', serverName.	bag sortedCounts do:[:assoc| Transcript cr; show: assoc].	^bag! !!ICMPSocket class methodsFor: 'utilities' stamp: 'ar 1/5/2009 18:54'!ping: serverName	"ICMPSocket ping: 'www.qwaq.com'"	^self ping: serverName timeout: 1000! !!ICMPSocket class methodsFor: 'utilities' stamp: 'ar 1/5/2009 19:11'!ping: serverName for: seconds informing: bar	"ICMPSocket ping: 'www.qwaq.com' for: 2 informing: nil"	| serverAddr socket startTime deadline nowTime trip bag |	bag := Bag new.	serverAddr := NetNameResolver addressForName: serverName.	socket := self new.	[		startTime := Time totalSeconds.		deadline := startTime + seconds.		[nowTime := Time totalSeconds.		nowTime <= deadline] whileTrue:[			bar ifNotNil:[bar value: nowTime - startTime].			trip := socket ping: serverAddr..			bag add: trip.		].	] ensure:[socket destroy].	^bag! !!ICMPSocket class methodsFor: 'utilities' stamp: 'ar 1/5/2009 19:00'!ping: serverName timeout: msecs	"ICMPSocket ping: 'www.qwaq.com'"	| serverAddr socket |	serverAddr := NetNameResolver addressForName: serverName.	socket := self new.	^[socket ping: serverAddr timeout: msecs] ensure:[socket destroy].! !!ICMPSocket class methodsFor: 'instance creation' stamp: 'ar 1/5/2009 18:45'!new	^self newRAW: 1! !!IdentityBagTest methodsFor: 'tests' stamp: 'EP 3/8/2006 09:50'!testIdentity	"self run:#testIdentity"	"self debug:#testIdentity"	| bag identityBag aString anOtherString |		aString := 'hello'.	anOtherString := aString copy.		self assert: (aString = anOtherString).	self assert: (aString == anOtherString) not.	bag := Bag new.	bag add: aString.	bag add: aString.	bag add: anOtherString.	self assert: (bag occurrencesOf: aString) = 3.	self assert: (bag occurrencesOf: anOtherString) = 3.		identityBag := IdentityBag new.	identityBag add: aString.	identityBag add: aString.	identityBag add: anOtherString.		self assert: (identityBag occurrencesOf: aString) = 2.	self assert: (identityBag occurrencesOf: anOtherString) = 1.! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'bgf 12/7/2008 15:32'!readerClass: aBinaryStream	"Answer an image reader class that understands the given stream,	 or nil if the stream does not appear to supply an image."	^ [ 		self withAllSubclasses			detect: [:subclass | subclass understandsImageFormat: aBinaryStream]			ifNone: [ nil ]	   ] ensure: [ aBinaryStream reset ].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 7/21/2008 14:18'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements naughtyBlocks goodToGo allClasses sizeHint proj |	Smalltalk forgetDoIts.	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj :=dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses := SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs := dummy references."	arrayOfRoots := self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements := dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy := nil.	"force GC?"	naughtyBlocks := arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [			goodToGo := (UIManager default				chooseFrom: #('keep going' 'stop and take a look')				title:'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?') == 1.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint := (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 1/21/2010 10:52'!rootsIncludingBlocks	"For export segments only.  Return a new roots array with more objects.  (Caller should store into rootArray.)  Collect Blocks and external methods pointed to by them.  Put them into the roots list.  Then ask for the segment again."	| extras have |	userRootCnt ifNil: [userRootCnt := arrayOfRoots size].	extras := OrderedCollection new.	outPointers do: [:anOut | 		anOut class == CompiledMethod ifTrue: [extras add: anOut].		(anOut isBlock) ifTrue: [extras add: anOut].		(anOut class == MethodContext) ifTrue: [extras add: anOut]].	[have := extras size.	 extras copy do: [:anOut |		anOut isBlock ifTrue: [			anOut home ifNotNil: [				(extras includes: anOut home) ifFalse: [extras add: anOut home]]].		(anOut class == MethodContext) ifTrue: [			anOut method ifNotNil: [				(extras includes: anOut method) ifFalse: [extras add: anOut method]]]].	 have = extras size] whileFalse.	extras := extras select: [:ea | (arrayOfRoots includes: ea) not].	extras isEmpty ifTrue: [^ nil].	"no change"	^ arrayOfRoots, extras! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 7/1/2010 14:34'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs existing |userRootCnt ifNil: [userRootCnt := arrayOfRoots size].extras := OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter := root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter := root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter := root world presenter]].(havePresenter notNiland: [havePresenter respondsTo: #associatedMorph]) ifTrue: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs := IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players := (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asArray.	players := players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	extras addAll: morphs.	"Make then ALL roots!!"	].existing := arrayOfRoots asIdentitySet.extras := extras reject: [ :each | existing includes: each].extras isEmpty ifTrue: [^ nil].	"no change"			havePresenter := players := morphs := nil.		^ arrayOfRoots, extras	"will contain multiples of some, but reduced later"! !!InflateStream methodsFor: 'accessing' stamp: 'bgf 5/23/2008 18:05'!next	"Answer the next decompressed object in the Stream represented by the	receiver."	"<primitive: 65>  Doesn't pay its way."	position >= readLimit		ifTrue: [^self pastEndRead]		ifFalse: [^collection at: (position := position + 1)]! !!InputSensor methodsFor: 'user interrupts' stamp: 'ar 1/22/2005 18:51'!installInterruptWatcher	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installInterruptWatcher"	World		ifNil:[self installInterruptWatcher:[self tweakInterruptWatcher]]		ifNotNil:[self installInterruptWatcher:[self userInterruptWatcher]].! !!InputSensor methodsFor: 'user interrupts' stamp: 'ar 11/23/2004 18:27'!installInterruptWatcher: aBlock	"Initialize the interrupt watcher process. Terminate the old process if any."	InterruptWatcherProcess == nil ifFalse: [InterruptWatcherProcess terminate].	InterruptSemaphore := Semaphore new.	InterruptWatcherProcess := aBlock newProcess.	InterruptWatcherProcess priority: Processor lowIOPriority.	InterruptWatcherProcess resume.	self primInterruptSemaphore: InterruptSemaphore.! !!InputSensor class methodsFor: 'public' stamp: 'ar 6/15/2007 11:01'!interruptSemaphore	"Answer the semaphore being signaled when the user hits the interrupt key combination"	^InterruptSemaphore! !!Inspector methodsFor: 'selecting' stamp: 'eem 3/12/2009 15:10'!defaultIntegerBase	"Answer the default base in which to print integers.	 Defer to the class of the instance."	^[object class methodClass defaultIntegerBaseInDebugger]		on: MessageNotUnderstood		do: [:ex| 10]! !!Inspector methodsFor: 'selecting' stamp: 'eem 2/16/2009 18:26'!selectionPrintString	| text |	selectionUpdateTime := [text := [self selection isInteger										ifTrue: [self selection storeStringBase: self defaultIntegerBase]										ifFalse: [self selection printStringLimitedTo: 5000]]						on: Error						do: [text := self printStringErrorText.							text								addAttribute: TextColor red								from: 1								to: text size.							text]] timeToRun.	^ text! !!InstVarRefLocatorTest methodsFor: 'examples' stamp: 'sd 6/5/2005 08:27'!example1	| ff |	(1 < 2) ifTrue: [tt ifNotNil: [ff := 'hallo']].	^ ff.! !!InstVarRefLocatorTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:31'!example2	| ff|		ff := 1.	(1 < 2) ifTrue: [ff ifNotNil: [ff := 'hallo']].	^ ff.! !!InstVarRefLocatorTest methodsFor: 'private' stamp: 'md 4/8/2003 12:39'!hasInstVarRef: aMethod	"Answer whether the receiver references an instance variable."	| scanner end printer |	scanner := InstructionStream on: aMethod.	printer := InstVarRefLocator new.	end := scanner method endPC.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!InstVarRefLocatorTest methodsFor: 'tests' stamp: 'md 4/8/2003 12:42'!testExample1	| method |	method := self class compiledMethodAt: #example1.	self assert: (self hasInstVarRef: method).! !!InstVarRefLocatorTest methodsFor: 'tests' stamp: 'md 4/8/2003 12:42'!testExample2	| method |	method := self class compiledMethodAt: #example2.	self deny: (self hasInstVarRef: method).! !!InstVarRefLocatorTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testInstructions		Object methodDict do: [:method | | scanner printer end |		scanner := InstructionStream on: method.		printer := InstVarRefLocator new.		end := scanner method endPC.		[scanner pc <= end] whileTrue: [			self shouldnt: [printer interpretNextInstructionUsing: scanner] raise: Error.		].	].! !!InstVarRefLocatorTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstVarRefLocator. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!addPackage: anObject	self packages add: anObject! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!availablePackages		^ self basicAvailablePackages! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:33'!bootstrap	"keep for compatability"		self deprecatedApi.	useFileIn := true.	self install.! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!browse	self logErrorDuring: [self basicBrowse]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!browse: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self browse! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:30'!fileInSource	useFileIn := true.	self install.! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:35'!initialize	useFileIn := false..! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:40'!install		noiseLevel = #quiet ifTrue: [ ^ self installQuietly ].	noiseLevel = #silent ifTrue: [ ^ self installSilently ].		^ self installLogging! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:45'!install: packageNameCollectionOrDetectBlock	self addPackage: packageNameCollectionOrDetectBlock.	self install! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:39'!installLogging	self logErrorDuring: [self basicInstall]! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:40'!installQuietly   	[ self installLogging ] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:41'!installQuietly: packageNameCollectionOrDetectBlock	self quietly install: packageNameCollectionOrDetectBlock. ! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:40'!installSilently	SystemChangeNotifier uniqueInstance doSilently: [ self installLogging ]	! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 18:48'!open! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:36'!quietly	noiseLevel := #quiet! !!Installer methodsFor: 'public interface' stamp: 'kph 3/30/2009 01:36'!silently	noiseLevel := #silent! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!versions		^ self basicVersions! !!Installer methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!view	self logErrorDuring: [self basicView]! !!Installer methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:06'!view: packageNameCollectionOrDetectBlock	self package: packageNameCollectionOrDetectBlock.	self view! !!Installer methodsFor: 'auto answering' stamp: 'sd 3/6/2008 18:46'!answer: aString with: anAnswer	^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'auto answering' stamp: 'kph 2/5/2008 15:48'!suppress: aMessage	messagesToSuppress add: aMessage! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/21/2006 06:52'!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers	^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:46'!answers: anObject	answers := anObject! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!isSkipLoadingTestsSet	^SkipLoadingTests ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:37'!label	^ self class label! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!messagesToSuppress	^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!messagesToSuppress: anObject	messagesToSuppress := anObject! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package	^ self packages isEmpty ifTrue: [ nil ] ifFalse: [ self packages last ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!package: anObject	self addPackage: anObject.! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages	 	^ packages ifNil: [ packages := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:48'!packages: aCollection 	packages := aCollection! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicBrowse! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicInstall! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicVersions! !!Installer methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicView! !!Installer methodsFor: 'script bindings' stamp: 'kph 5/8/2007 19:52'!bindingOf: aString 		InstallerBindings isNil ifTrue: [ InstallerBindings := Dictionary new].	(InstallerBindings includesKey: aString)		ifFalse: [InstallerBindings at: aString put: nil].	^ InstallerBindings associationAt: aString.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:03'!browse: aFileName from: stream		| mcThing ext browseSelector |		 	self log: ' browsing...'. 		mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].				mcThing 			ifNotNil: [ (mcThing respondsTo: #snapshot) 						ifTrue: [ mcThing browse ]				        	ifFalse: [ (MCSnapshotBrowser forSnapshot: mcThing) showLabelled: 'Browsing ', aFileName ]			]			ifNil: [ 						ext := aFileName copyAfterLast: $..				browseSelector := ('browse', ext asUppercase, ':from:') asSymbol.					(self respondsTo: browseSelector)					ifTrue: [ self perform: browseSelector with: aFileName with: stream ]					ifFalse: [ self browseDefault: aFileName from: stream ].			]! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 13:49'!browseCS: aFileName from: stream 		| list |		list := self classChangeList new			scanFile: stream from: 1 to: stream size.		 	self classChangeList open: list name: aFileName		multiSelect: true.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/19/2007 12:05'!browseDefault: aFileName from: stream	self view: aFileName from: stream! !!Installer methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:08'!browseGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	ChangeList browseStream: unzipped	! !!Installer methodsFor: 'mantis' stamp: 'nice 2/11/2010 20:42'!install: aFileName from: stream	self log: ' installing...'.	self withAnswersDo: [		| ext installSelector mcThing |		mcThing := self classMCReader ifNotNil: [ self mcThing: aFileName from: stream ].		mcThing 			ifNotNil: [ (mcThing respondsTo: #install) 						ifTrue: [ mcThing install ]				        	ifFalse: [ (mcThing respondsTo: #load) ifTrue: [ mcThing load ] ]			]			ifNil: [ 				ext := (aFileName copyAfterLast: $/) in: [ :path | path isEmpty ifTrue: [ aFileName ] ifFalse: [ path ] ].				ext :=  ext copyAfterLast: $..				ext = '' ifTrue: [ ext := 'st' ].				installSelector := ('install', ext asUppercase, ':from:') asSymbol.					useFileIn ifTrue: [ 				[					SystemChangeNotifier uniqueInstance doSilently: [self install: aFileName from: stream using: installSelector ]] 						on: Warning do: [ :ex | ex resume: true ].				] ifFalse: [					self install: aFileName from: stream using: installSelector. 				]			]	]. 	self log: ' done.'! !!Installer methodsFor: 'mantis' stamp: 'kph 2/24/2009 08:07'!install: aFileName from: stream using: installSelector		(self respondsTo: installSelector)			ifTrue: [ self perform: installSelector with: aFileName with: stream ]			ifFalse: [ self installDefault: aFileName from: stream ].! !!Installer methodsFor: 'mantis' stamp: 'kph 5/9/2007 18:14'!installCS: aFileName from: stream 	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).! !!Installer methodsFor: 'mantis' stamp: 'nice 3/27/2010 21:14'!installDefault: aFileName from: stream	"Check for UTF-8 input before filing it in"	| pos |	pos := stream position.	(stream next: 3) asByteArray = #[16rEF 16rBB 16rBF]	"BOM"		ifTrue: [(RWBinaryOrTextStream on: stream upToEnd utf8ToSqueak) fileIn]		ifFalse: [stream position: pos; fileIn]! !!Installer methodsFor: 'mantis' stamp: 'cmm 2/11/2010 12:34'!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self 		newChangeSetFromStream: unzipped 		named: (FileDirectory localNameFor: aFileName)! !!Installer methodsFor: 'mantis' stamp: 'mtf 2/4/2010 10:04'!installMCZ: aFileName from: stream 	| source pkg wc |		pkg := aFileName copyUpToLast: $-.		wc := Smalltalk at: #MCWorkingCopy ifAbsent: [ nil ].wc ifNotNil: [ 	(wc allManagers select:  [:each | each packageName = pkg ]) do: [ :ea | ea unregister ] ].		self classMczInstaller ifNotNil: [^ self classMczInstaller install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: 'snapshot/source.st') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: 'Booting ' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'mantis' stamp: 'mtf 2/4/2010 10:05'!installMCZBasic: aFileName from: stream 	| source |	 	self classMczInstaller ifNotNil: [^ self classMczInstaller install: aFileName stream: stream].  	source :=  ((ZipArchive new readFrom:stream) memberNamed: 'snapshot/source.st') contents.	[		SystemChangeNotifier uniqueInstance doSilently: [ 			source  readStream fileInAnnouncing: 'Booting ' , aFileName. 		]	] on: Warning do: [ :ex | ex resume: true ].! !!Installer methodsFor: 'mantis' stamp: 'DamienCassou 11/16/2009 14:23'!installMCcs: aFileName from: stream 	| reader |		reader := Smalltalk at: #MCCsReader ifPresent: [:class | class on: stream].! !!Installer methodsFor: 'mantis' stamp: 'mtf 2/4/2010 10:17'!installSAR: aFileName from: stream 	| newCS |	newCS := self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self removeChangeSet: newCS ]! !!Installer methodsFor: 'mantis' stamp: 'kph 3/30/2009 01:28'!mcThing: aFileName from: stream			"dont use monticello for .cs or for .st use monticello for .mcs"	| reader |		useFileIn ifTrue: [ ^ nil ].		reader := self classMCReader readerClassForFileNamed: aFileName.	reader name = 'MCStReader' ifTrue: [ ^ nil ].	reader ifNil: [ ^ nil ].	(reader respondsTo: #on:fileName:) 		ifTrue: [ reader := reader on: stream fileName: aFileName.					^ reader version  ]		ifFalse: [ reader := reader on: stream. 				    ^ reader snapshot  ].! !!Installer methodsFor: 'mantis' stamp: 'nice 12/27/2009 20:54'!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[ | newStream |	newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: 'Loading ' , newName , '...'.			Transcript cr; show: 'File ' , aName , ' successfully filed in to change set ' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet! !!Installer methodsFor: 'mantis' stamp: 'kph 5/10/2007 00:21'!view: aFileName from: stream		self log: ' viewing...'. 		Workspace new contents: (stream contents); openLabel: aFileName. 	 				 ! !!Installer methodsFor: 'utils' stamp: 'kph 3/12/2009 23:19'!changeSetNamed: aName	(ChangeSet respondsTo: #named:)		ifTrue: [ ^ ChangeSet named: aName ].			^ ChangeSorter changeSetNamed: aName.! !!Installer methodsFor: 'utils' stamp: 'kph 3/12/2009 23:18'!ditchOldChangeSetFor: aFileName 	| changeSetName changeSet | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	changeSet := self changeSetNamed: changeSetName.		changeSet ifNotNil: [				(self logCR:'Removing old change set ', changeSetName) cr.		self  removeChangeSet: changeSet 	].! !!Installer methodsFor: 'utils' stamp: 'kph 5/25/2007 01:15'!removeChangeSet: cs	(self classChangeSet respondsTo: #removeChangeSet:)		ifTrue: [ ^ChangeSet removeChangeSet: cs ].			^ self classChangeSorter removeChangeSet: cs .! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeList	^Smalltalk at: #ChangeList  ifAbsent: [ self error: 'ChangeList not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSet	^Smalltalk at: #ChangeSet  ifAbsent: [ self error: 'ChangeSet not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classChangeSorter	^Smalltalk at: #ChangeSorter ifAbsent: [ self error: 'ChangeSorter not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classGZipReadStream	^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: 'Compression not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCReader	^Smalltalk at: #MCReader ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMczInstaller	^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classMultiByteBinaryOrTextStream	^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: 'MultiByteBinaryOrTextStream not present' ]! !!Installer methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSARInstaller	^Smalltalk at: #SARInstaller  ifAbsent: [ self error: 'SARInstaller not present' ]! !!Installer methodsFor: 'logging' stamp: 'sd 3/6/2008 20:23'!log: text	^Transcript show: text.! !!Installer methodsFor: 'logging' stamp: 'mtf 10/15/2008 08:08'!logCR: text	self validate.	^ Transcript show: text; cr! !!Installer methodsFor: 'logging' stamp: 'kph 9/1/2008 21:39'!logErrorDuring: block	(IsSetToTrapErrors = true) ifFalse: [ ^ block value ].	block on: Error 		do: [ :e |			self halt. 			self logCR: '****', e class name, ': ', (e messageText ifNil: [ '']). 					(e isKindOf: MessageNotUnderstood) 				ifTrue: [ e pass ]				ifFalse: [ e isResumable ifTrue:[ e resume: true ]]]! !!Installer methodsFor: 'logging' stamp: 'kph 5/25/2007 01:36'!validate	ValidationBlock value = false ifTrue: [ self error: 'Validation failed' ].! !!Installer methodsFor: 'searching' stamp: 'kph 1/4/2007 23:59'!match: aMatch	^self packagesMatching: aMatch! !!Installer methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^'search type not supported'! !!Installer methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:29'!search: aMatch	^'search type not supported'! !!Installer methodsFor: 'squeakmap' stamp: 'mtf 10/15/2008 10:14'!packageAndVersionFrom: pkg	| p |	p := ReadStream on: pkg .	^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printConfigurationOn: stream	! !!Installer methodsFor: 'printing' stamp: 'damiencassou 2/20/2009 20:30'!printOn: s	s		nextPutAll: '(Installer ';		nextPutAll: self label;		nextPut: $).	"lf project ifNotNil: [ s nextPutAll: ' project:'; nextPutAll: '''', self project, ''''.						self package ifNotNil: [ s nextPutAll: '; '] ]."	self package ifNotNil: [ s nextPutAll: ' package:'; nextPutAll: '''', self package asString, '''' ].	self printConfigurationOn: s.	s nextPut: $..! !!Installer methodsFor: 'custom names' stamp: 'kph 5/28/2007 03:42'!rememberAs: symbol	self class remembered at: symbol asSymbol put: self! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		Installer actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ]].! !!Installer methodsFor: 'action report' stamp: 'sd 3/6/2008 18:45'!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].	report nextPutAll: '">>>> ' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	! !!Installer methodsFor: 'url' stamp: 'sd 3/6/2008 20:20'!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes"	 	(aFileName beginsWith:'http:') ifTrue: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: '.' with: '-').			asUrl path allButLastDo: [:each |				stream					nextPutAll: '/';					nextPutAll: (each copyReplaceAll: '.' with: '-') ].			stream				nextPutAll: '/';				nextPutAll: asUrl path last ] ].	^aFileName! !!Installer commentStamp: 'kph 3/30/2009 01:29' prior: 0!Documentation now available at http://installer.pbwiki.com/Installer useFileIn - flag to load source.st rather than using Monticello!!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.	self allSubclassesDo: [:class |		(class canReportLine: line)		ifTrue: [ ^ class new action: theLine reportOn: report ]].	^ aBlock value! !!Installer class methodsFor: 'action report' stamp: 'kph 3/30/2009 01:30'!bootstrapTheRestOfInstaller	(Installer url: 'www.squeaksource.com/Installer/Installer-Scripts')  			fileInSource;			logCR: 'installer bootstrap - loaded'.! !!Installer class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ false! !!Installer class methodsFor: 'action report' stamp: 'kph 2/23/2009 05:27'!install: scriptName	^ (self scripts install: scriptName) ifNil:[ self web install: scriptName ]! !!Installer class methodsFor: 'mantis' stamp: 'kph 2/15/2009 05:21'!bug: n fix: filename	Transcript cr; show: 'Code script in Mantis:', n asString, ' should read Installer mantis bug: ',n asString, ' fix: ', filename printString,'.'.		^ self mantis bug: n fix: filename! !!Installer class methodsFor: 'mantis' stamp: 'kph 3/14/2007 21:07'!mantis	^ self mantis: 'http://bugs.squeak.org/'! !!Installer class methodsFor: 'mantis' stamp: 'mtf 10/8/2008 12:00'!mantis: host	^ InstallerMantis host: host! !!Installer class methodsFor: 'monticello' stamp: 'mtf 5/20/2008 22:10'!cache	^ self monticello cache! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!mc	^ self monticello! !!Installer class methodsFor: 'monticello' stamp: 'kph 5/10/2007 00:49'!monticello	^ InstallerMonticello new! !!Installer class methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:24'!repository: host  	^self monticello http: host ! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!cancelSkipLoadingTests	"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := false. ! !!Installer class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 20:29'!label	^ ''! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!skipLoadingTests	"sets a flag to ignore loading of the testing portion of scripts embedded in pages"		SkipLoadingTests := true. ! !!Installer class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:28'!validationBlock	^ ValidationBlock! !!Installer class methodsFor: 'accessing' stamp: 'kph 5/25/2007 01:34'!validationBlock: aBlock	ValidationBlock := aBlock! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!debug	IsSetToTrapErrors := false! !!Installer class methodsFor: 'debug' stamp: 'kph 5/9/2007 23:05'!noDebug	IsSetToTrapErrors := true! !!Installer class methodsFor: 'launcher support' stamp: 'kph 2/23/2009 01:55'!do: webPageName	| rs |	rs := webPageName readStream.	[ rs atEnd ] whileFalse: [ self install: (rs upTo: $;) ].! !!Installer class methodsFor: 'launcher support' stamp: 'kph 2/27/2007 18:57'!launchFrom: launcher	^self launchWith: launcher getParameters! !!Installer class methodsFor: 'launcher support' stamp: 'kph 5/24/2007 19:59'!launchHelp^'path=/dir/*.txt          Specify a search path for the item to installp=/dir1/*.txt;<url2>/    Multiple items delimited by ;                         The page name is typically appended to the path string, or                         if a "*" is present, it will be replaced by the page name.					in,i,install=<page>      Page appended to the path to begin the install processurl,u=<url>              Install using an explicit url from which to obtain a script or filefile=<url>                Install using a local file+debug                   Do not trap errorsview=<page>              Print the script that would have been installed.For more options use Script eval="Installer ... " '! !!Installer class methodsFor: 'launcher support' stamp: 'kph 1/11/2008 07:58'!launchWith: params 	params at: 'P' ifPresent: [ :v | params at: 'PATH' put: v ]. 	params at: 'I' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'IN' ifPresent: [ :v | params at: 'INSTALL' put: v ]. 	params at: 'U' ifPresent: [ :v | params at: 'URL' put: v ].	params at: 'PATH' ifPresent: [ :v | 		self webSearchPathFrom: v.	].	params at: 'USER' ifPresent: [ :v | 		Utilities setAuthorInitials: v	].	params at: 'VERSION' ifPresent: [ :v | 		SystemVersion current version: v	].	params at: 'VIEW' ifPresent: [ :v |		self view: v	].	IsSetToTrapErrors := true.	params at: 'DEBUG' ifPresent: [ :v | IsSetToTrapErrors := (v == true) not ]. 	params at: 'URL' ifPresent: [ :v | 		 self installUrl: v	].	params at: 'FILE' ifPresent: [ :v | 		 self installFile: v	].  	params at: 'INSTALL' ifPresent: [ :v | 		  self do: v	].	params at: 'DO' ifPresent: [ :v | 		  self do: v	]. 	 ^true	! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 05:11'!doesNotUnderstand: aMessage	^ self remembered at: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]! !!Installer class methodsFor: 'custom names' stamp: 'kph 5/28/2007 00:54'!remembered	^	Remembered ifNil: [ Remembered := IdentityDictionary new ]! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 15:49'!file	^ InstallerFile new! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!file: fileName 	^ InstallerFile new file: fileName; yourself! !!Installer class methodsFor: 'file' stamp: 'mtf 10/23/2008 16:08'!installFile: fileName 	^ (self file: fileName) install.! !!Installer class methodsFor: 'url' stamp: 'kph 7/20/2009 23:39'!fromUrl: aUrl	"try and pick an Installer appropriate for the Url"	| inst | 	((aUrl endsWith: '.mcz') or: [ aUrl endsWith: '.mcm' ])	ifTrue: [ inst := Installer mc fromUrl: aUrl.		inst packages isEmpty ifFalse: [ ^ inst ]	] .		^ Installer url: aUrl 	! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installSilentlyUrl: urlString	^ SystemChangeNotifier uniqueInstance doSilently: [ self url url: urlString; install ].! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:24'!installUrl: urlString	^ self url url: urlString; install.! !!Installer class methodsFor: 'url' stamp: 'kph 12/9/2008 03:10'!url	^ InstallerUrl new url: ''! !!Installer class methodsFor: 'url' stamp: 'stephane.ducasse 9/30/2008 18:26'!url: urlString	^self url url: urlString; yourself! !!Installer class methodsFor: 'repositories' stamp: 'kph 6/2/2008 20:21'!goran	^ self monticello http: 'squeak.krampe.se'; project: ''! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:29'!impara	^ self monticello http: 'source.impara.de'! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/18/2008 02:06'!keith 	^ self monticello ftp: 'squeak.warwick.st' directory: 'mc' user: 'squeak' password: 'viewpoints'! !!Installer class methodsFor: 'repositories' stamp: 'damiencassou 4/25/2009 14:59'!lukas	^ self monticello http: 'http://source.lukas-renggli.ch'! !!Installer class methodsFor: 'repositories' stamp: 'kph 8/18/2008 03:15'!saltypickle	^ self monticello http: 'squeak.saltypickle.com'! !!Installer class methodsFor: 'repositories' stamp: 'kph 12/15/2007 11:08'!sophie	^ self monticello http: 'source.sophieproject.org'	! !!Installer class methodsFor: 'repositories' stamp: 'ul 2/26/2010 23:38'!squeak	^self monticello http: 'source.squeak.org'! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:21'!squeakfoundation	^ self monticello http: 'source.squeakfoundation.org'! !!Installer class methodsFor: 'repositories' stamp: 'damiencassou 4/25/2009 14:59'!squeaksource	^ self monticello http: 'http://www.squeaksource.com'! !!Installer class methodsFor: 'repositories' stamp: 'kph 5/10/2007 01:19'!ss	^ self squeaksource ! !!Installer class methodsFor: 'repositories' stamp: 'damiencassou 4/25/2009 14:59'!wiresong	^ self monticello http: 'http://source.wiresong.ca'! !!Installer class methodsFor: 'logging' stamp: 'kph 2/24/2009 07:29'!log: aString	Transcript show: aString; cr.! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 09:05'!noProgressDuring: block 	[ block value: self ] on: ProgressInitiationException do: [ :note | note resume ]! !!Installer class methodsFor: 'during' stamp: 'kph 5/21/2008 08:53'!skipLoadingTestsDuring: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := true.		[ block value: self ] ensure:[ SkipLoadingTests := oldValue ].! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:24'!path: aString	"convenience abbreviation"		self webSearchPathFrom: aString! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:26'!web 	^ InstallerWeb! !!Installer class methodsFor: 'web' stamp: 'kph 2/23/2009 01:56'!webInstall: webPageName	^ self web install: webPageName! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPath	"a search path item, has the following format. prefix*suffix"	^ self web searchPath! !!Installer class methodsFor: 'web' stamp: 'stephane.ducasse 9/30/2008 18:22'!webSearchPathFrom: string	| reader wsp path |	reader := string readStream.	wsp := self webSearchPath.	[ reader atEnd ] whileFalse: [ 		path := reader upTo: $;.		(wsp includes: wsp) ifFalse: [ wsp addFirst: path ]].	 ! !!Installer class methodsFor: 'instanciation' stamp: 'kph 3/4/2009 13:44'!privateUpgradeTheRest	Installer ss project: 'Installer'; 		installQuietly: 'Installer-Scripts';		installQuietly: 'Installer-Formats'..			^ self! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/1/2008 20:12'!repositories	^ self class organization listAtCategoryNamed: 'repositories'.! !!Installer class methodsFor: 'instanciation' stamp: 'kph 3/4/2009 13:45'!upgrade	Installer ss project: 'Installer'; 		installQuietly: 'Installer-Core'.			 	self privateUpgradeTheRest.		^ self! !!Installer class methodsFor: 'instanciation' stamp: 'stephane.ducasse 9/30/2008 18:26'!view: webPageNameOrUrl	| theReport |	theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: 'http://') ifTrue: [ 		self actionMatch: ('Installer installUrl: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]	ifFalse: [		self actionMatch: ('Installer install: ', (webPageNameOrUrl printString),'.')  				reportOn: report ifNoMatch: []	]].	Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.	^theReport contents! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!sake	^ self sake: InstallerSake sake! !!Installer class methodsFor: 'sake' stamp: 'kph 1/28/2008 10:42'!sake: aSakePackagesClass	^ InstallerSake new sake: aSakePackagesClass! !!Installer class methodsFor: 'sake' stamp: 'mtf 10/8/2008 12:00'!setSakeToUse: aClass	InstallerSake sake: aClass! !!Installer class methodsFor: 'documentation' stamp: 'kph 5/10/2007 01:21'!sf	^ self squeakfoundation ! !!Installer class methodsFor: 'squeakmap' stamp: 'kph 5/10/2007 01:19'!sm	^ self squeakmap! !!Installer class methodsFor: 'squeakmap' stamp: 'stephane.ducasse 9/30/2008 18:26'!squeakmap	^ InstallerSqueakMap new sm: true; yourself! !!Installer class methodsFor: 'universe' stamp: 'mtf 10/14/2008 10:10'!universe	^ InstallerUniverse default! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap	^ InstallerWebSqueakMap new wsm: 'http://map.squeak.org'; yourself! !!Installer class methodsFor: 'websqueakmap' stamp: 'stephane.ducasse 9/30/2008 18:28'!websqueakmap: host	^ InstallerWebSqueakMap new wsm: host; yourself! !!Installer class methodsFor: 'websqueakmap' stamp: 'kph 5/10/2007 01:19'!wsm	^ self websqueakmap! !!InstallerCruft methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classMCMczReader	^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	! !!InstallerCruft methodsFor: 'mantis' stamp: 'mtf 2/3/2010 23:49'!createRBforBug: aBugNo 	| aStream  fileList selFile aFileName suffix |	self setBug: aBugNo.fileList := self maFiles keys asOrderedCollection.fileList  addLast: 'none'.(Smalltalk classNamed: #ReleaseBuilderFor3dot10) clear.[selFile := UIManager default chooseFrom: fileList title: 'Choose what files load '.selFile = fileList size ifFalse:[aFileName := fileList at: selFile.	self logCR: 'obtaining ', aFileName, '...'.	aStream := self maStreamForFile: aFileName .suffix := (FileDirectory extensionFor: aFileName) asLowercase.		suffix caseOf:	{['gz'] -> [self installGZ: aFileName from: aStream ].['cs' ] -> [self installCS: aFileName from: aStream].['st' ] -> [self installCS: aFileName from: aStream].['mcz' ] -> [self installMCZ: aFileName from: aStream ].['sar'] -> [self installSAR: aFileName from: aStream ].}otherwise: [Error].].selFile = fileList size]whileFalse.				(Smalltalk classNamed: #ReleaseBuilderFor3dot10) current newUpdateFor: aBugNo			! !!InstallerCruft methodsFor: 'mantis' stamp: 'sd 3/6/2008 19:10'!evaluate: stream	stream fileIn.! !!InstallerCruft methodsFor: 'mantis' stamp: 'mtf 2/3/2010 23:44'!preambleCsForRB: aBugNo"Installer mantis preambleCsForRB: 5936."	| page text   | 	self setBug: aBugNo.		page := self maPage. 	text := String streamContents: [ :str |						#('Reporter'  'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		]	]. 	^ text	! !!InstallerCruft methodsFor: 'mantis' stamp: 'kph 12/21/2006 01:28'!skipTests! !!InstallerCruft methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!info	self sm ifTrue: [ ^ self smInfo  ].	self wsm ifNotNil: [ ^ self wsmInfo  ].! !!InstallerCruft methodsFor: 'monticello' stamp: 'kph 5/24/2007 18:56'!mczInstall: urlOrFile	self log: ('Loading ', urlOrFile, ' ...').	(urlOrFile beginsWith: 'http:')		ifTrue: [  MczInstaller installStream: (HTTPSocket httpGet: urlOrFile) ]		ifFalse: [ MczInstaller installFileNamed: urlOrFile ].			self logCR: ' Loaded'.	! !!InstallerCruft methodsFor: 'utils' stamp: 'kph 5/9/2007 21:49'!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.! !!InstallerCruft commentStamp: 'mtf 10/1/2008 22:24' prior: 0!I am a copy of Installer as of Installer-Core-kph.232. I am being split up.I  am called InstallerCruft because I stand-in for Sake{MC,SM,Mantis,Web,etc}Installer!!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classProjectLauncher	^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: 'ProjectLauncher not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classSakePackages	^Smalltalk at: #SakePackages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classes	^ Smalltalk! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!smalltalkImage	^ SmalltalkImage current! !!InstallerCruft class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:20'!sourceFiles	^ SourceFiles! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 7/25/2007 13:25'!history"7 Jan 2007  !!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually 'doit' portions as you wish.The report generation is not very clever, it only matches on: 'Installer install:' ,  'Installer installUrl:', and 'Installer mantis fixBug:' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!Now matches simpler htmlCheck for an html page, now matches'<!!DOCTYPE HTML' and <html> the allows use of pbwiki's raw=bare option which returns iframe embeddable html without the usual headers.8 May 2007Modified bug:fix:date: so that the fixesApplied history does not contain unnecessary duplicate entries.Fixed changeset naming for mantis bugs.25 July 2007Added Universes  Support"! !!InstallerCruft class methodsFor: 'documentation' stamp: 'kph 5/24/2007 18:54'!mczInstall: urlOrFile	^ self new mczInstall: urlOrFile! !!InstallerCruft class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:38'!label	^ 'cruft'! !!InstallerCruft class methodsFor: 'unload' stamp: 'stephane.ducasse 9/30/2008 18:30'!unload: categoryMatchesString 	^ self error: 'deprecated, use Installer mc unload: ''pkgname''.'! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicBrowse		self browse: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicInstall		self install: self file from: (FileDirectory default readOnlyFileNamed: self file)	! !!InstallerFile methodsFor: 'basic interface' stamp: 'kph 7/28/2007 23:48'!basicView		self view: self file from:  (FileDirectory readOnlyFileNamed: self file).	! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file	^ self package! !!InstallerFile methodsFor: 'accessing' stamp: 'mtf 10/23/2008 15:51'!file: f	self package: f! !!InstallerFile class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'file'! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 ! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers	^ markers ifNil: [ '<code st>..."test ...</code st>' ]! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:07'!markers: anObject	markers := anObject! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersBegin		 	 	 ^ self markers copyUpTo: $.! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersEnd	"return the third marker or the second if there are only two"		| str  a | 	str := self markers readStream.	a := str upToAll: '...'; upToAll: '...'.	str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!markersTest		 	 	^ self markers readStream upToAll: '...'; upToAll: '...'! !!InstallerInternetBased methodsFor: 'as yet unclassified' stamp: 'kph 12/9/2008 03:08'!removeHtmlMarkupFrom: in 	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: 'br') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.! !!InstallerInternetBased methodsFor: 'class references' stamp: 'sd 3/6/2008 20:16'!classHTTPSocket	^Smalltalk at: #HTTPSocket ifAbsent: [ self error: 'Network package not present' ]! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!hasPage	^ pageDataStream notNil and: [ pageDataStream size > 0 ]			! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:18'!isHtmlStream: page	"matches  '<!!DOCTYPE HTML', and <html>' "		| first |		first := (page next: 14) asUppercase.	^ (first = '<!!DOCTYPE HTML') | (first beginsWith: '<HTML>')	! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!replaceEntitiesIn: in	| out |	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: '?') ].		].	^out reset! !!InstallerInternetBased methodsFor: 'url' stamp: 'sd 3/6/2008 20:19'!urlGet	^ self urlGet: self urlToDownload! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 12/9/2008 03:17'!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.  	(page respondsTo: #reset)  ifFalse: [ ^ nil ].	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	! !!InstallerInternetBased methodsFor: 'url' stamp: 'kph 10/11/2008 17:02'!wasPbwikiSpeedWarning				^ self hasPage and: [pageDataStream contents includesSubString: 'Please slow down a bit' ]  ! !!InstallerInternetBased methodsFor: 'utils' stamp: 'sd 3/6/2008 20:15'!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ self error: 'unable to contact web site' ].	^ page	! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url	^url! !!InstallerInternetBased methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:06'!url: aUrl 	url := aUrl! !!InstallerInternetBased class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:20'!entities	^ Entities ifNil: [ Entities := 				"enough entities to be going on with"  				Dictionary new.				Entities at: 'lt' put: '<';				at: 'gt' put: '>';				at: 'amp' put: '&';				at: 'star' put: '*';				at: 'quot' put: '"';				at: 'nbsp' put: ' '; 			yourself] ! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:42'!= other	^ array = other array! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:40'!array	^ array! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!bug		^ bug ifNil: [ 				date := ((self dataAtName: 'Updated') replaceAll: $  with: $T) asDateAndTime. 		desc := (self dataAtName: 'Summary').		bug := (self dataAtName: 'Id'). 		self statusInit. 	]! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/17/2008 11:58'!date 	^ date ! !!InstallerMantis methodsFor: 'accessing' stamp: 'mtf 2/4/2010 10:03'!date: anObject	date := anObject ifNotNil: [anObject asDate ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc	 	^ desc! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc: anObject	desc := anObject! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/10/2008 14:21'!getView	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:41'!hash	^ array hash! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma	^ ma! !!InstallerMantis methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!ma: aUrl	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerMantis methodsFor: 'accessing' stamp: 'kph 12/9/2008 23:42'!printOn: stream	super printOn: stream.		(array ifNil: [ ^ self ]) printOn: stream.! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/11/2009 23:48'!status 	^ status! !!InstallerMantis methodsFor: 'accessing' stamp: 'test 1/13/2009 23:45'!statusInit	status ifNil: [ status := Status at: (self dataAtName: 'Status').		self dataAtName:'Status' put: status.	].	! !!InstallerMantis methodsFor: 'action report' stamp: 'sd 3/6/2008 18:44'!action: line reportOn: report		| param mantis |	mantis := Installer mantis.	param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $'; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $'; upTo: $' ]).		self reportSection: line on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).	self reportFor: line page: mantis maScript on: report.	report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	! !!InstallerMantis methodsFor: 'action report' stamp: 'test 1/13/2009 23:39'!bugsAll	^ array ifNil: [				array := ( self bugsSqueak ,  (self dataGetFrom: '/installer_export.php') ) asSet asSortedCollection: [ :a :b | a date > b date ]			]."Installer mantis bugsAll"	! !!InstallerMantis methodsFor: 'action report' stamp: 'kph 3/13/2009 22:02'!validChangeSetName: aFileName	| csn prefix |	csn := super validChangeSetName: aFileName.	prefix := 'M' , self bug asInteger asString.	csn := csn replaceAll: ('-', prefix) with: ''.	csn := csn replaceAll: (prefix,'-') with: ''.	csn := csn replaceAll: prefix with: ''.		^ prefix, '-', csn 		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:25'!browseFile: aFileName	^ self browse: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 7/11/2009 16:21'!bug: aBugNo	| page |	self setBug: aBugNo.		page := self maPage.	date := ((self maRead: page field: 'Date Updated') value replaceAll: $  with: $T) asDateAndTime.	status := (self maRead: page field: 'Status') value."	Installer mantis bug: 7235 "! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:26'!bug: aBugNo browse: aFileName	 self setBug: aBugNo.	^ self browseFile: aFileName! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/18/2006 04:11'!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:46'!bug: aBugNo fix: aFileName date: aDate 	| |	self setBug: aBugNo.	self ditchOldChangeSetFor: aFileName.	self install: aFileName from: (self maThing: aFileName date: aDate).			^ date! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents! !!InstallerMantis methodsFor: 'public interface' stamp: 'sd 3/6/2008 19:09'!bug: aBugNo view: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		 self setBug: aBugNo.	^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:35'!bugFiles: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; files! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugFilesView: aBugNo 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	self setBug: aBugNo; viewFiles! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:37'!bugScript: aBugNo	^ (self setBug: aBugNo) script		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 2/22/2009 13:42'!dataGetFrom: aPath	| rs line first col row out |			rs := HTTPSocket httpGet: ma, aPath.		rs isString ifTrue: [ ^ ProtocolClientError signal: 'notFound' ].		first := true.		out := OrderedCollection new.		[ rs atEnd ] whileFalse: [ 				line := rs nextLine readStream.		col := 1.		row := Array new: 9.		[ (line atEnd or: [ col > 9 ]) ] whileFalse: [ row at: col put: (line upTo: $|). col := col + 1 ].			rs next.		[ out add: (self class new in: self row: row) ] ifError: []			 ].			^ out"self reset.self getBugsList "! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:29'!dataNames	^ #(Id Project Category Assigned Updated Status Severity FixedIn Summary)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:47'!ensureFix	| fixesAppliedNumbers |		fixesAppliedNumbers := self fixesApplied collect: [ :fixDesc | fixDesc asInteger ].	(fixesAppliedNumbers includes: bug) ifFalse: [ self fixBug ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!ensureFix: aBugNo	^self ensureFix: aBugNo date: nil! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 7/11/2009 16:17'!ensureFix: aBugNo date: aDate	self setBug: aBugNo.	self date: aDate.		self ensureFix.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:45'!ensureFixes: aBugNos	aBugNos do: [ :bugNo | self ensureFix: bugNo ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:34'!files 	"provide a list of files associated with the bug in id order"	"	Installer mantis bugFiles: 6660.	"	^ (self maFiles associations asSortedCollection: [ :a :b | a value asInteger < b value asInteger ]) 				collect: [ :a | a key ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 3/7/2009 00:04'!fixBug 	self install: self maUrl from: self maScript.	self maCheckDateAgainst: date.			self fixesAppliedNumbers in: [ :fixed |		(fixed isEmpty or: [ (fixed includes: bug asInteger) not]) 		ifTrue: [ self fixesApplied add: (bug asString, ' ', desc) ]].		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:48'!fixBug: aBugNo 	^ self fixBug: aBugNo date: nil.	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 13:44'!fixBug: aBugNo date: aDate	self setBug: aBugNo. 	self date: aDate.	self fixBug.	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 10/16/2008 00:04'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/9/2008 22:48'!fixesAppliedNumbers	^ self fixesApplied collect: [ :fixDesc | fixDesc asInteger ]. ! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:56'!in: parent row: dataRow	self ma: parent ma.	self markers: parent markers.	self setArray: dataRow.! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: nil ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo date: d	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: d ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/17/2008 14:03'!report	"Installer mantis viewBug: 5639."	| page text | 		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:27'!script 	^ self maScript contents.	 		! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/11/2008 15:30'!selectCategoryCollections	^ self select: [ :ea | ea category = 'Collections' ]! !!InstallerMantis methodsFor: 'public interface' stamp: 'test 1/11/2009 23:57'!setArray: dataRow	(array := dataRow) ifNotNil: [ self bug ].! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:32'!view		^ Workspace new contents: self report; openLabel: ('Mantis ', bug printString).! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:22'!viewBug: aBugNo	self setBug: aBugNo; view! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:23'!viewFile: aFileName	"Installer mantis bug: 6089 browse: 'TTFSpeedUp-dgd.1.cs'"		^ self view: aFileName from: (self maThing: aFileName date: nil)! !!InstallerMantis methodsFor: 'public interface' stamp: 'kph 12/10/2008 14:36'!viewFiles		^ self files do: [ :ea | self viewFile: ea ].! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 23:00'!bugsClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:08'!bugsRelease: version	^self bugsAll select: [ :ea | (ea status = 'resolved') and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:59'!bugsSqueak	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?project=Squeak' ]	"Installer mantis bugsSqueak.Installer mantis bugsAll.Installer mantis bugsClosed."! !!InstallerMantis methodsFor: 'search' stamp: 'kph 2/15/2009 15:14'!bugsTesting: version	^self bugsAll select: [ :ea | ea status = 'testing' and: [ ea fixedIn = version ]]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!category	^ self dataAtName: 'Category'	 "s bugs collect: [ :ea | ea category ]"! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:28'!dataAtName: key		^ array at: (self dataNames indexOf: key)! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/13/2009 22:51'!dataAtName: key put: v		^ array at: (self dataNames indexOf: key) put: v! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/12/2009 00:15'!dataClosed	^ array ifNil: [ array := self dataGetFrom: '/installer_export.php?closed' ]! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:12'!fixedIn	^ self dataAtName: 'FixedIn'! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/14/2009 01:06'!project	^ self dataAtName: 'Project'! !!InstallerMantis methodsFor: 'search' stamp: 'test 1/11/2009 23:15'!summary	^ self dataAtName: 'Summary'! !!InstallerMantis methodsFor: 'utils' stamp: 'sd 3/6/2008 20:16'!maCheckDateAgainst: okDate	(okDate notNil and: [date < okDate asDate ]) 		ifTrue: [ self notify: 'bug ', self bug asString, ' updated on ', date printString ]. ! !!InstallerMantis methodsFor: 'mantis' stamp: 'stephane.ducasse 9/30/2008 18:37'!maFiles 	| file files bugPage id  |  	files := Dictionary new. 	bugPage := self maPage.	 [ 		id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  		file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<. 		((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ]. 		id notEmpty ] whileTrue.	^files ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 3/12/2009 22:46'!maPage  	"  self mantis bug: 5251."	| page |	page :=  self httpGet: self maUrl. 	date := ((self maRead: page field: 'Date Updated') value copyUpTo: $ ).	date isEmpty ifTrue: [ ^self error: bug asString, ' not found' ].	date := date asDate. 	^page reset! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:55'!maRead: page field: fieldKey	 | value | 	value := page upToAll: ('!!-- ', fieldKey, ' -->'); upToAll: '<td'; upTo: $>; upToAll: '</td>'.		page upTo: $<.		page peek = $t ifTrue: [ value := page upToAll: 'td'; upTo: $>; upToAll: '</td>' ].	  	^Association key: fieldKey value: (self removeHtmlMarkupFrom: value withBlanksTrimmed readStream) contents! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/17/2008 13:51'!maReadNotes: page 	 |  notes note  | 	notes := OrderedCollection new.	[ page upToAll: 'tr class="bugnote"'; upTo: $>.	  page atEnd ]			whileFalse: [ 		note := (self removeHtmlMarkupFrom: (page upToAll: '</tr>') readStream) contents.		note := note withBlanksCondensed.		note replaceAll: Character lf with: Character cr.		notes add: note  	].		^notes! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:01'!maScript 	^self extractFromHtml: self maPage option: #last! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!maStreamForFile: aFileName	| fileId  | 	fileId :=  self maFiles at: aFileName ifAbsent: [ self error: aFileName, ' not found' ]. 	^ self httpGet: (self ma, 'file_download.php?file_id=' , fileId , '&type=bug').	 ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 5/9/2007 22:31'!maThing: aFileName date: aDate 	self logCR: 'obtaining ', aFileName, '...'.	pageDataStream := self maStreamForFile: aFileName.	self maCheckDateAgainst: aDate.	^ pageDataStream	! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maUrl 	^ url := self ma, 'view.php?id=', bug asString ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:08'!maUrlFor: maBugNo 	^ url := self ma, 'view.php?id=', maBugNo asString  ! !!InstallerMantis methodsFor: 'mantis' stamp: 'kph 12/9/2008 20:25'!setBug: stringOrNumber	| newBug |		(newBug := stringOrNumber asInteger) = bug ifTrue: [ ^ self ].		self logCR: 'Installer accessing bug: ' , stringOrNumber asString. 	bug := newBug.	 	stringOrNumber = bug ifTrue: [ desc := ''. ^ self ].	desc := stringOrNumber withoutLeadingDigits  ! !!InstallerMantis commentStamp: 'test 1/14/2009 00:11' prior: 0!Search feature is based upon a custom mantis query ceveloped and maintained by Ken Causey <ken@kencausey.com>Installer mantis bugsAll select: [ :ea | ea status = 'testing' ].!!InstallerMantis class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ line beginsWith: 'Installer mantis fixBug:'! !!InstallerMantis class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:21'!fixesApplied	^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!InstallerMantis class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'mantis'! !!InstallerMantis class methodsFor: 'instance creation' stamp: 'stephane.ducasse 9/30/2008 18:24'!host: host	^self new	ma: host; 			markers: '&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;'; 			yourself.! !!InstallerMantis class methodsFor: 'instance creation' stamp: 'test 1/12/2009 00:00'!initialize	Status := Dictionary new		at: '10' put: 'new';		at: '20' put: 'feedback';		at: '30' put: 'acknowledged';		at: '40' put: 'confirmed';		at: '50' put: 'assigned';		at: '60' put: 'pending';		at: '70' put: 'testing';		at: '80' put: 'resolved';		at: '90' put: 'closed';		yourself ! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'mtf 10/8/2008 12:00'!basicAvailablePackages	^ self mc allFileNames! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:46'!basicBrowse	 "Installer ss project: 'Installer'; browse: 'Installer-Core'."	| it |	it := self mcThing.		(it class includesSelector: #browse) ifTrue: [ ^ it browse ].		(it instVarNamed: 'versions') do: #browse.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 10/23/2008 23:09'!basicInstall	 	self withAnswersDo: [ self mcThing load ].	self logCR: 'loaded'.! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:18'!basicVersions	^ (self availablePackages select: [ :p | ( self package,'-*.mcz' ) match: p ]) collect: [ :p | self copy package: p  ; yourself ]. ! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'kph 12/5/2008 02:56'!basicView	 "Installer ss project: 'Installer'; view: 'Installer-Core'. "	| it |		packages isEmptyOrNil ifTrue: [ self mc morphicOpen: nil ].		it := self mcThing. 	(it respondsTo: #open) ifTrue: [ ^ it open ].	"in case an old mc doesnt have #open"		(it instVarNamed: 'versions') do: #open.! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'mtf 5/20/2008 17:38'!cache		mc := self classMCCacheRepository default.	root := mc directory localName ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/19/2007 00:30'!directory: dir	| directory |	directory := dir isString 		ifTrue: [  FileDirectory on: (FileDirectory default fullNameFor: dir) ]		ifFalse: [ dir ].			mc := self classMCDirectoryRepository new directory: directory; yourself. 	root := dir	 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 12/18/2008 02:06'!ftp: host directory: dir user: name password: secret	"Installer mc ftp: 'mc.gjallar.se' directory: '' user: 'gjallar' password: secret."		mc := self classMCFtpRepository host: host directory: dir user: name password: secret.	root :=  dir.	 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!goods: host port: aport		mc := (self classMCGOODSRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'damiencassou 4/25/2009 15:00'!http: aUrl  		self http: aUrl user: '' password: ''		 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 03:45'!http: aUrl user: name password: secret		mc := self classMCHttpRepository location: aUrl user: name password: secret.	root := mc locationWithTrailingSlash	 ! !!InstallerMonticello methodsFor: 'instance creation' stamp: 'kph 5/10/2007 00:58'!magma: host port: aport		mc := (self classMCMagmaRepository new) host: host port: aport; yourself ! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 5/20/2008 16:43'!classMCCacheRepository	^Smalltalk at: #MCCacheRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 01:01'!classMCDirectoryRepository	^Smalltalk at: #MCDirectoryRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCFtpRepository	^Smalltalk at: #MCFtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCGOODSRepository	^Smalltalk at: #MCGOODSRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCHttpRepository	^Smalltalk at: #MCHttpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:59'!classMCMagmaRepository	^Smalltalk at: #MCMagmaRepository ifAbsent: [ self error: 'Magma not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'mtf 10/25/2008 14:04'!classMCRepositoryGroup	^Smalltalk at: #MCRepositoryGroup ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'kph 5/10/2007 00:56'!classMCSmtpRepository	^Smalltalk at: #MCSmtpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!InstallerMonticello methodsFor: 'class references' stamp: 'stephane.ducasse 9/30/2008 18:34'!classMCVersionLoader	^Smalltalk at: #MCVersionLoader  ifAbsent: [ self error: 'Monticello not present' ]! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:43'!fromUrl: aUrl	| url  path |		url := aUrl asUrl.	self http: url authority.		path := url path.		path size = 2 ifTrue: [ 		self project: path first.		path removeFirst. 	].			path size = 1 ifTrue: [ self package: path first ].! !!InstallerMonticello methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'repository:''', mc description, ''''! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:42'!latest 	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: newPackage	"Installer mc fromUrl: 'http://www.squeaksource.com/Installer/Installer-Core-kph.100.mcz'."! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/2/2008 07:40'!latestFromUsers: list	| newPackage |	newPackage := self package copyUpToLast: $-.	self packages removeLast.	self package: (list collect: [ :ea | newPackage, '-', ea ])! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 18:47'!mc	^ mc! !!InstallerMonticello methodsFor: 'accessing' stamp: 'kph 12/8/2008 03:24'!mc: aRepo	mc := aRepo! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project	^ project! !!InstallerMonticello methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:04'!project: name	project := name.	packages := nil.		(mc respondsTo: #location:) ifTrue:[ mc := mc copy location: root , name ].	(mc respondsTo: #directory:) ifTrue: [ mc := mc copy directory: root ,'/', name ].			^self copy.! !!InstallerMonticello methodsFor: 'monticello' stamp: 'kph 7/2/2009 22:36'!mcDetectFileBlock: pkg	pkg isString ifTrue: [  ^ [ :aFile | aFile beginsWith: pkg ] ].	(pkg isKindOf: Array) 			ifTrue: [  ^  [ :aFile | (pkg detect: [ :item | aFile beginsWith: item ] ifNone: [ false ]) ~= false ] ].	pkg isBlock ifTrue: [ ^ pkg ].   ! !!InstallerMonticello methodsFor: 'monticello' stamp: 'stephane.ducasse 9/30/2008 18:39'!mcSortFileBlock	^ [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] 				on: Error do: [:ex | false]].! !!InstallerMonticello methodsFor: 'monticello' stamp: 'nice 2/11/2010 20:44'!mcThing	| loader files count |	loader := self classMCVersionLoader new.		count := 0. files := nil.	self logCR: 'reading ', mc description, '...'.		"several attempts to read files - repository readableFileNames sometimes fails"	[ count := count + 1.	 (files = nil) and:[ count < 5 ] ] 		whileTrue: [files := mc readableFileNames sort: self mcSortFileBlock ].	files ifNil: [  Warning signal: 'Repository not readable: ', mc description. ^ nil  ].			self packages do: [ :pkg |		| fileToLoad version |		self log: 'finding ', pkg asString, '...'.				fileToLoad := files detect: (self mcDetectFileBlock: pkg) ifNone: [ nil ].				version := mc versionFromFileNamed: fileToLoad.		(version isKindOf: MCConfiguration) 			ifTrue: [ ^ version ]			ifFalse:[				MCRepositoryGroup default addRepository: self normalizedRepository.				version workingCopy repositoryGroup addRepository: self normalizedRepository.				loader addVersion: version ].					self logCR: ' found ', version fileName, '...'.	].	^ loader! !!InstallerMonticello methodsFor: 'monticello' stamp: 'test 1/15/2009 15:10'!mcUrl	^ self mc description 	! !!InstallerMonticello methodsFor: 'monticello' stamp: 'mtf 10/25/2008 14:04'!normalizedRepository"Find an existing instance of the active repository so that we use whatever name and password the user usually uses. If not found, answer a copy"	self classMCRepositoryGroup default repositoriesDo: [:ea |		mc = ea ifTrue: [^ ea]].	^ mc copy! !!InstallerMonticello methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self mc morphicOpen: nil! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload 	(MCWorkingCopy allManagers select: [ :wc | self package match: (wc package name) ])		 do: [ :wc |  			 	self logCR: 'Unloading ', wc package asString. 				wc unload.].	self unloadCleanUp! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 12/8/2008 01:02'!unload: match 	self addPackage: match.	self unload.! !!InstallerMonticello methodsFor: 'public interface' stamp: 'kph 10/23/2008 20:57'!unloadCleanUp 	SystemOrganization removeEmptyCategories.	"Until Mantis 5718 is addressed" 	Smalltalk at: #PackagePaneBrowser ifPresent: [ :ppbClass | ppbClass allInstancesDo: [ :ppb | ppb updatePackages ]  ]. 	Smalltalk at: #Browser ifPresent: [ :bClass | bClass allInstancesDo: [ :b | b updateSystemCategories ] ].	MCFileBasedRepository freeSomeSpace.	SmalltalkImage current fixObsoleteReferences.! !!InstallerMonticello methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [:p | ( aMatch , '.mcz' ) match: p])		collect: [:p | self copy package: p ; yourself]! !!InstallerMonticello methodsFor: 'Installer-Core' stamp: 'kph 2/21/2009 18:41'!printConfigurationOn: stream	self project ifNil: [ ^ self ].		stream 		nextPutAll: ' project:''';		nextPutAll: self project;		nextPut: $'! !!InstallerMonticello class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:41'!label	^ 'monticello'! !!InstallerSake methodsFor: 'basic interface' stamp: 'kph 4/23/2008 22:44'!basicInstall 	self withAnswersDo: [ (self packages collect: [ :packageName | sake named: packageName ]) asTask run ].	! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 11:27'!sake 	^ sake  ! !!InstallerSake methodsFor: 'websqueakmap' stamp: 'kph 1/28/2008 10:41'!sake: aSakePackagesClass	sake := aSakePackagesClass! !!InstallerSake class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classPackages	^Smalltalk at: #Packages  ifAbsent: [ self error: 'Sake Packages code not present' ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'sake'! !!InstallerSake class methodsFor: 'accessing' stamp: 'kph 6/30/2008 16:49'!sake	^ Sake ifNil: [ self classPackages current ]! !!InstallerSake class methodsFor: 'accessing' stamp: 'mtf 10/8/2008 12:00'!sake: aClass	Sake := aClass! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicAvailablePackages		^self classSMSqueakMap default packagesByName! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:29'!basicBrowse	self smThing explore! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicInstall 	self log: ' installing '. 	self withAnswersDo: [ self smThing install ].	self log: ' done'.! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:43'!basicVersions 	^ (self smReleasesForPackage: self package) 			collect: [ :v | self copy package: (v package name,'(',v version,')'); yourself. ]  ! !!InstallerSqueakMap methodsFor: 'basic interface' stamp: 'kph 5/10/2007 00:25'!basicView	self smThing explore! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMLoader	^Smalltalk at: #SMLoader  ifAbsent: [ self error: 'SqueakMap Loader not present' ]! !!InstallerSqueakMap methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classSMSqueakMap	^Smalltalk at: #SMSqueakMap  ifAbsent: [ self error: 'SqueakMap not present' ]! !!InstallerSqueakMap methodsFor: 'public interface' stamp: 'mtf 10/8/2008 12:00'!open	self classSMLoader open! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | aMatch match: p name ]) 		collect: [ :p | self copy package: p name; yourself ]! !!InstallerSqueakMap methodsFor: 'searching' stamp: 'damiencassou 2/20/2009 19:30'!search: aMatch  	| results |	results := Set new.	self availablePackages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm	^ sm ifNil: [ false ]! !!InstallerSqueakMap methodsFor: 'accessing' stamp: 'sd 3/6/2008 19:05'!sm: anObject	sm := anObject! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'kph 4/24/2008 23:03'!smPackageAndVersion	| p |	p := ReadStream on: self package .	^Array with: (p upTo: $() with: (p upTo: $)).! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smReleasesForPackage: name 	^(self classSMSqueakMap default packageWithName: name) releases! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'sd 3/6/2008 20:43'!smThing 	| pkgAndVersion releases release |	pkgAndVersion := self packageAndVersionFrom: self package.	self logCR: 'retrieving ', self package, ' from SqueakMap...'.	releases := self smReleasesForPackage: pkgAndVersion first.	release := pkgAndVersion last isEmpty 				ifTrue: [ releases last ]				ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 	^ release			! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'nice 3/27/2010 21:16'!update"Updates the local map for SqueakMap, upgrading SqueakMap to the latest version if necessary.When SqueakMap is old and needs to be upgraded, it does four things that mostly make sense in the interactive world SM was built for, but are totally evil here in the world of automatic scripting:1. It asks the user if she wants to upgrade, in the form of a pop-up (see SMSqueakMap >> #checkVersion:).2. It terminates its own process.3. It creates a new UI process.(see the last line of the SqueakMap upgrade file-in: ''Project spawnNewProcessAndTerminateOld: true'', from http://map.squeak.org/accountbyid/9bdedc18-1525-44a6-9b79-db5d4a87f6f8/files/SqueakMap8.st4. It opens a SqueakMap windowWe work around these three problems seperately:1. We use #answer:with: and #withAnswersDo: to automatically answer ''Yes'' when asked if we want to upgrade2. We don't want this process to be terminated, so we run the update in a forked process and wait for it to finish, using #fork, #ensure:, and a Semaphore3. We keep track of the UI process before updating, and if it changes, we terminate the new UI process and reinstall the old one using Project >> #resumeProcess:4. We don't bother with the newly opened window. The other three problems are much worse.We do all this in a new process, since it is not unlikely that this method is executing in the UI process"	| oldUIProcess doneSema |	self answer: 'You need to upgrade the SqueakMap package' with: true.	oldUIProcess := Project uiProcess.	doneSema := Semaphore new.	[[self withAnswersDo: [self classSMSqueakMap default loadUpdates]] 		ensure: [			| newUIProcess |			newUIProcess := Project uiProcess.			(oldUIProcess ~~ newUIProcess				and: [oldUIProcess notNil					and: [oldUIProcess isTerminated not]])					 ifTrue: [							newUIProcess ifNotNil: [newUIProcess terminate].							oldUIProcess suspend.							Project resumeProcess: oldUIProcess.].			doneSema signal]] fork.	doneSema wait! !!InstallerSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'squeakmap'! !!InstallerUniverse methodsFor: 'basic interface' stamp: 'nice 2/11/2010 20:47'!basicInstall	self packages do: [ :packageName |		| potentials pkg pkgAndVersion version |			pkgAndVersion := self packageAndVersionFrom: packageName.		pkg := pkgAndVersion first.		version := pkgAndVersion last.			potentials := universe packageVersionsForPackage: pkg.			pkg := version isEmpty 			ifTrue: [ potentials last ]			ifFalse: [ 				version := self classUVersion readFrom: version readStream.  				potentials detect:[ :p | p version = version] ifNone: [ ^ self error: 'version not found']			].				universe planToInstallPackage: pkg.	].	self uniDoInstall! !!InstallerUniverse methodsFor: 'class references' stamp: 'sd 3/6/2008 20:17'!classUVersion	^Smalltalk at: #UVersion  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 13:46'!uniDoInstall	self withAnswersDo: [ self universe doInstall ] ! !!InstallerUniverse methodsFor: 'universes' stamp: 'kph 7/25/2007 12:52'!universe	^ universe! !!InstallerUniverse methodsFor: 'universes' stamp: 'squeak 7/26/2007 18:12'!universe: u	universe := u.	self update.! !!InstallerUniverse methodsFor: 'public interface' stamp: 'stephane.ducasse 9/30/2008 18:41'!update	(LastUniUpdate isNil or:[ (DateAndTime now - LastUniUpdate) > 600 seconds  ])		ifTrue: [universe requestPackageList.				LastUniUpdate := DateAndTime now]! !!InstallerUniverse class methodsFor: 'as yet unclassified' stamp: 'damiencassou 2/20/2009 19:42'!label	^ 'universe'! !!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUGlobalInstaller	^Smalltalk at: #UGlobalInstaller  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'accessing system' stamp: 'stephane.ducasse 9/30/2008 18:16'!classUUniverse	^Smalltalk at: #UUniverse  ifAbsent: [ self error: 'Universes code not present' ]! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:09'!default	^ self universe: (self classUGlobalInstaller universe: self classUUniverse systemUniverse)! !!InstallerUniverse class methodsFor: 'instance creation' stamp: 'mtf 10/14/2008 10:10'!universe: u	^ self new universe: u! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 3/27/2010 21:30'!changesetNamesFromUpdates: startNumber through: stopNumber	"Answer the concatenation of summary strings for updates numbered in the given range"	"self new changesetNamesFromUpdates: 7059 through: 7061"		^ String streamContents: [:aStream |		((ChangeSet changeSetsNamedSuchThat:			[:aName | aName first isDigit						and: [aName initialIntegerOrNil >= startNumber						and: [aName initialIntegerOrNil <= stopNumber]]]) asArray				sort: [:a :b | a name < b name])					do: [:aChangeSet | aStream cr; nextPutAll: aChangeSet summaryString]]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:15'!loadUpdatesFromDisk		| updateDirectory updateNumbers |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	updateNumbers := updateDirectory fileNames						collect: [:fn | fn initialIntegerOrNil]						thenSelect: [:fn | fn notNil].		self loadUpdatesFromDiskToUpdateNumber: updateNumbers max		stopIfGap: false			! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/9/2008 11:30'!loadUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Installer new loadUpdatesFromDiskToUpdateNumber: 100020 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."		"apparently does not use the updatelist too bad!! and to rewrite - sd 7 March 2008"	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size == 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/3/2008 10:37'!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'sd 3/8/2008 21:13'!updateDirectoryOrNil	^ (FileDirectory default directoryNames includes: 'updates')		ifTrue: [FileDirectory default directoryNamed: 'updates']		ifFalse: [self inform: 'Error: cannot find "updates" folder'.				nil]! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 2/11/2010 20:47'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseUpdateListContents:"	strm reset.	listContents do:		[:pair |		| releaseTag fileNames | 		releaseTag := pair first.  		fileNames := pair last.		strm nextPut: $#; nextPutAll: releaseTag; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !!InstallerUpdateStream class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:43'!label	^ 'updatestream'! !!InstallerUrl methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!action: line reportOn: report  	url :=  line readStream upTo: $' ; upTo: $'.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 		self reportFor: line page: pageDataStream on: report ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicBrowse 	"(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') browse.".		self browse: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicInstall  	 	self install: self urlToDownload from: self urlThing.	^ pageDataStream ! !!InstallerUrl methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:19'!basicView 	 "(Installer debug url: 'http://installer.pbwiki.com/f/Installer.st') view.".		self view: self urlToDownload from: self urlThing.		! !!InstallerUrl methodsFor: 'accessing' stamp: 'kph 3/30/2009 01:30'!fileInSource"(Installer url: 'http://www.squeaksource.com/Sake/Sake-Core-kph.47.mcz') bootstrap."| pkg splitPos repo getFileName fileName |useFileIn := true.splitPos := url lastIndexOf: $/. pkg := url copyFrom: splitPos + 1 to: url size.repo := url copyFrom: 1 to: splitPos.getFileName := [ :pkgName | pkgName , ((HTTPSocket httpGet: repo) upToAll: pkgName; upTo: $") ]. fileName := getFileName value: pkg.url := repo,fileName.self install! !!InstallerUrl methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:44'!label	^ 'url:''', url, ''''! !!InstallerUrl methodsFor: 'url' stamp: 'nice 2/11/2010 20:51'!urlThing 	| retry delay |		self logCR: 'retrieving ', self urlToDownload , ' ...'.		delay := 0.	[retry := false.	pageDataStream := self urlGet: self urlToDownload.	self wasPbwikiSpeedWarning ifTrue: [		retry := true. delay := delay + 5.		self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.		(Delay forSeconds: delay) wait ].	retry ] whileTrue.			pageDataStream ifNil: [ self error: 'unable to contact host' ].	 	^ pageDataStream	! !!InstallerUrl methodsFor: 'url' stamp: 'kph 1/4/2007 23:49'!urlToDownload	^ (self url, (self package ifNil: [ '' ])) asUrl asString.	 ! !!InstallerUrl class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer installUrl:') and: 		[ | ext |		 ext :=  (line readStream upToAll: '''.') copyAfterLast: $..		 (#( 'cs' 'st' 'mcz' 'sar') includes: ext) not ])! !!InstallerUrl class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:39'!label	^ 'url'! !!InstallerWeb methodsFor: 'action report' stamp: 'kph 10/11/2008 16:48'!action: line reportOn: report		self package: (line readStream upTo: $' ; upTo: $').	self reportSection: line on: report.	 	url := self urlToDownload.		self reportFor: line page: pageDataStream on: report ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicBrowse  	 self thing size > 0 		ifTrue: [ self browse: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicInstall  	 self thing size > 0 		ifTrue: [ self install: url from: pageDataStream ]		ifFalse: [ url ifNil: [ ^ self logCR: self package, ' not found on webSearchPath' ].				  self logCR: '...',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'basic interface' stamp: 'kph 10/11/2008 16:49'!basicView  	 self thing size > 0 		ifTrue: [ self view: url from: pageDataStream ]		ifFalse: [ self logCR: 'NO DATA ',url,' was empty' ].	 ! !!InstallerWeb methodsFor: 'web install' stamp: 'mtf 10/15/2008 09:04'!thing	self logCR: 'searching for web package ''', self package, ''''. 	url := self urlToDownload.	url ifNil: [ self logCR: 'page ', self package, ' not found on path' ]		ifNotNil: [ self logCR: 'found ',  url, ' ...'.   ].	^ pageDataStream! !!InstallerWeb methodsFor: 'web install' stamp: 'nice 2/11/2010 20:54'!urlToDownload	"while we look for a url which returns what we are looking for, we get the data anyway"		| delay |	delay := 0.	self class webSearchPath do: [ :pathSpec |		| potentialUrl readPathSpec retry |		readPathSpec := pathSpec value readStream.		potentialUrl := (readPathSpec upTo: $*), self package, (readPathSpec upToEnd ifNil: [ '' ]).		[retry := false.		pageDataStream := self urlGet: potentialUrl.		self wasPbwikiSpeedWarning			ifTrue: [				retry := true.				delay := delay + 5. 				self logCR: 'PBWiki speed warning. Retrying in ', delay printString, ' seconds'.				(Delay forSeconds: delay) wait]			ifFalse: [ self hasPage ifTrue: [ pageDataStream reset. ^ potentialUrl ] ].		retry ] whileTrue	].	^nil! !!InstallerWeb class methodsFor: 'action report' stamp: 'mtf 10/8/2008 12:00'!canReportLine: line	^ ((line beginsWith: 'Installer install:') | (line beginsWith: 'Installer do:'))! !!InstallerWeb class methodsFor: 'instanciation' stamp: 'kph 2/23/2009 04:10'!initialize		WebSearchPath := nil! !!InstallerWeb class methodsFor: 'compatability' stamp: 'stephane.ducasse 9/30/2008 18:22'!install: webPageName"This keeps the syntax Installer web install: working"	^ self new install: webPageName! !!InstallerWeb class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'web'! !!InstallerWeb class methodsFor: 'accessing' stamp: 'stephane.ducasse 9/30/2008 18:22'!searchPath	"a search path item, has the following format. prefix*suffix"	^ WebSearchPath ifNil: [ WebSearchPath := OrderedCollection new ].! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'squeak 3/31/2008 22:21'!basicAvailablePackages	| html id name pkgs | 	pkgs := Dictionary new.	html := self httpGet: (self wsm, 'packagesbyname').		[ id := html upToAll: '/package/'; upToAll: '">'.	name := html upTo: $<.	(id notEmpty and: [ name notEmpty ])] 		whileTrue: [ pkgs at: name put: id ].	^ pkgs		! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:40'!wsm		^ wsm! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsm: aUrl 	wsm := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:41'!wsmDownloadUrl 	| pkgAndVersion packageId packageName packageVersion releaseAutoVersion 	downloadPage |	pkgAndVersion := self packageAndVersionFrom: self package.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	releaseAutoVersion := (self wsmReleasesFor: packageId) at: packageVersion.					 	downloadPage := self httpGet: (self wsm,'packagebyname/', packageName,'/autoversion/', releaseAutoVersion,'/downloadurl') asUrl asString.				 		 	^ downloadPage contents	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmReleasesFor: packageId	| html autoVersion version releases |	releases := Dictionary new.	html := self httpGet: (self wsm, '/package/', packageId ).	[releases at: #latest put: autoVersion.	autoVersion := html upToAll: '/autoversion/'; upTo: $".	version := html upTo: $-; upTo: $<.	(autoVersion notEmpty and: [version notEmpty ])] 		whileTrue: [ releases at: version put: autoVersion ].	^ releases	! !!InstallerWebSqueakMap methodsFor: 'websqueakmap' stamp: 'sd 3/6/2008 20:42'!wsmThing	| downloadUrl |	self logCR: 'finding ', self package, ' from websqueakmap(', self wsm, ') ...'.	downloadUrl := self wsmDownloadUrl.	self logCR: 'found at ', downloadUrl asString, ' ...'.	^ downloadUrl	! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:41'!basicInstall		| it |	it := self wsmThing.	self install: it from: it asUrl retrieveContents contentStream.	! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'mtf 2/4/2010 09:50'!basicVersions	| pkgAndVersion packageId packageName packageVersion versions |	pkgAndVersion := self packageAndVersionFrom: self package .	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self availablePackages at: packageName.	versions := (self wsmReleasesFor: packageId) keys asSet.	versions remove: #latest.	^ versions collect: [ :version | self copy package: (packageName,'(', version ,')'); yourself ]. ! !!InstallerWebSqueakMap methodsFor: 'basic interface' stamp: 'sd 3/6/2008 20:42'!basicView		| it |	it := self wsmThing.	self view: it from: (self httpGet: it).	! !!InstallerWebSqueakMap methodsFor: 'searching' stamp: 'mtf 10/8/2008 12:00'!packagesMatching: aMatch	^ (self availablePackages		select: [ :p | ( aMatch) match: p ]) 		collect: [ :p | self copy package: p ; yourself ]! !!InstallerWebSqueakMap class methodsFor: 'accessing' stamp: 'damiencassou 2/20/2009 19:40'!label	^ 'websqueammap'! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:05'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!InstructionClientTest methodsFor: 'tests' stamp: 'nice 12/26/2009 10:21'!testInstructions	"just interpret all of methods of Object"	| client |	client := InstructionClient new.		Object methodDict do: [:method |			| scanner |			scanner := (InstructionStream on: method).			[scanner pc <= method endPC] whileTrue: [					self shouldnt: [scanner interpretNextInstructionFor: client] raise: Error.			].	].! !!InstructionClientTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstructionClient. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!InstructionPrinterTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:28'!example1	| ff|	(1 < 2) ifTrue: [tt ifNotNil: [ff := 'hallo']].	^ ff.! !!InstructionPrinterTest methodsFor: 'tests' stamp: 'nice 10/19/2009 20:43'!testInstructions	"just print all of methods of Object and see if no error accours"	| printer |	printer  := InstructionPrinter.	Object methodDict do: [:method |					self shouldnt: [ 						String streamContents: [:stream | 							(printer on: method) printInstructionsOn: stream]] raise: Error.			].! !!InstructionPrinterTest commentStamp: '<historical>' prior: 0!This is the unit test for the class InstructionPrinter. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingBytecode	"Answer the bytecode of the following bytecode (different to nextByte)."	^self method at: self followingPc! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingPc	"Answer the pc of the following bytecode."	^self nextPc: (self method at: pc)! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:43'!scanFor: scanBlock	"Answer the index of the first bytecode for which scanBlock	 answers true when supplied with that bytecode."	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/13/2010 11:38'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 8 "extensions"				ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]				ifFalse: [type = 10 "long jumps"							ifTrue: [pc + 2]							ifFalse: [pc + 1]]! !!Integer methodsFor: 'benchmarks' stamp: 'eem 10/6/2008 11:32'!benchSwitch	"Run a benchmark computing the number of process switches per second.	The reciever identifies the total number of processes to be used in the benchmark."	"10 benchSwitch"	^self benchSwitch: 1! !!Integer methodsFor: 'benchmarks' stamp: 'eem 10/6/2008 11:31'!benchSwitch: seconds	"Run a benchmark computing the number of process switches per second.	The reciever identifies the total number of processes to be used in the benchmark.	The argument is the length of time in seconds to run the test for."	"10 benchSwitch"	| semaphores processes count |	count := Association key: #counter value: 0.	semaphores := (1 to: self) collect:[:i| Semaphore new].	processes := Array new: self.	[		1 to: processes size do:[:i| | p waitSema signalSema |			waitSema := semaphores at: i.			signalSema := semaphores atWrap: i+1.			p := self benchSwitchCount: count wait: waitSema signal: signalSema.			processes at: i put: p.		].		semaphores first signal.		(Delay forSeconds: seconds) wait.	] ensure:[		processes do:[:p| p ifNotNil:[p terminate]].	].	^(count value // seconds) asStringWithCommas, ' switches/sec'! !!Integer methodsFor: 'benchmarks' stamp: 'ar 8/25/2008 16:46'!benchSwitchCount: assoc wait: sema1 signal: sema2	| p |	p := [		[true] whileTrue:[			sema1 wait.			assoc value: assoc value+1.			sema2 signal.		].	] forkAt: Processor activePriority+1.	p priority: Processor activePriority-1.	^p! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:06'!hex	"Print the receiver as hex, prefixed with 16r.  DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using any of		printStringHex		printStringBase: 16		printStringBase: 16 length: 8 padded: true		storeStringHex		storeStringBase: 16		storeStringBase: 16 length: 11 padded: true"	^self storeStringBase: 16! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:09'!hex8	"Print the receiver in base 16 with prefixed base, using at least 8 digits.	 DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using storeStringBase: 16 length: 11 padded: true instead."	  "16r3333 hex8"	| hex |	hex := self hex.  "16rNNN"	^hex size < 11		ifTrue: [hex copyReplaceFrom: 4 to: 3						 with: ('00000000' copyFrom: 1 to: 11-hex size)]		ifFalse: [hex]! !!IntegerArrayTest methodsFor: 'tests' stamp: 'dtl 10/3/2009 16:36'!testStoreLargeNegativeInteger	"A LargeNegativeInteger that does not exceed the range of a 32-bit twos	complement integer may be stored."	| ia val |	ia := IntegerArray new: 1.	val := (2 raisedTo: 31) negated. "smallest negative 32-bit integer, a LargeNegativeInteger"	ia at: 1 put: val.	self assert: ((ia at: 1) = val)! !!IntegerArrayTest methodsFor: 'tests' stamp: 'dtl 10/3/2009 16:34'!testStoreLargePositiveInteger	"A LargePositiveInteger that does not exceed the range of a 32-bit twos	complement integer may be stored."	| ia val |	ia := IntegerArray new: 1.	val := (2 raisedTo: 31) - 1. "largest positive 32-bit integer, a LargePositiveInteger"	ia at: 1 put: val.	self assert: ((ia at: 1) = val)! !!IntegerArrayTest methodsFor: 'tests' stamp: 'nice 12/27/2009 20:52'!testStoreNegativeOutOfRange	"A value too small for a 32-bit signed integer should raise an error."	| ia val |	ia := IntegerArray new: 1.	val := (2 raisedTo: 31) negated - 1. " -16r80000001 of range for 32-bit twos complement integer"	self should: [ | storedValue |				ia at: 1 put: val. "should raise error here"				storedValue := ia at: 1. "lack of range check leads to value of 16r7FFFFFFF"				self assert: val = storedValue "fail here"]		raise: Error! !!IntegerArrayTest methodsFor: 'tests' stamp: 'nice 12/27/2009 20:52'!testStorePositiveOutOfRange	"A value too large for a 32-bit signed integer should raise an error."	| ia val |	ia := IntegerArray new: 1.	val := 2 raisedTo: 31. "16r80000000 is out of range for 32-bit twos complement"	self should: [ | storedValue |				ia at: 1 put: val. "should raise error here"				storedValue := ia at: 1. "lack of range check leads to value of 16r-80000000"				self assert: val = storedValue "fail here"]		raise: Error! !!IntegerArrayTest methodsFor: 'tests' stamp: 'dtl 10/3/2009 16:31'!testStoreSmallInteger	"Any SmallInteger may be stored in an IntegerArray."	| ia val |	ia := IntegerArray new: 1.	val := SmallInteger maxVal.	ia at: 1 put: val.	self assert: ((ia at: 1) = val).	val := SmallInteger minVal.	ia at: 1 put: val.	self assert: ((ia at: 1) = val)! !!IntegerArrayTest commentStamp: 'dtl 10/3/2009 16:37' prior: 0!Verify storage of integer values in an IntegerArray. An IntegerArray stores 32-bit signed integer values. Lack of range check in primitive fallback code leads to arithmetic overflow errors, so attempts to store out of range values should raise errors.!!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testAndSingleBitWithMinusOne	"And a single bit with -1 and test for same value"	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitAnd: -1) = (1 bitShift: i)].! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'nice 1/10/2010 17:46'!testLargeShift	"A sanity check for LargeInteger bitShifts"		| suite |	suite := #(	"some numbers on 64 bits or less"		'101101011101001100110111110110011101101101000001110110011'		'1101101001100010011001101110100000111011011010100011101100'		'101101101011110011001100110011011101011001111000100011101000'		'10101101101000101001111111111100101101011001011000100011100000'		'1000101010101001111011101010111001011111110011110001000110000000'		'1100101010101000010011101000110010111110110011110000000000000001' ).	"65 bits or less"	suite := suite , (suite collect: [:e | '1' , e reversed ]).	"129 bits or less"	suite := suite , (suite collect: [:e | e ,e ]).	suite do: [:bits | | num ls rs |		num := Integer readFrom: bits readStream base: 2.		0 to: bits size-1 do: [:shift |			ls := (num bitShift: shift) printStringBase: 2.			rs := (num bitShift: 0-shift) printStringBase: 2.			self assert: ls = (bits , (String new: shift withAll: $0)).			self assert: rs = (bits copyFrom: 1 to: bits size - shift).			]].! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:13'!testMixedSignDigitLogic	"Verify that mixed sign logic with large integers works."	self assert: (-2 bitAnd: 16rFFFFFFFF) = 16rFFFFFFFE! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testNBitAndNNegatedEqualsN	"Verify that (n bitAnd: n negated) = n for single bits"	| n |	1 to: 100 do: [:i | n := 1 bitShift: i.				self assert: (n bitAnd: n negated) = n]! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testNNegatedEqualsNComplementedPlusOne	"Verify that n negated = (n complemented + 1) for single bits"	| n |	1 to: 100 do: [:i | n := 1 bitShift: i.				self assert: n negated = ((n bitXor: -1) + 1)]! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:13'!testShiftMinusOne1LeftThenRight	"Shift -1 left then right and test for 1"	1 to: 100 do: [:i | self assert: ((-1 bitShift: i) bitShift: i negated) = -1].! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testShiftOneLeftThenRight	"Shift 1 bit left then right and test for 1"	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitShift: i negated) = 1].! !!IntegerTest methodsFor: 'tests - benchmarks' stamp: 'sd 6/5/2005 08:37'!testBenchFib	self assert: (0 benchFib = 1).	self assert: (1 benchFib = 1).	self assert: (2 benchFib = 3).	! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'nice 12/27/2009 03:11'!testBitAt	| trials bitSequence2 |	self		assert: ((1 to: 100) allSatisfy: [:i | (0 bitAt: i) = 0])		description: 'all bits of zero are set to zero'.		self		assert: ((1 to: 100) allSatisfy: [:i | (-1 bitAt: i) = 1])		description: 'In two complements, all bits of -1 are set to 1'.				trials := #(		'2r10010011'		'2r11100100'		'2r10000000'		'2r0000101011011001'		'2r1000101011011001'		'2r0101010101011000'		'2r0010011110110010'		'2r0010011000000000'		'2r00100111101100101000101011011001'		'2r01110010011110110010100110101101'		'2r10101011101011001010000010110110'		'2r10101000000000000000000000000000'		'2r0010101110101001110010100000101101100010011110110010100010101100'		'2r1010101110101100101000001011011000100111101100101000101011011001'		'2r1010101110101000000000000000000000000000000000000000000000000000').	trials do: [:bitSequence | | aNumber |		aNumber := Number readFrom: bitSequence.		bitSequence2 := (bitSequence size - 2 to: 1 by: -1) inject: '2r' into: [:string :i | string copyWith: (Character digitValue: (aNumber bitAt: i))].		self assert: bitSequence2 = bitSequence].		trials do: [:bitSequence | | bitInvert |		bitInvert := -1 - (Number readFrom: bitSequence).		bitSequence2 := (bitSequence size - 2 to: 1 by: -1) inject: '2r' into: [:string :i | string copyWith: (Character digitValue: 1 - (bitInvert bitAt: i))].		self assert: bitSequence2 = bitSequence description: '-1-x is similar to a bitInvert operation in two complement']! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'sd 6/5/2005 08:43'!testBitLogic  	"This little suite of tests is designed to verify correct operation of most	of Squeak's bit manipulation code, including two's complement	representation of negative values.  It was written in a hurry and	is probably lacking several important checks."	"Shift 1 bit left then right and test for 1"	"self run: #testBitLogic"	| n |	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitShift: i negated) = 1].	"Shift -1 left then right and test for 1"	1 to: 100 do: [:i | self assert: ((-1 bitShift: i) bitShift: i negated) = -1].	"And a single bit with -1 and test for same value"	1 to: 100 do: [:i | self assert: ((1 bitShift: i) bitAnd: -1) = (1 bitShift: i)].	"Verify that (n bitAnd: n negated) = n for single bits"	1 to: 100 do: [:i |  n := 1 bitShift: i. self assert: (n bitAnd: n negated) = n].	"Verify that n negated = (n complemented + 1) for single bits"	1 to: 100 do: [:i | 					n := 1 bitShift: i. 					self assert: n negated = ((n bitXor: -1) + 1)].	"Verify that (n + n complemented) = -1 for single bits"	1 to: 100 do: [:i | 					n := 1 bitShift: i.					self assert: (n + (n bitXor: -1)) = -1].	"Verify that n negated = (n complemented +1) for single bits"	1 to: 100 do: [:i | 					n := 1 bitShift: i.					self assert: n negated = ((n bitXor: -1) + 1)].	self assert: (-2 bitAnd: 16rFFFFFFFF) = 16rFFFFFFFE.! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'nice 7/8/2008 02:47'!testHighBit	| suite |	suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA ) , {SmallInteger maxVal . SmallInteger maxVal+1}.	suite := suite , (suite collect: [:e | e raisedTo: 20]).		suite do: [:anInteger |		| highBit shifted |		highBit := 0.		shifted := 1.		[shifted > anInteger] whileFalse: [highBit := highBit+1. shifted := shifted bitShift: 1].		self assert: anInteger highBit = highBit].! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'nice 7/8/2008 02:44'!testHighBitOfMagnitude	| suite |	suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA ) , {SmallInteger maxVal . SmallInteger maxVal+1}.	suite := suite , (suite collect: [:e | e raisedTo: 20]).		suite do: [:anInteger |		| highBit shifted |		highBit := 0.		shifted := 1.		[shifted > anInteger] whileFalse: [highBit := highBit+1. shifted := shifted bitShift: 1].		self assert: anInteger highBitOfMagnitude = highBit.		self assert: anInteger negated highBitOfMagnitude = highBit].! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'nice 7/8/2008 02:21'!testLowBit	| suite |	suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA ) , {SmallInteger maxVal . SmallInteger maxVal+1}.	suite := suite , (suite collect: [:e | e raisedTo: 20]).		suite do: [:anInteger |		| lowBit |		lowBit := (anInteger respondsTo: #bitAt:)			ifTrue: [(1 to: anInteger highBit) detect: [:bitIndex | (anInteger bitAt: bitIndex) ~= 0] ifNone: [0]]			ifFalse: [(1 to: anInteger highBit) detect: [:bitIndex | (anInteger bitAnd: (1 bitShift: bitIndex-1)) ~= 0] ifNone: [0]].		self assert: anInteger lowBit = lowBit.		self assert: anInteger negated lowBit = lowBit].! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'nice 1/26/2008 02:22'!testTwoComplementBitLogicWithCarry	"This is non regression test for http://bugs.squeak.org/view.php?id=6874"		"By property of two complement, following operation is:	...111110000 this is -16	...111101111 this is -16-1	...111100000 this is -32, the result of bitAnd: on two complement		This test used to fail with n=31 39 47.... because of bug 6874"		self assert: ((2 to: 80) allSatisfy: [:n | ((2 raisedTo: n) negated bitAnd: (2 raisedTo: n) negated - 1) = (2 raisedTo: n + 1) negated]).! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'sd 6/5/2005 08:44'!testTwoComplementRightShift	"self run: #testTwoComplementRightShift"	| large small |	small := 2 << 16.	large := 2 << 32.		self assert: ((small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))).		     self assert: ((small bitShift: -1) ~= (small + 1 bitShift: -1)		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))).! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 08:48'!testCreationFromBytes1	"self run: #testCreationFromBytes1"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs SmallInteger maxVal as an instance of SmallInteger. "  	| maxSmallInt hexString byte1 byte2 byte3 byte4 	builtInteger |	maxSmallInt := SmallInteger maxVal.	hexString := maxSmallInt printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = maxSmallInt.	self assert: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 08:48'!testCreationFromBytes2 	"self run: #testCreationFromBytes2"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal + 1) as an instance of LargePositiveInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt + 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt + 1).	self deny: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 08:49'!testCreationFromBytes3	"self run: #testCreationFromBytes3"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal - 1) as an instance of SmallInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4     builtInteger |	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt - 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt - 1).	self assert: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 08:46'!testDifferentBases	"self run: #testDifferentBases"	"| value |	2 to: 36 do: [:each|		value := 0.		1 to: each-1 do: [:n| value := value + (n * (each raisedToInteger: n))].		value := value negated.		Transcript tab; show: 'self assert: (', value printString, ' printStringBase: ', each printString, ') = ''', (value printStringBase: each), '''.'; cr.		Transcript tab; show: 'self assert: (', value printString, ' radix: ', each printString, ') = ''', (value radix: each), '''.'; cr.		Transcript tab; show: 'self assert: ', value printString, ' printStringHex = ''', (value printStringBase: 16), '''.'; cr.		Transcript tab; show: 'self assert: (', value printString, ' storeStringBase: ', each printString, ') = ''', (value storeStringBase: each), '''.'; cr.		Transcript tab; show: 'self assert: ', value printString, ' storeStringHex = ''', (value storeStringBase: 16), '''.'; cr.].	"	self assert: 2r10 = 2.	self assert: 3r210 = 21.	self assert: 4r3210 = 228.	self assert: 5r43210 = 2930.	self assert: 6r543210 = 44790.	self assert: 7r6543210 = 800667.	self assert: 8r76543210 = 16434824.	self assert: 9r876543210 = 381367044.	self assert: 10r9876543210 = 9876543210.	self assert: 11rA9876543210 = 282458553905.	self assert: 12rBA9876543210 = 8842413667692.	self assert: 13rCBA9876543210 = 300771807240918.	self assert: 14rDCBA9876543210 = 11046255305880158.	self assert: 15rEDCBA9876543210 = 435659737878916215.	self assert: 16rFEDCBA9876543210 = 18364758544493064720.	self assert: 17rGFEDCBA9876543210 = 824008854613343261192.	self assert: 18rHGFEDCBA9876543210 = 39210261334551566857170.	self assert: 19rIHGFEDCBA9876543210 = 1972313422155189164466189.	self assert: 20rJIHGFEDCBA9876543210 = 104567135734072022160664820.	self assert: 21rKJIHGFEDCBA9876543210 = 5827980550840017565077671610.	self assert: 22rLKJIHGFEDCBA9876543210 = 340653664490377789692799452102.	self assert: 23rMLKJIHGFEDCBA9876543210 = 20837326537038308910317109288851.	self assert: 24rNMLKJIHGFEDCBA9876543210 = 1331214537196502869015340298036888.	self assert: 25rONMLKJIHGFEDCBA9876543210 = 88663644327703473714387251271141900.	self assert: 26rPONMLKJIHGFEDCBA9876543210 = 6146269788878825859099399609538763450.	self assert: 27rQPONMLKJIHGFEDCBA9876543210 = 442770531899482980347734468443677777577.	self assert: 28rRQPONMLKJIHGFEDCBA9876543210 = 33100056003358651440264672384704297711484.	self assert: 29rSRQPONMLKJIHGFEDCBA9876543210 = 2564411043271974895869785066497940850811934.	self assert: 30rTSRQPONMLKJIHGFEDCBA9876543210 = 205646315052919334126040428061831153388822830.	self assert: 31rUTSRQPONMLKJIHGFEDCBA9876543210 = 17050208381689099029767742314582582184093573615.	self assert: 32rVUTSRQPONMLKJIHGFEDCBA9876543210 = 1459980823972598128486511383358617792788444579872.	self assert: 33rWVUTSRQPONMLKJIHGFEDCBA9876543210 = 128983956064237823710866404905431464703849549412368.	self assert: 34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 11745843093701610854378775891116314824081102660800418.	self assert: 35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 1101553773143634726491620528194292510495517905608180485.	self assert: 36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 106300512100105327644605138221229898724869759421181854980.	self assert: -2r10 = -2.	self assert: -3r210 = -21.	self assert: -4r3210 = -228.	self assert: -5r43210 = -2930.	self assert: -6r543210 = -44790.	self assert: -7r6543210 = -800667.	self assert: -8r76543210 = -16434824.	self assert: -9r876543210 = -381367044.	self assert: -10r9876543210 = -9876543210.	self assert: -11rA9876543210 = -282458553905.	self assert: -12rBA9876543210 = -8842413667692.	self assert: -13rCBA9876543210 = -300771807240918.	self assert: -14rDCBA9876543210 = -11046255305880158.	self assert: -15rEDCBA9876543210 = -435659737878916215.	self assert: -16rFEDCBA9876543210 = -18364758544493064720.	self assert: -17rGFEDCBA9876543210 = -824008854613343261192.	self assert: -18rHGFEDCBA9876543210 = -39210261334551566857170.	self assert: -19rIHGFEDCBA9876543210 = -1972313422155189164466189.	self assert: -20rJIHGFEDCBA9876543210 = -104567135734072022160664820.	self assert: -21rKJIHGFEDCBA9876543210 = -5827980550840017565077671610.	self assert: -22rLKJIHGFEDCBA9876543210 = -340653664490377789692799452102.	self assert: -23rMLKJIHGFEDCBA9876543210 = -20837326537038308910317109288851.	self assert: -24rNMLKJIHGFEDCBA9876543210 = -1331214537196502869015340298036888.	self assert: -25rONMLKJIHGFEDCBA9876543210 = -88663644327703473714387251271141900.	self assert: -26rPONMLKJIHGFEDCBA9876543210 = -6146269788878825859099399609538763450.	self assert: -27rQPONMLKJIHGFEDCBA9876543210 = -442770531899482980347734468443677777577.	self assert: -28rRQPONMLKJIHGFEDCBA9876543210 = -33100056003358651440264672384704297711484.	self assert: -29rSRQPONMLKJIHGFEDCBA9876543210 = -2564411043271974895869785066497940850811934.	self assert: -30rTSRQPONMLKJIHGFEDCBA9876543210 = -205646315052919334126040428061831153388822830.	self assert: -31rUTSRQPONMLKJIHGFEDCBA9876543210 = -17050208381689099029767742314582582184093573615.	self assert: -32rVUTSRQPONMLKJIHGFEDCBA9876543210 = -1459980823972598128486511383358617792788444579872.	self assert: -33rWVUTSRQPONMLKJIHGFEDCBA9876543210 = -128983956064237823710866404905431464703849549412368.	self assert: -34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -11745843093701610854378775891116314824081102660800418.	self assert: -35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -1101553773143634726491620528194292510495517905608180485.	self assert: -36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -106300512100105327644605138221229898724869759421181854980.! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'nice 2/13/2010 03:11'!testIntegerReadFrom	self assert: (Integer readFrom: '123' readStream base: 10) = 123.	self assert: (Integer readFrom: '-123' readStream base: 10) = -123.	self should: [Integer readFrom: 'abc' readStream base: 10] raise: Error.	self should: [Integer readFrom: 'D12' readStream base: 10] raise: Error.	self assert: (Integer readFrom: 'abc' readStream ifFail: [0]) = 0.	self assert: (Integer readFrom: 'D12' readStream ifFail: [0]) = 0.	self assert: (Integer readFrom: '1two3' readStream base: 10) = 1.! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'md 3/25/2003 23:14'!testNew	self should: [Integer new] raise: TestResult error. ! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'nice 2/22/2010 22:15'!testReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.		rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.0.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'nice 2/22/2010 22:19'!testStringAsNumber	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	self assert: ('123' asNumber == 123).	self assert: ('-123' asNumber == -123).	self assert: ('123.' asNumber = 123).	self assert: ('123.' asNumber) isFloat.	self assert: ('-123.' asNumber = -123).	self assert: ('-123.' asNumber) isFloat.	self assert: ('123This is not to be read' asNumber == 123).	self assert: ('123s could be confused with a ScaledDecimal' asNumber == 123).	self assert: ('123e could be confused with a Float' asNumber == 123).! !!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'mga 5/11/2006 15:41'!testCrossSumBase	"self run: #testCrossSumBase"	self assert: (		((-20 to: 20) collect: [:each | each crossSumBase: 10]) asArray = 		#(2 10 9 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 10 2)).	self assert: (		((-20 to: 20) collect: [:each | each crossSumBase: 2]) asArray = 		#(2 3 2 2 1 4 3 3 2 3 2 2 1 3 2 2 1 2 1 1 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2)).	self should: [10 crossSumBase: 1] raise: AssertionFailure! !!IntegerTest methodsFor: 'tests - basic' stamp: 'sd 3/5/2004 14:50'!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ 45 degreeCos] raise: Error.	self assert: 45  degreeCos printString =  (2 sqrt / 2) asFloat printString ! !!IntegerTest methodsFor: 'tests - basic' stamp: 'md 4/21/2003 16:17'!testEven		self deny: (1073741825 even).	self assert: (1073741824  even).	! !!IntegerTest methodsFor: 'tests - basic' stamp: 'sd 6/5/2005 08:45'!testIsInteger	self assert: (0 isInteger).	! !!IntegerTest methodsFor: 'tests - basic' stamp: 'md 4/15/2003 20:40'!testIsPowerOfTwo	self assert: (0 isPowerOfTwo).	self assert: (1 isPowerOfTwo).	self assert: (2 isPowerOfTwo).	self deny:  (3 isPowerOfTwo).	self assert: (4 isPowerOfTwo).	! !!IntegerTest methodsFor: 'tests - basic' stamp: 'nice 1/25/2008 22:51'!testIsPowerOfTwoM6873	"This is a non regression test for http://bugs.squeak.org/view.php?id=6873"	self deny: ((1 to: 80) anySatisfy: [:n | (2 raisedTo: n) negated isPowerOfTwo])		description: 'A negative integer cannot be a power of two'.! !!IntegerTest methodsFor: 'tests - basic' stamp: 'ul 11/25/2009 02:51'!testIsPrime	"Not primes:"	#(-100 -5 -3 -2 -1 0 1) do: [ :each |		self deny: each isPrime ].	"The following tests should return 'true'"	#(17 78901 104729 15485863 2038074743) do: [ :each |		self assert: each isPrime ].		"The following tests should return 'false' (first 5 are Carmichael integers)"	#(561 2821 6601 10585 15841 256 29996224275831) do: [ :each |		self deny: each isPrime ].! !!IntegerTest methodsFor: 'tests - basic' stamp: 'ul 11/25/2009 02:49'!testIsProbablyPrime	"Not primes:"	#(-100 -5 -3 -2 -1 0 1) do: [ :each |		self deny: each isProbablyPrime ].	"The following tests should return 'true'"	#(17 78901 104729 15485863 2038074743 29996224275833) do: [ :each |		self assert: each isProbablyPrime ].		"The following tests should return 'false' (first 5 are Carmichael integers)"	#(561 2821 6601 10585 15841 256 29996224275831) do: [ :each |		self deny: each isProbablyPrime ].! !!IntegerTest methodsFor: 'tests - basic' stamp: 'md 2/12/2006 14:36'!testLargePrimesUpTo	| nn | 	nn := (2 raisedTo: 17) - 1. 	self deny: (Integer primesUpTo: nn) last = nn.	self assert: (Integer primesUpTo: nn + 1) last  = nn.		! !!IntegerTest methodsFor: 'tests - basic' stamp: 'md 2/12/2006 14:36'!testPrimesUpTo	| primes nn|	primes := Integer primesUpTo: 100.	self assert: primes = #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97).		"upTo: semantics means 'non-inclusive'"	primes := Integer primesUpTo: 5.	self assert: primes = #(2 3).		"this test is green for nn>25000, see #testLargePrimesUpTo"	nn := 5. 	self deny: (Integer primesUpTo: nn) last = nn.	self assert: (Integer primesUpTo: nn + 1) last  = nn.! !!IntegerTest methodsFor: 'tests - printing' stamp: 'laza 1/30/2005 14:04'!testIntegerByteEncoded	self assert: (ByteEncoder stream writeNumber: 2 base: 2; yourself) contents = '10'.	self assert: (ByteEncoder stream writeNumber: 21 base: 3; yourself) contents = '210'.	self assert: (ByteEncoder stream writeNumber: 228 base: 4; yourself) contents = '3210'.	self assert: (ByteEncoder stream writeNumber: 2930 base: 5; yourself) contents = '43210'.	self assert: (ByteEncoder stream writeNumber: 44790 base: 6; yourself) contents = '543210'.	self assert: (ByteEncoder stream writeNumber: 800667 base: 7; yourself) contents = '6543210'.	self assert: (ByteEncoder stream writeNumber: 16434824 base: 8; yourself) contents = '76543210'.	self assert: (ByteEncoder stream writeNumber: 381367044 base: 9; yourself) contents = '876543210'.	self assert: (ByteEncoder stream writeNumber: 9876543210 base: 10; yourself) contents = '9876543210'.	self assert: (ByteEncoder stream writeNumber: 282458553905 base: 11; yourself) contents = 'A9876543210'.	self assert: (ByteEncoder stream writeNumber: 8842413667692 base: 12; yourself) contents = 'BA9876543210'.	self assert: (ByteEncoder stream writeNumber: 300771807240918 base: 13; yourself) contents = 'CBA9876543210'.	self assert: (ByteEncoder stream writeNumber: 11046255305880158 base: 14; yourself) contents = 'DCBA9876543210'.	self assert: (ByteEncoder stream writeNumber: 435659737878916215 base: 15; yourself) contents = 'EDCBA9876543210'.	self assert: (ByteEncoder stream writeNumber: 18364758544493064720 base: 16; yourself) contents = 'FEDCBA9876543210'.	self assert: (ByteEncoder stream writeNumber: -2 base: 2; yourself) contents = '-10'.	self assert: (ByteEncoder stream writeNumber: -21 base: 3; yourself) contents = '-210'.	self assert: (ByteEncoder stream writeNumber: -228 base: 4; yourself) contents = '-3210'.	self assert: (ByteEncoder stream writeNumber: -2930 base: 5; yourself) contents = '-43210'.	self assert: (ByteEncoder stream writeNumber: -44790 base: 6; yourself) contents = '-543210'.	self assert: (ByteEncoder stream writeNumber: -800667 base: 7; yourself) contents = '-6543210'.	self assert: (ByteEncoder stream writeNumber: -16434824 base: 8; yourself) contents = '-76543210'.	self assert: (ByteEncoder stream writeNumber: -381367044 base: 9; yourself) contents = '-876543210'.	self assert: (ByteEncoder stream writeNumber: -9876543210 base: 10; yourself) contents = '-9876543210'.	self assert: (ByteEncoder stream writeNumber: -282458553905 base: 11; yourself) contents = '-A9876543210'.	self assert: (ByteEncoder stream writeNumber: -8842413667692 base: 12; yourself) contents = '-BA9876543210'.	self assert: (ByteEncoder stream writeNumber: -300771807240918 base: 13; yourself) contents = '-CBA9876543210'.	self assert: (ByteEncoder stream writeNumber: -11046255305880158 base: 14; yourself) contents = '-DCBA9876543210'.	self assert: (ByteEncoder stream writeNumber: -435659737878916215 base: 15; yourself) contents = '-EDCBA9876543210'.	self assert: (ByteEncoder stream writeNumber: -18364758544493064720 base: 16; yourself) contents = '-FEDCBA9876543210'.! !!IntegerTest methodsFor: 'tests - printing' stamp: 'laza 3/29/2004 18:16'!testIntegerPadding	"self run: #testIntegerPadding"	self assert: (1 printStringBase: 10 length: 0 padded: false) = '1'.	self assert: (1 printStringBase: 10 length: 1 padded: false) = '1'.	self assert: (1 printStringBase: 10 length: 2 padded: false) = ' 1'.	self assert: (1024 printStringBase: 10 length: 19 padded: false) = '               1024'.	self assert: (1024 printStringBase: 10 length: -1 padded: false) = '1024'.	self assert: (1024 printStringBase: 10 length: 5 padded: false) =  ' 1024'.	self assert: (-1024 printStringBase: 10 length: 5 padded: false) =   '-1024'.	self assert: (-1024 printStringBase: 10 length: 19 padded: false) =  '              -1024'.	self assert: (1 printStringBase: 10 length: 0 padded: true) = '1'.	self assert: (1 printStringBase: 10 length: 1 padded: true) = '1'.	self assert: (1 printStringBase: 10 length: 2 padded: true) = '01'.	self assert: (1024 printStringBase: 10 length: 19 padded: true) = '0000000000000001024'.	self assert: (1024 printStringBase: 10 length: -1 padded: true) = '1024'.	self assert: (1024 printStringBase: 10 length: 5 padded: true) =  '01024'.	self assert: (-1024 printStringBase: 10 length: 5 padded: true) =   '-1024'.	self assert: (-1024 printStringBase: 10 length: 19 padded: true) =  '-000000000000001024'.	self assert: (1 printStringBase: 16 length: 0 padded: false) = '1'.	self assert: (1 printStringBase: 16 length: 1 padded: false) = '1'.	self assert: (1 printStringBase: 16 length: 2 padded: false) = ' 1'.	self assert: (2047 printStringBase: 16 length: 19 padded: false) =  '                7FF'.	self assert: (2047 printStringBase: 16 length: -1 padded: false) =  '7FF'.	self assert: (2047 printStringBase: 16 length: 4 padded: false) =  ' 7FF'.	self assert: (-2047 printStringBase: 16 length: 4 padded: false) = '-7FF'.	self assert: (-2047 printStringBase: 16 length: 19 padded: false) =  '               -7FF'.	self assert: (1 printStringBase: 16 length: 0 padded: true) = '1'.	self assert: (1 printStringBase: 16 length: 1 padded: true) = '1'.	self assert: (1 printStringBase: 16 length: 2 padded: true) = '01'.	self assert: (2047 printStringBase: 16 length: 19 padded: true) =  '00000000000000007FF'.	self assert: (2047 printStringBase: 16 length: -1 padded: true) =  '7FF'.	self assert: (2047 printStringBase: 16 length: 4 padded: true) =  '07FF'.	self assert: (-2047 printStringBase: 16 length: 4 padded: true) = '-7FF'.	self assert: (-2047 printStringBase: 16 length: 19 padded: true) =  '-0000000000000007FF'.	self assert: (1 storeStringBase: 10 length: 0 padded: false) = '1'.	self assert: (1 storeStringBase: 10 length: 1 padded: false) = '1'.	self assert: (1 storeStringBase: 10 length: 2 padded: false) = ' 1'.	self assert: (1024 storeStringBase: 10 length: 19 padded: false) = '               1024'.	self assert: (1024 storeStringBase: 10 length: -1 padded: false) = '1024'.	self assert: (1024 storeStringBase: 10 length: 5 padded: false) =  ' 1024'.	self assert: (-1024 storeStringBase: 10 length: 5 padded: false) =   '-1024'.	self assert: (-1024 storeStringBase: 10 length: 19 padded: false) =  '              -1024'.	self assert: (1 storeStringBase: 10 length: 0 padded: true) = '1'.	self assert: (1 storeStringBase: 10 length: 1 padded: true) = '1'.	self assert: (1 storeStringBase: 10 length: 2 padded: true) = '01'.	self assert: (1024 storeStringBase: 10 length: 19 padded: true) = '0000000000000001024'.	self assert: (1024 storeStringBase: 10 length: -1 padded: true) = '1024'.	self assert: (1024 storeStringBase: 10 length: 5 padded: true) =  '01024'.	self assert: (-1024 storeStringBase: 10 length: 5 padded: true) =   '-1024'.	self assert: (-1024 storeStringBase: 10 length: 19 padded: true) =  '-000000000000001024'.	self assert: (1 storeStringBase: 16 length: 0 padded: false) = '16r1'.	self assert: (1 storeStringBase: 16 length: 4 padded: false) = '16r1'.	self assert: (1 storeStringBase: 16 length: 5 padded: false) = ' 16r1'.	self assert: (2047 storeStringBase: 16 length: 19 padded: false) =  '             16r7FF'.	self assert: (2047 storeStringBase: 16 length: -1 padded: false) =  '16r7FF'.	self assert: (2047 storeStringBase: 16 length: 7 padded: false) =  ' 16r7FF'.	self assert: (-2047 storeStringBase: 16 length: 7 padded: false) = '-16r7FF'.	self assert: (-2047 storeStringBase: 16 length: 19 padded: false) =  '            -16r7FF'.	self assert: (1 storeStringBase: 16 length: 0 padded: true) = '16r1'.	self assert: (1 storeStringBase: 16 length: 4 padded: true) = '16r1'.	self assert: (1 storeStringBase: 16 length: 5 padded: true) = '16r01'.	self assert: (2047 storeStringBase: 16 length: 19 padded: true) =  '16r00000000000007FF'.	self assert: (2047 storeStringBase: 16 length: -1 padded: true) =  '16r7FF'.	self assert: (2047 storeStringBase: 16 length: 7 padded: true) =  '16r07FF'.	self assert: (-2047 storeStringBase: 16 length: 7 padded: true) = '-16r7FF'.	self assert: (-2047 storeStringBase: 16 length: 19 padded: true) =  '-16r0000000000007FF'.! !!IntegerTest methodsFor: 'tests - printing' stamp: 'laza 3/30/2004 14:20'!testNegativeIntegerPrinting	"self run: #testnegativeIntegerPrinting"	self assert: (-2 printStringBase: 2) = '-10'.	self assert: (-2 radix: 2) = '-10'.	self assert: -2 printStringHex = '-2'.	self assert: (-2 storeStringBase: 2) = '-2r10'.	self assert: -2 storeStringHex = '-16r2'.	self assert: (-21 printStringBase: 3) = '-210'.	self assert: (-21 radix: 3) = '-210'.	self assert: -21 printStringHex = '-15'.	self assert: (-21 storeStringBase: 3) = '-3r210'.	self assert: -21 storeStringHex = '-16r15'.	self assert: (-228 printStringBase: 4) = '-3210'.	self assert: (-228 radix: 4) = '-3210'.	self assert: -228 printStringHex = '-E4'.	self assert: (-228 storeStringBase: 4) = '-4r3210'.	self assert: -228 storeStringHex = '-16rE4'.	self assert: (-2930 printStringBase: 5) = '-43210'.	self assert: (-2930 radix: 5) = '-43210'.	self assert: -2930 printStringHex = '-B72'.	self assert: (-2930 storeStringBase: 5) = '-5r43210'.	self assert: -2930 storeStringHex = '-16rB72'.	self assert: (-44790 printStringBase: 6) = '-543210'.	self assert: (-44790 radix: 6) = '-543210'.	self assert: -44790 printStringHex = '-AEF6'.	self assert: (-44790 storeStringBase: 6) = '-6r543210'.	self assert: -44790 storeStringHex = '-16rAEF6'.	self assert: (-800667 printStringBase: 7) = '-6543210'.	self assert: (-800667 radix: 7) = '-6543210'.	self assert: -800667 printStringHex = '-C379B'.	self assert: (-800667 storeStringBase: 7) = '-7r6543210'.	self assert: -800667 storeStringHex = '-16rC379B'.	self assert: (-16434824 printStringBase: 8) = '-76543210'.	self assert: (-16434824 radix: 8) = '-76543210'.	self assert: -16434824 printStringHex = '-FAC688'.	self assert: (-16434824 storeStringBase: 8) = '-8r76543210'.	self assert: -16434824 storeStringHex = '-16rFAC688'.	self assert: (-381367044 printStringBase: 9) = '-876543210'.	self assert: (-381367044 radix: 9) = '-876543210'.	self assert: -381367044 printStringHex = '-16BB3304'.	self assert: (-381367044 storeStringBase: 9) = '-9r876543210'.	self assert: -381367044 storeStringHex = '-16r16BB3304'.	self assert: (-9876543210 printStringBase: 10) = '-9876543210'.	self assert: (-9876543210 radix: 10) = '-9876543210'.	self assert: -9876543210 printStringHex = '-24CB016EA'.	self assert: (-9876543210 storeStringBase: 10) = '-9876543210'.	self assert: -9876543210 storeStringHex = '-16r24CB016EA'.	self assert: (-282458553905 printStringBase: 11) = '-A9876543210'.	self assert: (-282458553905 radix: 11) = '-A9876543210'.	self assert: -282458553905 printStringHex = '-41C3D77E31'.	self assert: (-282458553905 storeStringBase: 11) = '-11rA9876543210'.	self assert: -282458553905 storeStringHex = '-16r41C3D77E31'.	self assert: (-8842413667692 printStringBase: 12) = '-BA9876543210'.	self assert: (-8842413667692 radix: 12) = '-BA9876543210'.	self assert: -8842413667692 printStringHex = '-80AC8ECF56C'.	self assert: (-8842413667692 storeStringBase: 12) = '-12rBA9876543210'.	self assert: -8842413667692 storeStringHex = '-16r80AC8ECF56C'.	self assert: (-300771807240918 printStringBase: 13) = '-CBA9876543210'.	self assert: (-300771807240918 radix: 13) = '-CBA9876543210'.	self assert: -300771807240918 printStringHex = '-1118CE4BAA2D6'.	self assert: (-300771807240918 storeStringBase: 13) = '-13rCBA9876543210'.	self assert: -300771807240918 storeStringHex = '-16r1118CE4BAA2D6'.	self assert: (-11046255305880158 printStringBase: 14) = '-DCBA9876543210'.	self assert: (-11046255305880158 radix: 14) = '-DCBA9876543210'.	self assert: -11046255305880158 printStringHex = '-273E82BB9AF25E'.	self assert: (-11046255305880158 storeStringBase: 14) = '-14rDCBA9876543210'.	self assert: -11046255305880158 storeStringHex = '-16r273E82BB9AF25E'.	self assert: (-435659737878916215 printStringBase: 15) = '-EDCBA9876543210'.	self assert: (-435659737878916215 radix: 15) = '-EDCBA9876543210'.	self assert: -435659737878916215 printStringHex = '-60BC6392F366C77'.	self assert: (-435659737878916215 storeStringBase: 15) = '-15rEDCBA9876543210'.	self assert: -435659737878916215 storeStringHex = '-16r60BC6392F366C77'.	self assert: (-18364758544493064720 printStringBase: 16) = '-FEDCBA9876543210'.	self assert: (-18364758544493064720 radix: 16) = '-FEDCBA9876543210'.	self assert: -18364758544493064720 printStringHex = '-FEDCBA9876543210'.	self assert: (-18364758544493064720 storeStringBase: 16) = '-16rFEDCBA9876543210'.	self assert: -18364758544493064720 storeStringHex = '-16rFEDCBA9876543210'.	self assert: (-824008854613343261192 printStringBase: 17) = '-GFEDCBA9876543210'.	self assert: (-824008854613343261192 radix: 17) = '-GFEDCBA9876543210'.	self assert: -824008854613343261192 printStringHex = '-2CAB6B877C1CD2D208'.	self assert: (-824008854613343261192 storeStringBase: 17) = '-17rGFEDCBA9876543210'.	self assert: -824008854613343261192 storeStringHex = '-16r2CAB6B877C1CD2D208'.	self assert: (-39210261334551566857170 printStringBase: 18) = '-HGFEDCBA9876543210'.	self assert: (-39210261334551566857170 radix: 18) = '-HGFEDCBA9876543210'.	self assert: -39210261334551566857170 printStringHex = '-84D97AFCAE81415B3D2'.	self assert: (-39210261334551566857170 storeStringBase: 18) = '-18rHGFEDCBA9876543210'.	self assert: -39210261334551566857170 storeStringHex = '-16r84D97AFCAE81415B3D2'.	self assert: (-1972313422155189164466189 printStringBase: 19) = '-IHGFEDCBA9876543210'.	self assert: (-1972313422155189164466189 radix: 19) = '-IHGFEDCBA9876543210'.	self assert: -1972313422155189164466189 printStringHex = '-1A1A75329C5C6FC00600D'.	self assert: (-1972313422155189164466189 storeStringBase: 19) = '-19rIHGFEDCBA9876543210'.	self assert: -1972313422155189164466189 storeStringHex = '-16r1A1A75329C5C6FC00600D'.	self assert: (-104567135734072022160664820 printStringBase: 20) = '-JIHGFEDCBA9876543210'.	self assert: (-104567135734072022160664820 radix: 20) = '-JIHGFEDCBA9876543210'.	self assert: -104567135734072022160664820 printStringHex = '-567EF3C9636D242A8C68F4'.	self assert: (-104567135734072022160664820 storeStringBase: 20) = '-20rJIHGFEDCBA9876543210'.	self assert: -104567135734072022160664820 storeStringHex = '-16r567EF3C9636D242A8C68F4'.	self assert: (-5827980550840017565077671610 printStringBase: 21) = '-KJIHGFEDCBA9876543210'.	self assert: (-5827980550840017565077671610 radix: 21) = '-KJIHGFEDCBA9876543210'.	self assert: -5827980550840017565077671610 printStringHex = '-12D4CAE2B8A09BCFDBE30EBA'.	self assert: (-5827980550840017565077671610 storeStringBase: 21) = '-21rKJIHGFEDCBA9876543210'.	self assert: -5827980550840017565077671610 storeStringHex = '-16r12D4CAE2B8A09BCFDBE30EBA'.	self assert: (-340653664490377789692799452102 printStringBase: 22) = '-LKJIHGFEDCBA9876543210'.	self assert: (-340653664490377789692799452102 radix: 22) = '-LKJIHGFEDCBA9876543210'.	self assert: -340653664490377789692799452102 printStringHex = '-44CB61B5B47E1A5D8F88583C6'.	self assert: (-340653664490377789692799452102 storeStringBase: 22) = '-22rLKJIHGFEDCBA9876543210'.	self assert: -340653664490377789692799452102 storeStringHex = '-16r44CB61B5B47E1A5D8F88583C6'.	self assert: (-20837326537038308910317109288851 printStringBase: 23) = '-MLKJIHGFEDCBA9876543210'.	self assert: (-20837326537038308910317109288851 radix: 23) = '-MLKJIHGFEDCBA9876543210'.	self assert: -20837326537038308910317109288851 printStringHex = '-1070108876456E0EF115B389F93'.	self assert: (-20837326537038308910317109288851 storeStringBase: 23) = '-23rMLKJIHGFEDCBA9876543210'.	self assert: -20837326537038308910317109288851 storeStringHex = '-16r1070108876456E0EF115B389F93'.	self assert: (-1331214537196502869015340298036888 printStringBase: 24) = '-NMLKJIHGFEDCBA9876543210'.	self assert: (-1331214537196502869015340298036888 radix: 24) = '-NMLKJIHGFEDCBA9876543210'.	self assert: -1331214537196502869015340298036888 printStringHex = '-41A24A285154B026B6ED206C6698'.	self assert: (-1331214537196502869015340298036888 storeStringBase: 24) = '-24rNMLKJIHGFEDCBA9876543210'.	self assert: -1331214537196502869015340298036888 storeStringHex = '-16r41A24A285154B026B6ED206C6698'.	self assert: (-88663644327703473714387251271141900 printStringBase: 25) = '-ONMLKJIHGFEDCBA9876543210'.	self assert: (-88663644327703473714387251271141900 radix: 25) = '-ONMLKJIHGFEDCBA9876543210'.	self assert: -88663644327703473714387251271141900 printStringHex = '-111374860A2C6CEBE5999630398A0C'.	self assert: (-88663644327703473714387251271141900 storeStringBase: 25) = '-25rONMLKJIHGFEDCBA9876543210'.	self assert: -88663644327703473714387251271141900 storeStringHex = '-16r111374860A2C6CEBE5999630398A0C'.	self assert: (-6146269788878825859099399609538763450 printStringBase: 26) = '-PONMLKJIHGFEDCBA9876543210'.	self assert: (-6146269788878825859099399609538763450 radix: 26) = '-PONMLKJIHGFEDCBA9876543210'.	self assert: -6146269788878825859099399609538763450 printStringHex = '-49FBA7F30B0F48BD14E6A99BD8ADABA'.	self assert: (-6146269788878825859099399609538763450 storeStringBase: 26) = '-26rPONMLKJIHGFEDCBA9876543210'.	self assert: -6146269788878825859099399609538763450 storeStringHex = '-16r49FBA7F30B0F48BD14E6A99BD8ADABA'.	self assert: (-442770531899482980347734468443677777577 printStringBase: 27) = '-QPONMLKJIHGFEDCBA9876543210'.	self assert: (-442770531899482980347734468443677777577 radix: 27) = '-QPONMLKJIHGFEDCBA9876543210'.	self assert: -442770531899482980347734468443677777577 printStringHex = '-14D1A80A997343640C1145A073731DEA9'.	self assert: (-442770531899482980347734468443677777577 storeStringBase: 27) = '-27rQPONMLKJIHGFEDCBA9876543210'.	self assert: -442770531899482980347734468443677777577 storeStringHex = '-16r14D1A80A997343640C1145A073731DEA9'.	self assert: (-33100056003358651440264672384704297711484 printStringBase: 28) = '-RQPONMLKJIHGFEDCBA9876543210'.	self assert: (-33100056003358651440264672384704297711484 radix: 28) = '-RQPONMLKJIHGFEDCBA9876543210'.	self assert: -33100056003358651440264672384704297711484 printStringHex = '-6145B6E6DACFA25D0E936F51D25932377C'.	self assert: (-33100056003358651440264672384704297711484 storeStringBase: 28) = '-28rRQPONMLKJIHGFEDCBA9876543210'.	self assert: -33100056003358651440264672384704297711484 storeStringHex = '-16r6145B6E6DACFA25D0E936F51D25932377C'.	self assert: (-2564411043271974895869785066497940850811934 printStringBase: 29) = '-SRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-2564411043271974895869785066497940850811934 radix: 29) = '-SRQPONMLKJIHGFEDCBA9876543210'.	self assert: -2564411043271974895869785066497940850811934 printStringHex = '-1D702071CBA4A1597D4DD37E95EFAC79241E'.	self assert: (-2564411043271974895869785066497940850811934 storeStringBase: 29) = '-29rSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -2564411043271974895869785066497940850811934 storeStringHex = '-16r1D702071CBA4A1597D4DD37E95EFAC79241E'.	self assert: (-205646315052919334126040428061831153388822830 printStringBase: 30) = '-TSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-205646315052919334126040428061831153388822830 radix: 30) = '-TSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -205646315052919334126040428061831153388822830 printStringHex = '-938B4343B54B550989989D02998718FFB212E'.	self assert: (-205646315052919334126040428061831153388822830 storeStringBase: 30) = '-30rTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -205646315052919334126040428061831153388822830 storeStringHex = '-16r938B4343B54B550989989D02998718FFB212E'.	self assert: (-17050208381689099029767742314582582184093573615 printStringBase: 31) = '-UTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-17050208381689099029767742314582582184093573615 radix: 31) = '-UTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -17050208381689099029767742314582582184093573615 printStringHex = '-2FC8ECB1521BA16D24A69E976D53873E2C661EF'.	self assert: (-17050208381689099029767742314582582184093573615 storeStringBase: 31) = '-31rUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -17050208381689099029767742314582582184093573615 storeStringHex = '-16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.	self assert: (-1459980823972598128486511383358617792788444579872 printStringBase: 32) = '-VUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-1459980823972598128486511383358617792788444579872 radix: 32) = '-VUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -1459980823972598128486511383358617792788444579872 printStringHex = '-FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.	self assert: (-1459980823972598128486511383358617792788444579872 storeStringBase: 32) = '-32rVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -1459980823972598128486511383358617792788444579872 storeStringHex = '-16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.	self assert: (-128983956064237823710866404905431464703849549412368 printStringBase: 33) = '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-128983956064237823710866404905431464703849549412368 radix: 33) = '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -128983956064237823710866404905431464703849549412368 printStringHex = '-584120A0328DE272AB055A8AA003CE4A559F223810'.	self assert: (-128983956064237823710866404905431464703849549412368 storeStringBase: 33) = '-33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -128983956064237823710866404905431464703849549412368 storeStringHex = '-16r584120A0328DE272AB055A8AA003CE4A559F223810'.	self assert: (-11745843093701610854378775891116314824081102660800418 printStringBase: 34) = '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-11745843093701610854378775891116314824081102660800418 radix: 34) = '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -11745843093701610854378775891116314824081102660800418 printStringHex = '-1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.	self assert: (-11745843093701610854378775891116314824081102660800418 storeStringBase: 34) = '-34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -11745843093701610854378775891116314824081102660800418 storeStringHex = '-16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.	self assert: (-1101553773143634726491620528194292510495517905608180485 printStringBase: 35) = '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-1101553773143634726491620528194292510495517905608180485 radix: 35) = '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -1101553773143634726491620528194292510495517905608180485 printStringHex = '-B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.	self assert: (-1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) = '-35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -1101553773143634726491620528194292510495517905608180485 storeStringHex = '-16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.	self assert: (-106300512100105327644605138221229898724869759421181854980 printStringBase: 36) = '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (-106300512100105327644605138221229898724869759421181854980 radix: 36) = '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -106300512100105327644605138221229898724869759421181854980 printStringHex = '-455D441E55A37239AB4C303189576071AF5578FFCA80504'.	self assert: (-106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) = '-36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: -106300512100105327644605138221229898724869759421181854980 storeStringHex = '-16r455D441E55A37239AB4C303189576071AF5578FFCA80504'.! !!IntegerTest methodsFor: 'tests - printing' stamp: 'nice 2/15/2008 22:23'!testNumberOfDigits		2 to: 32 do: [:b |		1 to: 1000//b do: [:n |			| bRaisedToN |			bRaisedToN := b raisedTo: n.			self assert: (bRaisedToN - 1 numberOfDigitsInBase: b) = n.			self assert: (bRaisedToN numberOfDigitsInBase: b) = (n+1).			self assert: (bRaisedToN + 1 numberOfDigitsInBase: b) = (n+1).						self assert: (bRaisedToN negated + 1 numberOfDigitsInBase: b) = n.			self assert: (bRaisedToN negated numberOfDigitsInBase: b) = (n+1).			self assert: (bRaisedToN negated - 1 numberOfDigitsInBase: b) = (n+1).]].! !!IntegerTest methodsFor: 'tests - printing' stamp: 'laza 3/30/2004 11:52'!testPositiveIntegerPrinting	"self run: #testPositiveIntegerPrinting"	self assert: 0 printString = '0'.	self assert: 0 printStringHex = '0'.	self assert: 0 storeStringHex = '16r0'.	self assert: (2 printStringBase: 2) = '10'.	self assert: (2 radix: 2) = '10'.	self assert: 2 printStringHex = '2'.	self assert: (2 storeStringBase: 2) = '2r10'.	self assert: 2 storeStringHex = '16r2'.	self assert: (21 printStringBase: 3) = '210'.	self assert: (21 radix: 3) = '210'.	self assert: 21 printStringHex = '15'.	self assert: (21 storeStringBase: 3) = '3r210'.	self assert: 21 storeStringHex = '16r15'.	self assert: (228 printStringBase: 4) = '3210'.	self assert: (228 radix: 4) = '3210'.	self assert: 228 printStringHex = 'E4'.	self assert: (228 storeStringBase: 4) = '4r3210'.	self assert: 228 storeStringHex = '16rE4'.	self assert: (2930 printStringBase: 5) = '43210'.	self assert: (2930 radix: 5) = '43210'.	self assert: 2930 printStringHex = 'B72'.	self assert: (2930 storeStringBase: 5) = '5r43210'.	self assert: 2930 storeStringHex = '16rB72'.	self assert: (44790 printStringBase: 6) = '543210'.	self assert: (44790 radix: 6) = '543210'.	self assert: 44790 printStringHex = 'AEF6'.	self assert: (44790 storeStringBase: 6) = '6r543210'.	self assert: 44790 storeStringHex = '16rAEF6'.	self assert: (800667 printStringBase: 7) = '6543210'.	self assert: (800667 radix: 7) = '6543210'.	self assert: 800667 printStringHex = 'C379B'.	self assert: (800667 storeStringBase: 7) = '7r6543210'.	self assert: 800667 storeStringHex = '16rC379B'.	self assert: (16434824 printStringBase: 8) = '76543210'.	self assert: (16434824 radix: 8) = '76543210'.	self assert: 16434824 printStringHex = 'FAC688'.	self assert: (16434824 storeStringBase: 8) = '8r76543210'.	self assert: 16434824 storeStringHex = '16rFAC688'.	self assert: (381367044 printStringBase: 9) = '876543210'.	self assert: (381367044 radix: 9) = '876543210'.	self assert: 381367044 printStringHex = '16BB3304'.	self assert: (381367044 storeStringBase: 9) = '9r876543210'.	self assert: 381367044 storeStringHex = '16r16BB3304'.	self assert: (9876543210 printStringBase: 10) = '9876543210'.	self assert: (9876543210 radix: 10) = '9876543210'.	self assert: 9876543210 printStringHex = '24CB016EA'.	self assert: (9876543210 storeStringBase: 10) = '9876543210'.	self assert: 9876543210 storeStringHex = '16r24CB016EA'.	self assert: (282458553905 printStringBase: 11) = 'A9876543210'.	self assert: (282458553905 radix: 11) = 'A9876543210'.	self assert: 282458553905 printStringHex = '41C3D77E31'.	self assert: (282458553905 storeStringBase: 11) = '11rA9876543210'.	self assert: 282458553905 storeStringHex = '16r41C3D77E31'.	self assert: (8842413667692 printStringBase: 12) = 'BA9876543210'.	self assert: (8842413667692 radix: 12) = 'BA9876543210'.	self assert: 8842413667692 printStringHex = '80AC8ECF56C'.	self assert: (8842413667692 storeStringBase: 12) = '12rBA9876543210'.	self assert: 8842413667692 storeStringHex = '16r80AC8ECF56C'.	self assert: (300771807240918 printStringBase: 13) = 'CBA9876543210'.	self assert: (300771807240918 radix: 13) = 'CBA9876543210'.	self assert: 300771807240918 printStringHex = '1118CE4BAA2D6'.	self assert: (300771807240918 storeStringBase: 13) = '13rCBA9876543210'.	self assert: 300771807240918 storeStringHex = '16r1118CE4BAA2D6'.	self assert: (11046255305880158 printStringBase: 14) = 'DCBA9876543210'.	self assert: (11046255305880158 radix: 14) = 'DCBA9876543210'.	self assert: 11046255305880158 printStringHex = '273E82BB9AF25E'.	self assert: (11046255305880158 storeStringBase: 14) = '14rDCBA9876543210'.	self assert: 11046255305880158 storeStringHex = '16r273E82BB9AF25E'.	self assert: (435659737878916215 printStringBase: 15) = 'EDCBA9876543210'.	self assert: (435659737878916215 radix: 15) = 'EDCBA9876543210'.	self assert: 435659737878916215 printStringHex = '60BC6392F366C77'.	self assert: (435659737878916215 storeStringBase: 15) = '15rEDCBA9876543210'.	self assert: 435659737878916215 storeStringHex = '16r60BC6392F366C77'.	self assert: (18364758544493064720 printStringBase: 16) = 'FEDCBA9876543210'.	self assert: (18364758544493064720 radix: 16) = 'FEDCBA9876543210'.	self assert: 18364758544493064720 printStringHex = 'FEDCBA9876543210'.	self assert: (18364758544493064720 storeStringBase: 16) = '16rFEDCBA9876543210'.	self assert: 18364758544493064720 storeStringHex = '16rFEDCBA9876543210'.	self assert: (824008854613343261192 printStringBase: 17) = 'GFEDCBA9876543210'.	self assert: (824008854613343261192 radix: 17) = 'GFEDCBA9876543210'.	self assert: 824008854613343261192 printStringHex = '2CAB6B877C1CD2D208'.	self assert: (824008854613343261192 storeStringBase: 17) = '17rGFEDCBA9876543210'.	self assert: 824008854613343261192 storeStringHex = '16r2CAB6B877C1CD2D208'.	self assert: (39210261334551566857170 printStringBase: 18) = 'HGFEDCBA9876543210'.	self assert: (39210261334551566857170 radix: 18) = 'HGFEDCBA9876543210'.	self assert: 39210261334551566857170 printStringHex = '84D97AFCAE81415B3D2'.	self assert: (39210261334551566857170 storeStringBase: 18) = '18rHGFEDCBA9876543210'.	self assert: 39210261334551566857170 storeStringHex = '16r84D97AFCAE81415B3D2'.	self assert: (1972313422155189164466189 printStringBase: 19) = 'IHGFEDCBA9876543210'.	self assert: (1972313422155189164466189 radix: 19) = 'IHGFEDCBA9876543210'.	self assert: 1972313422155189164466189 printStringHex = '1A1A75329C5C6FC00600D'.	self assert: (1972313422155189164466189 storeStringBase: 19) = '19rIHGFEDCBA9876543210'.	self assert: 1972313422155189164466189 storeStringHex = '16r1A1A75329C5C6FC00600D'.	self assert: (104567135734072022160664820 printStringBase: 20) = 'JIHGFEDCBA9876543210'.	self assert: (104567135734072022160664820 radix: 20) = 'JIHGFEDCBA9876543210'.	self assert: 104567135734072022160664820 printStringHex = '567EF3C9636D242A8C68F4'.	self assert: (104567135734072022160664820 storeStringBase: 20) = '20rJIHGFEDCBA9876543210'.	self assert: 104567135734072022160664820 storeStringHex = '16r567EF3C9636D242A8C68F4'.	self assert: (5827980550840017565077671610 printStringBase: 21) = 'KJIHGFEDCBA9876543210'.	self assert: (5827980550840017565077671610 radix: 21) = 'KJIHGFEDCBA9876543210'.	self assert: 5827980550840017565077671610 printStringHex = '12D4CAE2B8A09BCFDBE30EBA'.	self assert: (5827980550840017565077671610 storeStringBase: 21) = '21rKJIHGFEDCBA9876543210'.	self assert: 5827980550840017565077671610 storeStringHex = '16r12D4CAE2B8A09BCFDBE30EBA'.	self assert: (340653664490377789692799452102 printStringBase: 22) = 'LKJIHGFEDCBA9876543210'.	self assert: (340653664490377789692799452102 radix: 22) = 'LKJIHGFEDCBA9876543210'.	self assert: 340653664490377789692799452102 printStringHex = '44CB61B5B47E1A5D8F88583C6'.	self assert: (340653664490377789692799452102 storeStringBase: 22) = '22rLKJIHGFEDCBA9876543210'.	self assert: 340653664490377789692799452102 storeStringHex = '16r44CB61B5B47E1A5D8F88583C6'.	self assert: (20837326537038308910317109288851 printStringBase: 23) = 'MLKJIHGFEDCBA9876543210'.	self assert: (20837326537038308910317109288851 radix: 23) = 'MLKJIHGFEDCBA9876543210'.	self assert: 20837326537038308910317109288851 printStringHex = '1070108876456E0EF115B389F93'.	self assert: (20837326537038308910317109288851 storeStringBase: 23) = '23rMLKJIHGFEDCBA9876543210'.	self assert: 20837326537038308910317109288851 storeStringHex = '16r1070108876456E0EF115B389F93'.	self assert: (1331214537196502869015340298036888 printStringBase: 24) = 'NMLKJIHGFEDCBA9876543210'.	self assert: (1331214537196502869015340298036888 radix: 24) = 'NMLKJIHGFEDCBA9876543210'.	self assert: 1331214537196502869015340298036888 printStringHex = '41A24A285154B026B6ED206C6698'.	self assert: (1331214537196502869015340298036888 storeStringBase: 24) = '24rNMLKJIHGFEDCBA9876543210'.	self assert: 1331214537196502869015340298036888 storeStringHex = '16r41A24A285154B026B6ED206C6698'.	self assert: (88663644327703473714387251271141900 printStringBase: 25) = 'ONMLKJIHGFEDCBA9876543210'.	self assert: (88663644327703473714387251271141900 radix: 25) = 'ONMLKJIHGFEDCBA9876543210'.	self assert: 88663644327703473714387251271141900 printStringHex = '111374860A2C6CEBE5999630398A0C'.	self assert: (88663644327703473714387251271141900 storeStringBase: 25) = '25rONMLKJIHGFEDCBA9876543210'.	self assert: 88663644327703473714387251271141900 storeStringHex = '16r111374860A2C6CEBE5999630398A0C'.	self assert: (6146269788878825859099399609538763450 printStringBase: 26) = 'PONMLKJIHGFEDCBA9876543210'.	self assert: (6146269788878825859099399609538763450 radix: 26) = 'PONMLKJIHGFEDCBA9876543210'.	self assert: 6146269788878825859099399609538763450 printStringHex = '49FBA7F30B0F48BD14E6A99BD8ADABA'.	self assert: (6146269788878825859099399609538763450 storeStringBase: 26) = '26rPONMLKJIHGFEDCBA9876543210'.	self assert: 6146269788878825859099399609538763450 storeStringHex = '16r49FBA7F30B0F48BD14E6A99BD8ADABA'.	self assert: (442770531899482980347734468443677777577 printStringBase: 27) = 'QPONMLKJIHGFEDCBA9876543210'.	self assert: (442770531899482980347734468443677777577 radix: 27) = 'QPONMLKJIHGFEDCBA9876543210'.	self assert: 442770531899482980347734468443677777577 printStringHex = '14D1A80A997343640C1145A073731DEA9'.	self assert: (442770531899482980347734468443677777577 storeStringBase: 27) = '27rQPONMLKJIHGFEDCBA9876543210'.	self assert: 442770531899482980347734468443677777577 storeStringHex = '16r14D1A80A997343640C1145A073731DEA9'.	self assert: (33100056003358651440264672384704297711484 printStringBase: 28) = 'RQPONMLKJIHGFEDCBA9876543210'.	self assert: (33100056003358651440264672384704297711484 radix: 28) = 'RQPONMLKJIHGFEDCBA9876543210'.	self assert: 33100056003358651440264672384704297711484 printStringHex = '6145B6E6DACFA25D0E936F51D25932377C'.	self assert: (33100056003358651440264672384704297711484 storeStringBase: 28) = '28rRQPONMLKJIHGFEDCBA9876543210'.	self assert: 33100056003358651440264672384704297711484 storeStringHex = '16r6145B6E6DACFA25D0E936F51D25932377C'.	self assert: (2564411043271974895869785066497940850811934 printStringBase: 29) = 'SRQPONMLKJIHGFEDCBA9876543210'.	self assert: (2564411043271974895869785066497940850811934 radix: 29) = 'SRQPONMLKJIHGFEDCBA9876543210'.	self assert: 2564411043271974895869785066497940850811934 printStringHex = '1D702071CBA4A1597D4DD37E95EFAC79241E'.	self assert: (2564411043271974895869785066497940850811934 storeStringBase: 29) = '29rSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 2564411043271974895869785066497940850811934 storeStringHex = '16r1D702071CBA4A1597D4DD37E95EFAC79241E'.	self assert: (205646315052919334126040428061831153388822830 printStringBase: 30) = 'TSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (205646315052919334126040428061831153388822830 radix: 30) = 'TSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 205646315052919334126040428061831153388822830 printStringHex = '938B4343B54B550989989D02998718FFB212E'.	self assert: (205646315052919334126040428061831153388822830 storeStringBase: 30) = '30rTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 205646315052919334126040428061831153388822830 storeStringHex = '16r938B4343B54B550989989D02998718FFB212E'.	self assert: (17050208381689099029767742314582582184093573615 printStringBase: 31) = 'UTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (17050208381689099029767742314582582184093573615 radix: 31) = 'UTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 17050208381689099029767742314582582184093573615 printStringHex = '2FC8ECB1521BA16D24A69E976D53873E2C661EF'.	self assert: (17050208381689099029767742314582582184093573615 storeStringBase: 31) = '31rUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 17050208381689099029767742314582582184093573615 storeStringHex = '16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.	self assert: (1459980823972598128486511383358617792788444579872 printStringBase: 32) = 'VUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (1459980823972598128486511383358617792788444579872 radix: 32) = 'VUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 1459980823972598128486511383358617792788444579872 printStringHex = 'FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.	self assert: (1459980823972598128486511383358617792788444579872 storeStringBase: 32) = '32rVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 1459980823972598128486511383358617792788444579872 storeStringHex = '16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.	self assert: (128983956064237823710866404905431464703849549412368 printStringBase: 33) = 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (128983956064237823710866404905431464703849549412368 radix: 33) = 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 128983956064237823710866404905431464703849549412368 printStringHex = '584120A0328DE272AB055A8AA003CE4A559F223810'.	self assert: (128983956064237823710866404905431464703849549412368 storeStringBase: 33) = '33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 128983956064237823710866404905431464703849549412368 storeStringHex = '16r584120A0328DE272AB055A8AA003CE4A559F223810'.	self assert: (11745843093701610854378775891116314824081102660800418 printStringBase: 34) = 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (11745843093701610854378775891116314824081102660800418 radix: 34) = 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 11745843093701610854378775891116314824081102660800418 printStringHex = '1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.	self assert: (11745843093701610854378775891116314824081102660800418 storeStringBase: 34) = '34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 11745843093701610854378775891116314824081102660800418 storeStringHex = '16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.	self assert: (1101553773143634726491620528194292510495517905608180485 printStringBase: 35) = 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (1101553773143634726491620528194292510495517905608180485 radix: 35) = 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 1101553773143634726491620528194292510495517905608180485 printStringHex = 'B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.	self assert: (1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) = '35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 1101553773143634726491620528194292510495517905608180485 storeStringHex = '16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.	self assert: (106300512100105327644605138221229898724869759421181854980 printStringBase: 36) = 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: (106300512100105327644605138221229898724869759421181854980 radix: 36) = 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 106300512100105327644605138221229898724869759421181854980 printStringHex = '455D441E55A37239AB4C303189576071AF5578FFCA80504'.	self assert: (106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) = '36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.	self assert: 106300512100105327644605138221229898724869759421181854980 storeStringHex = '16r455D441E55A37239AB4C303189576071AF5578FFCA80504'.! !!IntegerTest methodsFor: 'tests - printing' stamp: 'fbs 2/9/2006 08:48'!testPrintOnBaseShowRadix	| s |	s := ReadWriteStream on: ''.	123 printOn: s base: 10 showRadix: false.	self assert: (s contents = '123').		s := ReadWriteStream on: ''.	123 printOn: s base: 10 showRadix: true.	self assert: (s contents = '10r123').		s := ReadWriteStream on: ''.	123 printOn: s base: 8 showRadix: false.	self assert: (s contents = '173').		s := ReadWriteStream on: ''.	123 printOn: s base: 8 showRadix: true.	self assert: (s contents = '8r173').! !!IntegerTest methodsFor: 'tests - printing' stamp: 'nice 2/15/2008 22:31'!testPrintStringBase		2 to: 32 do: [:b |		1 to: 1000//b do: [:n |			| bRaisedToN |			bRaisedToN := b raisedTo: n.			self assert: (bRaisedToN - 1 printStringBase: b) = (String new: n withAll: (Character digitValue: b-1)).			self assert: (bRaisedToN printStringBase: b) = ('1' , (String new: n withAll: $0)).						self assert: (bRaisedToN negated + 1 printStringBase: b) = ('-' , (String new: n withAll: (Character digitValue: b-1))).			self assert: (bRaisedToN negated printStringBase: b) = ('-1' , (String new: n withAll: $0))]].! !!IntegerTest methodsFor: 'tests - printing' stamp: 'laza 3/30/2004 09:23'!testRomanPrinting	self assert: 0 printStringRoman = ''. "No symbol for zero"	self assert: 1 printStringRoman = 'I'.	self assert: 2 printStringRoman = 'II'.	self assert: 3 printStringRoman = 'III'.	self assert: 4 printStringRoman = 'IV'.	self assert: 5 printStringRoman = 'V'.	self assert: 6 printStringRoman = 'VI'.	self assert: 7 printStringRoman = 'VII'.	self assert: 8 printStringRoman = 'VIII'.	self assert: 9 printStringRoman = 'IX'.	self assert: 10 printStringRoman = 'X'.	self assert: 23 printStringRoman = 'XXIII'.	self assert: 36 printStringRoman = 'XXXVI'.	self assert: 49 printStringRoman = 'XLIX'.	self assert: 62 printStringRoman = 'LXII'.	self assert: 75 printStringRoman = 'LXXV'.	self assert: 88 printStringRoman = 'LXXXVIII'.	self assert: 99 printStringRoman = 'XCIX'.	self assert: 100 printStringRoman = 'C'.	self assert: 101 printStringRoman = 'CI'.	self assert: 196 printStringRoman = 'CXCVI'.	self assert: 197 printStringRoman = 'CXCVII'.	self assert: 198 printStringRoman = 'CXCVIII'.	self assert: 293 printStringRoman = 'CCXCIII'.	self assert: 294 printStringRoman = 'CCXCIV'.	self assert: 295 printStringRoman = 'CCXCV'.	self assert: 390 printStringRoman = 'CCCXC'.	self assert: 391 printStringRoman = 'CCCXCI'.	self assert: 392 printStringRoman = 'CCCXCII'.	self assert: 487 printStringRoman = 'CDLXXXVII'.	self assert: 488 printStringRoman = 'CDLXXXVIII'.	self assert: 489 printStringRoman = 'CDLXXXIX'.	self assert: 584 printStringRoman = 'DLXXXIV'.	self assert: 585 printStringRoman = 'DLXXXV'.	self assert: 586 printStringRoman = 'DLXXXVI'.	self assert: 681 printStringRoman = 'DCLXXXI'.	self assert: 682 printStringRoman = 'DCLXXXII'.	self assert: 683 printStringRoman = 'DCLXXXIII'.	self assert: 778 printStringRoman = 'DCCLXXVIII'.	self assert: 779 printStringRoman = 'DCCLXXIX'.	self assert: 780 printStringRoman = 'DCCLXXX'.	self assert: 875 printStringRoman = 'DCCCLXXV'.	self assert: 876 printStringRoman = 'DCCCLXXVI'.	self assert: 877 printStringRoman = 'DCCCLXXVII'.	self assert: 972 printStringRoman = 'CMLXXII'.	self assert: 973 printStringRoman = 'CMLXXIII'.	self assert: 974 printStringRoman = 'CMLXXIV'.	self assert: 1069 printStringRoman = 'MLXIX'.	self assert: 1070 printStringRoman = 'MLXX'.	self assert: 1071 printStringRoman = 'MLXXI'.	self assert: 1166 printStringRoman = 'MCLXVI'.	self assert: 1167 printStringRoman = 'MCLXVII'.	self assert: 1168 printStringRoman = 'MCLXVIII'.	self assert: 1263 printStringRoman = 'MCCLXIII'.	self assert: 1264 printStringRoman = 'MCCLXIV'.	self assert: 1265 printStringRoman = 'MCCLXV'.	self assert: 1360 printStringRoman = 'MCCCLX'.	self assert: 1361 printStringRoman = 'MCCCLXI'.	self assert: 1362 printStringRoman = 'MCCCLXII'.	self assert: 1457 printStringRoman = 'MCDLVII'.	self assert: 1458 printStringRoman = 'MCDLVIII'.	self assert: 1459 printStringRoman = 'MCDLIX'.	self assert: 1554 printStringRoman = 'MDLIV'.	self assert: 1555 printStringRoman = 'MDLV'.	self assert: 1556 printStringRoman = 'MDLVI'.	self assert: 1651 printStringRoman = 'MDCLI'.	self assert: 1652 printStringRoman = 'MDCLII'.	self assert: 1653 printStringRoman = 'MDCLIII'.	self assert: 1748 printStringRoman = 'MDCCXLVIII'.	self assert: 1749 printStringRoman = 'MDCCXLIX'.	self assert: 1750 printStringRoman = 'MDCCL'.	self assert: 1845 printStringRoman = 'MDCCCXLV'.	self assert: 1846 printStringRoman = 'MDCCCXLVI'.	self assert: 1847 printStringRoman = 'MDCCCXLVII'.	self assert: 1942 printStringRoman = 'MCMXLII'.	self assert: 1943 printStringRoman = 'MCMXLIII'.	self assert: 1944 printStringRoman = 'MCMXLIV'.	self assert: 2004 printStringRoman = 'MMIV'.	self assert: -1 printStringRoman = '-I'.	self assert: -2 printStringRoman = '-II'.	self assert: -3 printStringRoman = '-III'.	self assert: -4 printStringRoman = '-IV'.	self assert: -5 printStringRoman = '-V'.	self assert: -6 printStringRoman = '-VI'.	self assert: -7 printStringRoman = '-VII'.	self assert: -8 printStringRoman = '-VIII'.	self assert: -9 printStringRoman = '-IX'.	self assert: -10 printStringRoman = '-X'.! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'ul 11/25/2009 03:01'!testSqrtFloor	#(-1234567890123 -10 -5 -1) do: [ :each |		self should: [ each sqrtFloor ] raise: Error ].	#(		0 1 2 3 4 5 10 16 30 160479924 386234481 501619156 524723498 580855366 766098594 834165249 1020363860 1042083924 1049218924		1459774772895569 3050005981408238 4856589481837079 5650488387708463 7831037396100244) do: [ :each |			self assert: each asFloat sqrt floor = each sqrtFloor ]		! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:23'!testAdd	self assert: (1 to: 10)			+ 5			= (6 to: 15)! !!IntervalTest methodsFor: 'tests' stamp: 'nice 2/9/2010 20:44'!testAnyOne	self assert: ((2 to: 5) includes: (2 to: 5) anyOne).	self should: [(2 to: 1) anyOne] raise: Error description: 'This interval is empty'! !!IntervalTest methodsFor: 'tests' stamp: 'nice 1/18/2010 18:07'!testAsInterval	"This is the same as newFrom:"	self shouldnt: [		self assert: (#(1 2 3) as: Interval) = (1 to: 3).		self assert: (#(33 5 -23) as: Interval) = (33 to: -23 by: -28).		self assert: (#[2 4 6] as: Interval) = (2 to: 6 by: 2).	] raise: Error.	self should: [#(33 5 -22) as: Interval]		raise: Error		description: 'This is not an arithmetic progression'! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:15'!testAt	self assert: ((1 to: 10)			at: 1)			= 1.	self assert: ((1 to: 10)			at: 3)			= 3.	self assert: ((1 to: 10 by: 2)			at: 1)			= 1.	self assert: ((1 to: 10 by: 2)			at: 3)			= 5! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:34'!testDo	| s i |	s := OrderedCollection new.	i := (10 to: 20).	i do: [ :each | s addLast: each].	self assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:13'!testEquals	self shouldnt: [		self assert: (3 to: 5) = #(3 4 5).		self deny: (3 to: 5) = #(3 5).		self deny: (3 to: 5) = #().		self assert: #(3 4 5) = (3 to: 5).		self deny: #(3 5) = (3 to: 5).		self deny: #() = (3 to: 5).	] raise: MessageNotUnderstood.! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:13'!testEquals2	self assert: (3 to: 5) = #(3 4 5).	self deny: (3 to: 5) = #(3 5).	self deny: (3 to: 5) = #().	self assert: #(3 4 5) = (3 to: 5).	self deny: #(3 5) = (3 to: 5).	self deny: #() = (3 to: 5).! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:13'!testEquals3	self assert: (3 to: 5 by: 2) first = (3 to: 6 by: 2) first.	self assert: (3 to: 5 by: 2) last = (3 to: 6 by: 2) last.	self assert: (3 to: 5 by: 2) = (3 to: 6 by: 2).! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:13'!testEquals4	self assert: (3 to: 5 by: 2) = #(3 5).	self deny: (3 to: 5 by: 2) = #(3 4 5).	self deny: (3 to: 5 by: 2) = #().	self assert: #(3 5) = (3 to: 5 by: 2).	self deny: #(3 4 5) = (3 to: 5 by: 2).	self deny: #() = (3 to: 5 by: 2).! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:14'!testEquals5	self assert: (3 to: 5 by: 2) = (Heap withAll: #(3 5)).	self deny: (3 to: 5 by: 2) = (Heap withAll: #(3 4 5)).	self deny: (3 to: 5 by: 2) = Heap new.	self assert: (Heap withAll: #(3 5)) = (3 to: 5 by: 2).	self deny: (Heap withAll: #(3 4 5)) = (3 to: 5 by: 2).	self deny: Heap new = (3 to: 5 by: 2).! !!IntervalTest methodsFor: 'tests' stamp: 'md 10/12/2003 20:14'!testEquals6	self assert: #() = Heap new.	self assert: #(3 5) = (Heap withAll: #(3 5)).	self deny: (3 to: 5 by: 2) = (Heap withAll: #(3 4 5)).	self deny: (3 to: 5 by: 2) = Heap new.	self assert: Heap new = #().	self assert: (Heap withAll: #(3 5)) = #(3 5).	self deny: (Heap withAll: #(3 4 5)) = #(3 5).	self deny: Heap new = #(3 5).! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:08'!testExtent	self assert: (1 to: 10) extent = 9.	self assert: (1 to: 10 by: 2) extent = 9.	self assert: (1 to:-1) extent = -2! !!IntervalTest methodsFor: 'tests' stamp: 'nice 12/22/2009 16:06'!testInclusion	"Non regression test for another bug of fuzzy inclusion"		self deny: ((1.0 to: 3.0 by: 1.0 successor) includes: 3.0) description: 'The last element of this Interval is closed to 2'! !!IntervalTest methodsFor: 'tests' stamp: 'nice 4/29/2007 21:34'!testInclusionBug1603	"This test is by german morales.	It is about mantis bug 1603"		self shouldnt: ((1 to: 5 by: 1) includes: 2.5). "obvious"	self shouldnt: ((100000000000000 to: 500000000000000 by: 100000000000000) 		  includes: 250000000000000). "same as above with 14 zeros appended"! !!IntervalTest methodsFor: 'tests' stamp: 'nice 2/3/2008 21:43'!testInclusionBug6455	"This test is about mantis bug http://bugs.squeak.org/view.php?id=6455	It should work as long as Fuzzy inclusion test feature for Interval of Float is maintained.	This is a case when tested element is near ones of actual value, but by default.	Code used to work only in the case of close numbers by excess..."		self assert: ((0 to: Float pi by: Float pi / 100) includes: Float pi * (3/100))! !!IntervalTest methodsFor: 'tests' stamp: 'nice 4/29/2007 21:35'!testIndexOfBug1602	"This test is by german morales.	It is about mantis bug 1602"		self should: ((1 to: 5 by: 1) indexOf: 2.5) = 0. "obvious"	self should: ((100000000000000 to: 500000000000000 by: 100000000000000) 		  indexOf: 250000000000000) = 0. "same as above with 14 zeros appended"! !!IntervalTest methodsFor: 'tests' stamp: 'nice 2/3/2008 21:35'!testIndexOfBug6455	"This test is about mantis bug http://bugs.squeak.org/view.php?id=6455	It should work as long as Fuzzy inclusion test feature for Interval of Float is maintained.	This is a case when tested element is near ones of actual value, but by default.	Code used to work only in the case of close numbers by excess..."		self assert: ((0 to: Float pi by: Float pi / 100) indexOf: Float pi * (3/100)) = 4! !!IntervalTest methodsFor: 'tests' stamp: 'nice 12/22/2009 16:19'!testInfiniteLoopBug6456	"This is a non regression test against mantis bug #6456.	Some Float interval size was not consistent with do: loop.	Some Float Interval used to do: infinite loops"		| x interval counter size |	x := (1.0 timesTwoPower: Float precision). "Note: x+1 = x due to inexact arithmetic"	interval := x to: x+4.	size := interval size.	counter := 0.	interval do: [:each | self assert: (counter := counter + 1) <= size].! !!IntervalTest methodsFor: 'tests' stamp: 'nice 5/12/2007 00:53'!testIntervalStoreOn	"this is a test for http://bugs.squeak.org/view.php?id=4378"		| interval1 interval2 |	interval1 := 0 to: 1 by: 0.5s1 squared.	interval2 := Compiler evaluate: interval1 storeString.	self assert: interval1 size = interval2 size! !!IntervalTest methodsFor: 'tests'!testInvalid	"empty, impossible ranges"	self assert: (1 to: 0) = #().	self assert: (1 to: -1) = #().	self assert: (-1 to: -2) = #().	self assert: (1 to: 5 by: -1) = #().		"always contains only start value."	self assert: (1 to: 1) = #(1).	self assert: (1 to: 5 by: 10) = #(1).	self assert: (1 to: 0 by: -2) = #(1).! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/7/2005 13:29'!testIsInterval	self assert: (1 to: 10) isInterval.	self assert: (1 to: 10 by: 2) isInterval! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/7/2005 13:29'!testLastself assert: (1 to:10) last = 10.self assert: (1 to:10 by:2) last = 9 ! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:28'!testMinus	self assert: (1 to: 10)			- 5			= (-4 to: 5)! !!IntervalTest methodsFor: 'tests' stamp: 'md 1/14/2004 11:43'!testNewFrom	self shouldnt: [		 self assert: ( (Interval newFrom: (1 to: 1)) = (1 to: 1)).		 self assert: ( (Interval newFrom: #(1)) = (1 to: 1)).		 self assert: ( (Interval newFrom: #()) =  ( 1 to: 0)) .	] raise: Error.! !!IntervalTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:17'!testNumericTypes	(3 asNumber) to: 5 = #(3 4 5).		3.0 to: 5.0 = #(3.0 4.0 5.0).	3.0 to: 5.0 by: 0.5 = #(3.0 3.5 4.0 4.5 5.0).		3/1 to: 5/1 = #(3 4 5).	1/2 to: 5/2 by: 1/2 = #(1/2 1 3/2 2 5/2).! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:03'!testOtherNewFrom	self assert: (Interval newFrom: #(1 2 3 )) = (1 to: 3).	self assert: (Interval newFrom: #(33  5 -23 )) = (33 to: -23 by: -28).	self should: [(Interval newFrom: #(33  5 -22 ))] raise: Error.	self assert: (#(33  5 -23) as: Interval) = (33 to: -23 by: -28).	self should: [( #(33  5 -22 ) as: Interval)] raise: Error.		self assert: ( (-4 to: -12 by: -1) as: Interval) = (-4 to: -12 by: -1).	self assert: ( Interval newFrom: (1 to: 1)) = (1 to: 1).	self assert: ( Interval newFrom: (1 to: 0)) = (1 to: 0).	self assert: (#(1) as: Interval) = (1 to: 1).	self assert: (#() as: Interval) = (1 to: 0).! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:03'!testPermutationsDo	| i oc |	i := (1.234 to: 4.234).	oc := OrderedCollection new.	i permutationsDo: [:e | oc add: e].	self assert: (oc size == i size factorial).	^ oc! !!IntervalTest methodsFor: 'tests' stamp: 'zz 12/5/2005 18:20'!testRangeIncludes	self		assert: ((1 to: 10)				rangeIncludes: 3).	self		assert: ((1 to: 10 by: 2)				rangeIncludes: 3).	self		deny: ((1 to: 10)				rangeIncludes: 0).	self		deny: ((1 to: 10)				rangeIncludes: 11).	self		deny: ((1 to: 10 by: 2)				rangeIncludes: 0).	self		deny: ((1 to: 10 by: 2)				rangeIncludes: 11)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:35'!testReverseDo	| s i |	s := OrderedCollection new.	i := 10 to: 20.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:36'!testReverseUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:39'!testUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		do: [:each | s addLast: each].	self		assert: (s hasEqualElements: i)! !!InvalidDirectoryError methodsFor: 'accessing' stamp: 'ar 6/12/2007 12:55'!messageText	"Answer the message text for this exception"	^messageText ifNil:[pathName]! !!InvalidPort commentStamp: '<historical>' prior: 0!Error which occurs when the user request an operation on an invalid port (eg: attempting to listen to port 80 without root/admin privileges).!!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:16'!aaaREADMEaboutPrimitives	"most of the Islands tweaks allow primitive methods to be located in places other than class Object.  Thus they are copied here for testing."! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:17'!classOf: anObject	<primitive: 111>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:16'!instVarOf: anObject at: index	<primitive: 73>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:17'!instVarOf: anObject at: index put: anotherObject	<primitive: 74>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:18'!nextInstanceAfter: anObject	<primitive: 78>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:18'!nextObjectAfter: anObject	<primitive: 139>! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:21'!replaceIn: replacee  from: start  to: stop   with: replacer  startingAt: replStart	<primitive: 105>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:19'!someInstanceOf: aClass	<primitive: 77>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'primitives' stamp: 'ls 7/10/2003 10:20'!someObject	<primitive: 138>	self primitiveFailed! !!IslandVMTweaksTestCase methodsFor: 'miscellaneous' stamp: 'ls 7/10/2003 17:42'!returnTwelve	"this method is tweaked by testFlagInCompiledMethod"	^12! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 11:03'!testEmptyReplace	| array1 array2 |	array1 := Array with: 1 with: 2 with: 3 with: 4.	array2 := Array with: 5 with: 6 with: 7.	self replaceIn: array1 from: 1 to: 0 with: array2 startingAt: 1.	self should: [ array1 = #(1 2 3 4) ].! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 18:53'!testFlagInCompiledMethod	"this tests that the flag in compiled methods is treated correctly"	| method |	method := self class compiledMethodAt: #returnTwelve.	"turn off the flag"	method objectAt: 1 put: (method header bitAnd: (1 << 29) bitInvert).	self should: [ method flag not ].	"turn on the flag"	method objectAt: 1 put: (method header bitOr: (1 << 29)).	self should: [ method flag ].	"try running the method with the flag turned on"	self should: [ self returnTwelve = 12 ].	"make sure the flag bit isn't interpreted as a primitive"	self should: [ method primitive = 0 ].! !!IslandVMTweaksTestCase methodsFor: 'testing' stamp: 'ls 7/10/2003 10:38'!testForgivingPrims	| aPoint anotherPoint array1 array2 |	aPoint := Point x: 5 y: 6.	anotherPoint := Point x: 7 y: 8.  "make sure there are multiple points floating around"	anotherPoint.  "stop the compiler complaining about no uses"	self should: [ (self classOf:  aPoint) = Point ].	self should: [ (self instVarOf: aPoint at: 1) = 5 ].	self instVarOf: aPoint at: 2 put: 10.	self should: [ (self instVarOf: aPoint at: 2) = 10 ].	self someObject.	self nextObjectAfter: aPoint.	self should: [ (self someInstanceOf: Point) class = Point ].	self should: [ (self nextInstanceAfter: aPoint) class = Point ].	array1 := Array with: 1 with: 2 with: 3.	array2 := Array with: 4 with: 5 with: 6.	self replaceIn: array1 from: 2 to: 3 with: array2 startingAt: 1.	self should: [ array1 = #(1 4 5) ].! !!IslandVMTweaksTestCase commentStamp: 'ls 7/10/2003 18:59' prior: 0!Test case for some tweaks to the VM that Islands requires.  These tests are largely for documentation; with an un-tweaked VM, the tests mostly still succeed, albeit with possible memory corruption.!!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:49'!audioPlayerForChannel: anInteger	"Answer a streaming sound for playing the audio channel with the given index."	((anInteger >= 1) & (anInteger <= soundtrackOffsets size)) ifFalse: [^ nil].	^ StreamingMonoSound		onFileNamed: file fullName		headerStart: (soundtrackOffsets at: anInteger)! !!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/16/2001 17:03'!hasAudio	"Answer true if this movie has at least one sound track."	^ soundtrackOffsets size > 0! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/15/2001 08:02'!bytesForFrame: frameIndex	"Answer a ByteArray containing the encoded bytes for the frame with the given index. Answer nil if the index is out of range or if my file is not open."	frameIndex < 1 ifTrue: [^ nil].	frameIndex >= frameOffsets size ifTrue: [^ nil].	file ifNil: [^ nil].	file closed ifTrue: [file ensureOpen; binary].	file position: (frameOffsets at: frameIndex).	^ file next: (frameOffsets at: frameIndex + 1) - (frameOffsets at: frameIndex)! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/16/2001 17:01'!readHeader	"Read a JPEG movie header file."	"Details: The file structures is:		<header, including sequence frame offsets>		<sequence of JPEG compressed images>		<optional soundtracks>"	| tag w h frameOffsetCount soundtrackCount |	file position: 0.	tag := (file next: 10) asString.	tag = 'JPEG Movie' ifFalse: [self error: 'not a JPEG movie file'].	w := file uint16.	h := file uint16.	movieExtent := w @ h.	frameRate := file uint32 / 10000.0.	frameOffsetCount := file uint32.	frameOffsets := Array new: frameOffsetCount.	1 to: frameOffsetCount do: [:i | frameOffsets at: i put: file uint32].	soundtrackCount := file uint16.	soundtrackOffsets := Array new: soundtrackCount.	1 to: soundtrackCount do: [:i | soundtrackOffsets at: i put: file uint32].! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 12/13/2001 19:14'!soundtrackOffsets	"Answer the offsets for my soundtracks."	^ soundtrackOffsets! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/27/2001 10:23'!testPlay	"Performance benchmark. Decompress and display all my frames. Answer the frame rate achieved in frames/second. No sound is played."	| frameForm frameCount t |	frameForm := Form extent: movieExtent depth: (Display depth max: 16).	frameCount := self videoFrames: 0.	self videoSetFrame: 1 stream: 0.	t := [		frameCount timesRepeat: [			self videoReadFrameInto: frameForm stream: 0.			frameForm display].	] timeToRun.	^ ((1000.0 * frameCount) / t) roundTo: 0.01! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/14/2001 14:08'!closeFile	"Close my file stream."	file ifNotNil: [file close].! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/14/2001 14:13'!fileHandle	"Answer my file, or nil if the file is not open."	file ifNil: [^ nil].	file closed ifTrue: [^ nil].	^ file! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/15/2001 07:59'!fileName	"Answer the name of my file."	file ifNil: [^ ''].	^ file fullName! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 2/11/2002 13:09'!openFile: fileName	"For compatability with MPEGFile."	self openFileNamed: fileName.! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 2/11/2002 13:30'!openFileNamed: fileName	"Open the JPEG movie file with the given name."	file ifNotNil: [file finalize].	file := nil.	(FileDirectory default fileExists: fileName) ifFalse: [^ self].	file := (FileStream readOnlyFileNamed: fileName) binary.	self readHeader.	currentFrameIndex := 1.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/20/2001 16:08'!hasVideo	"Answer true if I have one or more frames."	^ frameOffsets size > 1  "note: the empty movie still has one frameOffset"! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:18'!videoDropFrames: skipCount stream: streamIndex	"Advance the index of the current frame by the given number of frames."	self videoSetFrame: currentFrameIndex + skipCount stream: streamIndex.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameHeight: ignored	"Answer the height of this movie."	^ movieExtent y! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:37'!videoFrameRate: ignored	"Answer the frame rate of this movie."	^ frameRate! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameWidth: ignored	"Answer the width of this movie."	^ movieExtent x! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:34'!videoFrames: ignored	"Answer the number of video frames in this movie."	^ (frameOffsets size - 1) max: 0! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:05'!videoGetFrame: ignored	"Answer the index of the current frame, or zero if the movie has no frames."	^ currentFrameIndex! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/20/2001 11:02'!videoReadFrameInto: aForm stream: aStream	"Read the next frame into the given 16-bit or 32-bit Form."	| compressedBytes |	compressedBytes := self bytesForFrame: currentFrameIndex.	compressedBytes ifNil: [^ self].	JPEGReadWriter2 new uncompress: compressedBytes into: aForm.	currentFrameIndex := (currentFrameIndex + 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:10'!videoSetFrame: newIndex stream: ignored	"Set the index of the current frame."	currentFrameIndex := (newIndex asInteger max: 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'initialization' stamp: 'jm 11/15/2001 08:13'!initialize	file := nil.	frameOffsets := #().	currentFrameIndex := 1.! !!JPEGMovieFile commentStamp: '<historical>' prior: 0!A JPEG movie file consists of a header followed by a sequence of JPEG-compressed images followed by one or more sound tracks. It responds to a subset of the protocol for MPEGFile so that a JPEG movie can be played by MPEGDisplayMorph as if it were an MPEG movie.!!JPEGMovieFile class methodsFor: 'movie soundtracks' stamp: 'jm 12/13/2001 21:03'!addSoundtrack: soundFileName toJPEGMovieNamed: jpegFileName compressionType: compressionTypeString	"Append the given audio file as a soundtrack the given JPEG movie using the given compression type ('none', 'adpcm3', 'adpcm4', 'adpcm5', 'mulaw', or 'gsm')."	"Note: While the Squeak JPEG movie format supports multiple soundtracks, the player currently plays only the first soundtrack."	| snd jpegFile outFile frameCount newFrameOffsets buf inFile newSoundtrackOffsets oldMovieName |	snd := StreamingMonoSound onFileNamed: soundFileName.	jpegFile := JPEGMovieFile new openFileNamed: jpegFileName.	outFile := (FileStream newFileNamed: 'movie.tmp') binary.	frameCount := jpegFile videoFrames: 0.	"write new header"	self		writeHeaderExtent: ((jpegFile videoFrameWidth: 0)@(jpegFile videoFrameHeight: 0))		frameRate: (jpegFile videoFrameRate: 0)		frameCount: frameCount		soundtrackCount: (jpegFile soundtrackOffsets size + 1)		on: outFile.	"copy frames to new file"	newFrameOffsets := Array new: frameCount + 1.	1 to: frameCount do: [:i |		newFrameOffsets at: i put: outFile position.		buf := jpegFile bytesForFrame: i.		outFile nextPutAll: buf].	newFrameOffsets at: frameCount + 1 put: outFile position.	"copy existing soundtracks, if any, to new file"	jpegFile soundtrackOffsets size > 0 ifTrue: [		inFile := jpegFile fileHandle.		inFile position: jpegFile soundtrackOffsets first.		buf := ByteArray new: 10000.		[inFile atEnd] whileFalse: [			buf := inFile next: buf size into: buf startingAt: 1.			outFile nextPutAll: buf]].	"adjust soundtrack offsets for header size increase and add new one:"	newSoundtrackOffsets := jpegFile soundtrackOffsets collect: [:n | n + 4].	newSoundtrackOffsets := newSoundtrackOffsets copyWith: outFile position.	snd storeSunAudioOn: outFile compressionType: compressionTypeString.	"update header:"	self updateFrameOffsets: newFrameOffsets on: outFile.	self updateSoundtrackOffsets: newSoundtrackOffsets frameOffsets: newFrameOffsets on: outFile.	"close files"	snd closeFile.	jpegFile closeFile.	outFile close.	"replace the old movie with the new version"	oldMovieName := (jpegFile fileName copyFrom: 1 to: (jpegFile fileName size - 4)), '.old'.	FileDirectory default deleteFileNamed: oldMovieName.	FileDirectory default rename: jpegFile fileName toBe: oldMovieName.	FileDirectory default rename: 'movie.tmp' toBe: jpegFile fileName.! !!JPEGMovieFile class methodsFor: 'movie soundtracks' stamp: 'jm 12/13/2001 21:03'!removeSoundtrackFromJPEGMovieNamed: jpegFileName	"Remove all soundtracks from the JPEG movie with the given name."	| jpegFile outFile frameCount newFrameOffsets buf oldMovieName |	jpegFile := JPEGMovieFile new openFileNamed: jpegFileName.	outFile := (FileStream newFileNamed: 'movie.tmp') binary.	frameCount := jpegFile videoFrames: 0.	"write new header"	self		writeHeaderExtent: ((jpegFile videoFrameWidth: 0)@(jpegFile videoFrameHeight: 0))		frameRate: (jpegFile videoFrameRate: 0)		frameCount: frameCount		soundtrackCount: 0		on: outFile.	"copy frames to new file"	newFrameOffsets := Array new: frameCount + 1.	1 to: frameCount do: [:i |		newFrameOffsets at: i put: outFile position.		buf := jpegFile bytesForFrame: i.		outFile nextPutAll: buf].	newFrameOffsets at: frameCount + 1 put: outFile position.	"update header:"	self updateFrameOffsets: newFrameOffsets on: outFile.	"close files"	jpegFile closeFile.	outFile close.	"replace the old movie with the new version"	oldMovieName := (jpegFile fileName copyFrom: 1 to: (jpegFile fileName size - 4)), '.old'.	FileDirectory default deleteFileNamed: oldMovieName.	FileDirectory default rename: jpegFile fileName toBe: oldMovieName.	FileDirectory default rename: 'movie.tmp' toBe: jpegFile fileName.! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 1/25/2002 20:46'!convertFromFolderOfFramesNamed: folderName toJPEGMovieNamed: jpegFileName frameRate: frameRate quality: quality	"Convert a folder of frames into a JPEG movie. The named folder is assumed to contain only image files, all of the same size, and whose alphabetical order (case-insensitive) is the sequence in which they will appear in in the movie. A useful convention is to make the image files end in zero-padded frame numbers, for example 'frame0001.bmp', 'frame0002.bmp', etc. The image files can be any format readable by Form>fromFileNamed:. The movie frame extent is taken from the first frame file."	| jpegFile dir fileNames frameCount frameForm frameOffsets |	(FileDirectory default directoryExists: folderName)		ifFalse: [^ self inform: 'Folder not found: ', folderName].	jpegFile := (FileStream newFileNamed: jpegFileName) binary.	dir := FileDirectory default on: folderName.	fileNames := self sortedByFrameNumber: dir fileNames.	frameCount := fileNames size.	frameForm := Form fromFileNamed: (dir fullNameFor: fileNames first).	"write header"	self writeHeaderExtent: frameForm extent		frameRate: frameRate		frameCount: frameCount		soundtrackCount: 0		on: jpegFile.	"convert and write frames"	frameOffsets := Array new: frameCount + 1.	1 to: frameCount do: [:i |		frameOffsets at: i put: jpegFile position.		frameForm := Form fromFileNamed: (dir fullNameFor: (fileNames at: i)).		self writeFrame: frameForm on: jpegFile quality: quality displayFlag: true].	frameOffsets at: (frameCount + 1) put: jpegFile position.	self updateFrameOffsets: frameOffsets on: jpegFile.	jpegFile close.	Display restore.! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 12/13/2001 09:38'!convertMPEGFileNamed: mpegFileName toJPEGMovieNamed: jpegFileName quality: quality	"Convert the MPEG movie with the given file name into a JPEG movie with the given file name."	| mpegFile jpegFile soundtrackCount movieExtent frameOffsets soundTrackOffsets |	(FileDirectory default fileExists: mpegFileName)		ifFalse: [^ self inform: 'File not found: ', mpegFileName].	(MPEGFile isFileValidMPEG: mpegFileName)		ifFalse: [^ self inform: 'Not an MPEG file: ', mpegFileName].	mpegFile := MPEGFile openFile: mpegFileName.	mpegFile fileHandle ifNil: [^ self inform: 'Could not open ', mpegFileName].	jpegFile := (FileStream newFileNamed: jpegFileName) binary.	"write header"	soundtrackCount := mpegFile hasAudio ifTrue: [1] ifFalse: [0].	mpegFile hasVideo		ifTrue: [			movieExtent := (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0).			self writeHeaderExtent: movieExtent				frameRate: (mpegFile videoFrameRate: 0)				frameCount: (mpegFile videoFrames: 0)				soundtrackCount: soundtrackCount				on: jpegFile]		ifFalse: [			self writeHeaderExtent: 0@0				frameRate: 0				frameCount: 0				soundtrackCount: soundtrackCount				on: jpegFile].	"convert and write frames"	frameOffsets := self writeFramesFrom: mpegFile on: jpegFile quality: quality.	self updateFrameOffsets: frameOffsets on: jpegFile.	"convert and write sound tracks"	jpegFile position: frameOffsets last.  "store sound tracks after the last frame"	soundTrackOffsets := self writeSoundTracksFrom: mpegFile on: jpegFile.	self updateSoundtrackOffsets: soundTrackOffsets frameOffsets: frameOffsets on: jpegFile.	mpegFile closeFile.	jpegFile close.	Display restore.! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 12/13/2001 09:39'!convertSqueakMovieNamed: squeakMovieFileName toJPEGMovieNamed: jpegFileName quality: quality	"Convert the Squeak movie with the given file name into a JPEG movie with the given file name."	| sqMovieFile jpegFile w h d frameCount mSecsPerFrame frameForm bytesPerFrame frameOffsets |	(FileDirectory default fileExists: squeakMovieFileName)		ifFalse: [^ self inform: 'File not found: ', squeakMovieFileName].	sqMovieFile := (FileStream readOnlyFileNamed: squeakMovieFileName) binary.	sqMovieFile ifNil: [^ self inform: 'Could not open ', squeakMovieFileName].	jpegFile := (FileStream newFileNamed: jpegFileName) binary.	sqMovieFile nextInt32.  "skip first word"	w := sqMovieFile nextInt32.	h := sqMovieFile nextInt32.	d := sqMovieFile nextInt32.	frameCount := sqMovieFile nextInt32.	mSecsPerFrame := (sqMovieFile nextInt32) / 1000.0.	"write header"	self writeHeaderExtent: w@h		frameRate: (1000.0 / mSecsPerFrame)		frameCount: frameCount		soundtrackCount: 0		on: jpegFile.	"convert and write frames"	frameForm := Form extent: w@h depth: d.	bytesPerFrame := 4 + (frameForm bits size * 4).	frameOffsets := Array new: frameCount + 1.	1 to: frameCount do: [:i |		frameOffsets at: i put: jpegFile position.		sqMovieFile position: 128 + ((i - 1) * bytesPerFrame) + 4.		sqMovieFile next: frameForm bits size into: frameForm bits startingAt: 1.		frameForm display.		self writeFrame: frameForm on: jpegFile quality: quality displayFlag: false].	frameOffsets at: (frameCount + 1) put: jpegFile position.	self updateFrameOffsets: frameOffsets on: jpegFile.	sqMovieFile close.	jpegFile close.	Display restore.! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 1/25/2002 21:08'!extractFrameNumberFrom: aString	"Answer the integer frame number from the given file name string. The frame number is assumed to be the last contiguous sequence of digits in the given string. For example, 'take2 005.jpg' is frame 5 of the sequence 'take2'."	"Assume: The given string contains at least one digit."	| end start |	end := aString size.	[(aString at: end) isDigit not] whileTrue: [end := end - 1].	start := end.	[(start > 1) and: [(aString at: start - 1) isDigit]] whileTrue: [start := start - 1].	^ (aString copyFrom: start to: end) asNumber! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 2/3/2002 10:14'!sortedByFrameNumber: fileNames	"Sort the given collection of fileNames by frame number. The frame number is the integer value of the last contiguous sequence of digits in the file name. Omit filenames that do not contain at least one digit; this helps filter out extraneous non-frame files such as the invisible 'Icon' file that may be inserted by some file servers."	| filtered pairs |	"select the file names contain at least one digit"	filtered := fileNames select: [:fn | fn anySatisfy: [:c | c isDigit]].	"make array of number, name pairs"	pairs := filtered asArray collect: [:fn |		Array with: (self extractFrameNumberFrom: fn) with: fn].	"sort the pairs, then answer a collection containing the second element of every pair"	pairs sort: [:p1 :p2 | p1 first < p2 first].	^ pairs collect: [:p | p last].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:05'!updateFrameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given collection of frame offsets."	aBinaryStream position: 22.	frameOffsets do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 07:40'!updateSoundtrackOffsets: soundtrackOffsetList frameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given sequence of sound track offsets."	aBinaryStream position: 22 + (4 * frameOffsets size).	aBinaryStream uint16: soundtrackOffsetList size.	soundtrackOffsetList do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 14:20'!writeFrame: aForm on: aBinaryStream quality: quality displayFlag: displayFlag	"Compress and the given Form on the given stream and answer its offset. If displayFlag is true, show the result of JPEG compression on the display."	| offset compressed outForm |	offset := aBinaryStream position.	compressed := JPEGReadWriter2 new compress: aForm quality: quality.	displayFlag ifTrue: [  "show decompressed frame"		outForm := (JPEGReadWriter2 on: (ReadStream on: compressed)) nextImage.		outForm display].	aBinaryStream nextPutAll: compressed.	^ offset! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 14:23'!writeFramesFrom: mpegFile on: aBinaryStream quality: quality	"Write the frames of the given MPEG movie on the given stream at the given JPEG quality level. Answer a collection of frame offsets. The size of this collection is one larger than the number of frames; it's final entry is the stream position just after the final frame. The byte count for any frame can thus be computed as the difference between two adjacent offsets."	| frameCount frameOffsets frameForm |	mpegFile hasVideo ifFalse: [^ Array with: aBinaryStream position].	frameCount := mpegFile videoFrames: 0.	frameOffsets := OrderedCollection new: frameCount + 1.	frameForm := Form		extent: (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0)		depth: 32.	[(mpegFile videoGetFrame: 0) < (mpegFile videoFrames: 0)] whileTrue: [		frameOffsets addLast: aBinaryStream position.		mpegFile videoReadFrameInto: frameForm stream: 0.		self writeFrame: frameForm on: aBinaryStream quality: quality displayFlag: true].	frameOffsets addLast: aBinaryStream position.  "add final offset"	^ frameOffsets! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:01'!writeHeaderExtent: movieExtent frameRate: frameRate frameCount: frameCount soundtrackCount: soundtrackCount on: aBinaryStream	"Write a header on the given stream for a JPEG movie file with the given specifications. Leave the stream positioned at the start of the first movie frame."	| offsetCount |	aBinaryStream position: 0.	aBinaryStream nextPutAll: ('JPEG Movie') asByteArray.	aBinaryStream uint16: movieExtent x.	aBinaryStream uint16: movieExtent y.	aBinaryStream uint32: (frameRate * 10000) rounded.	offsetCount := frameCount + 1.	aBinaryStream uint32: offsetCount.	aBinaryStream skip: (offsetCount * 4).  "leave room for frame offsets"	aBinaryStream uint16: soundtrackCount.	aBinaryStream skip: (soundtrackCount * 4).  "leave room for sound track offsets"! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 16:55'!writeSoundTracksFrom: mpegFile on: aBinaryStream	"Convert and write the sound tracks from the given MPEG file to given stream. Answer a collection of sound track offsets."	"Details: Currently converts at most one sound track; only the left channel of a stereo movie will be converted."	| soundtrackCount soundTrackOffsets snd |	soundtrackCount := mpegFile hasAudio ifTrue: [1] ifFalse: [0].	soundTrackOffsets := Array new: soundtrackCount.	1 to: soundtrackCount do: [:i |		soundTrackOffsets at: i put: aBinaryStream position.		snd := mpegFile audioPlayerForChannel: i.		snd storeSunAudioOn: aBinaryStream compressionType: 'mulaw'.		snd closeFile].	^ soundTrackOffsets! !!JPEGMovieFile class methodsFor: 'testing' stamp: 'jm 11/15/2001 14:56'!isJPEGMovieFile: fileName	"Answer true if the file with the given name appears to be a JPEG movie file."	| f tag |	(FileDirectory default fileExists: fileName) ifFalse: [^ false].	f := (FileStream readOnlyFileNamed: fileName) binary.	tag := (f next: 10) asString.	f close.	^ tag = 'JPEG Movie'! !!KeyedSet methodsFor: 'private' stamp: 'ar 11/20/2007 14:52'!errorKeyNotFound: key	"Signal KeyNotFound error"	^(KeyNotFound key: key) signal! !!KeyedSetTest methodsFor: 'tests' stamp: 'ul 2/19/2010 15:57'!testLike		| k |	k := KeyedSet keyBlock: [ :each | each * 2 ].	self assert: (k like: 1) isNil.	k add: 1.	self assert: (k like: 1) = 1.	k add: 2.	self assert: (k like: 2) = 2.	self assert: (k like: 3) isNil.! !!KeyedSetTest methodsFor: 'tests' stamp: 'ul 2/19/2010 15:57'!testLikeIfAbsent		| k missing |	k := KeyedSet keyBlock: [ :each | each * 2 ].	missing := false.	self assert: (k like: 1 ifAbsent: [ missing := true. nil ]) isNil.	self assert: missing.	k add: 1.	missing := false.	self assert: (k like: 1 ifAbsent: [ missing := true. nil ]) = 1.	self deny: missing.	k add: 2.	self assert: (k like: 2 ifAbsent: nil) = 2.	self assert: (k like: 3 ifAbsent: nil) isNil! !!KeyedSetTest methodsFor: 'tests' stamp: 'nice 5/22/2008 14:18'!testSelect	"this is a non regression test for http://bugs.squeak.org/view.php?id=6535"		| ks ks2 |		"Creare a KeyedSet"	ks := KeyedSet keyBlock: [:e | e asInteger \\ 4].	ks addAll: #(1.2 1.5 3.8 7.7 9.1 12.4 13.25 14.0 19.2 11.4).		"There is non more than 4 possible keys (0 1 2 3)"	self assert: ks size <= 4.		"Select some elements"	ks2 := ks select: [:e | e fractionPart > 0.5].	"If keyBlock was preserved, then still no more than 4 keys..."	ks2 addAll: #(1.2 1.5 3.8 7.7 9.1 12.4 13.25 14.0 19.2 11.4).	self assert: ks2 size <= 4.! !!KeyedSetTest commentStamp: 'nice 5/22/2008 14:12' prior: 0!KeyedSetTest hold sunit tests for class KeyedSet!!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'ar 7/13/2010 15:11'!testIsFontAvailable	"self new testIsFontAvailable"	"self run: #testIsFontAvailable"	| oldPref |	oldPref := Preferences valueOfPreference: #tinyDisplay.	Preferences restoreFontsAfter:[	[Preferences enable: #tinyDisplay .	self 		shouldnt:[(LanguageEnvironment localeID: 'en' ) isFontAvailable] 		raise: Error.	] ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref].	].! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'bgf 8/12/2008 23:41'!defaultClipboardInterpreter	"Qwaq VM, which uses UTF-8 for clipboard exchange on both of these..."	Smalltalk platformName = 'Mac OS' ifTrue: [ ^UTF8ClipboardInterpreter new ].	Smalltalk platformName = 'Win32' ifTrue:[^UTF8ClipboardInterpreter new].	ClipboardInterpreterClass ifNil: [ClipboardInterpreterClass := self currentPlatform class clipboardInterpreterClass].	^ ClipboardInterpreterClass new.! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 12/30/2007 18:04'!defaultFileNameConverter	"All platforms use UTF-8 for the file system interface, so don't pretend otherwise."	^UTF8TextConverter new! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'ar 11/30/2009 22:06'!testCompactClassIndex	self assert: LargeNegativeInteger indexIfCompact = 4.! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'nice 7/22/2008 00:25'!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargeNegativeInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size == 4.	self assert: i printString = '-65280'.	"-256*255"	self assert: i normalize == -65280.		i0 := LargeNegativeInteger new: 0.	self assert: i0 size == 0.	self assert: i0 printString = '-0'.	self assert: i0 normalize == 0.! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:36'!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargeNegativeInteger new: 4.	self assert: i size == 4.	self assert: i printString = '-0'.	self assert: i normalize == 0! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:50'!* anInteger 	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 29>	^super * anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:51'!+ anInteger 	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 21>	^super + anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:51'!- anInteger 	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 22>	^super - anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:56'!/ anInteger 	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is 	not in 64 bit range. 	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 30>	^super / anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:56'!// anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not in 64 bit range. 	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 32>	^super // anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:56'!\\ anInteger 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not in 64 bit range. 	Optional. See Object documentation whatIsAPrimitive."	<primitive: 31>	^super \\ anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'ar 3/21/2008 15:54'!quo: anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 33>	^super quo: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'ar 3/21/2008 15:57'!bitAnd: anInteger 	"Primitive. Answer an Integer whose bits are the logical AND of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 64 bits. 	Optional. See Object documentation whatIsAPrimitive."	<primitive: 34>	^ super bitAnd: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'ar 3/21/2008 15:57'!bitOr: anInteger 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 64 bits. 	Optional. See Object documentation whatIsAPrimitive."	<primitive: 35>	^ super bitOr: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'ar 3/21/2008 15:57'!bitShift: anInteger 	"Primitive. Answer an Integer whose value (in twos-complement 	representation) is the receiver's value (in twos-complement	representation) shifted left by the number of bits indicated by the	argument. Negative arguments shift right. Zeros are shifted in from the	right in left shifts. The sign bit is extended in right shifts.	Fail if the receiver or result is greater than 64 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 37>	^super bitShift: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'ar 3/21/2008 15:57'!bitXor: anInteger 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument. Fail if the receiver or argument	is greater than 64 bits. 	Optional. See Object documentation whatIsAPrimitive."	<primitive: 36>	^ super bitXor: anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:55'!< anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 23>	^super < anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:55'!<= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 25>	^super <= anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:48'!= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 64 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 27>	^ super = anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:55'!> anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 24>	^super > anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:55'!>= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not in 64 bit range.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 26>	^super >= anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'ar 3/21/2008 15:56'!~= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 64 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 28>	^ super ~= anInteger! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'md 3/17/2003 15:20'!testBitShift	"Check bitShift from and back to SmallInts"		1 to: 257 do: [:i | self should: [((i bitShift: i) bitShift: 0-i) == i]].! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'ar 11/30/2009 22:06'!testCompactClassIndex	self assert: LargePositiveInteger indexIfCompact = 5.! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'nice 7/22/2008 00:23'!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargePositiveInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size == 4.	self assert: i printString = '65280'.	"256*255"	self assert: i normalize == 65280.		i0 := LargePositiveInteger new: 0.	self assert: i0 size == 0.	self assert: i0 printString = '0'.	self assert: i0 normalize == 0.! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'dtl 5/26/2004 18:33'!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargePositiveInteger new: 4.	self assert: i size == 4.	self assert: i printString = '0'.	self assert: i normalize == 0! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:52'!testMultDicAddSub	"self run: #testMultDicAddSub"	| n f f1 |		n := 100.	f := 100 factorial.	f1 := f*(n+1).	n timesRepeat: [f1 := f1 - f].	self assert: (f1 = f). 	n timesRepeat: [f1 := f1 + f].	self assert: (f1 // f = (n+1)). 	self assert: (f1 negated = (Number readFrom: '-' , f1 printString)).! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:53'!testNormalize	"self run: #testNormalize"	"Check normalization and conversion to/from SmallInts"	self assert: ((SmallInteger maxVal + 1 - 1) == SmallInteger maxVal).	self assert: (SmallInteger maxVal + 3 - 6) == (SmallInteger maxVal-3).	self should: ((SmallInteger minVal - 1 + 1) == SmallInteger minVal).	self assert: (SmallInteger minVal - 3 + 6) == (SmallInteger minVal+3).! !!LayoutFrameTest methodsFor: 'as yet unclassified' stamp: 'bp 4/2/2010 20:17'!testInset	| lf rectangle |	lf := LayoutFrame new		leftFraction: 0 offset: 10;		topFraction: 0 offset: 10;		rightFraction: 1 offset: -10;		bottomFraction: 1 offset: -10;		yourself.	rectangle := lf layout: nil in: (50@10 corner: 150@70).	self assert: (60@20 corner: 140@60) = rectangle! !!LayoutFrameTest methodsFor: 'as yet unclassified' stamp: 'bp 4/2/2010 20:20'!testLeftTopAligned	| lf rectangle |	lf := LayoutFrame new		leftFraction: 0 offset: 10;		topFraction: 0 offset: 10;		rightFraction: 0 offset: 60;		bottomFraction: 0 offset: 25;		yourself.	rectangle := lf layout: nil in: (50@10 corner: 150@70).	self assert: (60@20 corner: 110@35) = rectangle! !!LayoutFrameTest methodsFor: 'as yet unclassified' stamp: 'bp 4/2/2010 20:25'!testRightBottomQuadrant	| lf rectangle |	lf := LayoutFrame new		leftFraction: 1/2 offset: 1;		topFraction: 1/2 offset: 1;		rightFraction: 1 offset: -2;		bottomFraction: 1 offset: -2;		yourself.	rectangle := lf layout: nil in: (50@10 corner: 150@70).	self assert: (101@41 corner: 148@68) = rectangle! !!LayoutFrameTest methodsFor: 'as yet unclassified' stamp: 'bp 4/2/2010 20:16'!testSpaceFill	| lf rectangle |	lf := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	rectangle := lf layout: nil in: (50@10 corner: 150@70).	self assert: (50@10 corner: 150@70) = rectangle! !!LazyListMorph methodsFor: 'drawing' stamp: 'bgf 9/28/2007 16:23'!colorForRow: 	row	^(selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Morph selectionForeground ]		ifFalse: [ self color ].! !!LazyListMorph methodsFor: 'drawing' stamp: 'bgf 12/28/2008 12:00'!drawSelectionOn: aCanvas	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas fillRectangle: selectionDrawBounds			 fillStyle: (Morph selectionBackgroundFillForBounds: selectionDrawBounds)! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^self! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:25'!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:24'!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:10'!sizeCodeForValue: encoder	self subclassResponsibility! !!LeftGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:41'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!LeftGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:27'!defaultWidth	^ 5! !!LeftGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!LeftGripMorph methodsFor: 'accessing' stamp: 'ar 6/23/2010 16:51'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 0 @ 1)		offsets: (0 @ 0 negated corner: self defaultWidth @ 0)! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!ptName	^#left! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!resizeCursor	^ Cursor resizeForEdge: #left! !!Line methodsFor: 'accessing'!beginPoint	"Answer the first end point of the receiver."	^self first! !!Line methodsFor: 'accessing'!beginPoint: aPoint 	"Set the first end point of the receiver to be the argument, aPoint. 	Answer aPoint."	self at: 1 put: aPoint.	^aPoint! !!Line methodsFor: 'accessing'!endPoint	"Answer the last end point of the receiver."	^self last! !!Line methodsFor: 'accessing'!endPoint: aPoint 	"Set the first end point of the receiver to be the argument, aPoint. 	Answer aPoint."	self at: 2 put: aPoint.	^aPoint! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"The form associated with this Path will be displayed, according  	to one of the sixteen functions of two logical variables (rule), at  	each point on the Line. Also the source form will be first anded  	with aForm as a mask. Does not effect the state of the Path."	collectionOfPoints size < 2 ifTrue: [self error: 'a line must have two points'].	aDisplayMedium		drawLine: self form		from: self beginPoint + aPoint		to: self endPoint + aPoint		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newPath newLine |	newPath := aTransformation applyTo: self.	newLine := Line new.	newLine beginPoint: newPath firstPoint.	newLine endPoint: newPath secondPoint.	newLine form: self form.	newLine		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line methodsFor: 'displaying'!displayOnPort: aPort at: aPoint 	aPort sourceForm: self form; combinationRule: Form under; fillColor: nil.	aPort drawFrom: collectionOfPoints first + aPoint		to: collectionOfPoints last + aPoint! !!Line commentStamp: '<historical>' prior: 0!I represent the line segment specified by two points.!!Line class methodsFor: 'examples'!example	"Designate two places on the screen by clicking any mouse button. A	straight path with a square black form will be displayed connecting the	two selected points."	| aLine aForm |  	aForm := Form extent: 20@20.		"make a form one quarter of inch square"	aForm fillBlack.							"turn it black"	aLine := Line new.	aLine form: aForm.						"use the black form for display"	aLine beginPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aLine beginPoint.		aLine endPoint: Sensor waitButton.	aLine displayOn: Display.				"display the line"	"Line example"! !!Line class methodsFor: 'instance creation'!from: beginPoint to: endPoint withForm: aForm 	"Answer an instance of me with end points begingPoint and endPoint; 	the source form for displaying the line is aForm."	| newSelf | 	newSelf := super new: 2.	newSelf add: beginPoint.	newSelf add: endPoint.	newSelf form: aForm.	^newSelf! !!Line class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 2.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 22:16'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anIntegerfillColor: aForm 	| line |	line := Line new.	line form: self form.	1 to: self size - 1 do: 		[:i | 		line beginPoint: (self at: i).		line endPoint: (self at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 23:00'!displayOn: aDisplayMedium transformation: aTransformation clippingBox:clipRect rule: anInteger fillColor: aForm 	| transformedPath |	"get the scaled and translated Path."	transformedPath := aTransformation applyTo: self.	transformedPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!LinearFit commentStamp: '<historical>' prior: 0!I represent a piece-wise linear approximation to a set of points in the plane.!!LinearFit class methodsFor: 'examples'!example	"Select points on a Path using the red button. Terminate by selecting	any other button. Creates a Path from the points and displays it as a	piece-wise linear approximation." 	| aLinearFit aForm flag |	aLinearFit := LinearFit new.	aForm := Form extent: 1 @ 40.	aForm  fillBlack.	aLinearFit form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: [aLinearFit add: Sensor waitButton. Sensor waitNoButton.					aForm displayOn: Display at: aLinearFit last]			ifFalse: [flag:=false]].	aLinearFit displayOn: Display	"LinearFit example"! !!Link commentStamp: '<historical>' prior: 0!A simple container to hold any object in a linked list!!LinkedItem methodsFor: 'accessing' stamp: 'jdm 11/28/2007 14:07'!item	"Answer the value of item"	^ item! !!LinkedItem methodsFor: 'accessing' stamp: 'jdm 11/28/2007 14:07'!item: anObject	"Set the value of item"	item := anObject! !!LinkedListTest methodsFor: 'accessing' stamp: 'md 10/14/2004 10:47'!n	^n! !!LinkedListTest methodsFor: 'accessing' stamp: 'md 10/14/2004 10:47'!n: number	n := number.	! !!LinkedListTest methodsFor: 'accessing' stamp: 'md 10/14/2004 10:46'!nextLink	^nextLink! !!LinkedListTest methodsFor: 'accessing' stamp: 'md 10/14/2004 10:46'!nextLink: aLink	nextLink := aLink! !!LinkedListTest methodsFor: 'running' stamp: 'zz 12/7/2005 19:07'!setUp	super setUp.	list := LinkedList new.	link1 := Link new.	link2 := Link new.	link3 := Link new.	link4 := Link new! !!LinkedListTest methodsFor: 'running' stamp: 'zz 12/7/2005 19:08'!tearDown	list := nil.	link1 := nil.	link2 := nil.	link3 := nil.	link4 := nil.	^ super tearDown! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:04'!test01add	self assert: list isEmpty.	list add: link1.	self assert: list size = 1.	self assert: list first = link1.		list add: link2.	self assert: list size = 2.	self assert: list first = link1.	self assert: list second = link2.		list add: link3.	self assert: list size = 3.	self assert: list first = link1.	self assert: list second = link2.	self assert: list third = link3.		list add: link4.	self assert: list size = 4.	self assert: list first = link1.	self assert: list second = link2.	self assert: list third = link3.	self assert: list fourth = link4! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:04'!test02addLast	self assert: list isEmpty.		list addLast: link1.	self assert: list size = 1.	self assert: list first = link1.		list addLast: link2.	self assert: list size = 2.	self assert: list first = link1.	self assert: list second = link2.		list addLast: link3.	self assert: list size = 3.	self assert: list first = link1.	self assert: list second = link2.	self assert: list third = link3.		list addLast: link4.	self assert: list size = 4.	self assert: list first = link1.	self assert: list second = link2.	self assert: list third = link3.	self assert: list fourth = link4! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:04'!test03addFirst	self assert: list isEmpty.		list addFirst: link1.	self assert: list size = 1.	self assert: list first = link1.		list addFirst: link2.	self assert: list size = 2.	self assert: list first = link2.	self assert: list second = link1.		list addFirst: link3.	self assert: list size = 3.	self assert: list first = link3.	self assert: list second = link2.	self assert: list third = link1.		list addFirst: link4.	self assert: list size = 4.	self assert: list first = link4.	self assert: list second = link3.	self assert: list third = link2.	self assert: list fourth = link1! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:05'!test04addBefore	self assert: list isEmpty.		list add: link1.	self assert: list size = 1.	self assert: list first == link1.		list add: link2 before: link1.	self assert: list size = 2.	self assert: list first == link2.	self assert: list second == link1.		list add: link3 before: link1.	self assert: list size = 3.	self assert: list first == link2.	self assert: list second == link3.	self assert: list third == link1.		list add: link4 before: link1.	self assert: list size = 4.	self assert: list first == link2.	self assert: list second == link3.	self assert: list third == link4.	self assert: list fourth == link1! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:05'!test05addBefore	self assert: list isEmpty.		list add: link1.	self assert: list size = 1.	self assert: list first == link1.		list add: link2 before: link1.	self assert: list size = 2.	self assert: list first == link2.	self assert: list second == link1.		list add: link3 before: link2.	self assert: list size = 3.	self assert: list first == link3.	self assert: list second == link2.	self assert: list third == link1.		list add: link4 before: link3.	self assert: list size = 4.	self assert: list first == link4.	self assert: list second == link3.	self assert: list third == link2.	self assert: list fourth == link1! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:05'!test06addAfter	self assert: list isEmpty.		list add: link1.	self assert: list size = 1.	self assert: list first == link1.		list add: link2 after: link1.	self assert: list size = 2.	self assert: list first == link1.	self assert: list second == link2.		list add: link3 after: link2.	self assert: list size = 3.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.		list add: link4 after: link3.	self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.	self assert: list fourth == link4! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:10'!test07addAfter	self assert: list isEmpty.		list add: link1.	self assert: list size = 1.	self assert: list first == link1.		list add: link2 after: link1.	self assert: list size = 2.	self assert: list first == link1.	self assert: list second == link2.		list add: link3 after: link1.	self assert: list size = 3.	self assert: list first == link1.	self assert: list second == link3.	self assert: list third == link2.		list add: link4 after: link1.	self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link4.	self assert: list third == link3.	self assert: list fourth == link2! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:09'!test08addAfter	| l first |	l := LinkedList new.	first := self class new n: 1.		l add: first.	l add: (self class new n: 3).	self assert: (l collect:[:e | e n]) asArray  = #(1 3).		l add: (self class new n: 2) after: first.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:09'!test09addAfter	| l last |	l := LinkedList new.	last := self class new n: 2.	l add: (self class new n: 1).	l add: last.		self assert: (l collect:[:e | e n]) asArray  = #(1 2).	 	l add: (self class new n: 3) after: last.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:10'!test10removeFirst	list add: link1.	list add: link2.	list add: link3.	list add: link4.		self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.	self assert: list fourth == link4.		list removeFirst.	self assert: list size = 3.	self assert: list first == link2.	self assert: list second == link3.	self assert: list third == link4.		list removeFirst.	self assert: list size = 2.	self assert: list first == link3.	self assert: list second == link4.		list removeFirst.	self assert: list size = 1.	self assert: list first == link4.		list removeFirst.	self assert: list isEmpty! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:10'!test11removeLast	list add: link1.	list add: link2.	list add: link3.	list add: link4.		self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.	self assert: list fourth == link4.		list removeLast.	self assert: list size = 3.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.		list removeLast.	self assert: list size = 2.	self assert: list first == link1.	self assert: list second == link2.		list removeLast.	self assert: list size = 1.	self assert: list first == link1.		list removeFirst.	self assert: list isEmpty! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:11'!test12remove	list add: link1.	list add: link2.	list add: link3.	list add: link4.		self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.	self assert: list fourth == link4.		list remove: link3.	self assert: list size = 3.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link4.		list remove: link2.	self assert: list size = 2.	self assert: list first == link1.	self assert: list second == link4.		list remove: link1.	self assert: list size = 1.	self assert: list first == link4.		list remove: link4.	self assert: list isEmpty! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:12'!test13remove	list add: link1.	list add: link2.	list add: link3.	list add: link4.		self assert: list size = 4.	self assert: list first == link1.	self assert: list second == link2.	self assert: list third == link3.	self assert: list fourth == link4.		list remove: link1.	self assert: list size = 3.	self assert: list first == link2.	self assert: list second == link3.	self assert: list third == link4.		list remove: link4.	self assert: list size = 2.	self assert: list first == link2.	self assert: list second == link3.		list remove: link2.	self assert: list size = 1.	self assert: list first == link3.		list remove: link3.	self assert: list isEmpty! !!LinkedListTest methodsFor: 'testing' stamp: 'mk 8/3/2005 12:13'!test14removeIfAbsent	list add: link1.		self assert: list size = 1.	self assert: list first == link1.		list remove: link1.	self assert: list isEmpty.		[list remove: link1]		on: Error		do: [^ self].			"The execution should not get here. If yes, something went wrong."	self assert: false! !!LinkedListTest methodsFor: 'testing' stamp: 'zz 12/7/2005 19:08'!test22addAll	| link5 link6 link7 link8 listToBeAdded |	link5 := Link new.	link6 := Link new.	link7 := Link new.	link8 := Link new.		list		add: link1;		add: link2;		add: link3;		add: link4.			listToBeAdded := LinkedList new.	listToBeAdded		add: link5;		add: link6;		add: link7;		add: link8.			list addAll: listToBeAdded.		self should: [(list at: 1) == link1].	self should: [(list at: 2) == link2].	self should: [(list at: 3) == link3].	self should: [(list at: 4) == link4].	self should: [(list at: 5) == link5].	self should: [(list at: 6) == link6].	self should: [(list at: 7) == link7].	self should: [(list at: 8) == link8].! !!LinkedListTest methodsFor: 'testing' stamp: 'nice 9/14/2009 20:57'!testRemoveAll	| list2 |	list add: link1.	list add: link2.	list add: link3.	list add: link4.	list2 := list copy.	list removeAll.		self assert: list size = 0.	self assert: list2 size = 4 description: 'the copy has not been modified'! !!LinkedListTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:20'!testAddAfter	| l first |	l := LinkedList new.	first := self class new n: 1.		l add: first.	l add: (self class new n: 3).	self assert: (l collect:[:e | e n]) asArray  = #(1 3).	l add: (self class new n: 2) after: first.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).! !!LinkedListTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:20'!testAddAfterLast	| l last |	l := LinkedList new.	last := self class new n: 2.	l add: (self class new n: 1).	l add: last.	self assert: (l collect:[:e | e n]) asArray  = #(1 2). 	l add: (self class new n: 3) after: last.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).! !!LinkedListTest methodsFor: 'tests' stamp: 'nice 7/28/2008 22:27'!testAddAfterLast2	"LinkedListTest new testAddAfterLast2"	| l first second third fourth |	l := LinkedList new.	first := self class new n: 1.	second := self class new n: 2.	third := self class new n: 3.	fourth :=self class new n: 4.	l addLast: first.	l addLast: second.	self assert: (l collect:[:e | e n]) asArray  = #(1 2). 	l add: third after: second.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3).	l addLast: fourth.	self assert: (l collect:[:e | e n]) asArray  = #(1 2 3 4).! !!LinkedListTest commentStamp: 'mk 8/3/2005 11:55' prior: 0!A set of test cases which thoroughly test functionality of the LinkedList class.!!ListController methodsFor: 'private'!changeModelSelection: anInteger	model toggleListIndex: anInteger! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList := view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListController methodsFor: 'marker adjustment'!markerDelta	| viewList |	viewList := view list.	viewList compositionRectangle height == 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'control defaults' stamp: 'bf 4/14/1999 12:41'!controlActivity	self scrollByKeyboard ifTrue: [^self].	self processKeyboard.	super controlActivity.! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!ListController methodsFor: 'selecting' stamp: 'tk 4/1/98 10:33'!redButtonActivity	| noSelectionMovement oldSelection selection nextSelection pt scrollFlag firstTime |	noSelectionMovement := true.	scrollFlag := false.	oldSelection := view selection.	firstTime := true.	[sensor redButtonPressed | firstTime]		whileTrue: 			[selection := view findSelection: (pt := sensor cursorPoint).			firstTime := false.			selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"					[pt y < view insetDisplayBox top ifTrue:						[self scrollView: view list lineGrid.						scrollFlag := true.						selection := view firstShown].					pt y > view insetDisplayBox bottom ifTrue:						[self scrollView: view list lineGrid negated.						scrollFlag := true.						selection := view lastShown]].			selection == nil ifFalse:					[view moveSelectionBox: (nextSelection := selection).					nextSelection ~= oldSelection						ifTrue: [noSelectionMovement := false]]].	nextSelection ~~ nil & (nextSelection = oldSelection			ifTrue: [noSelectionMovement]			ifFalse: [true]) ifTrue: [self changeModelSelection: nextSelection].	scrollFlag ifTrue: [self moveMarker]! !!ListController methodsFor: 'scrolling'!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar inside top! !!ListController methodsFor: 'scrolling'!scrollView: anInteger 	"Scroll the view and highlight the selection if it just came into view"	| wasClipped |	wasClipped := view isSelectionBoxClipped.	(view scrollBy: anInteger)		ifTrue: [view isSelectionBoxClipped ifFalse:					[wasClipped ifTrue:  "Selection came into view"						[view displaySelectionBox]].				^ true]		ifFalse: [^ false]! !!ListController methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	| viewList |	viewList := view list.	^(viewList clippingRectangle top -			viewList compositionRectangle top -			((marker top - scrollBar inside top) asFloat /				scrollBar inside height asFloat *				viewList compositionRectangle height asFloat))		roundTo: viewList lineGrid! !!ListController commentStamp: '<historical>' prior: 0!I am a kind of ScrollController that assumes that the view is a kind of ListView. Therefore, scrolling means moving the items in a textual list (menu) up or down. In addition, I provide the red button activity of determining when the red button is selecting an item in the list.!!ListItemWrapper methodsFor: 'accessing' stamp: 'bgf 9/28/2007 16:26'!highlightingColor	^ Morph selectionForeground! !!ListParagraph methodsFor: 'composition'!composeAll	"No composition is necessary once the ListParagraph is created."		lastLine isNil ifTrue: [lastLine := 0].			"Because composeAll is called once in the process of creating the ListParagraph."	^compositionRectangle width! !!ListParagraph methodsFor: 'private'!trimLinesTo: lastLineInteger	"Since ListParagraphs are not designed to be changed, we can cut back the		lines field to lastLineInteger."	lastLine := lastLineInteger.	lines := lines copyFrom: 1 to: lastLine! !!ListParagraph methodsFor: 'private' stamp: 'di 7/13/97 16:56'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines := Array new: 20.	lastLine := 0.	startOfLine := 1.	endOfLine := 1.	lineIndex := 0.	anArray do: 		[:item | 		endOfLine := startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex := lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine := endOfLine + 1].	endOfLine := endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString := String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item asString			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	anArray with: lines do: 		[:item :interval |  item isText ifTrue:			[text replaceFrom: interval first to: interval last - 1 with: item]].	self updateCompositionHeight! !!ListParagraph commentStamp: '<historical>' prior: 0!I represent a special type of Paragraph that is used in the list panes of a browser.  I  avoid all the composition done by more general Paragraphs, because I know the structure of my Text.!!ListParagraph class methodsFor: 'initialization' stamp: 'ar 2/26/2010 23:03'!cleanUp	"Re-initialize"	self initialize.! !!ListParagraph class methodsFor: 'initialization' stamp: 'nk 9/1/2004 10:27'!initialize 	"ListParagraph initialize"	| aFont |	"Allow different line spacing for lists"	aFont := Preferences standardListFont.	ListStyle := TextStyle fontArray: { aFont }.	ListStyle gridForFont: 1 withLead: 1! !!ListParagraph class methodsFor: 'style' stamp: 'sw 12/10/1999 10:43'!standardListStyle	^ ListStyle! !!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListView methodsFor: 'list access' stamp: 'sw 12/10/1999 10:43'!assuredTextStyle	^ textStyle ifNil:		[textStyle :=  ListParagraph standardListStyle]! !!ListView methodsFor: 'list access'!list	"Answer the list of items the receiver displays."	^list! !!ListView methodsFor: 'list access' stamp: 'sw 12/9/1999 18:06'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty := anArray isEmpty.	arrayCopy := Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i := 2.	anArray do: [:el | arrayCopy at: i put: el. i := i+1].	arrayCopy := arrayCopy copyWithout: nil.	list := ListParagraph withArray: arrayCopy style: self assuredTextStyle.	selection := 0.	self positionList.! !!ListView methodsFor: 'list access'!reset	"Set the list of items displayed to be empty."	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'list access'!resetAndDisplayView	"Set the list of items displayed to be empty and redisplay the receiver."	isEmpty		ifFalse: 			[self reset.			self displayView]! !!ListView methodsFor: 'list access'!selection: selIndex	selection := selIndex! !!ListView methodsFor: 'delimiters'!bottomDelimiter	"Answer the string used to indicate the bottom of the list."	^bottomDelimiter! !!ListView methodsFor: 'delimiters'!bottomDelimiter: aString 	"Set the string used to indicate the bottom of the list."	bottomDelimiter := aString! !!ListView methodsFor: 'delimiters'!noBottomDelimiter	"Set the string used to indicate the bottom of the list to be nothing."	bottomDelimiter := nil! !!ListView methodsFor: 'delimiters'!noTopDelimiter	"Set the string used to indicate the top of the list to be nothing."	topDelimiter := nil! !!ListView methodsFor: 'delimiters'!topDelimiter	"Answer the string used to indicate the top of the list."	^topDelimiter! !!ListView methodsFor: 'delimiters'!topDelimiter: aString 	"Set the string used to indicate the top of the list."	topDelimiter := aString! !!ListView methodsFor: 'display box access'!boundingBox 	"Refer to the comment in View|boundingBox."	^list boundingBox! !!ListView methodsFor: 'display box access' stamp: 'mkd 11/4/1999 14:31'!isSelectionBoxClipped        "Answer whether there is a selection and whether the selection is visible         on the screen."        ^ selection ~= 0 and:			[(self selectionBox intersects:                        (self clippingBox insetBy: (Rectangle left: 0 right: 0 top: 1 bottom: 0))) not]! !!ListView methodsFor: 'clipping box access'!clippingBox	"Answer the rectangle in which the model can be displayed--this is the 	insetDisplayBox inset by the height of a line for an item."	^self insetDisplayBox insetBy: 		(Rectangle			left: 0			right: 0			top: 0			bottom: self insetDisplayBox height \\ list lineGrid)! !!ListView methodsFor: 'displaying'!deEmphasizeSelectionBox	self displaySelectionBox! !!ListView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[selection isNil ifTrue: [selection := 0].			self positionList].	super display! !!ListView methodsFor: 'displaying'!displaySelectionBox	"If the receiver has a selection and that selection is visible on the display 	screen, then highlight it."	selection ~= 0 ifTrue:		[Display reverse: (self selectionBox intersect: self clippingBox)]! !!ListView methodsFor: 'displaying'!displayView 	"Refer to the comment in View|displayView."	self clearInside.	list foregroundColor: self foregroundColor		backgroundColor: self backgroundColor.	list displayOn: Display! !!ListView methodsFor: 'displaying'!scrollBy: anInteger 	"Scroll up by this amount adjusted by lineSpacing and list limits"	| maximumAmount minimumAmount amount wasClipped |	maximumAmount := 0 max:		list clippingRectangle top - list compositionRectangle top.	minimumAmount := 0 min:		list clippingRectangle bottom - list compositionRectangle bottom.	amount := (anInteger min: maximumAmount) max: minimumAmount.	amount ~= 0		ifTrue: [list scrollBy: amount negated.  ^ true]		ifFalse: [^ false]  "Return false if no scrolling took place"! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta := self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta := self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!ListView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	^ self deEmphasizeSelectionBox! !!ListView methodsFor: 'deEmphasizing'!emphasizeView 	"List emphasis is its own inverse."	^ self deEmphasizeView! !!ListView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^ListController! !!ListView methodsFor: 'selecting'!deselect	"If the receiver has a selection, then it is highlighted. Remove the 	highlighting."	selection ~= 0 ifTrue: [Display reverse: (self selectionBox intersect: self clippingBox)]! !!ListView methodsFor: 'selecting'!findSelection: aPoint 	"Determine which selection is displayed in an area containing the point, 	aPoint. Answer the selection if one contains the point, answer nil 	otherwise."	| trialSelection |	(self clippingBox containsPoint: aPoint) ifFalse: [^nil].	trialSelection := aPoint y - list compositionRectangle top // list lineGrid + 1.	topDelimiter == nil ifFalse: [trialSelection := trialSelection - 1].	(trialSelection < 1) | (trialSelection > self maximumSelection)		ifTrue: [^ nil]		ifFalse: [^ trialSelection]! !!ListView methodsFor: 'selecting'!maximumSelection	"Answer which selection is the last possible one."	^ list numberOfLines		- (topDelimiter == nil ifTrue: [0] ifFalse: [1])		- (bottomDelimiter == nil ifTrue: [0] ifFalse: [1])! !!ListView methodsFor: 'selecting'!minimumSelection	"Answer which selection is the first possible one."	^ 1! !!ListView methodsFor: 'selecting'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[self deselect.			selection := anInteger.			self displaySelectionBox].	self isSelectionBoxClipped		ifTrue: [self scrollSelectionIntoView]! !!ListView methodsFor: 'selecting' stamp: 'di 5/22/1998 00:25'!numSelectionsInView	^ self clippingBox height // self list lineGrid! !!ListView methodsFor: 'selecting'!selection	"Answer the receiver's current selection."	^selection! !!ListView methodsFor: 'selecting'!selectionBox	"Answer the rectangle in which the current selection is displayed."	^(self insetDisplayBox left @ (list compositionRectangle top + self selectionBoxOffset) 		extent: self insetDisplayBox width @ list lineGrid)		insetBy: (Rectangle left: 1 right: 1 top: 1 bottom: 0)! !!ListView methodsFor: 'selecting'!selectionBoxOffset	"Answer an integer that determines the y position for the display box of 	the current selection."	^ (selection - 1 + (topDelimiter == nil ifTrue: [0] ifFalse: [1]))		* list lineGrid! !!ListView methodsFor: 'private'!firstShown	"Return the index of the top item currently visible"	| trial |	trial := self findSelection: self insetDisplayBox topLeft.	^ trial == nil		ifTrue: [1]		ifFalse: [trial]! !!ListView methodsFor: 'private'!lastShown	"Return the index of the bottom item currently visible"	| trial bottomMargin |	bottomMargin := self insetDisplayBox height \\ list lineGrid.	trial := self findSelection: self insetDisplayBox bottomLeft - (0@bottomMargin).	trial == nil		ifTrue: [trial := self findSelection: self insetDisplayBox bottomLeft					- (0@(list lineGrid+bottomMargin))].	^ trial == nil		ifTrue: [list numberOfLines - 2]		ifFalse: [trial]! !!ListView methodsFor: 'private'!positionList	list wrappingBox: self wrappingBox clippingBox: self clippingBox ! !!ListView methodsFor: 'private'!wrappingBox	| aRectangle |	aRectangle := self insetDisplayBox. 	selection = 0		ifTrue: [^aRectangle topLeft + (4 @ 0) extent: list compositionRectangle extent]		ifFalse: [^aRectangle left + 4 @ 					(aRectangle top - 						(self selectionBoxOffset 							min: ((list height - aRectangle height 									+ list lineGrid truncateTo: list lineGrid)							max: 0))) 					extent: list compositionRectangle extent]! !!ListView methodsFor: 'font access' stamp: 'sw 12/9/1999 18:07'!font	^ self assuredTextStyle fontNamed: textStyle fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle := nil]		ifNotNil: [			textStyle := TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter := '------------'.	bottomDelimiter := '------------'.	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'lock access'!lock	"Refer to the comment in view|lock.  Must do at least what display would do to lock the view."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[self positionList].	super lock! !!ListView methodsFor: 'updating'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == #list		ifTrue: 			[self list: model list.			self displayView.			^self].	aSymbol == #listIndex		ifTrue: 			[self moveSelectionBox: model listIndex.			^self]! !!ListView commentStamp: '<historical>' prior: 0!I am an abstract View of a list of items. I provide support for storing a selection of one item, as well as formatting the list for presentation on the screen. My instances' default controller is ListController.!!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:19'!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:03'!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!LiteralNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:13'!isSpecialConstant	^ code between: LdTrue and: LdMinus1+3! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralNode: self! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:44'!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:09'!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:17'!emitCodeForValue: stack encoder: encoder	^readNode		ifNil: [stack push: 1.			encoder genPushLiteralVar: index]		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:45'!sizeCodeForLoad: encoder	^writeNode ifNil: [0] ifNotNil: [encoder sizePushLiteral: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:06'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^(encoder sizePushLiteralVar: index)	 + (writeNode sizeCode: encoder args: 1 super: false)! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2010 08:55'!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:58'!sizeCodeForValue: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialReadBinding]) 		ifFalse:			[^encoder sizePushLiteralVar: index].	readNode := MessageNode new 		receiver: (encoder encodeLiteral: key)		selector: (encoder encodeSelector: #value)		arguments: #()		precedence: #value precedence.	^readNode sizeCodeForValue: encoder! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!LocaleTest methodsFor: 'testing' stamp: 'ar 4/5/2010 20:56'!expectedFailures	^#(testIsFontAvailable)! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/4/2005 11:02'!testEncodingName	"self debug: #testEncodingName"	| locale |	locale := Locale isoLanguage: 'ja'.	self assert: locale languageEnvironment fontEncodingName = #FontJapaneseEnvironment! !!LocaleTest methodsFor: 'testing' stamp: 'ar 7/13/2010 15:13'!testIsFontAvailable	"self debug: #testIsFontAvailable"	Preferences restoreFontsAfter:[	(Locale isoLanguage: 'ja') languageEnvironment removeFonts.	self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.	"Next test should fail after installing Japanese font"	self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.	(Locale isoLanguage: 'ja') languageEnvironment installFont.	self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable.	].! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/4/2005 14:48'!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!LocaleTest commentStamp: 'tak 8/3/2005 18:24' prior: 0!LocaleTest buildSuite run!!LookupKey methodsFor: 'accessing' stamp: 'ajh 9/12/2002 12:04'!key	"Answer the lookup key of the receiver."	^key! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #leftSamples declareC: 'short int *leftSamples'>	<var: #rightSamples declareC: 'short int *rightSamples'>	isInStereo := leftSamples ~~ rightSamples.	compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.	compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor.	i := (2 * startIndex) - 1.	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex := (scaledIndex := scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex := (scaledIndex := scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex := sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count := 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex := sampleIndex]				ifFalse: [nextSampleIndex := ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m := scaledIndex bitAnd: LoopIndexFractionMask.		rightVal := leftVal :=			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal :=				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		rightVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0].			compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.			compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor]].	count := count - n.! !!MCAncestry methodsFor: 'ancestry' stamp: 'avi 10/22/2005 20:01'!trimAfterVersionInfo: aVersionInfo	aVersionInfo = self		ifTrue: [ancestors := #()]		ifFalse:			[aVersionInfo date <= self date ifTrue:				[ancestors do: [:ea | ea trimAfterVersionInfo: aVersionInfo]]		]! !!MCAncestryTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertCommonAncestorOf: leftName and: rightName in: options in: tree	| left right ancestor |	left := self versionForName: leftName in: tree.	right := self versionForName: rightName in: tree.		ancestor := left commonAncestorWith: right.		self assert: (options includes: ancestor name)! !!MCAncestryTest methodsFor: 'asserting' stamp: 'avi 9/17/2005 21:09'!assertCommonAncestorOf: leftName and: rightName is: ancestorName in: tree	self assertCommonAncestorOf: leftName and: rightName in: (Array with: ancestorName) in: tree! !!MCAncestryTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNamesOf: versionInfoCollection are: nameArray	| names |	names := versionInfoCollection collect: [:ea | ea name].		self assert: names asArray = nameArray! !!MCAncestryTest methodsFor: 'asserting' stamp: 'jf 8/16/2003 23:42'!assertPathTo: aSymbol is: anArray	self		assertNamesOf: (self tree allAncestorsOnPathTo: (self treeFrom: {aSymbol}))		are: anArray! !!MCAncestryTest methodsFor: 'tests' stamp: 'avi 9/17/2005 21:08'!testCommonAncestors	self assertCommonAncestorOf: #a2 and: #e2 is: #a1 in: self tree.	self assertCommonAncestorOf: #e2 and: #b3 is: #a1 in: self tree.	self assertCommonAncestorOf: #b2 and: #e2 is: #'00' in: self tree.		self assertCommonAncestorOf: #a4 and: #b5 in: #(b2 a1) in: self twoPersonTree.	self assertCommonAncestorOf: #b5 and: #b3 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #a4 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #b2 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #a1 is: #a1 in: self twoPersonTree.	self assertCommonAncestorOf: #a1 and: #b2 is: #a1 in: self twoPersonTree.! !!MCAncestryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testDescendants	| c1 a1 b3 q1 q2 c2 |	c1 := self tree.	a1 := self treeFrom: #(a1 (('00'))).	b3 := self treeFrom: #(b3				((b2					((b1						((b0							(('00')))))))				(a1					(('00'))))).	q1 := MCWorkingAncestry new addAncestor: a1.	q2 := MCWorkingAncestry new addAncestor: q1.	self assert: (q2 commonAncestorWith: b3) = a1.	self assert: (b3 commonAncestorWith: q2) = a1.	self assert: (q2 commonAncestorWith: c1) = a1.	self assert: (c1 commonAncestorWith: q2) = a1.	q1 addStepChild: c1.	self assert: (q2 commonAncestorWith: c1) = q1.	self assert: (c1 commonAncestorWith: q2) = q1.	c2 := MCWorkingAncestry new addAncestor: c1.	self assert: (q2 commonAncestorWith: c2) = q1.	self assert: (c2 commonAncestorWith: q2) = q1.! !!MCAncestryTest methodsFor: 'tests' stamp: 'jf 8/16/2003 20:45'!testLinearPath	self assertPathTo: #b1 is: #(b3 b2)! !!MCAncestryTest methodsFor: 'tests' stamp: 'jf 8/16/2003 20:42'!testPathToMissingAncestor	self assert: (self tree allAncestorsOnPathTo: MCVersionInfo new) isEmpty! !!MCAncestryTest methodsFor: 'building' stamp: 'jf 8/16/2003 21:21'!tree	^ self treeFrom:		#(c1			((e2				((e1					((a1						(('00')))))))			(a2				((a1					(('00')))))			(b3				((b2					((b1						((b0							(('00')))))))				(a1					(('00')))))			(d1)))! !!MCAncestryTest methodsFor: 'building' stamp: 'jf 8/16/2003 22:55'!twoPersonTree	^ self treeFrom:		#(c1			((a4				((a1)				(b3					((b2						((a1)))))))			(b5				((b2					((a1)))))))! !!MCAncestryTest methodsFor: 'building' stamp: 'ul 12/12/2009 14:10'!versionForName: name in: tree	(tree name = name) ifTrue: [^ tree].		tree ancestors do: [:ea | (self versionForName: name in: ea) ifNotNil: [:v | ^ v]].		^ nil! !!MCChangeNotificationTest methodsFor: 'private' stamp: 'bf 5/20/2005 16:19'!foreignMethod	"see testForeignMethodModified"! !!MCChangeNotificationTest methodsFor: 'events' stamp: 'cwp 11/6/2004 22:32'!modifiedEventFor: aSelector ofClass: aClass	| method |	method := aClass compiledMethodAt: aSelector.	^ ModifiedEvent 				methodChangedFrom: method				to: method				selector: aSelector				inClass: aClass.! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'ar 4/7/2010 09:47'!setUp	"FIXME: Unregister Monticellomocks if it got created in another test	(for example MCMethodDefinitionTest may create it implicitly).	This avoids a nasty failure of MCChangeNotificationTest due to	some inconsistency about the package info registered with it.	If Monticellomocks was created earlier it will contain a 'regular'	PackageInfo instance but the test requires it to be an MCMockPackageInfo"	MCWorkingCopy registry 		removeKey: (MCPackage new name: 'Monticellomocks')		ifAbsent:[].	PackageOrganizer default unregisterPackageNamed: 'Monticellomocks'.		workingCopy := MCWorkingCopy forPackage: self mockPackage.! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'bf 5/20/2005 17:02'!tearDown	workingCopy unregister! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 19:54'!testCoreMethodModified	| event |	workingCopy modified: false.	event := self modifiedEventFor: #one ofClass: self mockClassA.	MCWorkingCopy methodModified: event.	self assert: workingCopy modified! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 17:05'!testExtMethodModified	| event mref |	workingCopy modified: false.	mref := workingCopy packageInfo extensionMethods first.	event := self modifiedEventFor: mref methodSymbol ofClass: mref actualClass.	MCWorkingCopy methodModified: event.	self assert: workingCopy modified! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 17:00'!testForeignMethodModified	| event |	workingCopy modified: false.	event := self modifiedEventFor: #foreignMethod ofClass: self class.	MCWorkingCopy methodModified: event.	self deny: workingCopy modified! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:20'!classAComment	^ self class classAComment! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 17:17'!creationMessage	^ MessageSend		receiver: MCClassDefinition		selector: #name:superclassName:category:instVarNames:classVarNames:poolDictionaryNames:classInstVarNames:type:comment:commentStamp:! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 16:57'!tearDown	Smalltalk at: 'MCMockClassC' ifPresent: [:c | c removeFromSystem]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCannotLoad	| d |	d :=  self mockClass: 'MCMockClassC' super: 'NotAnObject'.	self should: [d load] raise: Error.	self deny: (Smalltalk hasClassNamed: 'MCMockClassC').! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testComparison	| d1 d2 d3 d4 |	d1 := self mockClass: 'A' super: 'X'.	d2 := self mockClass: 'A' super: 'Y'.	d3 := self mockClass: 'B' super: 'X'.	d4 := self mockClass: 'B' super: 'X'.		self assert: (d1 isRevisionOf: d2).	self deny: (d1 isSameRevisionAs: d2).	self assert: (d3 isRevisionOf: d4).	self assert: (d3 isSameRevisionAs: d4).		self deny: (d1 isRevisionOf: d3).	self deny: (d4 isRevisionOf: d2).! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCreation	| d |	d :=  self mockClassA asClassDefinition.	self assert: d className = #MCMockClassA.	self assert: d superclassName = #MCMock.	self assert: d type = #normal.	self assert: d category = self mockCategoryName.	self assert: d instVarNames asArray = #('ivar').	self assert: d classVarNames asArray = #('CVar').	self assert: d classInstVarNames asArray = #().	self assert: d comment isString.	self assert: d comment = self classAComment.	self assert: d commentStamp = self mockClassA organization commentStamp! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testDefinitionString	| d |	d := self mockClassA asClassDefinition.	self assert: d definitionString = self mockClassA definition.! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testEquals	| a b |	a := self mockClass: 'ClassA' super: 'SuperA'.	b := self mockClass: 'ClassA' super: 'SuperA'.	self assert: a = b! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testEqualsSensitivity	| message a b defA args defB |	message := self creationMessage.	a := #(ClassA SuperA CategoryA #(iVarA) #(CVarA) #(PoolA) #(ciVarA)			typeA 'A comment' 'A').	b := #(ClassB SuperB CategoryB #(iVarB) #(CVarB) #(PoolB) #(ciVarB)			typeB 'B comment' 'B').		defA := message valueWithArguments: a.	1 to: 8 do: [:index |				args := a copy.				args at: index put: (b at: index).				defB := message valueWithArguments: args.				self deny: defA = defB.]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!testKindOfSubclass	| classes |	classes := {self mockClassA. String. MethodContext. WeakArray. Float}.	classes do: [:c | | d |		d :=  c asClassDefinition.		self assert: d kindOfSubclass = c kindOfSubclass.	].! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadAndUnload	| d c |	d :=  self mockClass: 'MCMockClassC' super: 'Object'.	d load.	self assert: (Smalltalk hasClassNamed: 'MCMockClassC').	c := (Smalltalk classNamed: 'MCMockClassC').	self assert: (c isKindOf: Class).	self assert: c superclass = Object.	self assert: c instVarNames isEmpty.	self assert: c classVarNames isEmpty.	self assert: c sharedPools isEmpty.	self assert: c category = self mockCategoryName.	self assert: c organization classComment = (self commentForClass: 'MCMockClassC').	self assert: c organization commentStamp = (self commentStampForClass: 'MCMockClassC').	d unload.	self deny: (Smalltalk hasClassNamed: 'MCMockClassC').! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:20'!classAComment	^ 'This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.'! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 17:59'!classACommentStamp	^  'cwp 8/10/2003 16:43'! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 18:01'!restoreClassAComment	Smalltalk 		at: #MCMockClassA 		ifPresent: [:a | a classComment: self classAComment stamp: self classACommentStamp]! !!MCCodeTool methodsFor: 'menus' stamp: 'ar 9/27/2005 20:27'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass := self selectedClassOrMetaClass) ifNotNil:		[ToolSet browse: myClass selector: self selectedMessageName]! !!MCCodeTool methodsFor: 'menus' stamp: 'ar 9/27/2005 20:28'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	ToolSet 		browseVersionsOf: self selectedClassOrMetaClass		selector: self selectedMessageName! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32'!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'ar 9/27/2005 20:28'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName := self selectedMessageName) ifNotNil: [		ToolSet browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 10/27/2008 17:07'!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 6/22/2010 16:10'!log	"Answer the receiver's log. If no log exist use the default log"		^log ifNil: [Transcript]! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 7/20/2010 11:06'!versionBlock	"A block evaluated with the versions processed in #updateFromRepositories and #load.	Useful to track progress when loading large configurations."	^versionBlock! !!MCConfiguration methodsFor: 'accessing' stamp: 'ar 7/20/2010 11:06'!versionBlock: aBlock	"A block evaluated with the versions processed in #updateFromRepositories and #load.	Useful to track progress when loading large configurations."	versionBlock := aBlock! !!MCConfiguration methodsFor: 'actions' stamp: 'ar 7/20/2010 11:07'!load	^self depsSatisfying: [:dep | dep isCurrent not]		versionDo: [:ver | 			versionBlock ifNotNil:[versionBlock value: ver].			ver load.		] displayingProgress: 'loading packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'ar 7/20/2010 11:07'!merge	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver |			versionBlock ifNotNil:[versionBlock value: ver].			ver merge.		] displayingProgress: 'merging packages'! !!MCConfiguration methodsFor: 'actions' stamp: 'ar 7/20/2010 11:07'!upgrade	^self depsSatisfying: [:dep | dep isFulfilledByAncestors not]		versionDo: [:ver | 			versionBlock ifNotNil:[versionBlock value: ver].			(Preferences upgradeIsMerge and: [self mustMerge: ver])				ifFalse: [ver load]				ifTrue: [[ver merge]					on: MCMergeResolutionRequest do: [:request |						request merger conflicts isEmpty							ifTrue: [request resume: true]							ifFalse: [request pass]]]]		displayingProgress: 'upgrading packages'! !!MCConfiguration methodsFor: 'updating' stamp: 'ar 7/20/2010 11:05'!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asArray sort:		[:a :b | a numericSuffix > b numericSuffix].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | (each copyUpToLast: $-) = dep package name]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo info  |				repo := newNames at: newName.				info := self versionInfoNamed: newName for: dep from: repo.				info ifNil: [dep]					ifNotNil: [MCVersionDependency package: dep package info: info]			]).		versionBlock ifNotNil:[versionBlock value: newDeps last].	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration methodsFor: 'copying' stamp: 'bf 11/26/2005 20:22'!postCopy	dependencies := dependencies shallowCopy.	repositories := repositories shallowCopy.! !!MCDependencySorterTest methodsFor: 'asserting' stamp: 'avi 10/7/2004 22:32'!assertItems: anArray orderAs: depOrder withRequired: missingDeps toLoad: unloadableItems	self assertItems: anArray orderAs: depOrder withRequired: missingDeps  toLoad: unloadableItems  extraProvisions: #()! !!MCDependencySorterTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertItems: anArray orderAs: depOrder withRequired: missingDeps toLoad: unloadableItems extraProvisions: provisions	| order sorter items missing unloadable |	items := anArray collect: [:ea | self itemWithSpec: ea].	sorter := MCDependencySorter items: items.	sorter addExternalProvisions: provisions.	order := (sorter orderedItems collect: [:ea | ea name]) asArray.	self assert: order = depOrder.	missing := sorter externalRequirements.	self assert: missing asSet = missingDeps asSet.	unloadable := (sorter itemsWithMissingRequirements collect: [:ea | ea name]) asArray.	self assert: unloadable asSet = unloadableItems asSet! !!MCDependencySorterTest methodsFor: 'building' stamp: 'ab 5/24/2003 14:08'!itemWithSpec: anArray	^ MCMockDependentItem new		name: anArray first;		provides: anArray second;		requires: anArray third! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testCascadingUnresolved	self assertItems: #(		(a (x) (z))		(b () (x))		(c () ()))	orderAs: #(c)	withRequired: #(z)	toLoad: #(a b)	! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testCycle	self assertItems: #(		(a (x) (y))		(b (y) (x)))	orderAs: #()	withRequired: #()	toLoad: #(a b)	! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'avi 10/7/2004 22:35'!testExtraProvisions	self assertItems:		#((a (x) (z))		(b () (x)))	orderAs: #(a b)	withRequired: #()	toLoad: #()		extraProvisions: #(x z)! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testMultiRequirementOrdering	self assertItems: #(		(a (x) (z))		(b (y) ())		(c (z) ())		(d () (x y z)))		orderAs: #(b c a d)		withRequired: #()		toLoad: #()! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testSimpleOrdering	self assertItems: #((a (x) ())								 (c () (y))								 (b (y) (x)))		orderAs: #(a b c)		withRequired: #()		toLoad: #()! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:12'!testSimpleUnresolved	self assertItems: #(		(a () (z)))	orderAs: #()	withRequired: #(z)	toLoad: #(a)		! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'avi 10/7/2004 22:12'!testUnusedAlternateProvider	self assertItems: #(		(a (x) (z))		(b () (x))		(c (x) ()))	orderAs: #(c b)	withRequired: #(z)	toLoad: #(a)	! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 8/16/2003 17:53'!addVersion: aVersion	dict at: aVersion info put: aVersion! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 16:06'!deleteNode: aNode	dict removeKey: aNode! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!dictionary	^ dict ifNil: [dict := Dictionary new]! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	repository :=  MCDictionaryRepository new dictionary: self dictionary! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ar 3/20/2006 13:44'!morphicConfigure	^UIManager default chooseDirectory ifNotNilDo:[:dir| self new directory: dir].! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addVersion: aVersion	| file |	file := FileStream newFileNamed: (directory fullNameFor: aVersion fileName).	aVersion fileOutOn: file.	file close.! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!directory	directory ifNil:		[directory := FileDirectory default directoryNamed: 'mctest'.		directory assureExistence].	^ directory! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	repository := MCDirectoryRepository new directory: self directory! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 12:53'!tearDown	self directory recursiveDelete! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!classes	^ Array new: 0.! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'al 2/16/2006 09:53'!methods	^ MCMockClassA selectors		select: [:ea | ea beginsWith: 'ordinal']		thenCollect:			[:ea | 				MethodReference new 					setStandardClass: MCMockClassA 					methodSymbol: ea].! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCDirtyPackage'! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:45'!wantsChangeSetLogging	^ false! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!classes	^ #()! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!methods	^ #()! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCEmptyPackage'! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:45'!wantsChangeSetLogging	^ false! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'abc 2/11/2010 19:31'!cacheAllFileNamesDuring: aBlock	allFileNames ifNotNil:[^aBlock value].	allFileNames := self allFileNames.	readableFileNames := self readableFileNamesUncached.	^ aBlock ensure: [allFileNames := nil. readableFileNames:= nil]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bgf 12/30/2008 09:09'!readableFileNames	| all cached new |	readableFileNames ifNotNil: [ ^ readableFileNames ].	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	new := all difference: cached.	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'bgf 12/30/2008 09:07'!readableFileNamesUncached	| all cached new |	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	new := all difference: cached.	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:08'!alterInitialState	self mockClassA touchCVar! !!MCFileInTest methodsFor: 'testing' stamp: 'avi 2/17/2004 03:21'!assertFileOutFrom: writerClass canBeFiledInWith: aBlock	(writerClass on: stream) writeSnapshot: self mockSnapshot.	self alterInitialState.	self assertSuccessfulLoadWith: aBlock.	self mockPackage unload.	self assertSuccessfulLoadWith: aBlock.! !!MCFileInTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!assertInitializersCalled	| cvar |	cvar := self mockClassA cVar.	self assert: cvar = #initialized! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:30'!assertSuccessfulLoadWith: aBlock	stream reset.	aBlock value.	self assertNoChange.	self assertInitializersCalled.! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 00:13'!testStWriter	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !!MCFileInTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNoChange	| actual |	actual := MCSnapshotResource takeSnapshot.	diff := actual patchRelativeToBase: expected.	self assert: diff isEmpty! !!MCFileInTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	expected := self mockSnapshot.	stream := RWBinaryOrTextStream on: String new.! !!MCFileInTest methodsFor: 'running' stamp: 'cwp 8/10/2003 00:27'!tearDown	(diff isNil or: [diff isEmpty not])		 ifTrue: [expected updatePackage: self mockPackage]! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'ar 2/22/2007 11:36'!defaultExtent	^450@400! !!MCFileRepositoryInspector methodsFor: 'morphic ui' stamp: 'ar 2/22/2007 11:37'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.4) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.4) (0 30 0 0))		((textMorph: summary) (0 0.4 1 1) (0 0 0 0)) )! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:06'!clientDo: aBlock	| client |	client := FTPClient openOnHostNamed: host.	client loginUser: user password: self password.	directory isEmpty ifFalse: [client changeDirectoryTo: directory].	^ [aBlock value: client] ensure: [client close]! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: 'ftp://',host user: user) ifNil:[^''].! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: 'ftp://',host user: user put: pwd.! !!MCFtpRepository methodsFor: 'required' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: 'ftp://',host user: user put: nil.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!asCreationTemplate	^self class creationTemplateLocation: location user: user password: (		(MCPasswordManager default passwordAt: location user: user) ifNil:['']	)! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 17:28'!creationTemplate	^ self asCreationTemplate! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 17:29'!creationTemplate: ignored	creationTemplate := nil.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	self user isEmpty ifTrue: [^''].	^(MCPasswordManager default queryPasswordAt: location user: self user) ifNil:[^'']! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: location user: self user put: pwd.! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:05'!user	^user! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: location user: user put: nil.! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 6/21/2010 15:00'!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response data statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	data := stream contents.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: data					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	statusLine := response copyUpTo: Character cr.	code := (statusLine findTokens: ' ') second asInteger.	(#(200 201 204) includes: code)			ifFalse: [self error: response].! !!MCHttpRepository class methodsFor: 'class initialization' stamp: 'ar 11/4/2005 17:33'!initialize	Smalltalk removeFromStartUpList: self.! !!MCInitializationTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/11/2003 23:06'!tearDown	(MCWorkingCopy forPackage: self mockPackage) unregister! !!MCInitializationTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/11/2003 23:50'!testWorkingCopy	MczInstaller storeVersionInfo: self mockVersion.	MCWorkingCopy initialize.	MCWorkingCopy allManagers						detect: [:man | man package name = self mockPackage name]						ifNone: [self assert: false]! !!MCInitializationTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 12:11'!isAbstract	^ (Smalltalk hasClassNamed: #MczInstaller) not		! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!assertDict: dict matchesInfo: info	#(name id message date time author)		do: [:sel |  (info perform: sel) ifNotNil: [:i | dict at: sel ifPresent: [:d | self assert: i = d]]].	info ancestors 			with: (dict at: #ancestors) 			do: [:i :d | self assertDict: d matchesInfo: i]! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNoChange	| actual |	actual := MCSnapshotResource takeSnapshot.	diff := actual patchRelativeToBase: expected snapshot.	self assert: diff isEmpty! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionInfoPresent	| dict info |	dict := MczInstaller versionInfo at: self mockPackage name.	info := expected info.	self assertDict: dict matchesInfo: info.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:18'!deleteFile	(FileDirectory default fileExists: self fileName)		ifTrue: [FileDirectory default deleteFileNamed: self fileName]! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:15'!fileName	^ 'InstallerTest.mcz'! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:16'!fileStream	^ FileStream forceNewFileNamed: self fileName.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	expected := self mockVersion.	self change: #one toReturn: 2.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 19:36'!tearDown	expected snapshot updatePackage: self mockPackage.	self deleteFile.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 16:25'!testInstallFromFile	MCMczWriter fileOut: expected on: self fileStream.	MczInstaller installFileNamed: self fileName.	self assertNoChange.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testInstallFromStream	| stream |	stream := RWBinaryOrTextStream on: String new.	MCMczWriter fileOut: expected on: stream.	MczInstaller installStream: stream reset.	self assertNoChange.	self assertVersionInfoPresent.	! !!MCMczInstallerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 12:11'!isAbstract	^ (Smalltalk hasClassNamed: #MczInstaller) not		! !!MCMczInstallerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 11:56'!suite	^ (Smalltalk hasClassNamed: #MczInstaller)		ifTrue: [super suite]		ifFalse: [TestSuite new name: self name asString]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2006 11:54'!getConflictMenu: aMenu	selection remoteChosen		ifTrue: [aMenu add: 'undo keep remote' target: self selector: #clearChoice]		ifFalse: [aMenu add: 'keep remote' target: self selector: #chooseRemote].	selection localChosen		ifTrue: [aMenu add: 'undo keep local' target: self selector: #clearChoice]			ifFalse: [aMenu add: 'keep local' target: self selector: #chooseLocal].	^ aMenu! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'ar 9/26/2006 11:54'!innerButtonRow	^ self buttonRow:		#(('Keep Local' chooseLocal 'Keep the local version' selectionIsConflicted)		('Keep Remote' chooseRemote 'Keep the remote version' selectionIsConflicted))! !!MCMergingTest methodsFor: 'asserting' stamp: 'ab 1/15/2003 16:46'!assert: aCollection hasElements: anArray	self assert: (aCollection collect: [:ea | ea token]) asSet = anArray asSet! !!MCMergingTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertMerge: local with: remote base: ancestor gives: result conflicts: conflictResult	| merger |	conflicts := #().	merger := MCThreeWayMerger				base: (self snapshotWithElements: local)				target: (self snapshotWithElements: remote)				ancestor: (self snapshotWithElements: ancestor).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: result.	self assert: conflicts asSet = conflictResult asSet.! !!MCMergingTest methodsFor: 'emulating' stamp: 'ul 12/12/2009 14:12'!handleConflict: aConflict		|l r|	l := #removed.	r := #removed.	aConflict localDefinition ifNotNil: [:d | l := d token].	aConflict remoteDefinition ifNotNil: [:d | r := d token].		conflicts := conflicts copyWith: (Array with: r with: l).	(l = #removed or: [r = #removed])		ifTrue: [aConflict chooseRemote]		ifFalse:			[l > r				ifTrue: [aConflict chooseLocal]				ifFalse: [aConflict chooseRemote]]		! !!MCMergingTest methodsFor: 'emulating' stamp: 'ab 7/6/2003 23:48'!snapshotWithElements: anArray	^ MCSnapshot		fromDefinitions: (anArray collect: [:t | self mockToken: t])! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:28'!testAdditiveConflictlessMerge	self		assertMerge: #(a1 b1)				with: #(a1 c1)				base: #(a1)							gives: #(a1 b1 c1)				conflicts: #()! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:27'!testComplexConflictlessMerge	self 		assertMerge: #(a1 b1 d1)				with: #(a2 c1)				base: #(a1 c1 d1)								gives: #(a2 b1)				conflicts: #()! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:28'!testIdenticalModification	self		assertMerge: #(a2 b1)				with: #(a2 b1)				base: #(a1 b1)								gives: #(a2 b1)				conflicts: #()! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:44'!testLocalModifyRemoteRemove	self assertMerge: #(a2 b1)				with: #(b1)				base: #(a1 b1)								gives: #(b1)				conflicts: #((removed a2)).					self assertMerge: #(a1 b1)				with: #(b1)				base: #(a2 b1)								gives: #(b1)				conflicts: #((removed a1)).! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:43'!testLocalRemoveRemoteModify	self assertMerge: #(b1)				with: #(a1 b1)				base: #(a2 b1)								gives: #(a1 b1)				conflicts: #((a1 removed)).	self assertMerge: #(b1)				with: #(a2 b1)				base: #(a1 b1)								gives: #(a2 b1)				conflicts: #((a2 removed)).! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger applyPatch: ((self snapshotWithElements: #(a2 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a2 b1).	self assert: conflicts isEmpty! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge2	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger applyPatch: ((self snapshotWithElements: #(a1 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a1 b1).	self assert: conflicts isEmpty! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge3	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #(a1 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a1 b1).	self assert: conflicts isEmpty! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:38'!testMultipleConflicts	self assertMerge: #(a1 b3 c1)				with: #(a1 b2 d1)				base: #(a1 b1 c2)								gives: #(a1 b3 d1)				conflicts: #((removed c1) (b2 b3))! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:38'!testSimultaneousModification	self assertMerge: #(a2)				with: #(a3)				base: #(a1)								gives: #(a3)				conflicts: #((a3 a2)).! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 01:27'!testSimultaneousRemove	self assertMerge: #(a1)				with: #(a1)				base: #(a1 b1)								gives: #(a1)				conflicts: #()! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 01:31'!testSubtractiveConflictlessMerge	self assertMerge: #(a1 b1)				with: #()				base: #(a1)								gives: #(b1)				conflicts: #()! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'abc 2/12/2010 16:34'!override ^ 1! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'cwp 11/13/2003 14:15'!ownPackage	^ MCWorkingCopy forPackage: (MCPackage named: 'Monticello')! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'ar 7/13/2010 16:16'!setUp	navigation := (Smalltalk hasClassNamed: #SystemNavigation)		ifTrue: [(Smalltalk at: #SystemNavigation) new]		ifFalse: [Smalltalk].	isModified := self ownPackage modified.	Utilities authorInitialsPerSe = '' ifTrue:[Utilities setAuthorInitials: 'test'].! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'ar 7/13/2010 16:15'!tearDown	self restoreMocks.	(MCWorkingCopy forPackage: (MCPackage named: 'FooBarBaz')) unregister.	self class compile: 'override ^ 1' classified: 'mocks'.	self ownPackage modified: isModified.	Utilities authorInitialsPerSe = 'test' ifTrue:[Utilities setAuthorInitials: ''].! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testCannotLoad	| definition |	definition := self mockMethod: #kjahs87 class: 'NoSuchClass' source: 'kjahs87 ^self' meta: false.	self should: [definition load] raise: Error.	self assert: (navigation allImplementorsOf: #kjahs87) isEmpty! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testComparison	|d1 d2 d3 d4 d5 |	d1 := self mockMethod: #one class: 'A' source: '1' meta: false.	d2 := self mockMethod: #one class: 'A' source: '2' meta: false.	d3 := self mockMethod: #one class: 'A' source: '1' meta: true.	d4 := self mockMethod: #two class: 'A' source: '1' meta: false.	d5 := self mockMethod: #two class: 'A' source: '1' meta: false.		self assert: (d1 isRevisionOf: d2).	self deny: (d1 isSameRevisionAs: d2).		self deny: (d1 isRevisionOf: d3).	self deny: (d1 isRevisionOf: d4).		self assert: (d4 isSameRevisionAs: d5).! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadAndUnload	|definition|	definition := self mockMethod: #one class: 'MCMockClassA' source: 'one ^2' meta: false.	self assert: self mockInstanceA one = 1.	definition load.	self assert: self mockInstanceA one = 2.	definition unload.	self deny: (self mockInstanceA respondsTo: #one)! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testPartiallyRevertOverrideMethod	| definition |	self class compile: 'override ^ 2' classified: '*foobarbaz'.	self class compile: 'override ^ 3' classified: self mockOverrideMethodCategory.	self class compile: 'override ^ 4' classified: self mockOverrideMethodCategory.	definition := (MethodReference class: self class selector: #override) asMethodDefinition.	self assert: definition isOverrideMethod.	self assert: self override = 4.	definition unload.	self assert: self override = 2.	self assert: (MethodReference class: self class selector: #override) category = '*foobarbaz'.	! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testRevertOldMethod	| definition changeRecord |	Object compile: 'yourself ^ self' classified: MCMockPackageInfo new methodCategoryPrefix.	definition := (MethodReference class: Object selector: #yourself) asMethodDefinition.	changeRecord := definition scanForPreviousVersion.	self assert: changeRecord notNil.	self assert: changeRecord category = 'accessing'.	changeRecord fileIn.! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testRevertOverrideMethod	| definition |	self class compile: 'override ^ 2' classified: self mockOverrideMethodCategory.	definition := (MethodReference class: self class selector: #override) asMethodDefinition.	self assert: definition isOverrideMethod.	self assert: self override = 2.	definition unload.	self assert: self override = 1.	self assert: (MethodReference class: self class selector: #override) category = 'mocks'.	! !!MCMock class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:40'!wantsChangeSetLogging	^ false! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables	^ x + Y + MCMockClassA! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables2	^ ivar + CVar! !!MCMockClassA methodsFor: 'numeric'!a	^ 'a2'! !!MCMockClassA methodsFor: 'numeric'!b	^ 'b1'! !!MCMockClassA methodsFor: 'numeric'!c	^ 'c1'! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!one	^ 1! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!two	^ 2! !!MCMockClassA methodsFor: 'as yet classified'!d	^ 'd'! !!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!falsehood	^ false! !!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!moreTruth	^ true! !!MCMockClassA methodsFor: 'boolean'!truth	^ true! !!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!q! !!MCMockClassA commentStamp: 'cwp 8/10/2003 16:43' prior: 0!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!cVar	^ CVar! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	CVar := #initialized! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!one	^ 1! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!touchCVar	CVar := #touched! !!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!two	^ 2! !!MCMockClassB commentStamp: '' prior: 0!This comment has a bang!! Bang!! Bang!!!!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!one	^ 1! !!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!two	^ 2! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:25'!= definition	^definition token = token! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!asString	^ token! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!description	^ token first! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!hash	^ token hash! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!printString	^ token! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!summary	^ token! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!token	^ token! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!token: aString	token := aString! !!MCMockDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!token: aString	^ self new token: aString! !!MCMockDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:46'!wantsChangeSetLogging	^ false! !!MCMockDependency methodsFor: 'comparing' stamp: 'cwp 11/7/2004 13:32'!= other	^ self name = other name! !!MCMockDependency methodsFor: 'comparing' stamp: 'cwp 11/7/2004 13:33'!hash	^ self name hash! !!MCMockDependency methodsFor: 'accessing' stamp: 'cwp 11/7/2004 14:43'!children	^ children collect: [:ea | self class fromTree: ea]! !!MCMockDependency methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithTree: expr	expr isSymbol		ifTrue: [name := expr.				children := Array new.				hasResolution := true.]		ifFalse: [name := expr first.				expr second isSymbol					ifTrue: [hasResolution := false.							children := Array new]					ifFalse: [hasResolution := true.							children := expr second]]! !!MCMockDependency methodsFor: 'accessing' stamp: 'cwp 11/7/2004 14:38'!name	^ name! !!MCMockDependency methodsFor: 'resolving' stamp: 'cwp 11/7/2004 14:42'!hasResolution	^ hasResolution! !!MCMockDependency methodsFor: 'resolving' stamp: 'cwp 11/7/2004 14:16'!resolve	^ self hasResolution		ifTrue: [MCVersion new					setPackage: MCSnapshotResource mockPackage					info: self mockVersionInfo					snapshot: MCSnapshotResource current snapshot					dependencies: self children]		ifFalse: [nil]! !!MCMockDependency methodsFor: 'mocks' stamp: 'cwp 11/7/2004 14:41'!mockVersionInfo	^ MCVersionInfo		name: self name		id: (self uuidForName: name)		message: ''		date: nil		time: nil		author: ''		ancestors: #()! !!MCMockDependency methodsFor: 'mocks' stamp: 'nk 2/22/2005 21:17'!uuidForName: aName 	| nm id |	nm := aName asString.	id := '00000000-0000-0000-0000-0000000000' 				, (nm size = 1 ifTrue: [nm , '0'] ifFalse: [nm]).	^UUID fromString: id! !!MCMockDependency class methodsFor: 'instance creation' stamp: 'cwp 11/7/2004 14:43'!fromTree: anArray 	^ self new initializeWithTree: anArray! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 16:15'!<= other	^ self name <= other name! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!name	^ name! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!name: aString	name := aString! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!provides: anArray	provides := anArray! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!provisions	^ provides ifNil: [#()]! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!requirements	^ requires ifNil: [#()]! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!requires: anArray	requires := anArray! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:09'!classNames	^ #(	MCMockClassA		 	MCMockASubclass			MCMockClassB			MCMockClassD			MCMockClassE			MCMockClassF			MCMockClassG			MCMockClassH			MCMockClassI		)! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:12'!classes	^ self classNames 		select: [:name | Smalltalk hasClassNamed: name]		thenCollect: [:name | Smalltalk at: name]! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:25'!extensionMethods	^ Array with: (MethodReference new 					setStandardClass: MCSnapshotTest 					methodSymbol: #mockClassExtension)! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 16:54'!includesClass: aClass	^self classes includes: aClass! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 17:18'!includesSystemCategory: categoryName	^self systemCategories anySatisfy: [:cat | cat sameAs: categoryName]! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:31'!packageName	^ 'MonticelloMocks'! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 7/31/2003 15:30'!systemCategories	^ Array with: 'Monticello-Mocks'! !!MCMockPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReordering	|dec cats newCats |	dec := MCOrganizationDefinition categories: #(A B C).	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #(B C A).	self assert: newCats asArray = #(X Y A B C Z Q).! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReorderingWithNoCategoriesInVersion	|dec cats newCats |	dec := MCOrganizationDefinition categories: #().	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #().	self assert: newCats asArray = cats.! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReorderingWithRemovals	|dec cats newCats |	dec := MCOrganizationDefinition categories: #(A B C).	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #(Y B C A Q).	self assert: newCats asArray = #(X A B C Z).! !!MCPTest methodsFor: 'constants' stamp: 'dgd 2/14/2003 10:13'!defaultBounds	"the default bounds for morphs"	^ 0 @ 0 corner: 50 @ 40 ! !!MCPTest methodsFor: 'constants' stamp: 'dgd 2/14/2003 10:13'!defaultTop	"the default top for morphs"	^ self defaultBounds top ! !!MCPTest methodsFor: 'tests' stamp: 'gm 2/22/2003 12:58'!testIsMorphicModel	"test isMorphicModel"	self deny: Object new isMorphicModel.	self deny: Morph new isMorphicModel.	self assert: MorphicModel new isMorphicModel.! !!MCPTest methodsFor: 'tests' stamp: 'ar 9/19/2009 20:18'!testIsSystemWindow	"test isSystemWindow"	self deny: Object new isSystemWindow.	self assert: SystemWindow new isSystemWindow.! !!MCPTest methodsFor: 'tests' stamp: 'dgd 2/14/2003 10:15'!testTop	"test the #top: messages and its consequences"	| morph factor newTop newBounds |	morph := Morph new.	""	factor := 10.	newTop := self defaultTop + factor.	newBounds := self defaultBounds translateBy: 0 @ factor.	""	morph top: newTop.	""	self assert: morph top = newTop;		 assert: morph bounds = newBounds! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'jcg 5/22/2008 17:54'!recompile	self packageInfo methods do: [:m | m actualClass recompile: m methodSymbol].! !!MCPackageLoader methodsFor: 'private' stamp: 'eem 10/14/2008 16:05'!errorDefinitionWarning	^ String streamContents:		[:s |		s nextPutAll: 'The following definitions had errors while loading:'; cr.		errorDefinitions do: [:ea | s space; space; nextPutAll: ea summary; cr].		s cr; nextPutAll: 'If you want to see the errors as they occur set the debugErrorsDuringLoading preference in the Monticello preference category.'; cr] ! !!MCPackageLoader methodsFor: 'private' stamp: 'bgf 1/2/2007 11:20'!shouldWarnAboutErrors	^ errorDefinitions isEmpty not and: [true "should make this a preference"]! !!MCPackageLoader class methodsFor: 'class initialization' stamp: 'eem 10/14/2008 15:24'!initialize	Preferences		addBooleanPreference: #debugErrorsDuringLoading 		category: #Monticello 		default: false		balloonHelp: 'If enabled, Monticvello will allow notifiers and such to be produced during loading.'! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15'!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCPackageManager class methodsFor: 'cleanup' stamp: 'ar 6/16/2010 14:56'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCPackageManager."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCPackageTest methodsFor: 'running' stamp: 'cwp 8/9/2003 23:43'!tearDown	self mockSnapshot install! !!MCPackageTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testUnload	| mock |	self mockPackage unload.	self deny: (Smalltalk hasClassNamed: #MCMockClassA).	self deny: (MCSnapshotTest includesSelector: #mockClassExtension).	mock := (Smalltalk at: #MCMock).	self assert: (mock subclasses detect: [:c | c name = #MCMockClassA] ifNone: []) isNil! !!MCPasswordManager methodsFor: 'accessing' stamp: 'bf 11/7/2005 14:58'!directory	"Answer the directory in which to find the passwords"	^directory ifNil:[ExternalSettings assuredPreferenceDirectory]! !!MCPasswordManager methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:01'!directory: aDirectory	"Indicate the directory in which to find the passwords"	directory := aDirectory! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:48'!editPasswords	"Edit the passwords"	(self directory fileNamesMatching: '*.pwd') do:[:fName|		self editPasswordsIn: (self directory fullNameFor: fName).	].! !!MCPasswordManager methodsFor: 'editing' stamp: 'ar 11/4/2005 16:53'!editPasswordsIn: pwdFile	"Edit the passwords"	| file data |	file := FileStream readOnlyFileNamed: pwdFile.	data := file contents.	file close.	UIManager default edit: data label: pwdFile accept:[:text|		file := FileStream forceNewFileNamed: pwdFile.		file nextPutAll: text asString.		file close.	].! !!MCPasswordManager methodsFor: 'queries' stamp: 'ar 11/4/2005 17:14'!passwordAt: location user: user	"Answer the password stored under the given key, or nil if none can be found"	| file stream tokens pwdFile |	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Location must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'User name must not contain spaces'].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[stream := file contents readStream] ensure:[file close].	[stream atEnd] whileFalse:[		tokens := stream nextLine findTokens: ' '.		(tokens size = 2 and:[tokens first match: location]) ifTrue:[			^(Base64MimeConverter mimeDecode: tokens last as: String)		].	].	^nil! !!MCPasswordManager methodsFor: 'queries' stamp: 'ar 11/4/2005 17:13'!passwordAt: location user: user put: password	"Store the password under the given key"	| file tokens pwd in out done sz pwdFile |	(location indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	(user indexOf: Character space) = 0 		ifFalse:[^self error: 'Key must not contain spaces'].	password ifNotNil:[		pwd := (Base64MimeConverter mimeEncode: password readStream) contents.	].	pwdFile := user,'.pwd'.	file := [self directory readOnlyFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNotNil:[		[in := file contents readStream] ensure:[file close].	] ifNil:[in := String new readStream].	out := WriteStream on: (String new: 1000).	done := pwd == nil. "if clearing passwords, we're done already"	[in atEnd] whileFalse:[		tokens := in nextLine findTokens: ' '.		tokens size = 2 ifTrue:[			(tokens first match: location) 				ifTrue:[pwd ifNotNil:[out nextPutAll: location; space; nextPutAll: pwd; cr. done := true]]				ifFalse:[out nextPutAll: tokens first; space; nextPutAll: tokens last; cr]]].	done ifFalse:[out nextPutAll: location; space; nextPutAll: pwd; cr].	file := [self directory forceNewFileNamed: pwdFile] on: Error do:[:ex| ex return: nil].	file ifNil:[^nil].	[file nextPutAll: out contents.	sz := file size] ensure:[file close].	sz = 0 ifTrue:[self directory deleteFileNamed: pwdFile ifAbsent:[]].! !!MCPasswordManager methodsFor: 'queries' stamp: 'ar 3/6/2006 18:26'!queryPasswordAt: location user: user	"Answer the password for the given user/location. 	If the password is absent, query the user if interactive."	| pwd |	"search for existing password"	pwd := self passwordAt: location user: user.	pwd ifNotNil:[^pwd].	pwd := UIManager default requestPassword: 'Password for "', user, '" at ', location.	pwd isEmptyOrNil ifTrue:[^nil].	(self confirm: 'Remember password for "', user, '" at ', location,'?') ifTrue:[		self passwordAt: location user: user put: pwd.	].	^pwd! !!MCPasswordManager commentStamp: '<historical>' prior: 0!Simple password manager to avoid storing passwords in the image.!!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 15:23'!default	^Default ifNil:[Default := self new]! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:53'!editPasswords	^self default editPasswords! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user	^self default passwordAt: location user: user! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:14'!passwordAt: location user: user put: password	^self default passwordAt: location user: user put: password! !!MCPasswordManager class methodsFor: 'accessing' stamp: 'ar 11/4/2005 16:37'!queryPasswordAt: location user: user	^self default queryPasswordAt: location user: user! !!MCPatch methodsFor: 'applying' stamp: 'ar 4/15/2007 23:19'!applyTo: anObject	operations do: [:ea | ea applyTo: anObject].! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	|rev1 rev2|	rev1 :=  MCSnapshotResource takeSnapshot.	self change: #one toReturn: 2.	rev2 :=  MCSnapshotResource takeSnapshot.	patch := rev2 patchRelativeToBase: rev1.	self change: #one toReturn: 1.! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/2/2003 17:24'!tearDown	self restoreMocks! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:31'!testPatchContents	self assert: patch operations size = 1.	self assert: patch operations first isModification.	self assert: patch operations first definition selector = #one.! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 16:58'!flushPasswords! !!MCRepository class methodsFor: 'class initialization' stamp: 'ar 11/4/2005 17:30'!initialize	"self initialize"	ExternalSettings registeredClients remove: self ifAbsent:[].! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 8/16/2003 17:46'!addVersion: aVersion	self subclassResponsibility ! !!MCRepositoryTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!addVersionWithSnapshot: aSnapshot name: aString	| version |	version := self versionWithSnapshot: aSnapshot name: aString.	self addVersion: version.	^ version info! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 7/19/2003 16:20'!saveSnapshot1	^ self saveSnapshot: self snapshot1 named: 'rev1'! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 7/19/2003 16:20'!saveSnapshot2	^ self saveSnapshot: self snapshot2 named: 'rev2'! !!MCRepositoryTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!saveSnapshot: aSnapshot named: aString	| version |	version := self versionWithSnapshot: aSnapshot name: aString.	repository storeVersion: version.	^ version info	! !!MCRepositoryTest methodsFor: 'asserting' stamp: 'ab 7/19/2003 23:59'!assertMissing: aVersionInfo	self assert: (repository versionWithInfo: aVersionInfo) isNil! !!MCRepositoryTest methodsFor: 'asserting' stamp: 'ab 8/16/2003 18:07'!assertVersionInfos: aCollection	self assert: repository allVersionInfos asSet = aCollection asSet! !!MCRepositoryTest methodsFor: 'building' stamp: 'ab 7/10/2003 01:03'!snapshot1	^ (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: #('y'))))! !!MCRepositoryTest methodsFor: 'building' stamp: 'ab 7/10/2003 01:03'!snapshot2	^ (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: #('x'))))! !!MCRepositoryTest methodsFor: 'building' stamp: 'stephaneducasse 2/4/2006 20:47'!versionWithSnapshot: aSnapshot name: aString	| info |	info := self mockVersionInfo: aString. 	^ MCVersion 		package: (MCPackage new name: aString)		info: info		snapshot: aSnapshot! !!MCRepositoryTest methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:32'!snapshotAt: aVersionInfo	^ (repository versionWithInfo: aVersionInfo) snapshot! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testAddAndLoad	| node |	node := self addVersionWithSnapshot: self snapshot1 name: 'rev1'.	self assert: (self snapshotAt: node) = self snapshot1.! !!MCRepositoryTest methodsFor: 'tests' stamp: 'avi 2/17/2004 03:24'!testIncludesName	self deny: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev1').	self saveSnapshot1.	self assert: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev1').	self deny: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev2').	self saveSnapshot2.	self assert:  (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev2').! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadMissingNode	| node |	node := MCVersionInfo new.	self assertMissing: node! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testStoreAndLoad	| node node2 |	node := self saveSnapshot1.	node2 := self saveSnapshot2.	self assert: (self snapshotAt: node) = self snapshot1.	self assert: (self snapshotAt: node2) = self snapshot2.! !!MCRepositoryTest class methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 12:45'!isAbstract	^ self = MCRepositoryTest! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!flushPasswords	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: nil! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:11'!initializeWithPackage: packageString user: userString password: passString	packageName := packageString.	user := userString.	self password: passString.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password	^(MCPasswordManager default queryPasswordAt: self squeakMapUrl user: user) ifNil:[^''].! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:26'!password: passwordString	| pwd |	passwordString isEmpty ifTrue:[pwd := nil] ifFalse:[pwd := passwordString].	MCPasswordManager default passwordAt: self squeakMapUrl user: user put: pwd.! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:11'!releaseVersion: aVersion url: urlString	| result |	result := HTTPSocket		httpPost: self squeakMapUrl, '/packagebyname/', packageName, '/newrelease'		args: {'version' -> {(aVersion info name copyAfter: $.) extractNumber asString}.			   'note' -> {aVersion info message}.			   'downloadURL' -> {urlString}}		user: user		passwd: self password.	result contents size > 4 ifTrue: [self error: result contents]! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'ar 11/4/2005 17:11'!uploadVersion: aVersion	| result stream |	result := HTTPSocket		httpPut: (self stringForVersion: aVersion)		to: self squeakMapUrl, '/upload/', aVersion fileName		user: user		passwd: self password.	self checkResult: result.	stream := result readStream.	stream upToAll: 'http://'.	^ 'http://', stream upToEnd! !!MCScannerTest methodsFor: 'asserting' stamp: 'avi 1/22/2004 20:23'!assertScans: anArray	self assert: (MCScanner scan: anArray printString readStream) = anArray! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:19'!test1	self assertScans: #(a '23' (x))! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:22'!test2	self assertScans: 'it''s alive'! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:23'!test3	self assert: (MCScanner scan: '(a #b c)' readStream) = #(a #b c)! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:23'!test4	self assertScans: #(a '23' (x () ')''q' y12)).! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:26'!test5	self assertScans: #((a) b)! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:28'!test6	self should: [MCScanner scan: '(a b' readStream] raise: Error! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertClass: readerClass providesServices: labels	| services suffix |	suffix := readerClass extension.	self assert: (FileList isReaderNamedRegistered: readerClass name).	services := readerClass fileReaderServicesForFile: 'foo' suffix: suffix.	self assert: ((services collect: [:service | service buttonLabel]) includesAllOf: labels)! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertDependenciesMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersionWithDependencies.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := (readerClass on: stream reset) dependencies.	self assert: actual = expected dependencies.! !!MCSerializationTest methodsFor: 'asserting' stamp: 'cwp 8/1/2003 14:57'!assertExtensionProvidedBy: aClass	self shouldnt: [aClass readerClass extension] raise: Exception.! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertSnapshotsMatchWith: writerClass	| readerClass expected stream actual |	readerClass := writerClass readerClass.	expected := self mockSnapshot.	stream := RWBinaryOrTextStream on: String new.	(writerClass on: stream) writeSnapshot: expected.	actual := readerClass snapshotFromStream: stream reset.	self assertSnapshot: actual matches: expected.! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionInfosMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersion.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := readerClass versionInfoFromStream: stream reset.	self assert: actual = expected info.! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionsMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersion.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := readerClass versionFromStream: stream reset.	self assertVersion: actual matches: expected.! !!MCSerializationTest methodsFor: 'mocks' stamp: 'stephaneducasse 2/4/2006 20:47'!mockDiffyVersion	| repos workingCopy base next |	repos := MCDictionaryRepository new.	workingCopy := MCWorkingCopy forPackage: self mockPackage.	workingCopy repositoryGroup addRepository: repos.	MCRepositoryGroup default removeRepository: repos.	base := self mockVersion.	repos storeVersion: base.	self change: #a toReturn: 'a2'.	next := self mockVersionWithAncestor: base.	^ next asDiffAgainst: base	! !!MCSerializationTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testMcdSerialization	| stream expected actual |	expected := self mockDiffyVersion.	stream := RWBinaryOrTextStream on: String new.	MCMcdWriter fileOut: expected on: stream.	actual := MCMcdReader versionFromStream: stream reset.	self assertVersion: actual matches: expected.! !!MCSerializationTest methodsFor: 'testing' stamp: 'avi 1/19/2004 15:14'!testMczSerialization	self assertVersionsMatchWith: MCMczWriter.	self assertExtensionProvidedBy: MCMczWriter.	self assertVersionInfosMatchWith: MCMczWriter.	self assertDependenciesMatchWith: MCMczWriter.! !!MCSerializationTest methodsFor: 'testing' stamp: 'cwp 8/3/2003 18:43'!testStSerialization	self assertSnapshotsMatchWith: MCStWriter.! !!MCSmtpRepository class methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2006 18:28'!morphicConfigure	| address |	address := UIManager default request: 'Email address:'.	^ address isEmpty ifFalse: [self new emailAddress: address]! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:46'!allCategories	^ Array with: model extensionsCategory with: self mockCategoryName.! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:58'!allMethods	^ MCSnapshotResource current definitions		select: [:def | def isMethodDefinition]		thenCollect: [:def | def selector]		! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:58'!allProtocols	^ MCSnapshotResource current definitions		select: [:def | def isMethodDefinition]		thenCollect: [:def | def category]		! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/13/2003 02:23'!classABooleanMethods	^ #(falsehood moreTruth truth)! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAClassProtocols	^ self protocolsForClass: self mockClassA class.! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAComment	^ self mockClassA organization classComment.! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classADefinitionString	^ self mockClassA definition! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAProtocols	^ self protocolsForClass: self mockClassA.! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:59'!definedClasses	^ MCSnapshotResource current definitions 		select: [:def | def isClassDefinition] 		thenCollect: [:def | def className].! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/13/2003 02:53'!falsehoodMethodSource	^ 'falsehood	^ false'! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!protocolsForClass: aClass	| protocols |	protocols := aClass organization categories.	protocols size > 1 ifTrue: [protocols := protocols copyWith: '-- all --'].	^ protocols.! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/28/2003 22:21'!annotationTextMorph	^ (self morphsOfClass: TextMorph) first! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'kb 2/24/2010 21:57'!buildWindow	Smalltalk at: #ToolBuilder ifPresent: [:tb | 		morph := tb build: model. 		^self ].	morph := model buildWindow.! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 09:12'!buttonMorphs	^ self morphsOfClass: PluggableButtonMorph! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 09:19'!findButtonWithLabel: aString	^ self buttonMorphs detect: [:m | m label = aString]! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 01:28'!findListContaining: aString	^ self listMorphs detect: [:m | m getList includes: aString]! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 02:34'!listMorphs	^ self morphsOfClass: PluggableListMorph! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'stephaneducasse 2/4/2006 20:47'!morphsOfClass: aMorphClass	| morphs |	morphs := OrderedCollection new.	morph allMorphsDo: [:m | (m isKindOf: aMorphClass) ifTrue: [morphs add: m]].	^ morphs! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/28/2003 22:21'!textMorph	^ (self morphsOfClass: TextMorph) last! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 01:19'!assertAListIncludes: anArrayOfStrings	self listMorphs 			detect: [:m | m getList includesAllOf: anArrayOfStrings]			ifNone: [self assert: false].! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 12/27/2009 20:58'!assertAListMatches: strings	| listMorphs |	listMorphs := self listMorphs.	listMorphs 		detect: [:m | | list |			list := m getList. (list size = strings size) and: [list includesAllOf: strings]]		ifNone: [self assert: false].! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:12'!assertButtonExists: aString	self buttonMorphs detect: [:m | m label = aString] ifNone: [self assert: false].				! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:26'!assertButtonOn: aString	self assert: (self findButtonWithLabel: aString) getModelState.	! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 02:38'!assertTextIs: aString	self assert: self textMorph contents = aString.! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!denyAListHasSelection: aString	| found |	found := true.	self listMorphs 			detect: [:m | m selection = aString]			ifNone: [found := false].	self deny: found.! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!denyAListIncludesAnyOf: anArrayOfStrings	| found |	found := true.	self listMorphs 			detect: [:m | m getList includesAnyOf: anArrayOfStrings]			ifNone: [found := false].	self deny: found.! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:27'!denyButtonOn: aString	self deny: (self findButtonWithLabel: aString) getModelState.	! !!MCSnapshotBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/13/2003 09:22'!clickOnButton: aString	(self findButtonWithLabel: aString) performAction.! !!MCSnapshotBrowserTest methodsFor: 'simulating' stamp: 'stephaneducasse 2/4/2006 20:47'!clickOnListItem: aString	| listMorph |	listMorph := self findListContaining: aString.	listMorph changeModelSelection: (listMorph getList indexOf: aString).! !!MCSnapshotBrowserTest methodsFor: 'selecting' stamp: 'cwp 7/13/2003 13:04'!selectMockClassA	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	! !!MCSnapshotBrowserTest methodsFor: 'running' stamp: 'kb 2/24/2010 21:57'!setUp	model := MCSnapshotBrowser forSnapshot: MCSnapshotResource current snapshot.	self buildWindow! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'kb 2/24/2010 21:58'!testAnnotationPane	| oldPref |	oldPref := Preferences annotationPanes.	Preferences disable: #annotationPanes.	self buildWindow.	self assert: (self morphsOfClass: TextMorph) size = 1.	Preferences enable: #annotationPanes.	self buildWindow.	self assert: (self morphsOfClass: TextMorph) size = 2.	Preferences setPreference: #annotationPanes toValue: oldPref! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:40'!testCategorySelected	self clickOnListItem: self mockCategoryName.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self denyAListIncludesAnyOf: self allProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: ''.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 13:04'!testClassSelected	self selectMockClassA.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: self classADefinitionString.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 13:06'!testClassSideClassSelected	self clickOnButton: 'class'.	self selectMockClassA.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAClassProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: self classADefinitionString.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 12:52'!testComment	self clickOnButton: '?'.	self assertTextIs: ''.		self clickOnListItem: self mockCategoryName.	self assertTextIs: ''.		self clickOnListItem: 'MCMockClassA'.	self assertTextIs: self classAComment.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:30'!testFourColumns	self assert: self listMorphs size = 4.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 09:00'!testMethodIsCleared	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.	self clickOnListItem: 'falsehood'.	self clickOnListItem: '-- all --'.		self denyAListHasSelection: 'falsehood'.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:50'!testMethodSelected	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.	self clickOnListItem: 'falsehood'.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self assertAListMatches: self classABooleanMethods.	self assertTextIs: self falsehoodMethodSource.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'tfel 8/28/2009 20:43'!testNoSelection	self assertAListMatches: self allCategories.	self denyAListIncludesAnyOf: self definedClasses.	self denyAListIncludesAnyOf: self allProtocols.	self denyAListIncludesAnyOf: self allMethods.	"and if there I need to see the packages scripts (or none)"	self assertTextIs: '(package defines no scripts)'.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 08:46'!testProtocolIsCleared	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockASubclass'.	self clickOnListItem: 'as yet unclassified'.	self clickOnListItem: 'MCMockClassA'.		self denyAListHasSelection: 'as yet unclassified'.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 08:52'!testProtocolSelected	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self assertAListMatches: self classABooleanMethods.	self assertTextIs: ''.		! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:37'!testTextPane	self shouldnt: [self textMorph] raise: Exception.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 09:14'!testThreeButtons	self assertButtonExists: 'instance'.	self assertButtonExists: '?'.	self assertButtonExists: 'class'.! !!MCSnapshotBrowserTest class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:59'!resources	^ Array with: MCSnapshotResource! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:50'!definitions	^ snapshot definitions! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	snapshot := self class takeSnapshot.! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:51'!snapshot	^ snapshot! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:18'!mockPackage	^ (MCPackage new name: self mockPackageName)! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 13:54'!mockPackageName	^ MCMockPackageInfo new packageName! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:19'!takeSnapshot	^ self mockPackage snapshot! !!MCSnapshotTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	snapshot :=  self mockSnapshot.! !!MCSnapshotTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testCreation	|d|	d :=  self mockSnapshot definitions.	self assert: (d anySatisfy: [:ea | ea isClassDefinition and: [ea className = #MCMockClassA]]).	self assert: (d anySatisfy: [:ea | ea isMethodDefinition and: [ea selector = #mockClassExtension]]).	self assert: (d allSatisfy: [:ea | ea isClassDefinition not or: [ea category endsWith: 'Mocks']]).	! !!MCSnapshotTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testInstanceReuse	| x m n y |	x := (MCPackage new name: self mockCategoryName) snapshot.	Smalltalk garbageCollect.	n := MCDefinition allSubInstances size.	y := (MCPackage new name: self mockCategoryName) snapshot.	Smalltalk garbageCollect.	m := MCDefinition allSubInstances size.	self assert: m = n! !!MCSnapshotTest methodsFor: '*monticello-mocks' stamp: 'ab 7/7/2003 23:21'!mockClassExtension! !!MCSortingTest methodsFor: 'building' stamp: 'ab 4/8/2003 17:56'!classNamed: aSymbol	^ MCClassDefinition		name: aSymbol		superclassName: #Object		category: ''		instVarNames: #()		comment: ''! !!MCSortingTest methodsFor: 'building' stamp: 'ab 4/8/2003 18:03'!methodNamed: aSymbol class: className meta: aBoolean	^ MCMethodDefinition		className: className		classIsMeta: aBoolean		selector: aSymbol		category: ''		timeStamp: ''		source: ''! !!MCSortingTest methodsFor: 'building' stamp: 'ab 7/19/2003 17:56'!sortKeyFor: aDefinition	^ String streamContents:		[:s |		aDefinition description			do: [:ea | s nextPutAll: ea asString]			separatedBy: [s nextPut: $.]]! !!MCSortingTest methodsFor: 'actions' stamp: 'ab 7/19/2003 18:01'!sortDefinitions: aCollection	^ aCollection asSortedCollection asArray! !!MCSortingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testConsistentSorting	| definitions shuffledAndSorted|	definitions :=		{self methodNamed: #a class: #A meta: false.		self methodNamed: #a class: #A meta: true.		self methodNamed: #a class: #B meta: false.		self methodNamed: #b class: #A meta: false.		self methodNamed: #b class: #B meta: false.		self classNamed: #A.		self classNamed: #B}.	shuffledAndSorted :=		(1 to: 100) collect: [:ea | self sortDefinitions: definitions shuffled].	self assert: shuffledAndSorted asSet size = 1.! !!MCSortingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSortOrder	| aA aAm aB bA bB A B cA bAm cAm |	aA := self methodNamed: #a class: #A meta: false.	bA := self methodNamed: #b class: #A meta: false.	cA := self methodNamed: #c class: #A meta: false.	aAm := self methodNamed: #a class: #A meta: true.	bAm := self methodNamed: #b class: #A meta: true.	cAm := self methodNamed: #c class: #A meta: true.	aB := self methodNamed: #a class: #B meta: false.	bB := self methodNamed: #b class: #B meta: false.	A := self classNamed: #A.	B := self classNamed: #B.	self assert: (self sortDefinitions: {aA. aAm. cAm. aB. bAm. bA. bB. A. cA. B})					= {A. aAm. bAm. cAm. aA. bA. cA. B. aB.  bB}! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/16/2003 23:35'!commentWithStyle	^ '!!AEDesc commentStamp: ''<historical>'' prior: 0!!I represent an Apple Event Descriptor.  I am a low-level representation of Apple Event (and hence Applescript) information.  For further Information, see Apple''s Inside Macintosh: Interapplication Communications, at	http://developer.apple.com/techpubs/mac/IAC/IAC-2.html.Essentially, I represent a record comprising a one-word "string" (treating the word as fourbyte characters) representing a data type, followed by a pointer to a pointer (a handle) to the data I represent.  Care must be taken to assure that the Handle data is disposed after use, or memory leaks result.  At this time, I make no effort to do this automatically through finalization.!!]style[(218 54 384)f1,f1Rhttp://developer.apple.com/techpubs/mac/IAC/IAC-2.html;,f1!!'! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 16:52'!commentWithoutStyle	^ 'CharacterScanner subclass: #CanvasCharacterScanner	instanceVariableNames: ''canvas fillBlt foregroundColor runX lineY ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Morphic-Support''!!!!CanvasCharacterScanner commentStamp: ''<historical>'' prior: 0!!A displaying scanner which draws its output to a Morphic canvas.!!!!CanvasCharacterScanner methodsFor: ''stop conditions'' stamp: ''ar 12/15/2001 23:27''!!setStopConditions	"Set the font and the stop conditions for the current run."	self setFont.	stopConditions		at: Space asciiValue + 1		put: (alignment = Justified ifTrue: [#paddedSpace])!! !!'! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'md 7/23/2006 15:28'!methodWithStyle	^ '!!EventHandler methodsFor: ''copying'' stamp: ''tk 1/22/2001 17:39''!!veryDeepInner: deepCopier	"ALL fields are weakly copied.  Can''t duplicate an object by duplicating a button that activates it.  See DeepCopier."	super veryDeepInner: deepCopier.	"just keep old pointers to all fields"	clickRecipient := clickRecipient.!!]style[(25 108 10 111)f1b,f1,f1LDeepCopier Comment;,f1!! !!'! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCommentWithStyle	| reader |	reader := MCStReader on: self commentWithStyle readStream.	reader definitions! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCommentWithoutStyle	| reader |	reader := MCStReader on: self commentWithoutStyle readStream.	self assert: (reader definitions anySatisfy: [:ea | ea isMethodDefinition]).! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testMethodWithStyle	| reader |	reader := MCStReader on: self methodWithStyle readStream.	self assert: reader definitions first isMethodDefinition.! !!MCStWriter methodsFor: '*TweakMC' stamp: 'ar 7/29/2004 19:39'!visitTweakFieldDefinition: definition	self writeTweakFieldDefinition: definition.! !!MCStWriter methodsFor: '*TweakMC' stamp: 'ar 7/29/2004 19:39'!writeTweakFieldDefinition: definition	self chunkContents: [:s | definition printDefinitionOn: stream]! !!MCStWriterTest methodsFor: 'asserting' stamp: 'cwp 8/2/2003 12:13'!assertAllChunksAreWellFormed	stream reset.	stream 		untilEnd: [self assertChunkIsWellFormed: stream nextChunk]		displayingProgress: 'Checking syntax...'! !!MCStWriterTest methodsFor: 'asserting' stamp: 'al 7/21/2006 22:14'!assertChunkIsWellFormed: chunk	self class parserClass new		parse: chunk readStream 		class: UndefinedObject 		noPattern: true		context: nil		notifying: nil		ifFail: [self assert: false]! !!MCStWriterTest methodsFor: 'asserting' stamp: 'nk 2/22/2005 21:17'!assertContentsOf: strm match: expected 	| actual |	actual := strm contents.	self assert: actual size = expected size.	actual with: expected do: [:a :e | self assert: a = e]! !!MCStWriterTest methodsFor: 'asserting' stamp: 'al 7/21/2006 22:14'!assertMethodChunkIsWellFormed: chunk	self class parserClass new		parse: chunk readStream 		class: UndefinedObject 		noPattern: false		context: nil		notifying: nil		ifFail: [self assert: false]! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:03'!expectedClassDefinitionA ^ 'MCMock subclass: #MCMockClassA	instanceVariableNames: ''ivar''	classVariableNames: ''CVar''	poolDictionaries: ''''	category: ''Tests-Monticello-Mocks''!!!!MCMockClassA commentStamp: ''cwp 8/10/2003 16:43'' prior: 0!!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!!'! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:03'!expectedClassDefinitionB ^ 'MCMock subclass: #MCMockClassB	instanceVariableNames: ''ivarb''	classVariableNames: ''CVar''	poolDictionaries: ''MCMockAPoolDictionary''	category: ''Tests-Monticello-Mocks''!!MCMockClassB class	instanceVariableNames: ''ciVar''!!!!MCMockClassB commentStamp: '''' prior: 0!!This comment has a bang!!!! Bang!!!! Bang!!!!!!'! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 14:43'!expectedClassMethodDefinition	^ '!!MCMockClassA class methodsFor: ''as yet unclassified'' stamp: ''ab 7/7/2003 23:21''!!one	^ 1!! !!'! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 17:27'!expectedMethodDefinition	^ '!!MCMockClassA methodsFor: ''numeric'' stamp: ''cwp 8/2/2003 17:26''!!one	^ 1!! !!'! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:09'!expectedMethodDefinitionWithBangs	^'!!MCStWriterTest methodsFor: ''testing'' stamp: ''ar 1/4/2010 18:03''!!methodWithBangs	^ ''	^ ReadStream on: ''''MCRevisionInfo packageName: ''''MonticelloCompatibilityTest''''!!!!!!!!MCOrganizationDeclaration categories:   #(  ''''Tests-Monticello-Mocks'''')!!!!!!!!MCClassDeclaration  name: #MCMockClassD  superclassName: #Object  category: #''''Tests-Monticello-Mocks''''  instVarNames: #()  comment: ''''''''!!!!!!!!MCMethodDeclaration className: #MCMockClassD selector: #one category: #''''as yet unclassified'''' timeStamp: ''''cwp 7/8/2003 21:21'''' source: ''''one	^ 1''''!!!!!!!!''''''!! !!'! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 12:14'!expectedOrganizationDefinition	^ 'SystemOrganization addCategory: ''Monticello-Mocks''!!'! !!MCStWriterTest methodsFor: 'testing' stamp: 'ab 8/8/2003 17:01'!expectedInitializerA	^ 'MCMockClassA initialize'! !!MCStWriterTest methodsFor: 'testing' stamp: 'ar 1/4/2010 18:03'!methodWithBangs	^ '	^ ReadStream on: ''MCRevisionInfo packageName: ''MonticelloCompatibilityTest''!!!!MCOrganizationDeclaration categories:   #(  ''Tests-Monticello-Mocks'')!!!!MCClassDeclaration  name: #MCMockClassD  superclassName: #Object  category: #''Tests-Monticello-Mocks''  instVarNames: #()  comment: ''''!!!!MCMethodDeclaration className: #MCMockClassD selector: #one category: #''as yet unclassified'' timeStamp: ''cwp 7/8/2003 21:21'' source: ''one	^ 1''!!!!'''! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	stream := RWBinaryOrTextStream on: String new.	writer := MCStWriter on: stream.! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testClassDefinitionA	writer visitClassDefinition: (self mockClassA asClassDefinition).	self assertContentsOf: stream match: self expectedClassDefinitionA.	stream reset.	2 timesRepeat: [self assertChunkIsWellFormed: stream nextChunk]! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 9/14/2003 19:39'!testClassDefinitionB	writer visitClassDefinition: (self mockClassB asClassDefinition).	self assertContentsOf: stream match: self expectedClassDefinitionB.	! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testClassMethodDefinition	writer visitMethodDefinition: (MethodReference class: self mockClassA class selector: #one) 									asMethodDefinition.	self assertContentsOf: stream match: self expectedClassMethodDefinition.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testInitializerDefinition	|chunk lastChunk|	writer writeSnapshot: self mockSnapshot.	stream reset.	[stream atEnd] whileFalse:		[chunk := stream nextChunk.		chunk isAllSeparators ifFalse: [lastChunk := chunk]].	self assertContentsOf: lastChunk readStream match: self expectedInitializerA! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testMethodDefinition	writer visitMethodDefinition: (MethodReference class: self mockClassA selector: #one) 									asMethodDefinition.	self assertContentsOf: stream match: self expectedMethodDefinition.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/9/2003 14:52'!testMethodDefinitionWithBangs	writer visitMethodDefinition: (MethodReference 									class: self class 									selector: #methodWithBangs) asMethodDefinition.	self assertContentsOf: stream match: self expectedMethodDefinitionWithBangs.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testOrganizationDefinition	| definition |	definition := MCOrganizationDefinition categories: 					(self mockPackage packageInfo systemCategories).	writer visitOrganizationDefinition: definition.	self assertContentsOf: stream match: self expectedOrganizationDefinition.	self assertAllChunksAreWellFormed.! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 14:58'!assertPackage: actual matches: expected	self assert: actual = expected! !!MCTestCase methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertSnapshot: actual matches: expected	| diff |	diff := actual patchRelativeToBase: expected.	self assert: diff isEmpty! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 14:58'!assertVersion: actual matches: expected	self assertPackage: actual package matches: expected package.		self assertVersionInfo: actual info matches: expected info.	self assertSnapshot: actual snapshot matches: expected snapshot.! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 15:50'!assertVersionInfo: actual matches: expected	self assert: actual name = expected name.	self assert: actual message = expected message.	self assert: actual ancestors size = expected ancestors size.	actual ancestors with: expected ancestors do: [:a :e | self assertVersionInfo: a matches: e]	! !!MCTestCase methodsFor: 'compiling' stamp: 'cwp 8/10/2003 02:12'!change: aSelector toReturn: anObject	self 		compileClass: self mockClassA 		source: aSelector, ' ^ ', anObject printString 		category: 'numeric'! !!MCTestCase methodsFor: 'compiling' stamp: 'abc 2/16/2006 09:24'!compileClass: aClass source: source category: category	aClass compileSilently: source classified: category! !!MCTestCase methodsFor: 'compiling' stamp: 'cwp 8/2/2003 15:05'!restoreMocks	self mockSnapshot updatePackage: self mockPackage! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:51'!commentForClass: name	^ 'This is a comment for ', name! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:53'!commentStampForClass: name	^ 'tester-', name,  ' 1/1/2000 00:00'! !!MCTestCase methodsFor: 'mocks' stamp: 'ar 1/4/2010 18:02'!mockCategoryName	^ 'Tests-Monticello-Mocks'! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:50'!mockClass: className super: superclassName	^ MCClassDefinition		name:  className		superclassName:  superclassName		category: self mockCategoryName		instVarNames: #()		classVarNames: #()		poolDictionaryNames: #()		classInstVarNames: #()		type: #normal		comment: (self commentForClass: className)		commentStamp: (self commentStampForClass: className)! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 02:05'!mockClassA	^ Smalltalk at: #MCMockClassA! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 9/14/2003 19:39'!mockClassB	^ Smalltalk at: #MCMockClassB! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 1/19/2004 15:54'!mockDependencies	^ Array with: (MCVersionDependency package: self mockEmptyPackage info: (self mockVersionInfo: 'x'))! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/22/2004 14:08'!mockEmptyPackage	^ MCPackage named: (MCEmptyPackageInfo new packageName)! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/22/2004 13:56'!mockExtensionMethodCategory	^ MCMockPackageInfo new methodCategoryPrefix.! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 02:06'!mockInstanceA	^ self mockClassA new! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:24'!mockMessageString	^ 'A version generated for testing purposes.'! !!MCTestCase methodsFor: 'mocks' stamp: 'ab 4/1/2003 02:02'!mockMethod: aSymbol class: className source: sourceString meta: aBoolean	^ MCMethodDefinition		className: className		classIsMeta: aBoolean		selector:  aSymbol		category: 'as yet unclassified'		timeStamp: ''		source: sourceString! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/13/2003 13:24'!mockOverrideMethodCategory	^ self mockExtensionMethodCategory, '-override'! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/1/2003 20:27'!mockPackage	^ MCSnapshotResource mockPackage! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/14/2003 15:07'!mockSnapshot	^ MCSnapshotResource current snapshot! !!MCTestCase methodsFor: 'mocks' stamp: 'ab 1/15/2003 17:55'!mockToken: aSymbol	^ MCMockDefinition token: aSymbol! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:23'!mockVersion	^ MCVersion 		package: self mockPackage		info: self mockVersionInfo		snapshot: self mockSnapshot! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/12/2004 19:58'!mockVersionInfo	^ self treeFrom: #(d ((b ((a))) (c)))! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/12/2004 21:01'!mockVersionInfo: tag 	^ MCVersionInfo		name: self mockVersionName, '-', tag asString		id: UUID new		message: self mockMessageString, '-', tag asString		date: Date today		time: Time now		author: Utilities authorInitials 		ancestors: #()! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/6/2004 16:06'!mockVersionInfoWithAncestor: aVersionInfo 	^ MCVersionInfo		name: aVersionInfo name, '-child'		id: UUID new		message: self mockMessageString		date: Date today		time: Time now		author: Utilities authorInitials 		ancestors: {aVersionInfo}! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:25'!mockVersionName	^ 'MonticelloTest-xxx.1'! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/6/2004 16:03'!mockVersionWithAncestor: aMCVersion 	^ MCVersion		package: self mockPackage		info: (self mockVersionInfoWithAncestor: aMCVersion info)		snapshot: self mockSnapshot! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 1/19/2004 15:15'!mockVersionWithDependencies	^ MCVersion 		package: self mockPackage		info: self mockVersionInfo		snapshot: self mockSnapshot		dependencies: self mockDependencies! !!MCTestCase methodsFor: 'mocks' stamp: 'stephaneducasse 2/4/2006 20:47'!treeFrom: anArray	| name id |	name := anArray first.	id := '00000000-0000-0000-0000-0000000000', (name asString size = 1 ifTrue: [name asString, '0'] ifFalse: [name asString]).	^ MCVersionInfo		name: name		id: (UUID fromString: id)		message: ''		date: nil		time: nil		author: ''		ancestors: (anArray size > 1 ifTrue: [(anArray second collect: [:ea | self treeFrom: ea])] ifFalse: [#()])! !!MCTestCase class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:12'!isAbstract	^ self = MCTestCase! !!MCTestCase class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:05'!resources	^ Array with: MCSnapshotResource! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:24'!treeMorph: listSymbol	^ self		treeMorph: listSymbol		selection: listSymbol		menu: (listSymbol, 'TreeMenu:') asSymbol! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 17:46'!treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol	^self treeMorph: listSymbol selection: selectionSymbol menu: menuSymbol keystroke: nil! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2006 18:25'!treeMorph: treeSymbol selection: selectionSymbol menu: menuSymbol keystroke: keystrokeSymbol	| tree |	tree := builder pluggableTreeSpec new.	tree 		model: tool;		roots: (treeSymbol, 'TreeRoots') asSymbol;		setSelected: (selectionSymbol, ':') asSymbol;		getChildren: (treeSymbol,'TreeChildrenOf:') asSymbol;		label: (treeSymbol,'TreeLabelOf:') asSymbol;		frame: currentFrame.	menuSymbol ifNotNil: [tree menu: menuSymbol].	keystrokeSymbol ifNotNil: [tree keyPress: keystrokeSymbol].	window children add: tree! !!MCTweakFieldDoItParser methodsFor: 'parsing' stamp: 'bf 5/26/2005 19:06'!addDefinitionsTo: aCollection	| tokens def classDef |	tokens := Scanner new scanTokens: source.	(tokens size = 3 and:[tokens second == #defineFields:]) ifFalse:[		self error:'Field definition error'.	].	def := MCTweakFieldsDefinition new.	def className: tokens first.	def fields: tokens last.	classDef := aCollection detect: [:each| 		(each isClassDefinition) and:[each className = def className]	] ifNone: [nil].	classDef		ifNil: [ aCollection add: def ]			ifNotNil: [ aCollection add: def after: classDef ]! !!MCTweakFieldDoItParser class methodsFor: 'as yet unclassified' stamp: 'ar 7/30/2004 10:52'!pattern	^ '* defineFields: ''*'''! !!MCTweakFieldsDefinition methodsFor: 'comparing' stamp: 'bf 4/25/2005 14:56'!= aDefinition	^(super = aDefinition)		and: [aDefinition normalizedFields = self normalizedFields]! !!MCTweakFieldsDefinition methodsFor: 'comparing' stamp: 'bf 4/25/2005 13:26'!description	^ Array			with: className		with: #fields! !!MCTweakFieldsDefinition methodsFor: 'comparing' stamp: 'ar 7/31/2004 16:55'!sortKey	"Note: This must sort before MCMethodDefinition>>sortKey"	^className,'.fields'! !!MCTweakFieldsDefinition methodsFor: 'visiting' stamp: 'ar 7/31/2004 16:57'!accept: aVisitor	^ aVisitor visitTweakFieldDefinition: self! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:54'!actualClass	^Smalltalk at: className! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:54'!className	^className! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:54'!className: aString	className := aString! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:54'!fields	^fields! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:54'!fields: newFields	fields := newFields! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'bf 4/25/2005 14:55'!normalizedFields	^fields copyWithoutAll: (String with: Character cr with: Character tab)! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 16:57'!requirements	^Array with: className! !!MCTweakFieldsDefinition methodsFor: 'accessing' stamp: 'ar 7/31/2004 17:03'!source	^fields! !!MCTweakFieldsDefinition methodsFor: 'printing' stamp: 'bf 9/17/2004 17:20'!definitionString	^ String streamContents: [:stream | self printDefinitionOn: stream]! !!MCTweakFieldsDefinition methodsFor: 'printing' stamp: 'ar 7/31/2004 16:57'!printDefinitionOn: aStream	aStream nextPutAll: className; nextPutAll: ' defineFields: '; print: fields.! !!MCTweakFieldsDefinition methodsFor: 'printing' stamp: 'ar 7/31/2004 16:56'!summary	^className,'''s fields'! !!MCTweakFieldsDefinition methodsFor: 'testing' stamp: 'bf 11/12/2004 14:55'!isClassDefinitionExtension	^true! !!MCTweakFieldsDefinition methodsFor: 'installing' stamp: 'ar 5/4/2005 17:22'!load	| needRecompile existingFields |	"Ugly, ugly ... but MC often loads subclass methods before loading the field definition."	existingFields := Set withAll: self actualClass classFields.	needRecompile := fields anySatisfy:[:field| (existingFields includes: field) not].	self actualClass defineFields: fields.	needRecompile ifTrue:[self actualClass allSubclassesDo:[:each| each compileAll]].! !!MCVersionReader class methodsFor: 'file services' stamp: 'nk 2/25/2005 11:15'!serviceLoadVersion	^ (SimpleServiceEntry		provider: self		label: 'load version'		selector: #loadVersionStream:fromDirectory:		description: 'load a package version'		buttonLabel: 'load')		argumentGetter: [ :fileList | { fileList readOnlyStream . fileList directory } ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'nk 2/25/2005 11:16'!serviceMergeVersion	^ (SimpleServiceEntry		provider: self		label: 'merge version'		selector: #mergeVersionStream:		description: 'merge a package version into the image'		buttonLabel: 'merge')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'nk 2/25/2005 11:16'!serviceOpenVersion	^ (SimpleServiceEntry		provider: self		label: 'open version'		selector: #openVersionFromStream:		description: 'open a package version'		buttonLabel: 'open')		argumentGetter: [ :fileList | fileList readOnlyStream ]! !!MCVersionTest methodsFor: 'asserting' stamp: 'cwp 11/7/2004 14:32'!assert: aSelector orders: sexpr as: array	| expected |	expected := OrderedCollection new.	version := self versionFromTree: sexpr.	version perform: aSelector with: [:ea | expected add: ea info name].	self assert: expected asArray = array! !!MCVersionTest methodsFor: 'asserting' stamp: 'md 9/6/2005 18:41'!assert: aSelector orders: sexpr as: expected unresolved: unresolved	| missing |	missing := OrderedCollection new.	version := self versionFromTree: sexpr.	version 		perform: aSelector 		with: [:ea | visited add: ea info name]		with: [:ea | missing add: ea name].	self assert: visited asArray = expected.	self assert: missing asArray = unresolved.! !!MCVersionTest methodsFor: 'building' stamp: 'cwp 11/7/2004 12:29'!dependencyFromTree: sexpr	^ MCMockDependency fromTree: sexpr! !!MCVersionTest methodsFor: 'building' stamp: 'cwp 11/7/2004 12:40'!versionFromTree: sexpr	^ (self dependencyFromTree: sexpr) resolve! !!MCVersionTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	visited := OrderedCollection new.! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:53'!testAllAvailablePostOrder	self 		assert: #allAvailableDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:50'!testAllMissing	self 		assert: #allDependenciesDo: 		orders: #(a ((b (d e)) (c missing))) 		as: #(d e b)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:47'!testAllUnresolved	self 		assert: #allDependenciesDo:ifUnresolved: 		orders: #(a ((b (d e)) (c missing)))		as: #(d e b)		unresolved: #(c)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 13:55'!testDependencyOrder	self 		assert: #allDependenciesDo: 		orders: #(a (b c)) 		as: #(b c)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:25'!testPostOrder	self 		assert: #allDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:22'!testWithAll	self 		assert: #withAllDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c a)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:56'!testWithAllMissing	self 		assert: #withAllDependenciesDo: 		orders: #(a ((b (d e)) (c missing))) 		as: #(d e b a)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:29'!testWithAllUnresolved	self 		assert: #withAllDependenciesDo:ifUnresolved: 		orders: #(a ((b (d e)) (c missing)))		as: #(d e b a)		unresolved: #(c)! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'bf 11/7/2005 11:37'!addAncestor: aNode	"Add aNode, remove ancestors of it, preserve original order"	| writeNode |	writeNode := true.	"Write aNode only once, replacing the first of its ancestors, or add last"	ancestors := Array streamContents: [:newAncestors |		self ancestors do: [:each |			(aNode hasAncestor: each)				ifTrue: [writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]]				ifFalse: [newAncestors nextPut: each]].		writeNode ifTrue: [newAncestors nextPut: aNode. writeNode := false]].! !!MCWorkingAncestry methodsFor: 'as yet unclassified' stamp: 'avi 10/22/2005 19:58'!date	^ Date today! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21'!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 11/4/2005 17:46'!addPackageRepository	workingCopy ifNotNil:		[		(self pickRepositorySatisfying: [ :repos | (workingCopy repositoryGroup includes: repos) not ])			ifNotNilDo:				[:repos |					workingCopy repositoryGroup addRepository: repos.					self repository: repos.						self						changed: #repositoryList;						changed: #repositorySelection.					self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 3/6/2006 18:28'!addWorkingCopy	|name|	name := UIManager default request: 'Name of package:'.	name isEmptyOrNil ifFalse:		[PackageInfo registerPackageName: name.		workingCopy := MCWorkingCopy forPackage: (MCPackage new name: name).		workingCopyWrapper := nil.		self repositorySelection: 0].	self workingCopyListChanged; changed: #workingCopySelection; changed: #repositoryList.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ar 11/4/2005 16:57'!flushPasswords	MCRepository allSubInstancesDo:[:repo| repo flushPasswords].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'jcg 5/22/2008 17:55'!recompilePackages: collectionOfPackages	collectionOfPackages 		do: [:pkg | pkg recompile] 		displayingProgress: 'Recompiling...'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'jcg 5/23/2008 11:12'!recompilePackagesMatchingPattern	"Get a pattern from a dialog, and recompile all packages matching it."	| pattern |	pattern := UIManager default							request: 'Pattern for matching package names?'							initialAnswer: '*'.	pattern isEmpty ifTrue: [^nil].	self recompilePackagesWhoseNameMatches: pattern	! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'jcg 5/22/2008 17:57'!recompilePackagesWhoseNameMatches: patternString	"Uses same match algorithm as String>>match:"	"This isn't hooked up to a UI (yet), but you might use it like this:1. bring up a halo on a Monticello Browser2. click the debug handle (the light grey one with the wrench)3. select 'inspect model'4. in the inspector, evaluate:  self recompilePackagesWhoseNameMatches: 'Croquet-*'    "	| pkgs |	pkgs := self workingCopies 					collect: [:wc | wc package] 					thenSelect: [:pkg | patternString match: pkg name].	self recompilePackages: pkgs.! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'bf 1/27/2006 18:31'!showFeed	| parser xml text |	parser := Smalltalk at: #XMLDOMParser		ifAbsent: [^self inform: 'Yaxo not installed'].	Cursor wait showWhile: [		xml := self repository readStreamForFileNamed: 'feed.rss'			do: [:stream | parser parseDocumentFrom: stream ]].	xml ifNil: [^self inform: 'feed.rss not found'].	text := Text streamContents: [:stream |		xml tagsNamed: #item do: [:item |			#(title bold author italic pubDate normal description normal) pairsDo: [:tag :attr |				stream withAttribute: (TextEmphasis perform: attr) do: [					item tagsNamed: tag do: [:element | 						stream nextPutAll: (element contentString							copyReplaceAll: '<br/>' with: String cr) ; space]].				attr = #normal ifTrue: [stream cr]]]].	UIManager default edit: text label: 'Feed: ', self repository description! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'avi 10/22/2005 19:34'!trimAncestry	self pickAncestorVersionInfo ifNotNilDo:		[:ancestor |		workingCopy ancestry trimAfterVersionInfo: ancestor]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'tpr 2/2/2006 19:11'!viewChanges	| patch |	'Finding changes' displayProgressAt: Sensor cursorPoint from: 0 to: 10 during:[:bar|		self canSave ifTrue:[		bar value: 1.		patch := workingCopy changesRelativeToRepository: self repository].		patch isNil ifTrue: [^ self].		bar value:3.		patch isEmpty			ifTrue: [ workingCopy modified: false.				bar value: 10.				self inform: 'No changes' ]			ifFalse:				[ workingCopy modified: true.				bar value: 5.				(MCPatchBrowser forPatch: patch)					label: 'Patch Browser: ', workingCopy description;					show]]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 3/6/2006 18:16'!pickRepositorySatisfying: aBlock	| repos index |	repos := MCRepositoryGroup default repositories select: aBlock.	index := UIManager default chooseFrom: (repos collect: [:ea | ea description])				title: 'Repository:'.	^ index = 0 ifFalse: [repos at: index]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 1/27/2006 18:29'!repositoryListMenu: aMenu	self repository ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('open repository' #openRepository)		    ('edit repository info' #editRepository)		   ('add to package...' #addRepositoryToPackage)		   ('show feed' #showFeed)		   ('remove repository' #removeRepository)			   ('load repositories' #loadRepositories)			   ('save repositories' #saveRepositories)		   ('flush cached versions' #flushAllCaches)			   ('flush passwords' #flushPasswords)			).		aMenu		add: (self repository alwaysStoreDiffs					ifTrue: ['store full versions']					ifFalse: ['store diffs'])		target: self		selector: #toggleDiffs.	^ aMenu				! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:30'!workingCopyListChanged	self changed: #workingCopyList.	self changed: #workingCopyTree.	self changed: #workingCopyTreeRoots.	self changedButtons.! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'bf 11/4/2005 17:34'!workingCopyListMenu: aMenu	workingCopy ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('add repository...' #addPackageRepository)			('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)			('recompile package' #recompilePackage)			('revert package...' #revertPackage)			('trim ancestry' #trimAncestry)			('unload package' #unloadPackage)			('delete working copy' #deleteWorkingCopy)).	(Smalltalk includesKey: #SARMCPackageDumper) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:10'!workingCopyTreeChildrenOf: aWorkingCopy	| workingCopies |	workingCopies := self unsortedWorkingCopies.	^aWorkingCopy requiredPackages collect:[:each | 			workingCopies detect: [:wc | wc package = each] ifNone: [nil]]			thenSelect: [:x | x notNil].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:15'!workingCopyTreeLabelOf: aWorkingCopy	^aWorkingCopy description! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'jcg 5/23/2008 11:12'!workingCopyTreeMenu: aMenu	| specs | 	specs := workingCopy			ifNil:  [#(('recompile packages matching...' #recompilePackagesMatchingPattern))]			ifNotNil: [				#(('add required package' #addRequiredPackage)				('clear required packages' #clearRequiredPackages)				('add repository...' #addPackageRepository)				('browse package' #browseWorkingCopy)				('view changes' #viewChanges)				('view history' #viewHistory)				('recompile package' #recompilePackage)				('revert package...' #revertPackage)				('unload package' #unloadPackage)				('trim ancestry' #trimAncestry)				('delete working copy' #deleteWorkingCopy)				('inspect working copy' #inspectWorkingCopy))			].	self fillMenu: aMenu fromSpecs: specs.	(workingCopy notNil and: [Smalltalk includesKey: #SARMCPackageDumper]) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	^aMenu! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'ar 2/23/2006 18:18'!workingCopyTreeRoots	^self workingCopies! !!MCWorkingCopyTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNameWhenSavingTo: aRepository is: aString	| name |	name := nil.	[aRepository storeVersion: workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | name := n suggestedName. n resume: (Array with: name with: '')].	self assert: name = aString! !!MCWorkingCopyTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNumberWhenSavingTo: aRepository is: aNumber	| name |	name := nil.	[aRepository storeVersion: workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | name := n suggestedName. n resume: (Array with: name with: '')].	self assert: name = (self packageName, '-', Utilities authorInitials, '.', aNumber asString)! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'avi 2/13/2004 14:30'!basicMerge: aVersion	aVersion merge! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'avi 1/24/2004 20:13'!load: aVersion	aVersion load! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'jf 8/21/2003 20:22'!merge: aVersion	[[self basicMerge: aVersion]		on: MCMergeResolutionRequest do: [:n | n resume: true]]			on: MCNoChangesException do: [:n | ]! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!snapshot	| version |	[version := workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | n resume: (Array with: n suggestedName with: '')].	versions at: version info put: version.	^ version! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!clearPackageCache	| dir |	dir := MCCacheRepository default directory.	(dir fileNamesMatching: 'MonticelloMocks*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'MonticelloTest*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'rev*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'foo-*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'foo2-*') do: [:ea | dir deleteFileNamed: ea].! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	| repos1 repos2 |	self clearPackageCache.	repositoryGroup := MCRepositoryGroup new.	workingCopy := MCWorkingCopy forPackage: self mockPackage.	versions := Dictionary new.	versions2 := Dictionary new.	repos1 := MCDictionaryRepository new dictionary: versions.	repos2 := MCDictionaryRepository new dictionary: versions2.	repositoryGroup addRepository: repos1.	repositoryGroup addRepository: repos2.	MCRepositoryGroup default removeRepository: repos1; removeRepository: repos2.	workingCopy repositoryGroup: repositoryGroup.	savedInitials := Utilities authorInitials.	Utilities setAuthorInitials: 'abc'.! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'avi 2/10/2004 12:30'!tearDown	workingCopy unregister.	self restoreMocks.	self clearPackageCache.	Utilities setAuthorInitials: savedInitials.! !!MCWorkingCopyTest methodsFor: 'accessing' stamp: 'ab 7/7/2003 18:02'!description	^ self class name! !!MCWorkingCopyTest methodsFor: 'private' stamp: 'cwp 8/2/2003 15:03'!packageName	^ self mockPackage name! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testAncestorMerge	| base revA revB revC |	base := self snapshot.	self change: #a toReturn: 'a1'.	revA :=  self snapshot.	self change: #b toReturn: 'b1'.	revB :=  self snapshot.		self change: #c toReturn: 'c1'.	revC :=  self snapshot.		self should: [self basicMerge: revA] raise: MCNoChangesException.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testBackport	| inst base final backported |	inst := self mockInstanceA.	base :=  self snapshot.	self assert: inst one = 1.	self change: #one toReturn: 2.	self change: #two toReturn: 3.	final := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | e resume: e patch].	self assert: inst one = 2.	self assert: inst two = 3.	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = final info.	backported := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | e resume: e patch].	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = backported info.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMergeIntoImageWithNoChanges	| base revB revA1 |	self change: #a toReturn: 'a'.	base := self snapshot.	self change: #b toReturn: 'b'.	revB := self snapshot.		self load: base.	self change: #a toReturn: 'a1'.	revA1 := self snapshot.	self change: #a toReturn: 'a'.	self snapshot.	self merge: revB.	self assert: (workingCopy ancestors size = 2)	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMergeIntoUnmodifiedImage	| base revA |	base := self snapshot.	self change: #a toReturn: 'a1'.	revA := self snapshot.		self load: base.	self merge: revA.	self assert: (workingCopy ancestors size = 1)	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testOptimizedLoad	| inst base diffy |	inst := self mockInstanceA.	base := self snapshot.	self change: #one toReturn: 2.	self assert: inst one = 2.	diffy := self snapshot asDiffAgainst: base.	self deny: diffy canOptimizeLoading.	self load: base.	self assert: inst one = 1.	self assert: diffy canOptimizeLoading.	self load: diffy.	self assert: inst one = 2.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testRedundantMerge	| base |	base :=  self snapshot.	self merge: base.	self shouldnt: [self merge: base] raise: Error.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testRepeatedMerge	| base mother1 mother2 inst |	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testSelectiveBackport	| inst base intermediate final |	inst := self mockInstanceA.	base :=  self snapshot.	self assert: inst one = 1.	self change: #one toReturn: 2.	intermediate := self snapshot.	self change: #two toReturn: 3.	final := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | | selected patch |			patch := e patch.			selected := patch operations select: [:ea | ea definition selector = #two].			e resume: (MCPatch operations: selected)]. 	self assert: inst one = 1.	self assert: inst two = 3.	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = final info! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSimpleMerge	| mother base inst |	inst := self mockInstanceA.	base :=  self snapshot.	self change: #one toReturn: 2.	mother :=  self snapshot.	self load: base.	self change: #two toReturn: 3.	self snapshot.	self assert: inst one = 1.	self assert: inst two = 3.		self merge: mother.	self assert: inst one = 2.	self assert: inst two = 3.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSnapshotAndLoad	| base inst |	inst := self mockInstanceA.	base :=  self snapshot.	self change: #one toReturn: 2.	self assert: inst one = 2.	self load: base.	self assert: inst one = 1.! !!MIMEDocument methodsFor: 'accessing' stamp: 'hrs 4/2/2009 15:36'!parts	"Return the parts of this message.  There is a far more reliable implementation of parts in MailMessage, but for now we are continuing to use this implementation"	| parseStream currLine separator msgStream messages |	self isMultipart ifFalse: [^ #()].	parseStream := ReadStream on: self content.	currLine := ''.	['--*' match: currLine]		whileFalse: [currLine := parseStream nextLine].		"Subtle: The MIME doc might use CR or CRLF for its text parts, but we can't globally change	things because there might be binary data within a part. Here we are using the unique long	boundary tag to figure out how to divide up the message.  Alas, LimitingLineStreamWrapper	will be reading (and preserving) a line at a time based on CR termination, which will leave an	LF at the start of the NEXT line, and so it will not be able to match against a separator	that is assumed to start the line.  So here's what we do: If the next character AFTER reading	the border line and its terminating CR is a LF, then we assume that all the border lines	will BEGIN with a LF from the previous termination, and LimitingLineStreamWrapper will	be able to find it if we cons a LF on to the BEGINNING of the string it is searching for.	This has no effect on parsing MIME content that is not CRLF, nor on LimitingLineStreamWrapper."	separator := parseStream peek = Character lf ifTrue: [String lf, currLine] ifFalse: [currLine copy].	msgStream := LimitingLineStreamWrapper on: parseStream delimiter: separator.	messages := OrderedCollection new.	[parseStream atEnd]		whileFalse: 			[messages add: msgStream upToEnd.			msgStream skipThisLine].	"LimitingLineStreamWrapper adds a CR to each line. That's right and proper for headers,	but not so good for the last line, which might be binary data. Here we remove it	before turning it over to MailMessage."	^ messages collect: [:e | MailMessage from: e allButLast.]! !!MIMEDocument class methodsFor: 'initialize-release' stamp: 'hrs 6/10/2009 16:58'!extendedMIMEdatabase	| d |	(d := self defaultMIMEdatabase)	at: 'hqx' put: 'application/mac-binhex40';	at: 'cpt' put: 'application/mac-compactpro';	at: 'pdf' put: 'application/pdf';	at: 'ps' put: 'application/postscript';	at: 'ai' put: 'application/postscript';	at: 'eps' put: 'application/postscript';	at: 'rtf' put: 'text/rtf';	at: 'bin' put: 'application/octet-stream';	at: 'dms' put: 'application/octet-stream';	at: 'lha' put: 'application/octet-stream';	at: 'lzh' put: 'application/octet-stream';	at: 'exe' put: 'application/octet-stream';	at: 'class' put: 'application/octet-stream';	at: 'doc' put: 'application/msword';	at: 'pptx' put: 'application/vnd.openxmlformats-officedocument.presentationml.presentation';	at: 'xlsx' put: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';	at: 'docx' put: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';	at: 'ppt' put: 'application/vnd.ms-powerpoint';	at: 'xls' put: 'application/vnd.ms-excel';	at: 'zip' put: 'application/zip';	at: 'gtar' put: 'application/x-gtar';	at: 'swf' put: 'application/x-shockwave-flash';	at: 'sit' put: 'application/x-stuffit';	at: 'tar' put: 'application/x-tar';	at: 'au' put: 'audio/basic';	at: 'snd' put: 'audio/basic';	at: 'mid' put: 'audio/midi';	at: 'midi' put: 'audio/midi';	at: 'mpga' put: 'audio/mpeg';	at: 'mp2' put: 'audio/mpeg';	at: 'mp3' put: 'audio/mpeg';	at: 'aiff' put: 'audio/x-aiff';	at: 'aif' put: 'audio/x-aiff';	at: 'aifc' put: 'audio/x-aiff';	at: 'rm' put: 'audio/x-pn-realaudio';	at: 'ram' put: 'audio/x-pn-realaudio';	at: 'rpm' put: 'audio/x-pn-realaudio-plugin';	at: 'ra' put: 'audio/x-realaudio';	at: 'wav' put: 'audio/x-wav';	at: 'ico' put: 'image/vnd.microsoft.icon';	at: 'ics' put: 'text/calendar';	at: 'css' put: 'text/css';	at: 'text' put: 'text/plain';	at: 'mp4' put: 'video/mp4';	at: 'mpeg' put: 'video/mpeg';	at: 'mpg' put: 'video/mpeg';	at: 'mpe' put: 'video/mpeg';	at: 'qt' put: 'video/quicktime';	at: 'mov' put: 'video/quicktime';	at: 'm4v' put: 'video/x-m4v';	at: 'avi' put: 'video/x-msvideo';	at: 'movie' put: 'video/x-sgi-movie'.	^d! !!MPEGFile methodsFor: 'audio' stamp: 'jm 11/17/2001 08:18'!audioChannels: aStream	"Returns -1 if error, otherwise returns audioChannels for stream aStream"	self hasAudio ifFalse: [^ 0].	^[self primAudioChannels: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioGetSample: aStream	"Returns number of current sample, or -1 if error"	self hasAudio ifFalse: [^-1].	^[(self primGetSample: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:36'!audioPlayerForChannel: channelNumber	"Answer a streaming sound for playing the audio channel with the given index."	"Note: The MP3 player can not yet isolate a single channel from a multi-channel audio stream."	^ StreamingMP3Sound new initMPEGFile: self streamIndex: 0! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size * aBuffer bytesPerElement // 2)] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber 	"Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size* aBuffer bytesPerElement)//2] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSampleRate: aStream	"Returns sample rate, or -1 if error"	self hasAudio ifFalse: [^-1].	^[self primSampleRate: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSamples: aStream	"Returns -1 if error, 	otherwise returns audioSamples for stream aStream"	self hasAudio ifFalse: [^-1].	^[(self primAudioSamples: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 11/21/2000 13:13'!audioSetSample: aNumber stream: aStream	"Set number of targeted sample, returns 0 if ok, -1 if failure"	self hasAudio ifFalse: [^-1].	^[self primSetSample: self fileHandle sample: aNumber asFloat stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:57'!endOfAudio: aStream	"Returns true if end of Audio"	self hasAudio ifFalse: [^true].	^self primEndOfAudio: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:56'!hasAudio	"Returns true if file has audio"	^self primHasAudio: self fileHandle ! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:53'!totalAudioStreams	"Returns total number of audio streams"	^self primTotalAudioStreams: self fileHandle ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 1/20/2006 18:12'!buffer	^buffer! !!MPEGFile methodsFor: 'access' stamp: 'yo 7/2/2004 15:58'!endianness	^endianness isNil 		ifTrue: [endianness := SmalltalkImage current endianness] 		ifFalse: [endianness]! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 19:04'!fileHandle	(Smalltalk externalObjects at: fileIndex ifAbsent: [^nil]) == fileBits 		ifTrue: [^fileBits]		ifFalse: [^nil].! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/18/2000 18:38'!fileName	^pathToFile! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:54'!getPercentage	"Return current location by percentage, 0.0-1.0"	^self primGetPercentage: self fileHandle ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/29/2000 19:28'!getTOC: timecode doStreams: streams	| buffer |		buffer := String new: 64*1024+1.	self primGenerateToc: self fileHandle useSearch: timecode doStreams: streams buffer: buffer.	^buffer! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!getTimeCode	"Return time code, (float) "	^self primGetTime: self fileHandle! !!MPEGFile methodsFor: 'access' stamp: 'JMM 1/20/2006 23:15'!isBufferBased	^(buffer == nil) not ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:53'!seekPercentage: aFloat	self primSeekPercentage: self fileHandle percentage: aFloat asFloat ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!setMMX: aValue	" true is set, false is off. May not be supported "	self primSetMMX: self fileHandle useMMX: aValue  ! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 01:59'!closeFile	self finalize.! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 1/20/2006 18:11'!openBuffer: aByteArray	pathToFile := nil.	buffer := aByteArray.	fileBits := self primFileOpenABuffer: aByteArray size: aByteArray size.	fileBits notNil ifTrue: 		[fileIndex := Smalltalk registerExternalObject: fileBits.		self register.]	! !!MPEGFile methodsFor: 'initialize-release' stamp: 'bgf 5/12/2006 16:10'!openBuffer: aByteArray path: aPath	pathToFile := aPath.	buffer := aByteArray.	fileBits := self primFileOpenABuffer: aByteArray size: aByteArray size.	fileBits notNil ifTrue: 		[fileIndex := Smalltalk registerExternalObject: fileBits.		self register.]	! !!MPEGFile methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 01:57'!openFile: aPath	pathToFile := aPath.	fileBits := self primFileOpen: aPath.	fileBits notNil ifTrue: 		[fileIndex := Smalltalk registerExternalObject: fileBits.		self register.]	! !!MPEGFile methodsFor: 'converting' stamp: 'dgd 2/16/2004 14:19'!convertToSqueakMovieFileNamed: fileName 	"convert the receiver to a squeak-format movie"	" 	(MPEGFile openFile:	'/H/squeak/Small-Land/Demo/media/mazinger:=z:=spanish:=op.mpg') 	convertToSqueakMovieFileNamed: 'MazingerZ.squeakmovie' 	"	| movieFile max w h d frameBuffer |	movieFile := FileStream newFileNamed: fileName.	[movieFile binary.	"no idea what goes here..."	movieFile nextInt32Put: 0.	movieFile nextInt32Put: (w := self videoFrameWidth: 0).	movieFile nextInt32Put: (h := self videoFrameHeight: 0).	"Depth of form data stored"	"we really don't know but try to preserve some space"	movieFile nextInt32Put: (d := 16).	movieFile nextInt32Put: (max := self videoFrames: 0).	"min: 100"	movieFile nextInt32Put: (1000 * 1000			/ (self videoFrameRate: 0)) rounded.	"Padding?"	movieFile		nextPutAll: (ByteArray new: 128 - movieFile position).	frameBuffer := Form extent: w @ h depth: d.	self videoSetFrame: 1 stream: 0.	'Converting movie...'		displayProgressAt: Sensor cursorPoint		from: 1		to: max		during: [:bar | 1				to: max				do: [:i | 					bar value: i.					self videoReadFrameInto: frameBuffer stream: 0.					frameBuffer display.					movieFile nextInt32Put: i.					movieFile nextPutAll: frameBuffer bits]]]		ensure: [movieFile close]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!endOfVideo: aStream	"Returns true if end of video"	self hasVideo ifFalse: [^true].	^self primEndOfVideo: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!hasVideo	"Returns true if file has video"	^self primHasVideo: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:59'!totalVideoStreams	"Returns total number of video streams"	^self primTotalVideoStreams: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoDropFrames: aNumberOfFrames stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primDropFrame: self fileHandle frame: aNumberOfFrames stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameHeight: aStream	"Returns video frame height, -1 if error "	self hasVideo ifFalse: [^-1].	^[self primVideoHeight: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameRate: aStream	"Returns video frame rate (float), -1 if error"	self hasVideo ifFalse: [^-1].	^[self primFrameRate: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoFrameWidth: aStream	"Returns video frame width, -1 if error"	self hasVideo ifFalse: [^-1].	^[self primVideoWidth: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoFrames: aStream	"Total number of frames" 	^(self primVideoFrames: self fileHandle stream: aStream) asInteger! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:14'!videoGetFrame: aStream	"Returns frame number, or -1 if error"	self hasVideo ifFalse: [^-1].	^[(self primGetFrame: self fileHandle stream: aStream) asInteger] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoPreviousFrame: aStream	"Returns 0 if ok"	self hasVideo ifFalse: [^-1].	^[self primPreviousFrame: self fileHandle stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 11/16/2001 07:53'!videoReadFrameInto: aForm stream: aStream	"Read the next video frame from the given stream into the given 16- or 32-bit Form. The movie frame will be scaled to fit the Form if necessary."	| colorModel bytesPerRow |	((aForm depth = 16) | (aForm depth = 32)) ifFalse: [self error: 'must use 16- or 32-bit Form'].	aForm depth = 16		ifTrue: [			colorModel := self endianness = #big ifTrue: [14] ifFalse: [16].			bytesPerRow := 2 * (aForm width roundUpTo: 2)]		ifFalse: [			colorModel := self endianness = #big ifTrue: [13] ifFalse: [1].			bytesPerRow := 4 * aForm width]. 	^ self		videoReadNextFrameInto: aForm bits		x: 0 y: 0		width: (self videoFrameWidth: aStream)		height: (self videoFrameHeight: aStream)		outWidth: aForm width		outHeight: aForm height		colorModel: colorModel		stream: aStream		bytesPerRow: bytesPerRow! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoReadNextFrameInto: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	"return nonZero if failure "	self hasVideo ifFalse: [^-1].	^[self primVideoReadNextFrameFor: self fileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount] on: Error do: [-1]"/* Supported color models for mpeg3:=read:=frame */#define MPEG3:=RGB565 2#define MPEG3:=RGB555 14  //JMM for mac#define MPEG3:=RGBI555 16  //SVP for intel#define MPEG3:=BGR888 0#define MPEG3:=BGRA8888 1#define MPEG3:=RGB888 3#define MPEG3:=RGBA8888 4  #define MPEG3:=ARGB8888 13  //JMM for mac#define MPEG3:=RGBA16161616 5/* Color models for the 601 to RGB conversion *//* 601 not implemented for scalar code */#define MPEG3:=601:=RGB565 11#define MPEG3:=601:=RGB555 15 //JMM for Squeak#define MPEG3:=601:=RGBI555 17 //SVP for intel#define MPEG3:=601:=BGR888 7#define MPEG3:=601:=BGRA8888 8#define MPEG3:=601:=RGB888 9#define MPEG3:=601:=RGBA8888 10#define MPEG3:=601:=ARGB8888 12 //JMM for Squeak"! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoSetCPUs: aNumber	self primSetCPUs: self fileHandle number: aNumber! !!MPEGFile methodsFor: 'video' stamp: 'JMM 11/21/2000 13:15'!videoSetFrame: aFrameNumber stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primSetFrame: self fileHandle frame: aFrameNumber asFloat stream: aStream] on: Error do: [-1]! !!MPEGFile methodsFor: 'file ops' stamp: 'bgf 7/3/2009 20:20'!finalize	[		self fileHandle notNil ifTrue: [self primFileClose: self fileHandle].	] on: Error do: [ :ex| Transcript cr; show: 'MPG File primClose ', (ex description) ].	[		self fileHandle = fileBits ifTrue: [Smalltalk unregisterExternalObject: fileIndex].	] on: Error do: [ :ex| Transcript cr; show: 'MPG File unregister ', (ex description) ].	fileBits := nil.		fileIndex := 0.! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:19'!primAudioChannels: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioChannels' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:35'!primAudioReReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:31'!primAudioReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:23'!primAudioSamples: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioSamples' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 17:54'!primDropFrame: aHandle frame: aNumberOfFrames stream: aStream	<primitive: 'primitiveMPEG3DropFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:50'!primEndOfAudio: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:51'!primEndOfVideo: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 13:58'!primFileClose: aHandle	"Close the file"	<primitive: 'primitiveMPEG3Close' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 03:56'!primFileOpen: aPath	"Open the file"	<primitive: 'primitiveMPEG3Open' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 1/20/2006 17:52'!primFileOpenABuffer: buffer size: aSize	"Open the file"	<primitive: 'primitiveMPEG3OpenABuffer' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:52'!primFrameRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3FrameRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/29/2000 17:29'!primGenerateToc: fileHandle useSearch: timecode doStreams: streams buffer: aString	<primitive: 'primitiveMPEG3GenerateToc' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:11'!primGetFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:37'!primGetPercentage: aHandle	<primitive: 'primitiveMPEG3TellPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:12'!primGetSample: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:15'!primGetTime: aFileHandle	<primitive: 'primitiveMPEG3GetTime' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasAudio: aHandle	<primitive: 'primitiveMPEG3HasAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasVideo: aHandle	<primitive: 'primitiveMPEG3HasVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:17'!primPreviousFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3PreviousFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:19'!primSampleRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3SampleRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:23'!primSeekPercentage: aHandle percentage: aNumber	<primitive: 'primitiveMPEG3SeekPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:27'!primSetCPUs: aHandle number: aNumber	"Not support on the macintosh below OS X"	<primitive: 'primitiveMPEG3SetCpus' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:29'!primSetFrame: aHandle frame: aFrameNumber stream: aStream	<primitive: 'primitiveMPEG3SetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:31'!primSetMMX: aFileHandle useMMX: aValue  	<primitive: 'primitiveMPEG3SetMmx' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:35'!primSetSample: aHandle sample: aSampleNumber stream: aStream	<primitive: 'primitiveMPEG3SetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:39'!primTotalAudioStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalAStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:40'!primTotalVideoStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalVStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoFrames: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoHeight: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoHeight' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 2/26/2006 13:08'!primVideoReadNextFrameFor: aFileHandle into: aFormBuffer offset: aBufferOffsetInBytes x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	<primitive: 'primitiveMPEG3ReadFrameBufferOffset' module: 'Mpeg3Plugin'>! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:28'!primVideoReadNextFrameFor: aFileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	<primitive: 'primitiveMPEG3ReadFrame' module: 'Mpeg3Plugin'>! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 16:35'!primVideoWidth: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoWidth' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'private' stamp: 'JMM 9/17/2000 23:58'!register	^self class register: self! !!MPEGFile methodsFor: 'private' stamp: 'JMM 9/17/2000 23:58'!unregister	^self class unregister: self! !!MPEGFile commentStamp: '<historical>' prior: 0!* An interface to LibMPEG3 * Author: Adam Williams <broadcast@earthling.net> * Page: heroine.linuxbox.com * * Changed for Squeak to work with Squeak and to work on the Macintosh * Sept 2000, by John M McIntosh johnmci@smalltalkconsulting.com * The smalltalk code and the C code it produces is released under the  * Squeak licence. The libmpeg3 C code is co-licenced under either the Squeak licence or * the GNU LGPL!!MPEGFile class methodsFor: 'testing' stamp: 'JMM 9/18/2000 14:28'!isFileValidMPEG: path	^self primFileValidMPEG: path! !!MPEGFile class methodsFor: 'instance creation' stamp: 'JMM 1/20/2006 18:18'!openBuffer: aBuffer 	^self new openBuffer: aBuffer! !!MPEGFile class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 21:50'!openFile: aPath 	^self new openFile: aPath! !!MPEGFile class methodsFor: 'instance creation' stamp: 'bgf 11/1/2006 17:14'!openFileUseBuffer: aPath 	| file bytes |	file := StandardFileStream readOnlyFileNamed: aPath.	file binary.	bytes := file contents.	file close.	^self new openBuffer: bytes path: aPath! !!MPEGFile class methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:27'!primFileValidMPEG: aPath	"Check to see if the file is valid"	<primitive: 'primitiveMPEG3CheckSig' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!audioChannels: aStream	^self external audioChannels: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!audioSampleRate: aStream	^self external audioSampleRate: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!audioSamples: aStream	^self external audioSamples: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/13/2000 20:05'!currentExternalLocationInPercent	"Warning this might not return what you want, it gets percentage based on audio, or video stream based on last usage, because we buffer audio it may give incorrect information when playing mpeg movies"	^self external getPercentage! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/13/2000 20:09'!currentLocationInPercent: aStream	self hasVideo ifTrue: [^ ((self currentVideoFrameForStream: aStream)/(self videoFrames: aStream)) asFloat].	self hasAudio ifTrue: [^ ((self currentAudioSampleForStream: aStream)/(self audioSamples: aStream)) asFloat].! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:32'!endOfAudio: aStream	^self external endOfAudio: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!endOfVideo: aStream	^self external endOfVideo: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!getTOC: timecode doStreams: streams	^self external getTOC: timecode doStreams: streams! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!getTimeCode	^self external getTimeCode! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!hasAudio	^self external hasAudio	! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!hasVideo	^self external hasVideo! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:31'!setMMX: aBoolean	self external setMMX: aBoolean! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!totalVideoStreams	^self external totalVideoStreams! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:32'!videoDropFrames: aNumberOfFrames stream: aStream	^self external videoDropFrames: aNumberOfFrames stream: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:30'!videoFrameHeight: aStream	^self external videoFrameHeight: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!videoFrameRate: aStream	^self external videoFrameRate: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:29'!videoFrameWidth: aStream	^self external videoFrameWidth: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoFrames: aStream	^self external videoFrames: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoPreviousFrame: aStream	^self external videoPreviousFrame: aStream! !!MPEGPlayer methodsFor: 'access to attributes' stamp: 'JMM 11/8/2000 10:33'!videoSetCPUs: aNumber	^self external videoSetCPUs: aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!audioPlayerProcess	^audioPlayerProcess ! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:39'!audioPlayerProcess: aProcess	audioPlayerProcess := aProcess! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBias	^clockBias! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBias: aArray	clockBias := aArray! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:31'!clockBiasForStream: aStream	^self clockBias at: aStream + 1.! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:32'!clockBiasForStream: aStream put: aValue	self clockBias at: aStream + 1 put: aValue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:30'!currentAudioSampleForStream: aStream	^self external audioGetSample: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:31'!currentAudioSampleForStream: aStream put: aNumber	self external audioSetSample: aNumber stream: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:29'!currentVideoFrameForStream: aStream	^self external videoGetFrame: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:30'!currentVideoFrameForStream: aStream put: aNumber	self external videoSetFrame: aNumber stream: aStream! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 18:33'!errorForSoundStart: aValueInMilliseconds	errorForSoundStart := aValueInMilliseconds! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 1/20/2006 18:10'!external	[external hasVideo] on: Error do: 		[self isBuffer			ifTrue:			[external := MPEGFile openBuffer: external buffer]			ifFalse: 				[(MPEGFile isFileValidMPEG: external fileName) 					ifFalse: [^self error: 'Mpeg File is invalid'].				external := MPEGFile openFile: external fileName]].	^external! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 11/8/2000 10:31'!fileName	^self external fileName! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:29'!form	form isNil ifTrue: 		[self morph isNil ifTrue: [^nil].		^self morph form].	^form! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:37'!form: aForm	form := aForm! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:39'!frameRate	^frameRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:36'!frameRate: aRate	frameRate := aRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 1/20/2006 18:05'!isBuffer	^isBuffer == true! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:04'!lastDelay	^lastDelay! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:03'!lastDelay: aNumber	lastDelay := aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:20'!morph	^morph! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/17/2000 23:20'!morph: aMorph		morph := aMorph.! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 10/20/2000 22:36'!mpegFile	^external! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!noSound	^noSound! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:59'!noSound: flag	noSound := flag! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:59'!playerProcessPriority	^playerProcessPriority! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:59'!playerProcessPriority: aNumber	playerProcessPriority := aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/19/2000 17:34'!sampleRate	^sampleRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:36'!sampleRate: aRate	sampleRate := aRate! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:01'!soundQueue	^soundQueue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:01'!soundQueue: aQueue	soundQueue := aQueue! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:38'!startTime	^startTime! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:38'!startTime: aArray	startTime := aArray! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:12'!startTimeForStream: aStream	^self startTime at: aStream + 1! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 15:11'!startTimeForStream: aStream put: aNumber	^self startTime at: aStream + 1 put: aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:03'!timeCheck	^timeCheck! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 14:02'!timeCheck: aNumber	timeCheck := aNumber! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:58'!videoPlayerProcess	^videoPlayerProcess ! !!MPEGPlayer methodsFor: 'access' stamp: 'JMM 9/20/2000 13:58'!videoPlayerProcess: aProcess	videoPlayerProcess := aProcess! !!MPEGPlayer methodsFor: 'access' stamp: 'kfr 11/9/2000 21:21'!volume: aVolume	volume := aVolume! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:38'!backAudio: aNumber forStream: aStream	self forwardAudio: (0-aNumber) forStream: aStream! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:39'!backVideo: aNumber forStream: aStream	self forwardVideo: (0-aNumber) forStream: aStream! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:35'!forwardAudio: aNumber forStream: aStream	| newLocation |	self hasAudio ifFalse: [^self].	newLocation := (((self currentAudioSampleForStream: aStream) + aNumber) min: (self audioSamples: aStream)) max: 0 .	self currentAudioSampleForStream: aStream put: newLocation! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:35'!forwardVideo: aNumber forStream: aStream	| newLocation |	self hasVideo ifFalse: [^self].	newLocation := (((self currentVideoFrameForStream: aStream) + aNumber) min: (self videoFrames: aStream)) max: 0.	self currentVideoFrameForStream: aStream put: newLocation.! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/19/2000 12:50'!isPlaying	^((self audioPlayerProcess isNil) and: [self videoPlayerProcess isNil]) not! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/13/2000 19:37'!recalculateNewSampleLocationForStream: aStream givenFrame: aFrame	| estimated |	self hasAudio ifFalse: [^self].	estimated := (aFrame / (self videoFrames: aStream) * (self audioSampleRate: aStream)) asInteger.	self currentAudioSampleForStream: aStream put: estimated.! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/8/2000 10:47'!seekToHere: aPercentage forStream: aStream	"Alternate method is to seek all video/audio for stream to a certain percentage using the primitive, but I think your mpeg must have timecodes!! otherwise endless loop"	self external seekPercentage: aPercentage! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/19/2000 11:44'!seekVideoAudioBasedOnFrame: aFrame forStream: aStream	self external hasVideo ifTrue: 		[self currentVideoFrameForStream: aStream put:  aFrame].	self recalculateNewSampleLocationForStream: aStream givenFrame: aFrame! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 11/10/2000 00:19'!setLocation: aPercentage forStream: aStream	self hasAudio ifTrue: [self currentAudioSampleForStream: aStream put: ((self audioSamples: aStream) * aPercentage) asInteger]. 	self hasVideo ifTrue: [self currentVideoFrameForStream: aStream put: ((self videoFrames: aStream) * aPercentage) asInteger].! !!MPEGPlayer methodsFor: 'play controls' stamp: 'JMM 9/20/2000 18:46'!stop	self videoPlayerProcess notNil ifTrue: 		[self videoPlayerProcess terminate. 		self videoPlayerProcess: nil].	self audioPlayerProcess notNil ifTrue: 		[self audioPlayerProcess terminate. 		self audioPlayerProcess: nil.		SoundPlayer stopPlayingAll]! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 15:30'!calculateDelayGivenFrame: frame stream: aStream	| estimated current delta |	current :=  Time millisecondClockValue  - (self startTimeForStream: aStream).	estimated := ((frame asFloat / self frameRate) * 1000) asInteger  - (self clockBiasForStream: aStream).	delta := estimated - current.	delta > 33  ifTrue: 		[self lastDelay: (delta + self lastDelay) // 2. 		 (Delay forMilliseconds: self lastDelay) wait].	delta < -33  ifTrue: 		[self lastDelay: self lastDelay // 2.		 self decideToSkipAFrame: delta averageWait: current//frame stream: aStream].	! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 10:13'!calculateDelayToSoundGivenFrame: frame stream: aStream	| current delta buffers estimatedAudio estimatedVideo |	current :=  Time millisecondClockValue   - (self startTimeForStream: aStream) + (self clockBiasForStream: aStream).	buffers := (self soundQueue sounds size - 1 ) max: 0.	buffers = 0 ifTrue: [^self].	estimatedAudio :=  ((self currentAudioSampleForStream: aStream) 			- (buffers * self sampleRate // 10) 			- self soundQueue currentSound samplesRemaining) * 1000 / self sampleRate.	estimatedAudio := estimatedAudio - 0000.	estimatedVideo := ((frame asFloat / self frameRate) * 1000) asInteger.	delta := estimatedVideo - estimatedAudio.	delta > 100  ifTrue: 		[self lastDelay < delta ifTrue: [self lastDelay: self lastDelay + (((delta-self lastDelay)/10) max: 1)].		(Delay forMilliseconds: self lastDelay) wait].	delta < -100  ifTrue: 		[self lastDelay: ((self lastDelay - 10) max: 1).		 self decideToSkipAFrame: delta averageWait: current//frame stream: aStream].! !!MPEGPlayer methodsFor: 'delay' stamp: 'JMM 11/8/2000 14:28'!decideToSkipAFrame: delta averageWait: aWaitTime stream: aStream	| estimatedFrames |	delta abs > aWaitTime ifTrue: 		[estimatedFrames := ( delta abs / (1000 / self frameRate)) asInteger.		self videoDropFrames:  estimatedFrames stream: aStream].! !!MPEGPlayer methodsFor: 'utility' stamp: 'JMM 10/17/2000 23:22'!changed	self morph notNil ifTrue: [self morph changed].! !!MPEGPlayer methodsFor: 'utility' stamp: 'JMM 11/8/2000 10:25'!checkForm: aStream	| y x |	self form notNil ifTrue: [^self].	y := self videoFrameHeight: aStream.	x := self videoFrameWidth: aStream.	self form:  (Form extent: x@y depth: 32)! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 11/8/2000 10:31'!close	self external closeFile! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 1/20/2006 18:54'!initialize: aPath	self halt.	self isBuffer ifTrue: 		[external := MPEGFile openBuffer: buffer]	 ifFalse: 		[(MPEGFile isFileValidMPEG: aPath) ifFalse: [^nil].		external := MPEGFile openFile: aPath.].	self playerProcessPriority: Processor userSchedulingPriority.	self lastDelay: 10.	volume := 1.0.	errorForSoundStart := 500.	semaphoreForSound := Semaphore new.	self startTime: (Array new: self totalVideoStreams).	self clockBias: (Array new: self totalVideoStreams withAll: 0).! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 1/20/2006 18:17'!initializeWithBuffer: aBuffer form: aForm	isBuffer := true.	buffer := aBuffer.	self initialize: aBuffer.	self form: aForm.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 1/20/2006 18:07'!initializeWithBuffer: aBuffer morph: aMorphic	isBuffer := true.	buffer := aBuffer.	self initialize: aBuffer.	self morph: aMorphic.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:06'!initializeWithFileName: aPath 	self initialize: aPath.	self form: nil.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:06'!initializeWithFileName: aPath form: aForm	self initialize: aPath.	self form: aForm.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 10/17/2000 23:34'!initializeWithFileName: aPath morph: aMorphic	self initialize: aPath.	self morph: aMorphic.	^self! !!MPEGPlayer methodsFor: 'initialize-release' stamp: 'JMM 9/20/2000 14:15'!stopAndClose	self stop.	self close! !!MPEGPlayer methodsFor: 'audio' stamp: 'kfr 11/9/2000 22:26'!createSoundFrom: aStream 	| snds channels |		snds := OrderedCollection new.	channels := self audioChannels: 0.	1 to: channels do: [:c | snds add: (self readSoundChannel: c - 1 stream: aStream)].	channels = 1		ifTrue:[^ MixedSound new				add: (snds at: 1) pan: 0.5 volume: volume;								yourself]		ifFalse: [			^ MixedSound new				add: (snds at: 1) pan: 0.0 volume: volume;				add: (snds at: 2) pan: 1.0 volume: volume;				yourself].! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/19/2000 18:03'!privatePlayAudioStream: aStream	| number |	number := 5.	self soundQueue: (QueueSound new startTime: 0).	[number + 2 timesRepeat: [self soundQueue add: (self createSoundFrom: aStream)].	self soundQueue play.	semaphoreForSound signal.	[[self soundQueue sounds size > number] whileTrue: [(Delay forMilliseconds: 100) wait].	self soundQueue add: (self createSoundFrom: aStream).	(self endOfAudio: aStream) 		ifTrue: 			[self audioPlayerProcess: nil.			^self]] repeat] on: Error do: 				[self audioPlayerProcess: nil.				^self]! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/19/2000 18:02'!readSoundChannel: aChannel stream: aStream	| buffer result samples |	samples := (self sampleRate // 10)  min: 		((self audioSamples: aStream) - (self currentAudioSampleForStream: aStream)).	(samples == 0) ifTrue: [self error: 'Mpeg at end of stream, toss error, catch up high']. 	buffer := SoundBuffer newMonoSampleCount: samples.	aChannel = 0 		ifTrue: [result := self external audioReadBuffer: buffer stream: 					aStream channel: aChannel]		ifFalse: [result := self external audioReReadBuffer: buffer stream: 					aStream channel: aChannel].	^SampledSound samples: buffer samplingRate: self sampleRate.! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/8/2000 10:49'!setupStream: aStream	self sampleRate: (self audioSampleRate: aStream).	SoundPlayer startPlayerProcessBufferSize:  8192 "(SoundPlayer bufferMSecs * self sampleRate) // 1000"		rate: self sampleRate stereo: true.! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 11/8/2000 10:33'!setupStreamNoSeek: aStream	self sampleRate: (self audioSampleRate: aStream).	SoundPlayer startPlayerProcessBufferSize:  8192 "(SoundPlayer bufferMSecs * self sampleRate) // 1000"		rate: self sampleRate stereo: ((self  audioChannels: aStream) > 1).! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 9/20/2000 13:38'!startAudioPlayerProcess: aStream	self audioPlayerProcess: ([self privatePlayAudioStream: aStream] forkAt: Processor userInterruptPriority)! !!MPEGPlayer methodsFor: 'audio' stamp: 'JMM 9/19/2000 16:59'!updateSoundStream: aStream! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStream: aStream	self hasAudio ifFalse: [^self].	self setupStream: aStream.	self startAudioPlayerProcess: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStreamNoSeek: aStream	self hasAudio ifFalse: [^self].	self setupStreamNoSeek: aStream.	self startAudioPlayerProcess: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playAudioStreamWaitTilDone: aStream	self hasAudio ifFalse: [^self].	self setupStream: aStream.	self privatePlayAudioStream: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playStream: aStream	self noSound: self hasAudio not.	self startVideoPlayerProcess: aStream! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 11/8/2000 10:20'!playStreamWaitTilDone: aStream	self noSound: self hasAudio not.	self privatePlayVideoStream: aStream.! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 9/20/2000 14:00'!playVideoStream: aStream	self noSound: true.	self startVideoPlayerProcess: aStream! !!MPEGPlayer methodsFor: 'play' stamp: 'JMM 9/20/2000 14:00'!playVideoStreamWaitTilDone: aStream	self noSound: true.	self privatePlayVideoStream: aStream! !!MPEGPlayer methodsFor: 'video' stamp: 'JMM 11/19/2000 12:47'!privatePlayVideoStream: aStream		| location |	self hasVideo ifFalse: 		[self timeCheck: 0@0.		^self].	self checkForm: aStream.	self frameRate: (self videoFrameRate: aStream).	location := self currentVideoFrameForStream: aStream.	self clockBiasForStream: aStream 		put: (1/self frameRate*location*1000) asInteger.	self videoLoop: aStream.	self timeCheck: ((Time millisecondClockValue + (self clockBiasForStream: aStream) - (self startTimeForStream: aStream))/1000.0) @ ((self videoFrames: aStream) / self frameRate).	self videoPlayerProcess: nil! !!MPEGPlayer methodsFor: 'video' stamp: 'JMM 9/20/2000 13:59'!startVideoPlayerProcess: aStream	self videoPlayerProcess: ([self privatePlayVideoStream: aStream] forkAt: self playerProcessPriority)! !!MPEGPlayer methodsFor: 'video' stamp: 'jm 12/17/2001 09:36'!videoLoop: aStream	| location oneTime | 	oneTime := true.	[self external videoReadFrameInto: self form stream: aStream.	oneTime ifTrue: 			[oneTime := false.			self noSound ifFalse: 				[self playAudioStreamNoSeek: aStream.				semaphoreForSound wait.				(Delay forMilliseconds: errorForSoundStart) wait].			self startTimeForStream: aStream put: (Time millisecondClockValue)].	self morph ifNil: 			[self form == Display				ifTrue: [Display forceToScreen]				ifFalse: [self form displayOn: Display]].	self changed.		location := (self currentVideoFrameForStream: aStream)+1.	true 			ifTrue: [self calculateDelayGivenFrame: location stream: aStream]			ifFalse: [self calculateDelayToSoundGivenFrame: location stream: aStream].	(self endOfVideo: aStream)  ifTrue: [^self]] repeat.! !!MPEGPlayer commentStamp: '<historical>' prior: 0!V1.01 johnmci@smalltalkconsulting.com Nov 8th 2000A Simple MPEG Player for playing MPEG3 audio or video | foo |foo _ MpegPlayer playFile: 'my.mpg'.foo playStream: 0. "To play both audio and video, stream #0 "foo playAudioStream: 0 "To play audio stream".foo playVideoStream: 0 "To play video stream"foo playStreamWaitTilDone: 0 "To play audio/video as currrent process"or 	| foo |	foo _ MPEGPlayer playFile: 'my.mpg' onForm: Display.	foo playStream: 0.	To play full screen.!!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 1/20/2006 18:16'!playBuffer: aBuffer onForm: aForm	^self new initializeWithBuffer: aBuffer morph: aForm! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 1/20/2006 18:06'!playBuffer: aBuffer onMorph: aMorph	^self new initializeWithBuffer: aBuffer morph: aMorph! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 19:02'!playFile: aPath	^self new initializeWithFileName: aPath ! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 18:32'!playFile: aPath onForm: aForm	^self new initializeWithFileName: aPath form: aForm! !!MPEGPlayer class methodsFor: 'instance creation' stamp: 'JMM 10/17/2000 23:19'!playFile: aPath onMorph: aMorph	^self new initializeWithFileName: aPath morph: aMorph! !!MPEGPlayer class methodsFor: 'file suffixes' stamp: 'bkv 11/21/2002 15:28'!registeredAudioFileSuffixes    "Answer the file extensions for which MPEGPlayer registers audio services with FileList."     "MPEGPlayer registeredAudioFileSuffixes"     ^{ 'mp3'.  }	! !!MPEGPlayer class methodsFor: 'file suffixes' stamp: 'bkv 11/21/2002 11:14'!registeredVideoFileSuffixes    "Answer the file extensions for which MPEGPlayer registers video services with FileList."     "MPEGPlayer registeredVideoFileSuffixes"     ^{ 'mpg'. 'mpeg'. 'jmv'. }	! !!MPEGSubtitleElement methodsFor: 'accessing' stamp: 'dgd 3/8/2004 20:17'!contents	"answer the receiver's contents"	^ contents! !!MPEGSubtitleElement methodsFor: 'accessing' stamp: 'dgd 3/8/2004 20:17'!contents: aString 	"change the receiver's contents"	contents := aString replaceAll: $| with: Character cr! !!MPEGSubtitleElement methodsFor: 'testing' stamp: 'dgd 3/8/2004 20:23'!correspondsToFrame: aNumber	"answer if the receiver corresponds to a given frame number"	^ aNumber between:  initialFrame and:  endFrame! !!MPEGSubtitleElement methodsFor: 'parsing' stamp: 'asm 7/30/2003 21:04'!is: text in: aStream	" Returns true if text is present in aStream.	Advance the stream if present. "	| position |	(text isKindOf: Character) ifTrue: [		^self is: (String with: text) in: aStream	].	position := aStream position.	aStream skipSeparators.	text = (aStream next: text size) ifFalse: [		aStream position: position.		^false	].	^true! !!MPEGSubtitleElement methodsFor: 'parsing' stamp: 'asm 7/30/2003 21:01'!mustBe: text in: aStream	" Check text to be present in aStream. "	(text isKindOf: Character) ifTrue: [		^self is: (String with: text) in: aStream	].	(self is: text in: aStream) ifFalse: [		^self error: 'Invalid token, must be: ',text	].! !!MPEGSubtitleElement methodsFor: 'parsing' stamp: 'asm 7/30/2003 21:05'!nextIntegerFrom: aStream	" Returns the next Integer present in aStream. "	| sign result |	sign := (self is: $- in: aStream) ifTrue: [-1] ifFalse: [1].	result := 0.	self skipBlanks: aStream.	[aStream peek isDigit] whileTrue: [		result := aStream next asciiValue - $0 asciiValue + (result * 10)	].	^result * sign! !!MPEGSubtitleElement methodsFor: 'parsing' stamp: 'dgd 3/8/2004 20:17'!readFrom: aStream 	"Private - Read the receiver's contents from aStream."	self mustBe: '{' in: aStream.	initialFrame := self nextIntegerFrom: aStream.	self mustBe: '}{' in: aStream.	endFrame := self nextIntegerFrom: aStream.	self mustBe: '}' in: aStream.	""	self contents: aStream nextLine isoToSqueak! !!MPEGSubtitleElement methodsFor: 'parsing' stamp: 'asm 7/30/2003 21:42'!skipBlanks: aStream	" Advance aStream skipping all blank characters and comments. "	aStream skipSeparators! !!MPEGSubtitleElement methodsFor: 'printing' stamp: 'dgd 3/8/2004 20:50'!printOn: aStream 	"append to aStream a sequence of characters that identifies 	the receiver."	aStream nextPutAll: '{';		 nextPutAll: initialFrame asString;		 nextPutAll: '}{';		 nextPutAll: endFrame asString;		 nextPutAll: '}';		 nextPutAll: contents asString! !!MPEGSubtitleElement commentStamp: 'asm 7/31/2003 22:27' prior: 0!an element of a subtitle file,this has the form{initialFrame}{endFrame} subtitle line[| next subtitle line]!!MPEGSubtitleElement class methodsFor: 'instance creation' stamp: 'asm 7/30/2003 21:26'!fromStream: aStream	"Returns an instance of the receiver read from aStream."	^self new readFrom: aStream! !!MPEGSubtitles methodsFor: 'accessing' stamp: 'dgd 3/8/2004 20:49'!elementCorrespondingToFrame: frameNumber 	"answer the element corresponding to frameNumber"	^ elements		detect: [:each | each correspondsToFrame: frameNumber]		ifNone: []! !!MPEGSubtitles methodsFor: 'accessing' stamp: 'dgd 3/8/2004 22:45'!fileName	"answer the receiver's fileName"	^ fileName! !!MPEGSubtitles methodsFor: 'accessing' stamp: 'dgd 3/8/2004 20:42'!subtitleForFrame: frameNumber 	"answer the subtitle for the given frame number"	| element |	element := self elementCorrespondingToFrame: frameNumber.	^ element isNil		ifTrue: ['']		ifFalse: [element contents]! !!MPEGSubtitles methodsFor: 'initialization' stamp: 'dgd 3/8/2004 22:24'!initializeFromFileNamed: aString 	"initialize the receiver from a file named aString"	| file result |fileName := aString.	elements := OrderedCollection new.	""	file := CrLfFileStream readOnlyFileNamed: aString.	[result := self readFrom: file]		ensure: [file close].	^ result! !!MPEGSubtitles methodsFor: 'initialization' stamp: 'dgd 3/8/2004 22:04'!readFrom: aStream 	"private - Read the next definitions found in aStream onto the  	receiver"	[aStream atEnd]		whileFalse: [| element | 			element := MPEGSubtitleElement fromStream: aStream.			elements add: element]! !!MPEGSubtitles commentStamp: 'asm 7/31/2003 22:12' prior: 0!a subtitle filei can only read subtitle files with a format like this:[..]{1043}{1082}La gente siempre me pregunta|si conozco a Tyler Durden.{1083}{1096}Tres minutos.{1097}{1133}El momento de la verdad.|Punto cero.[..]from Fight Clubwhile reading, pipes(|) are replaced by carriage returns!!MPEGSubtitles class methodsFor: 'instance creation' stamp: 'dgd 3/8/2004 22:02'!fromFileNamed: aString 	"Returns an instance of the receiver read from file named  	aString"	^self new initializeFromFileNamed: aString ! !!MVCProject methodsFor: 'scheduling' stamp: 'ul 12/12/2009 14:09'!addDeferredUIMessage: valuableObject 	"Arrange for valuableObject to be evaluated at a time when the user interface	is in a coherent state."	ScheduledControllers activeController		ifNotNil: [:controller | controller addDeferredUIMessage: valuableObject]! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 11/25/2009 13:56'!addItem: item toMenu: menu selection: action color: aColor thumbnail: aForm	"Add menu item representing the sender to a menu. Morphic projects use	aColor and aForm for menu items."	menu add: item action: action! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 11/25/2009 13:29'!addItem: item toMenu: menu selection: action requestor: requestingProject	"Add a menu item representing this project to a menu being created by requestingProject"	| color |	"Color to be used for this menu item, will be ignored if current project is MVC"	color := self world isInMemory						ifTrue: [Color veryVeryDarkGray]						ifFalse: [Color blue].	"Menu item of type appropriate for current project"	requestingProject		addItem: item		toMenu: menu		selection: action		color: color		thumbnail: thumbnail! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 11/30/2009 22:34'!do: aBlock withProgressInfoOn: aMorphOrNil label: aString	"Evaluate aBlock with a labeled progress bar. Use a simple progress	bar set to 50% progress. In Morphic, progress is displayed with a	ComplexProgressIndicator."	aString		displayProgressAt: Sensor cursorPoint		from: 0 to: 2		during: [:bar |  bar value: 1.				aBlock value]! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 12/2/2009 20:29'!findAFolderForProject: aProject label: dialogLabel	"Find a folder for saving or loading a project"	^PluggableFileList getFolderDialog openLabel: dialogLabel! !!MVCProject methodsFor: 'utilities' stamp: 'nice 12/27/2009 03:10'!findProjectView: projectDescription	"In this world, find the ProjectController for the project described by projectDescription."	| pName |	pName := (projectDescription isString) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	world scheduledControllers do: [:cont | | proj dpName |		(cont isKindOf: ProjectController) ifTrue: [			((proj := cont model) class == Project and: 				[proj name = pName]) ifTrue: [^ cont view].			proj class == DiskProxy ifTrue: [ 				dpName := proj constructorArgs first.				dpName := (dpName findTokens: '/') last.				dpName := (Project parseProjectFileName: dpName unescapePercents) first.				dpName = pName ifTrue: [^ cont view]]]].	^ nil! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 11/23/2009 14:47'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	^ ScheduledControllers interruptName: labelString! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 11/23/2009 21:44'!jumpToProject	"Present a list of potential projects and enter the one selected."	"Project current jumpToProject"	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUpLeftFlush! !!MVCProject methodsFor: 'utilities' stamp: 'ar 1/10/2010 10:23'!offerMenu: menuSelector from: aModel shifted: aBoolean	"Pop up a menu whose target is aModel and whose contents are provided	by sending the menuSelector to the model. The menuSelector takes two	arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := CustomMenu new.	aModel perform: menuSelector with: aMenu with: aBoolean.	aMenu invokeOn: aModel! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 2/27/2010 09:56'!setAsBackground: aForm	"Set  aForm as a background image."	ScheduledControllers screenController model form: aForm.	Display restoreAfter: []! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 2/12/2010 20:41'!showImage: aForm named: imageName	"Show an image, possibly attached to the pointer for positioning"	FormView open: aForm named: imageName! !!MVCProject methodsFor: 'utilities' stamp: 'ar 9/18/2009 20:19'!subProjects	"Answer a list of all the subprojects  of the receiver. "	^(world controllersSatisfying: [:m | m model isKindOf: Project]) 		collect: [:c | c model]! !!MVCProject methodsFor: 'utilities' stamp: 'dtl 2/14/2010 20:44'!textWindows	"Answer a dictionary of all system windows for text display keyed by window title.	Generate new window titles as required to ensure unique keys in the dictionary."	| aDict windows title |	aDict := Dictionary new.	windows := ScheduledControllers controllersSatisfying:		[:c | (c model isKindOf: StringHolder)].	windows do:		[:aController | | textToUse aTextView | 			aTextView := aController view subViews detect: [:m | m isKindOf: PluggableTextView] ifNone: [nil].			textToUse := aTextView				ifNil:		[aController model contents]				ifNotNil:	[aTextView controller text].  "The latest edits, whether accepted or not"				title := aController view label.				(aDict includesKey: title) ifTrue: [ | newKey | "Ensure unique keys in aDict"					(1 to: 100) detect: [:e |							newKey := title, '-', e asString.							(aDict includesKey: newKey) not].					title := newKey].			aDict at: title put: textToUse].	^ aDict! !!MVCProject methodsFor: 'file in/out' stamp: 'dtl 11/2/2009 23:37'!armsLengthCommand: aCommand withDescription: aString	| pvm |	"Set things up so that this aCommand is sent to self as a messageafter jumping to the parentProject.  For things that can't be executedwhile in this project, such as saveAs, loadFromServer, storeOnServer.  SeeProjectViewMorph step."	parentProject ifNil: [^ self inform: 'The top project can''t do that'].	pvm := parentProject findProjectView: self.	pvm armsLengthCommand: {self. aCommand}.	self exit! !!MVCProject methodsFor: 'file in/out' stamp: 'dtl 11/29/2009 13:26'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	self flag: #toRemove.	self halt.  "unused"	"world == World ifTrue: [^ false]."	"self inform: 'Can''t send the current world out'."	self projectParameters at: #isMVC put: true.	^ false	"Only Morphic projects for now"! !!MVCProject methodsFor: 'file in/out' stamp: 'dtl 11/29/2009 13:23'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	"Files out a changeSet first, so that a project can containits own classes"	self projectParameters at: #isMVC put: true.	^ false	"Only Morphic projects for now"! !!MVCProject methodsFor: 'file in/out' stamp: 'dtl 11/29/2009 13:14'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"	(World == world) ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."	world isInMemory ifFalse: [^ false].  "already done"	self projectParameters at: #isMVC put: true.	^ false	"Only Morphic projects for now"! !!MVCProject methodsFor: 'file in/out' stamp: 'dtl 11/29/2009 13:10'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"	(World == world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."	world isInMemory ifFalse: [^ self].  "already done"	self projectParameters at: #isMVC put: true.	^ self	"Only Morphic projects for now"! !!MVCProject methodsFor: 'editors' stamp: 'dtl 1/23/2010 18:25'!bitEdit: aForm	"Create and schedule a view located in an area designated by the user 	that contains a view of aForm magnified by 8@8 that can be modified using	a bit editor. It also contains a view of the original form."	BitEditor openOnForm: aForm	"Note that using direct messages to BitEditor, fixed locations and scales can be created.	That is, also try:		BitEditor openOnForm: self at: <some point>		BitEditor openOnForm: self at: <some point> scale: <some point>"! !!MVCProject methodsFor: 'editors' stamp: 'dtl 1/23/2010 18:34'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor	"Create and schedule a view whose top left corner is magnifiedLocation 	and that contains a view of aForm magnified by scaleFactor that  can be	modified using the Bit Editor. It also contains a view of the original form."	BitEditor openOnForm: aForm at: magnifiedFormLocation scale: scaleFactor ! !!MVCProject methodsFor: 'editors' stamp: 'dtl 1/24/2010 11:30'!editCharacter: character ofFont: strikeFont	"Open a bit editor on a character in the given strike font. Note that you must	do an accept (in the option menu of the bit editor) if you want this work. 	Accepted edits will not take effect in the font until you leave or close the bit editor. 	Also note that unaccepted edits will be lost when you leave or close."	"Note that BitEditor only works in MVC currently."	"(TextStyle default fontAt: 1) edit: $="	| charForm editRect scaleFactor bitEditor savedForm r |	charForm := strikeFont characterFormAt: character.	editRect := Rectangle locateMagnifiedView: charForm scale: (scaleFactor := 8 @ 8).	bitEditor := BitEditor				bitEdit: charForm				at: editRect topLeft				scale: scaleFactor				remoteView: nil.	savedForm := Form fromDisplay: (r := bitEditor displayBox							expandBy: (0 @ 23 corner: 0 @ 0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	strikeFont characterFormAt: character put: charForm! !!MVCProject methodsFor: 'editors' stamp: 'dtl 1/24/2010 16:06'!formEdit: aForm	"Start up an instance of the FormEditor on a form. Typically the form 	is not visible on the screen. The editor menu is located at the bottom of 	the form editing frame. The form is displayed centered in the frame. 	YellowButtonMenu accept is used to modify the form to reflect the 	changes made on the screen version; cancel restores the original form to 	the screen. Note that the changes are clipped to the original size of the 	form." 	FormEditor openOnForm: aForm! !!MVCProject methodsFor: 'editors' stamp: 'dtl 2/10/2010 13:19'!formViewClass	"Answer a class suitable for a view on a form or collection of forms"	^ FormInspectView! !!MVCProject methodsFor: 'editors' stamp: 'dtl 2/10/2010 15:27'!openImage: aForm name: fullName saveResource: aBoolean	"Open a view on an image. Do not save project resource in an MVC project."	FormView open: aForm named: fullName! !!MVCProject methodsFor: 'protocols' stamp: 'dtl 2/27/2010 15:28'!currentVocabulary	"Answer the currently-prevailing default vocabulary."	Smalltalk at: #Vocabulary ifPresent: [:v | ^ v fullVocabulary].	self error: 'package Protocols not present in this image'! !!MVCProject methodsFor: 'initialize' stamp: 'dtl 10/31/2009 15:34'!defaultBackgroundColor	^ Color r: 1.0 g: 1.0 b: 0.065! !!MVCProject methodsFor: 'initialize' stamp: 'ar 9/18/2009 20:31'!initialize	super initialize.	world := ControlManager new.! !!MVCProject methodsFor: 'initialize' stamp: 'ar 9/18/2009 21:32'!openProject: aProject	"Create a new for a new project in the context of the receiver"	ProjectView openAndEnter: aProject.! !!MVCProject methodsFor: 'display' stamp: 'ar 9/18/2009 20:27'!displaySizeChanged	"Inform the current project that its display size has changed"	world "ScheduledControllers" restore; searchForActiveController! !!MVCProject methodsFor: 'display' stamp: 'ar 9/18/2009 20:25'!invalidate	"Invalidate the entire project so that a redraw will be forced later."	world "ScheduledControllers" unCacheWindows! !!MVCProject methodsFor: 'display' stamp: 'dtl 2/27/2010 10:33'!resetDisplay 	"Bring the display to a usable state after handling primitiveError."	ScheduledControllers searchForActiveController! !!MVCProject methodsFor: 'display' stamp: 'ar 9/18/2009 20:26'!restore	"Redraw the entire Project"	world "ScheduledControllers" restore.! !!MVCProject methodsFor: 'display' stamp: 'dtl 12/28/2009 16:13'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Display extent = DisplayScreen actualScreenSize		ifFalse:			[DisplayScreen startUp.			ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!MVCProject methodsFor: 'display' stamp: 'ul 12/12/2009 14:09'!viewLocFor: exitedProject 	"Look for a view of the exitedProject, and return its center"	(world controllerWhoseModelSatisfies: [:p | p == exitedProject])		ifNotNil: [:ctlr | ^ctlr view windowBox center].	^Sensor cursorPoint	"default result"! !!MVCProject methodsFor: 'project parameters' stamp: 'dtl 11/28/2009 18:35'!initializeProjectPreferences	"Initialize the project's preferences from currently-prevailing preferences that are currently being held in projects in this system"		self flapsSuppressed: true.	super initializeProjectPreferences! !!MVCProject methodsFor: 'enter' stamp: 'ar 3/5/2010 20:32'!pauseSoundPlayers	"Pause sound players, subject to preference settings"	Smalltalk at: #ScorePlayer ifPresent:[:playerClass| 		playerClass allSubInstancesDo: [:player | player pause]]! !!MVCProject methodsFor: 'enter' stamp: 'dtl 11/9/2009 21:34'!saveState	"Save the current state in me prior to leaving this project"	changeSet := ChangeSet current.	thumbnail ifNotNil: [thumbnail hibernate].	world := ScheduledControllers.	ScheduledControllers unCacheWindows.	Sensor flushAllButDandDEvents. "Will be reinstalled by World>>install"	transcript := Transcript! !!MVCProject methodsFor: 'enter' stamp: 'nice 1/11/2010 20:56'!scheduleProcessForEnter: showZoom	"Complete the enter: by launching a new process"	| newProcess |	SystemWindow clearTopWindow.	"break external ref to this project"	newProcess := [			ScheduledControllers resetActiveController.	"in case of walkback in #restore"		showZoom ifFalse: [ScheduledControllers restore].		ScheduledControllers searchForActiveController	] newProcess priority: Processor userSchedulingPriority.	newProcess resume.		"lose the current process and its referenced morphs"	Processor terminateActive! !!MVCProject methodsFor: 'enter' stamp: 'dtl 11/7/2009 20:18'!setWorldForEmergencyRecovery	"Prepare world for enter with an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project."	World := nil.	Smalltalk at: #ScheduledControllers put: world.	ScheduledControllers restore! !!MVCProject methodsFor: 'enter' stamp: 'dtl 11/7/2009 20:22'!setWorldForEnterFrom: old recorder: recorderOrNil	"Prepare world for enter."	World := nil.  "Signifies MVC"	Smalltalk at: #ScheduledControllers put: world! !!MVCProject methodsFor: 'dispatching' stamp: 'dtl 1/30/2010 15:49'!selectorPrefixForDispatch	"A string to be prepended to selectors for project specific methods"	^ 'mvc'! !!MVCProject commentStamp: 'ar 9/18/2009 21:38' prior: 0!Holds MVC Projects. Currently in transition from the hodge-podge in Project, it stores its control manager in the "world" instance variable inherited from Project.!!MVCProject class methodsFor: 'class initialization' stamp: 'ar 9/18/2009 20:43'!convertOldProjects	"Convert old MVC projects to be MVCProjects"	Project allInstancesDo:[:p|		(p world isKindOf: ControlManager) 			ifTrue:[p primitiveChangeClassTo: self basicNew]].! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:05'!testMacFileDirectory	"(self run: #testMacFileDirectory)"		"This fails before the the fix if the Squeak directory is on the root	directory like: 'HardDisk:Squeak'	But should work both before and after the fix of John if there is several	directories in the hieracry: HardDisk:User:Squeak"	"If somebody can find a way to make the test failed all the time when the fix is not 	present we should replace it"	self assert: (FileDirectory default fullName) = (FileDirectory default fullNameFor: (FileDirectory default fullName))! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'kfr 7/28/2004 15:06'!testMacIsAbsolute	"(self selector: #testMacIsAbsolute) run"			self deny: (MacFileDirectory isAbsolute: 'Volumes').	self assert: (MacFileDirectory isAbsolute: 'Volumes:Data:Stef').	self deny: (MacFileDirectory isAbsolute: ':Desktop:test.st')! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:02'!testMakeAbsolute	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: 'Data')).	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: ':Data')).! !!Magnitude methodsFor: 'testing' stamp: 'bgf 3/7/2009 01:51'!atLeast: aMin atMost: aMax 	"A rephrasing of min:max: for readability.	 The implementation inside reads oddly,	 but in use in code it can read more clearly when used for bracketing.	 These two statements...		result := (aNumber atLeast: 1 atMost: 10).		result := (aNumber min: 10 max: 1).	... are equivalent."	^ (self max: aMin) min: aMax! !!MailAddressParserTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:31'!testAddressesIn	| testString correctAnswer |	testString := 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'.correctAnswer := #('joe@lama.com' 'joe2@lama.com' 'joe3@lama.com' 'joe4' 'joe5@address' 'joe.literal@[1.2.3.4]' 'joe1@groupie' 'joe2@groupie' '"Joey"' 'joe3@groupy' '"joe6"."joe8"@group.com' 'lex') asOrderedCollection.	self assert: ((MailAddressParser addressesIn: testString) =  correctAnswer).! !!MailAddressParserTest commentStamp: '<historical>' prior: 0!This is the unit test for the class MailAddressParser. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!MailComposition methodsFor: '*ST80-Support' stamp: 'dtl 2/9/2010 22:34'!mvcOpen	| textView sendButton  |	mvcWindow := StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250;		model: self.	textView := PluggableTextView		on: self		text: #messageText		accept: #messageText:.	textEditor := textView controller.	sendButton := PluggableButtonView 		on: self		getState: nil		action: #submit.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	mvcWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	mvcWindow addSubView: textView below: sendButton.	mvcWindow controller open.		! !!MailMessage methodsFor: 'initialize-release' stamp: 'hrs 4/24/2009 21:32'!addField: fieldName ofString: fieldValue	"add fieldValue as an additional value for fieldName (creating the field if it does not exist)"	(fields at: fieldName asLowercase ifAbsentPut: [OrderedCollection new: 1])		add: (MIMEHeaderValue forField: fieldName fromString: fieldValue)! !!MailMessage methodsFor: 'initialize-release' stamp: 'hrs 4/2/2009 15:32'!from: aString 	"Parse aString to initialize myself."	| parseStream contentType bodyText contentTransferEncoding |	text := aString. "Used to do withoutTrailingBlanks, String cr. But that's just wrong for binary."	parseStream := ReadStream on: text.	contentType := 'text/plain'.	contentTransferEncoding := nil.	fields := Dictionary new.	"Extract information out of the header fields"	self fieldsFrom: parseStream do: 		[:fName :fValue | 		"NB: fName is all lowercase"		fName = 'content-type' ifTrue: [contentType := (fValue copyUpTo: $;) asLowercase].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding := fValue asLowercase].		(fields at: fName ifAbsentPut: [OrderedCollection new: 1])			add: (MIMEHeaderValue forField: fName fromString: fValue)].	"Extract the body of the message"	bodyText := parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText := Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText := bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [bodyText := bodyText decodeQuotedPrintable].	body := MIMEDocument contentType: contentType content: bodyText! !!MailMessage methodsFor: 'parsing' stamp: 'hrs 2/20/2009 11:24'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	| line |	line := aStream upTo: Character cr.	"Mail messages can come from CR or CRLF systems, and we don't want to globally change 	all CRLF to CR because a '13 10' can be in a binary attachment.  However, this method is	ALWAYS used in parsing headers, so there's no danger in soaking up a LF here. If we fail	to do so, then a binary message part could have a 10 byte at it's start, which would make it 	useless."	aStream peek = Character lf ifTrue: [aStream next].	^line! !!MatrixTest methodsFor: 'testing' stamp: 'dc 3/3/2007 17:58'!setUp	matrix1 := Matrix new: 2.	matrix1 at:1 at:1 put: 1.	matrix1 at:1 at:2 put: 3.	matrix1 at:2 at:1 put: 2.	matrix1 at:2 at:2 put: 4.		matrix2 := Matrix new: 2.	matrix2 at:1 at:1 put: 3.	matrix2 at:1 at:2 put: 7.	matrix2 at:2 at:1 put: 4.	matrix2 at:2 at:2 put: 8.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:47'!testAtAt	self should:[matrix1 at: 2 at: 3] raise: Error.	self should:[matrix1 at: 3 at: 2] raise: Error.	self should:[matrix1 at: 3 at: 3] raise: Error.	self should:[matrix1 at: 0 at: 1] raise: Error.	self should:[matrix1 at: 1 at: 0] raise: Error.	self should:[matrix1 at: 0 at: 0] raise: Error.		self assert: (matrix1 at: 1 at: 1) = 1! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:52'!testReplaceAll	matrix1 replaceAll: 1 with: 10.	self assert: (matrix1 at:1 at:1) = 10.	self assert: (matrix1 at:2 at:1) = 2.	self assert: (matrix1 at:1 at:2) = 3.	self assert: (matrix1 at:2 at:2) = 4.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:53'!testSwap	matrix1 swap: 1 at: 2 with: 1 at: 1.	self assert: (matrix1 at: 1 at: 1) = 3.	self assert: (matrix1 at: 1 at: 2) = 1.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:58'!testTransposed	| transposedMatrix |		transposedMatrix := matrix1 transposed.	self assert: [(transposedMatrix at:1 at:1) = 1].	self assert: [(transposedMatrix at:1 at:2) = 2].	self assert: [(transposedMatrix at:2 at:1) = 3].	self assert: [(transposedMatrix at:2 at:2) = 4].! !!MatrixTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:48'!testCopy	| copyMatrix |		copyMatrix := matrix1 copy.	self assert: matrix1 = copyMatrix ! !!MatrixTest methodsFor: 'tests - testing' stamp: 'dc 3/3/2007 17:49'!testIncludes	self assert:			((1 to: 4)				allSatisfy: [:i | matrix1 includes: i])! !!MatrixTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:50'!testMultiply		| result |	self	should: [matrix1	preMultiplyByMatrix: (Matrix new: 3)]raise: Error.	result := matrix2 preMultiplyByMatrix: matrix1.	self assert: (result at: 1 at: 1) = 15.	self assert: (result at: 1 at: 2) = 31.	self assert: (result at: 2 at: 1) = 22.	self assert: (result at: 2 at: 2) = 46! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 6/19/2008 09:36'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:27'!cancelIcon	^self smallCancelIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:27'!copyIcon	^self smallCopyIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:28'!cutIcon	^self smallCutIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:28'!deleteIcon	^self smallDeleteIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:28'!doItIcon	^self smallDoItIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:26'!findIcon	^self smallFindIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:28'!inspectIcon	^self smallInspectItIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:29'!okIcon	^self smallOkIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:29'!pasteIcon	^self smallPasteIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:29'!printIcon	^self smallPrintIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:29'!quitIcon	^self smallQuitIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:29'!redoIcon	^self smallRedoIcon! !!MenuIcons class methodsFor: 'compatibility' stamp: 'ar 3/10/2010 21:30'!undoIcon	^self smallUndoIcon! !!MenuItemMorph methodsFor: 'drawing' stamp: 'abc 2/11/2010 22:12'!selectionFillStyle	"answer the fill style to use with the receiver is the selected  	element"	| fill baseColor preferenced |	Display depth <= 2		ifTrue: [^ Color gray].	preferenced := Preferences menuSelectionColor.	preferenced notNil ifTrue:[^ preferenced].	Morph subduedHilites ifFalse: [		owner color luminance > 0.6 ifTrue: [			baseColor := owner color alphaMixed: 0.4 with: Color black.		] ifFalse: [				baseColor := owner color alphaMixed: 0.35 with: Color white.		]		] ifTrue: [		baseColor := (Color r: 0.33 g: 0.44 b: 0.79).	].	"Gradient menus have a strong sideways gradient.	 If thats not in use, do a conventional button-like gradient."	Preferences gradientMenu ifFalse: [		^ (GradientFillStyle colors: (baseColor morphicMenuGradient))			origin: bounds topLeft;			direction: 0 @ (bounds extent y );			normal: (bounds extent x @0);			yourself ].	fill := GradientFillStyle ramp: {0.0 -> baseColor twiceLighter . 1 -> baseColor twiceDarker}.	fill origin: self topLeft.	fill direction: (self width-2) @ (self height).	^ fill! !!MenuMorph methodsFor: 'initialization' stamp: 'bgf 12/28/2008 13:03'!setDefaultParameters	| colorFromMenu worldColor menuColor menuBorderColor |	colorFromMenu := Preferences menuColorFromWorld				and: [Display depth > 4]				and: [(worldColor := self currentWorld color) isColor].	""	menuColor := colorFromMenu				ifTrue: [worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.8 with: Color black]						ifFalse: [worldColor mixed: 0.35 with: Color white]]				ifFalse: [Preferences menuColor].	""	menuBorderColor := Preferences menuAppearance3d				ifTrue: [#raised]				ifFalse: [colorFromMenu						ifTrue: [worldColor muchDarker]						ifFalse: [Preferences menuBorderColor]].	""	self		setColor: menuColor		borderWidth: Preferences menuBorderWidth		borderColor: menuBorderColor.	""	self layoutInset: 3! !!Message methodsFor: 'accessing' stamp: 'ajh 10/9/2001 16:32'!selector	"Answer the selector of the receiver."	^selector! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!MessageNames methodsFor: 'search' stamp: 'eem 1/27/2009 10:15'!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ . "?dubious?"	selectorList := Cursor wait showWhile:					[| sorted |					sorted := SortedCollection sortBlock:  [:x :y | x asLowercase <= y asLowercase].					(searchString findBetweenSubStrs: ';') do:						[:selPat| | raw n m |						selPat size > 0 ifTrue:							[(selPat first = $" and: [selPat last = $" and: [selPat size > 2]])								ifTrue:									[Symbol hasInterned: (selPat copyFrom: 2 to: selPat size - 1) ifTrue: [:sym| sorted add: sym]]								ifFalse:									[raw := (((n := selPat occurrencesOf: $*) > 0)										    | ((m := selPat occurrencesOf:  $#) > 0)										and: [selPat size > (n + m)])											ifTrue: [Symbol selectorsMatching: selPat]											ifFalse: [Symbol selectorsContaining: selPat].									sorted addAll: raw]]].					sorted asArray].	^selectorList! !!MessageNames methodsFor: 'selection' stamp: 'eem 6/18/2008 03:10'!selectedMessageName	^selectorListIndex = 0 ifFalse: [selectorList at: selectorListIndex]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 9/29/2008 14:45'!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:12'!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:28'!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:31'!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:36'!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 12/27/2009 03:11'!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last | | thenSize |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22'!sizeCodeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:15'!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:57'!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:09'!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22'!sizeCodeForValue: encoder	| total |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | | argSize | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:00'!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32'!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!MessageNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:59'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector key]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode commentStamp: '<historical>' prior: 0!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MessageNode class methodsFor: 'class initialization' stamp: 'eem 8/15/2010 10:22'!initialize		"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!MessageSet methodsFor: 'toolbuilder' stamp: 'ar 8/27/2010 11:26'!buildWith: builder	| windowSpec max result |	self wantsOptionalButtons ifTrue:[max := 0.3] ifFalse:[max := 0.3].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	autoSelectString ifNotNil:[		"Auto-select must be handled after the window is open"		Project current addDeferredUIMessage:[self changed: #autoSelect].	].	^result! !!MessageSet methodsFor: '*Tools' stamp: 'eem 6/12/2008 09:58'!fileOutMessage	"Put a description of the selected method on a file, or all methods if none selected."	| fileName |	self selectedMessageName ifNotNil:		[^super fileOutMessage].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		messageList do:			[:methodRef|			methodRef actualClass				printMethodChunk: methodRef methodSymbol				withPreamble: true				on: internalStream				moveSource: false				toFile: nil].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MessageSet class methodsFor: 'utilities' stamp: 'eem 7/15/2010 16:59'!parse: methodRef toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	self flag: #mref.	"compatibility with pre-MethodReference lists"	methodRef ifNil: [^ csBlock value: nil value: nil].	((methodRef isKindOf: MethodReference)	 or: [methodRef isKindOf: ClassReference]) ifTrue:		[^methodRef setClassAndSelectorIn: csBlock].	methodRef isEmpty ifTrue: [^ csBlock value: nil value: nil].	tuple := methodRef asString findTokens: ' .'.	cl := Smalltalk at: tuple first asSymbol ifAbsent: [^ csBlock value: nil value: nil].	^(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [csBlock value: cl class value: (tuple at: 3) asSymbol]! !!MessageSetDifferencer methodsFor: 'contents' stamp: 'eem 7/15/2010 17:30'!aboutToStyle: aPluggableShoutMorphOrView	"Style if there is only one definition (none styles nothing)"	^(leftSet selection isNil or: [rightSet selection isNil])	   and: [aPluggableShoutMorphOrView classOrMetaClass:				(leftSet selection					ifNotNil: [leftSet selection isClassReference ifFalse: [leftSet selection actualClass]]					ifNil: [rightSet selection ifNotNil:							[rightSet selection isClassReference ifFalse: [rightSet selection actualClass]]]).			true]! !!MessageSetDifferencer methodsFor: 'contents' stamp: 'eem 5/8/2008 17:06'!contents	"Answer the contents of the receiver"	| left right |	left := leftSet selection.	right := rightSet selection.	(left isNil and: [right isNil]) ifTrue:		[currentCompiledMethod := nil.		 ^''].	left isNil ifTrue:		[^rightSet contents].	right isNil ifTrue:		[^leftSet contents].	left := leftSet contents.	right := rightSet contents.	^leftSet selection isMethodReference		ifTrue:			[CodeDiffBuilder				buildDisplayPatchFrom: right				to: left				inClass: (leftSet selection isMethodReference ifTrue: [leftSet selection actualClass])				prettyDiffs: false]		ifFalse:			[CodeDiffBuilder buildDisplayPatchFrom: right to: left]! !!MessageSetDifferencer methodsFor: 'accessing' stamp: 'eem 5/8/2008 11:02'!annotation	"Provide a line of content for an annotation pane, representing information about	 the method associated with the selected class and selector in the receiver."	| left right |	(left := leftSet annotation) = (right := rightSet annotation) ifTrue:		[^left].	left = '------' ifTrue:		[^'> ', right].	right = '------' ifTrue:		[^left, ' <'].	^left, ' <-> ', right! !!MessageSetDifferencer methodsFor: 'accessing' stamp: 'eem 5/23/2008 13:24'!selectedMessageName	"Answer the message selector of the currently selected message, if any. 	 Answer nil otherwise."	| selectedMessageName class tree plainClassDefinition |	selectedMessageName := leftSet selectedMessageName								ifNotNil: [:leftMessage| leftMessage]								ifNil: [rightSet selectedMessageName ifNotNil:										[:rightMessage| rightMessage]].	(#(Definition Hierarchy Comment) includes: selectedMessageName) ifFalse:		[^selectedMessageName].	#Definition ~~ selectedMessageName ifTrue:		[^nil].	(plainClassDefinition := leftSet contents) isEmpty ifTrue:							[plainClassDefinition := rightSet contents].	class := self selectedClassOrMetaClass.	tree := class subclassDefinerClass parserClass new			parse: plainClassDefinition readStream			class: class			noPattern: true			context: nil			notifying: nil			ifFail: [].	"Demeter, who (tf) is Demeter??"	^tree block statements first expr selector key! !!MessageSetDifferencer methodsFor: 'private' stamp: 'eem 5/7/2008 13:40'!autoSelectString	"Return the string to be highlighted when making new selections"	^ autoSelectString! !!MessageSetDifferencer methodsFor: 'private' stamp: 'eem 5/7/2008 13:40'!autoSelectString: aString	"Set the string to be highlighted when making new selections"	autoSelectString := aString! !!MessageSetDifferencer methodsFor: 'toolbuilder' stamp: 'ar 8/25/2009 09:46'!buildWith: builder	| windowSpec max result |	self wantsOptionalButtons ifTrue:[max := 0.3] ifFalse:[max := 0.3].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	autoSelectString ifNotNil:[self changed: #autoSelect].	^result! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 7/15/2010 18:25'!changeDefinitions: newList	| oldSelection newListIndex |	oldSelection := messageList at: messageListIndex ifAbsent: [0].	leftSet initializeMessageList:  (newList collect: [:ea| ea first]).	rightSet initializeMessageList:  (newList collect: [:ea| ea last]).	messageList := newList.	messageListIndex := newListIndex := (oldSelection ifNil: [0] ifNotNil: [messageList indexOf: oldSelection ifAbsent: [0]]).	self reformulateList;		messageListIndex: newListIndex;		changed: #messageList! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 5/7/2008 16:33'!listEntryForIndex: index	^(leftSet messageList at: index) asStringOrText, ' <-> ', (rightSet messageList at: index) asStringOrText! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 5/7/2008 13:45'!messageList	"Answer the current list of messages."	^messageList! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 5/8/2008 12:17'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	leftSet messageListIndex: anInteger.	rightSet messageListIndex: anInteger.	currentCompiledMethod := leftSet selection								ifNotNil: [[leftSet selection compiledMethod]											on: KeyNotFound											do: [:ex| nil]]								ifNil: [rightSet selection ifNotNil:										[[rightSet selection compiledMethod											on: KeyNotFound											do: [:ex| nil]]]].	messageListIndex := anInteger.	contents := ''.	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self contentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].	self decorateButtons! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 7/15/2010 17:23'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove unchanged'		removeUnchangedDefinitions)			('remove changed'			removeChangedDefinitions)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 7/15/2010 18:24'!removeChangedDefinitions	self changeDefinitions: (messageList select: [:pair| pair first sourceString = pair second sourceString])! !!MessageSetDifferencer methodsFor: 'message list' stamp: 'eem 7/15/2010 18:25'!removeUnchangedDefinitions	self changeDefinitions: (messageList reject: [:pair| pair first sourceString = pair second sourceString])! !!MessageSetDifferencer methodsFor: 'initialize-release' stamp: 'eem 5/7/2008 16:34'!initializeDefinitionPairs: aSequence	leftSet := MessageSet messageList: (aSequence collect: [:ea| ea first]).	rightSet := MessageSet messageList: (aSequence collect: [:ea| ea last]).	messageList := aSequence.	contents := ''! !!MessageSetDifferencer methodsFor: 'class list' stamp: 'eem 5/23/2008 13:23'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	^leftSet selectedClassOrMetaClass		ifNotNil: [:leftBehavior| leftBehavior]		ifNil: [rightSet selectedClassOrMetaClass ifNotNil:				[:rightBehavior| rightBehavior]]! !!MessageSetDifferencer commentStamp: '<historical>' prior: 0!This is a variation of MessageSet that allows diffing of arbitrary definitions.  It is initialized with pairs of definitions, each pair being compared against each other.!!MessageSetDifferencer class methodsFor: 'instance creation' stamp: 'eem 3/3/2009 17:47'!compareClass: aClass to: bClass	| definitionPairSequence |	definitionPairSequence := { { ClassReference class: aClass. ClassReference class: bClass } },							((aClass selectors, bClass selectors) asSet asSortedCollection collect:								[:s| {									MethodReference class: aClass selector: s. 									MethodReference class: bClass selector: s }]).	self openMessageList: definitionPairSequence name: aClass name, ' <-> ', bClass name autoSelect: nil	"MessageSetDifferencer compareClass: InterpreterStackPages to: CoInterpreterStackPages"	"MessageSetTextDifferencer compareClass: InterpreterStackPages to: CoInterpreterStackPages"! !!MessageSetDifferencer class methodsFor: 'instance creation' stamp: 'eem 5/7/2008 12:47'!definitionPairs: aSequence	^self new initializeDefinitionPairs: aSequence! !!MessageSetDifferencer class methodsFor: 'instance creation' stamp: 'eem 7/15/2010 17:01'!openMessageList: definitionPairSequence name: labelString autoSelect: autoSelectString	"Open a system view for a MessageSetDifferencer on definitionPairSequence. "	| differencer |	differencer := self definitionPairs: definitionPairSequence.	differencer autoSelectString: autoSelectString.	^ToolBuilder open: differencer label: labelString! !!MessageSetTextDifferencer methodsFor: 'contents' stamp: 'eem 9/15/2008 14:16'!contents	"Answer the contents of the receiver"	| left right |	left := leftSet selection.	right := rightSet selection.	(left isNil and: [right isNil]) ifTrue:		[currentCompiledMethod := nil.		 ^''].	left isNil ifTrue:		[^rightSet contents].	right isNil ifTrue:		[^leftSet contents].	^TextDiffBuilder buildDisplayPatchFrom: rightSet contents to: leftSet contents! !!Metaclass methodsFor: 'testing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!MethodContext methodsFor: 'accessing' stamp: 'ajh 9/28/2001 02:16'!method	^method! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 9/10/2009 15:49'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	closureOrNil		ifNotNil:			[pc := closureOrNil startpc.			self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.			1 to: closureOrNil numCopiedValues do:				[:i | self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i)]]		ifNil:			[pc := method initialPC.			self stackp: method numTemps.			method numArgs+1 to: method numTemps do:				[:i | self tempAt: i put: nil]]! !!MethodContext methodsFor: 'printing' stamp: 'ar 7/13/2007 17:04'!longPrint: anObject on: aStream limitedTo: max indent: indent	"Carefully print anObject in the face of direct ProtoObject subclasses"	| value |	(anObject class includesBehavior: Object)		ifTrue:[^anObject longPrintOn: aStream limitedTo: max indent: indent].	anObject class allInstVarNames doWithIndex:[:title :index |		indent timesRepeat: [aStream tab].		aStream nextPutAll: title; nextPut: $:; space; tab.		(anObject class canUnderstand: #instVarAt:) 			ifTrue:[value := anObject instVarAt: index]			ifFalse:[value := '???'].		aStream nextPutAll: (self print: value limitedTo: (max -3 -title size max: 1)).		aStream cr.	].! !!MethodContext methodsFor: 'printing' stamp: 'jcg 8/3/2010 14:20'!printDetails: strm	"Put my class>>selector and instance variables and arguments and temporaries on the stream.  Protect against errors during printing."	| pe str pos |	self printOn: strm.	strm cr.	strm tab; nextPutAll: 'Receiver: '.	pe := '<<error during printing>>'.	strm nextPutAll: ([self print: receiver limitedTo: 190] ifError: [:err :rcvr | pe]).	strm cr; tab; nextPutAll: 'Arguments and temporary variables: '; cr.	str := [self tempsAndValuesLimitedTo: 180 indent: 2] ifError: [:err :rcvr | pe].	strm nextPutAll: str.	strm cr; tab; nextPutAll: 'Receiver''s instance variables: '; cr.	pos := strm position.	[self longPrint: receiver on: strm limitedTo: 180 indent: 2] ifError: [:err :rcvr | 				strm nextPutAll: pe].	pos = strm position ifTrue: ["normal printString for an Array (it has no inst vars)"		strm nextPutAll: ([self print: receiver limitedTo: 190] ifError: [:err :rcvr | pe])].	strm peekLast == Character cr ifFalse: [strm cr].! !!MethodContext methodsFor: 'system simulation' stamp: 'eem 7/2/2010 10:26'!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	closureOrNil		ifNil: [self error: 'context needs a closure!!']		ifNotNil:			["See BlockClosure>>asContextWithSender:"			 stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue:				[self error: 'stack pointer is incorrect!!'].].	1 to: closureOrNil numArgs do:		[:i| self at: i put: (args at: i)].	sender := sendr! !!MethodContext methodsFor: '*Tools-Inspector' stamp: 'ar 8/19/2010 12:16'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ ContextInspector! !!MethodContextTest methodsFor: 'running' stamp: 'tlk 5/31/2004 16:18'!setUp	super setUp.	aCompiledMethod := Rectangle methodDict at: #rightCenter.	aReceiver := 100@100 corner: 200@200.	aSender := thisContext.	aMethodContext := MethodContext sender: aSender receiver: aReceiver method: aCompiledMethod arguments: #(). ! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/30/2004 13:35'!testActivateReturnValue	self assert:  ((aSender activateReturn: aMethodContext value: #()) isKindOf: MethodContext).	self assert:  ((aSender activateReturn: aMethodContext value: #()) receiver = aMethodContext).! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 17:09'!testCopyStack	self assert: aMethodContext copyStack printString = aMethodContext printString.! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 17:10'!testFindContextSuchThat	self assert: (aMethodContext findContextSuchThat: [:each| true]) printString = aMethodContext printString.	self assert: (aMethodContext hasContext: aMethodContext). ! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/30/2004 10:57'!testMethodContext	self deny: aMethodContext isPseudoContext.	self assert: aMethodContext home notNil.	self assert: aMethodContext receiver notNil.	self assert: (aMethodContext method isKindOf: CompiledMethod).! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 17:08'!testMethodIsBottomContext	self assert: aMethodContext bottomContext = aSender.	self assert: aMethodContext secondFromBottom = aMethodContext.! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 16:55'!testReturn	"Why am I overriding setUp? Because sender must be thisContext, i.e, testReturn, not setUp."	aMethodContext := MethodContext sender: thisContext receiver: aReceiver method: aCompiledMethod arguments: #(). 	self assert: (aMethodContext return: 5) = 5.! !!MethodContextTest methodsFor: 'tests' stamp: 'mha 8/10/2009 08:56'!testSetUp	"Note: In addition to verifying that the setUp worked the way it was expected to, testSetUp is used to illustrate the meaning of the simple access methods, methods that are not normally otherwise 'tested'"	self assert: aMethodContext isMethodContext.	self deny: aMethodContext isClosure.	self deny: aMethodContext isPseudoContext.	self deny: aMethodContext isDead.	"self assert: aMethodContext home = aReceiver."	"self assert: aMethodContext blockHome = aReceiver."	self assert: aMethodContext receiver = aReceiver.	self assert: (aMethodContext method isKindOf: CompiledMethod).	self assert: aMethodContext method = aCompiledMethod.	self assert: aMethodContext methodNode selector = #rightCenter.	self assert: (aMethodContext methodNodeFormattedAndDecorated: true) selector = #rightCenter.	self assert: aMethodContext client printString = 'MethodContextTest>>#testSetUp'.! !!MethodContextTest commentStamp: 'tlk 5/31/2004 16:07' prior: 0!I am an SUnit Test of MethodContext and its super type, ContextPart. See also BlockContextTest.See pages 430-437 of A. Goldberg and D. Robson's  Smalltalk-80 The Language (aka the purple book), which deal with Contexts. My fixtures are from their example. (The Squeak byte codes are not quite the same as Smalltalk-80.)My fixtures are:aReceiver         - just some arbitrary object, "Rectangle origin: 100@100 corner: 200@200"aSender           - just some arbitrary object, thisContextaCompiledMethod - just some arbitrary method, "Rectangle rightCenter".aMethodContext   - just some arbitray context ...  !!MethodHighlightingTests methodsFor: 'tests' stamp: 'ar 7/22/2010 10:58'!asXML	"self new asXML"	"Convert the master index into external XML representation"	| writer |	^String streamContents:[:s|		writer := #XMLWriter on: s.		writer xmlDeclaration: '1.0'.		writer startTag: 'recording'; endTag.			writer tag: 'creator' pcData: creator.			writer tag: 'timestamp' pcData: timeStamp.			writer tag: 'duration' pcData: duration.			writer startTag: 'tracks'; endTag.				tracks do:[:tdata|					writer startTag: 'track'; attribute: 'type' value: tdata value; endTag.					writer pcData: tdata key.					writer endTag: 'track'.				].			writer endTag: 'tracks'.		writer endTag: 'recording'.	].! !!MethodHighlightingTests methodsFor: 'tests' stamp: 'eem 3/13/2009 16:18'!testMethodHighlighting	| map before after method retpc |	"Test the githlighting of the asXML method.  Test the highlighting of the return statement	 which should include the whole block supplied to streamContents:."	"DebuggerMethodMap voidMapCache"	"DebuggerMethodMap forMethod: MethodHighlightingTests >> #asXML"	method := MethodHighlightingTests >> #asXML.	map := DebuggerMethodMap forMethod: method.	retpc := method endPC.	before := map rangeForPC: retpc contextIsActiveContext: false.	map instVarNamed: 'abstractSourceRanges' put: nil.	after := map rangeForPC: retpc contextIsActiveContext: false.	self assert: before size > 500.	self assert: before = after! !!MethodNode methodsFor: 'code generation' stamp: 'eem 7/14/2010 11:28'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil: [primErrNode sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'Igor.Stasenko 12/20/2009 06:16'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^ self generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString).! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53'!properties	^properties! !!MethodNode methodsFor: 'printing' stamp: 'eem 8/15/2010 10:36'!printWithClosureAnalysisOn: aStream 	self ensureClosureAnalysisDone.	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMethodNode: self! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 11:54'!preen	"Preen for pretty-printing and/or decompilation.	 i.e. post-process to cover up for inadequacies in both algorithms.	 Currently one case, hiding the assignment to the arg of an inlined block arg to ifNotNil:,		(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...]."	self preenLocalIfNotNilArg! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 12:36'!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo:		[:node| | variable |		(node isMessageNode		and: [node macroPrinter == #printIfNilNotNil:indent:		and: [node receiver isMessageNode		and: [node receiver selector key == #==		and: [node receiver receiver isAssignmentNode		and: [(variable := node receiver receiver variable) isTemp		and: [variable isRemote not		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:			[node arguments last arguments isEmpty				ifTrue: [node arguments last arguments: { variable }.						varsToHide add: variable]				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].			 node receiver receiver: node receiver receiver value]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:59'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding parserClass new						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate.		methNode encoder blockExtentsToTempsMap]! !!MethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:58'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!MethodNode commentStamp: 'eem 8/15/2010 10:49' prior: 0!I am the root of the parse tree..Instance Variables	arguments:			<SequenceableCollection>	block:				<BlockNode>	encoder:			<BytecodeEncoder>	localsPool:			<IdentitySet>	locationCounter:	<Integer>	precedence:		<Integer>	primitive:			<Integer>	properties:			<AdditionalMethodState|nil>	selectorOrFalse:	<Object>	sourceText:		<String|Text>	temporaries:		<SequenceableCollection>arguments	- the collection of parsed or decompiled method argumentsblock	- the BlockNode holding the method's statementsencoder	- the object that comprises the copiler's scope table, literal pool and back-end bytecode generatorlocalsPool	- a set used to determine the set of copied values for each block in the methodlocationCounter	- an integer used to mark block scopes for the purposes of the closure transformation.  See BlockNode>>#analyseArguments:temporaries:rootNode:precedence	- the precedence of the method's selector (see Symbol>>precedence)primitive	- if non-zero this is the integer code of the method's primitiveproperties	- the object used to accumulate method properties (a.k.a. pragmas)selectorOrFalse	- the method's selector or false if this is a doitsourceText	- the source test from which the method was compiledtemporaries	- the collection of parsed or decompiled method temporaries!!MethodPragmaTest methodsFor: 'utilities' stamp: 'md 2/18/2006 19:39'!assertPragma: aString givesKeyword: aSymbol arguments: anArray	| pragma decompiled |	pragma := self pragma: aString selector: #zork.	self assert: pragma keyword = aSymbol.	self assert: pragma arguments = anArray.	decompiled := (self class>>#zork) decompile.	self assert: (decompiled properties pragmas includes: pragma). 	self assert: (decompiled asString includesSubString: pragma asString).! !!MethodPragmaTest methodsFor: 'utilities' stamp: 'lr 1/20/2006 02:23'!compile: aString selector: aSelector	self class 		compileSilently: aSelector , String lf , aString		classified: self methodCategory.	^ self class >> aSelector.! !!MethodPragmaTest methodsFor: 'utilities' stamp: 'lr 1/20/2006 11:50'!methodCategory	^ #generated! !!MethodPragmaTest methodsFor: 'utilities' stamp: 'lr 2/6/2006 20:48'!pragma: aString selector: aSelector	^ (self compile: '<' , aString , '>' selector: aSelector)		pragmas first.! !!MethodPragmaTest methodsFor: 'utilities' stamp: 'lr 1/20/2006 08:11'!pragma: aSymbol selector: aSelector times: anInteger	^ (self 		compile: (String streamContents: [ :stream | 			(1 to: anInteger) asArray shuffled do: [ :each | 				stream 					nextPut: $<; nextPutAll: aSymbol; space;					print: each; nextPut: $>; cr ] ])		selector: aSelector)			pragmas.! !!MethodPragmaTest methodsFor: 'running' stamp: 'lr 1/20/2006 02:15'!tearDown	(self class organization listAtCategoryNamed: self methodCategory)		do: [ :each | self class removeSelectorSilently: each ].	self class organization removeCategory: self methodCategory.! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/20/2006 08:18'!testAllNamedFromTo	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma allNamed: #foo: from: self class to: Object.	self assert: pragmasDetected = pragmasCompiled.		pragmasDetected := Pragma allNamed: #foo: from: Object to: Object.	self assert: pragmasDetected isEmpty.! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/20/2006 08:17'!testAllNamedFromToSortedByArgument	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma allNamed: #foo: from: self class to: Object sortedByArgument: 1.	self assert: pragmasDetected = (pragmasCompiled 		sort: [ :a :b | (a argumentAt: 1) < (b argumentAt: 1) ])! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/20/2006 08:17'!testAllNamedFromToSortedUsing	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma 		allNamed: #foo: from: self class to: Object 		sortedUsing: [ :a :b | (a argumentAt: 1) > (b argumentAt: 1) ].	self assert: pragmasDetected = (pragmasCompiled 		sort: [ :a :b | (a argumentAt: 1) > (b argumentAt: 1) ]).! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/20/2006 08:19'!testAllNamedIn	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma allNamed: #foo: in: self class.	self assert: pragmasDetected = pragmasCompiled.		pragmasDetected := Pragma allNamed: #foo: in: Object.	self assert: pragmasDetected isEmpty.! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/20/2006 08:15'!testAllNamedInSortedByArgument	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma allNamed: #foo: in: self class sortedByArgument: 1.	self assert: pragmasDetected = (pragmasCompiled 		sort: [ :a :b | (a argumentAt: 1) < (b argumentAt: 1) ])! !!MethodPragmaTest methodsFor: 'testing-finding' stamp: 'lr 1/21/2006 13:01'!testAllNamedInSortedUsing	| pragmasCompiled pragmasDetected |	pragmasCompiled := self pragma: #foo: selector: #bar times: 5.	pragmasDetected := Pragma 		allNamed: #foo: in: self class 		sortedUsing: [ :a :b | (a argumentAt: 1) > (b argumentAt: 1) ].	self assert: pragmasDetected = (pragmasCompiled 		sort: [ :a :b | (a argumentAt: 1) > (b argumentAt: 1) ]).! !!MethodPragmaTest methodsFor: 'testing-pragma' stamp: 'lr 1/20/2006 00:35'!testArguments	| pragma |	pragma := Pragma keyword: #foo: arguments: #( 123 ).	self assert: pragma arguments = #( 123 ).! !!MethodPragmaTest methodsFor: 'testing-pragma' stamp: 'lr 1/20/2006 00:35'!testKeyword	| pragma |	pragma := Pragma keyword: #foo: arguments: #( 123 ).	self assert: pragma keyword = #foo:.! !!MethodPragmaTest methodsFor: 'testing-pragma' stamp: 'lr 1/20/2006 00:36'!testMessage	| pragma message |	pragma := Pragma keyword: #foo: arguments: #( 123 ).	message := pragma message.		self assert: message selector = #foo:.	self assert: message arguments = #( 123 ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileArray	self assertPragma: 'foo: #()' givesKeyword: #foo: arguments: #( () ).	self assertPragma: 'foo: #( foo )' givesKeyword: #foo: arguments: #( ( foo ) ).	self assertPragma: 'foo: #( foo: )' givesKeyword: #foo: arguments: #( ( foo: ) ).	self assertPragma: 'foo: #( 12 )' givesKeyword: #foo: arguments: #( ( 12 ) ).	self assertPragma: 'foo: #( true )' givesKeyword: #foo: arguments: #( ( true ) ).	! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileCharacter	self assertPragma: 'foo: $a' givesKeyword: #foo: arguments: #( $a ).	self assertPragma: 'foo: $ ' givesKeyword: #foo: arguments: #( $  ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileEmpty	self assertPragma: 'foo' givesKeyword: #foo arguments: #().! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 07:39'!testCompileFull	self assertPragma: 'foo: 1' givesKeyword: #foo: arguments: #( 1 ).	self assertPragma: 'foo: 1 bar: 2' givesKeyword: #foo:bar: arguments: #( 1 2 ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15'!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileNumber	self assertPragma: 'foo: 123' givesKeyword: #foo: arguments: #( 123 ).	self assertPragma: 'foo: -123' givesKeyword: #foo: arguments: #( -123 ).	self assertPragma: 'foo: 12.3' givesKeyword: #foo: arguments: #( 12.3 ).	self assertPragma: 'foo: -12.3' givesKeyword: #foo: arguments: #( -12.3 ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileString	self assertPragma: 'foo: ''''' givesKeyword: #foo: arguments: #( '' ).	self assertPragma: 'foo: ''bar''' givesKeyword: #foo: arguments: #( 'bar' ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 1/20/2006 02:25'!testCompileSymbol	self assertPragma: 'foo: #bar' givesKeyword: #foo: arguments: #( bar ).	self assertPragma: 'foo: #bar:' givesKeyword: #foo: arguments: #( bar: ).	self assertPragma: 'foo: #bar:zork:' givesKeyword: #foo: arguments: #( bar:zork: ).! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 7/3/2006 15:00'!testCompileTemps	"Pragmas should be placeable before and after temps."		self 		shouldnt: [			self assert: (self compile: '| temps | <foo>' selector: #zork) 				pragmas notEmpty ]		raise: SyntaxErrorNotification.	self 		shouldnt: [			self assert: (self compile: '<foo> | temps |' selector: #zork) 				pragmas notEmpty ]		raise: SyntaxErrorNotification.! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49'!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!MethodPragmaTest methodsFor: 'testing-method' stamp: 'lr 1/20/2006 07:54'!testMethod	| pragma |	pragma := self pragma: 'foo' selector: #bar.	self assert: pragma method == (self class >> #bar).! !!MethodPragmaTest methodsFor: 'testing-method' stamp: 'md 2/18/2006 19:59'!testMethodClass	| pragma |	pragma := self pragma: 'foo' selector: #bar.	self assert: pragma methodClass == self class.! !!MethodPragmaTest methodsFor: 'testing-method' stamp: 'lr 1/20/2006 07:54'!testSelector	| pragma |	pragma := self pragma: 'foo' selector: #bar.	self assert: pragma selector == #bar.! !!MethodPragmaTest methodsFor: 'testing-compiled' stamp: 'lr 2/6/2006 21:03'!testNoPragma	| method |	method := self compile: '' selector: #foo.	self assert: method pragmas = #().! !!MethodPragmaTest methodsFor: 'testing-primitives' stamp: 'lr 1/20/2006 02:31'!testPrimitiveIndexed1	"This test useses the #instVarAt: primitive."		self compile: '<primitive: 74> ^ #inst' selector: #inst.	self assert: self inst = #inst.! !!MethodPragmaTest methodsFor: 'testing-primitives' stamp: 'lr 1/20/2006 02:31'!testPrimitiveIndexed2	"This test useses the #asOop primitive."	self compile: '<primitive: 75> ^ #oop' selector: #oop.	self assert: self oop = self asOop.! !!MethodPragmaTest methodsFor: 'testing-primitives' stamp: 'lr 1/20/2006 02:42'!testPrimitiveNamed1	"This test useses the #primitiveDirectoryLookup primitive."	self compile: '<primitive: ''primitiveDirectoryLookup'' module: ''FilePlugin''> ^ #lookup' selector: #lookup.	self assert: self lookup = #lookup.	! !!MethodPragmaTest methodsFor: 'testing-primitives' stamp: 'lr 1/20/2006 02:41'!testPrimitiveNamed2	"This test useses the #primPathNameDelimiter primitive."	self compile: '<primitive: ''primitiveDirectoryDelimitor'' module: ''FilePlugin''> ^ #delim' selector: #delim.	self assert: self delim = FileDirectory primPathNameDelimiter.	! !!MethodPragmaTest methodsFor: 'testing-printing-reformating' stamp: 'md 2/3/2007 11:55'!testReformat	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.		self shouldnt: [ DisplayScreen class reformatMethodAt: #actualScreenDepth] raise: Error.	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.	! !!MethodPropertiesTest methodsFor: 'private' stamp: 'mha 10/11/2009 20:13'!propertyDictionaryFor: aMethod	^ aMethod properties properties! !!MethodPropertiesTest methodsFor: 'running' stamp: 'lr 1/20/2006 19:16'!setUp	method := Object >> #halt.! !!MethodPropertiesTest methodsFor: 'running' stamp: 'lr 1/20/2006 19:20'!tearDown	Object recompile: #halt from: Object.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'kwl 7/26/2006 11:41'!testAllMethodsHaveMethodClass	Smalltalk garbageCollect.	self assert: (CompiledMethod allInstances			reject: [:cm | cm literals last isVariableBinding					and: [cm literals last value isBehavior							or: [cm literals last value isTrait]]]) isEmpty			description: 'CompiledMethods must have methodClass literal'! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'kwl 7/26/2006 11:40'!testAllMethodsHaveNewPropertyFormat	Smalltalk garbageCollect.	self assert: (CompiledMethod allInstances			reject: [:cm | cm hasNewPropertyFormat]) isEmpty		description: 'CompiledMethods must have new property format'! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'mha 10/11/2009 20:01'!testAt	self should: [ method properties at: #zork ] raise: Error.	self assert: (self propertyDictionaryFor: method) isEmpty.	method properties at: #zork put: 'hello'.	self assert: (method properties at: #zork) = 'hello'.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'mha 10/11/2009 20:10'!testAtIfAbsent	self assert: (method properties at: #zork ifAbsent: [ 'hello' ]) = 'hello'.	self assert: (self propertyDictionaryFor: method) isEmpty.	method properties at: #zork put: 'hi'.	self assert: (method properties at: #zork ifAbsent: [ 'hello' ]) = 'hi'.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'lr 2/6/2006 22:18'!testAtIfAbsentPut	self assert: (method properties at: #zork ifAbsentPut: [ 'hello' ]) = 'hello'.	self assert: (method properties at: #zork ifAbsentPut: [ 'hi' ]) = 'hello'.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'lr 2/6/2006 22:18'!testAtPut	self assert: (method properties at: #zork put: 'hello') = 'hello'.	self assert: (method properties at: #zork) = 'hello'.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'bs 12/18/2009 13:36'!testAtPutRepeatedly	self assert: (method properties at: #zork put: 'hello') = 'hello'.	self assert: (method properties at: #zork put: 'hello') = 'hello'.	self assert: (method properties at: #zork) = 'hello'.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'mha 10/11/2009 20:10'!testIncludesKey	self deny: (method properties includesKey: #zork).	self assert: (self propertyDictionaryFor: method) isEmpty.	method properties at: #zork put: 123.	self assert: (method properties includesKey: #zork).! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'mha 10/11/2009 20:13'!testRemoveKey	method properties at: #zork put: 'hello'.	self should: [ method properties removeKey: #halt ] raise: Error.	self assert: (method properties removeKey: #zork) = 'hello'.	self assert: (self propertyDictionaryFor: method) isEmpty.	self should: [ method properties removeKey: #zork ] raise: Error.	self assert: (self propertyDictionaryFor: method) isEmpty.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'mha 10/11/2009 20:13'!testRemoveKeyifAbsent	method properties at: #zork put: 'hello'.	self assert: (method properties removeKey: #halt ifAbsent: [ 'hi' ]) = 'hi'.	self assert: (method properties removeKey: #zork ifAbsent: [ 'hi' ]) = 'hello'.	self assert: (self propertyDictionaryFor: method) isEmpty.	self should: (method properties removeKey: #zork ifAbsent: [ 'hi' ]) = 'hi'.	self assert: (self propertyDictionaryFor: method) isEmpty.! !!MethodReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:29'!<= anotherMethodOrClassReference	classSymbol < anotherMethodOrClassReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodOrClassReference classSymbol ifTrue: [^false].	classIsMeta = anotherMethodOrClassReference classIsMeta ifFalse: [^classIsMeta not].	anotherMethodOrClassReference isMethodReference ifFalse: [^false].	^methodSymbol <= anotherMethodOrClassReference methodSymbol! !!MethodReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:31'!= anotherMethodReference 	"Answer whether the receiver and the argument represent the 	 same object."	^self species == anotherMethodReference species	   and: [self classSymbol = anotherMethodReference classSymbol	   and: [self classIsMeta = anotherMethodReference classIsMeta	   and: [self methodSymbol = anotherMethodReference methodSymbol]]]! !!MethodReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:27'!isClassReference	^false! !!MethodReference methodsFor: 'comparisons' stamp: 'eem 5/7/2008 11:27'!isMethodReference	^true! !!MethodReference methodsFor: 'queries' stamp: 'eem 5/25/2010 17:56'!selector	^methodSymbol! !!MethodReference methodsFor: 'setting' stamp: 'eem 5/5/2008 12:10'!setStandardClass: aClass methodSymbol: methodSym extraText: extraText	self setStandardClass: aClass methodSymbol: methodSym.	stringVersion := stringVersion, ' ' , extraText.! !!MethodReferenceTest methodsFor: 'Running' stamp: 'sd 11/20/2005 21:27'!testEquals	| aMethodReference anotherMethodReference |	aMethodReference := MethodReference new.	anotherMethodReference := MethodReference new.	" 	two fresh instances should be equals between them"	self		should: [aMethodReference = anotherMethodReference].	self		should: [aMethodReference hash = anotherMethodReference hash].	" 	two instances representing the same method (same class and  	same selector) should be equals"	aMethodReference setStandardClass: String methodSymbol: #foo.	anotherMethodReference setStandardClass: String methodSymbol: #foo.	self		should: [aMethodReference = anotherMethodReference].	self		should: [aMethodReference hash = anotherMethodReference hash] ! !!MethodReferenceTest methodsFor: 'Running' stamp: 'sd 11/20/2005 21:27'!testNotEquals	| aMethodReference anotherMethodReference |	aMethodReference := MethodReference new.	anotherMethodReference := MethodReference new.	""	aMethodReference setStandardClass: String methodSymbol: #foo.	anotherMethodReference setStandardClass: String class methodSymbol: #foo.	" 	differente classes, same selector -> no more equals"	self		shouldnt: [aMethodReference = anotherMethodReference].	" 	same classes, diferente selector -> no more equals"	anotherMethodReference setStandardClass: String methodSymbol: #bar.	self		shouldnt: [aMethodReference = anotherMethodReference] ! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'eem 7/6/2010 20:44'!expectedFailures	^Smalltalk isRunningCog		ifTrue: [#()]		ifFalse: [#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:52'!testMirrorAt	| stackpBefore stackpAfter array byteArray |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	byteArray := ByteArray with: 1 with: 2 with: 3.	self assert: (thisContext object: array basicAt: 1) = 1.	self assert: (thisContext object: byteArray basicAt: 2) = 2.	thisContext object: array basicAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: byteArray basicAt: 2 put: 222.	self assert: byteArray asArray = #(1 222 3).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array basicAt: 4] raise: Error.	self should: [thisContext object: byteArray basicAt: 0] raise: Error.	self should: [thisContext object: byteArray basicAt: 1 put: -1] raise: Error! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 19:44'!testMirrorClass	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectClass: Array new) = Array.	self assert: (thisContext objectClass: 1) = 1 class.	self assert: (thisContext objectClass: ProtoObject new) = ProtoObject.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:54'!testMirrorEqEq	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext object: Array new eqeq: Array new) == false.	self assert: (thisContext object: Array eqeq: Array) == true.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:45'!testMirrorInstVarAt	| stackpBefore stackpAfter array point |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	point := Point x: 1 y: 2.	self assert: (thisContext object: array instVarAt: 1) = 1.	self assert: (thisContext object: point instVarAt: 2) = 2.	thisContext object: array instVarAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: point instVarAt: 1 put: 1/2.	self assert: point = (Point x: 1 / 2 y: 2).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array instVarAt: 4] raise: Error.	self should: [thisContext object: point instVarAt: 3] raise: Error! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/12/2009 21:17'!testMirrorPerform	| stackpBefore stackpAfter anInterval |	stackpBefore := thisContext stackPtr.	anInterval := 1 to: 2.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval) == Array.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval superclass) == Interval.	self should: [thisContext object: anInterval perform:# species withArguments: #() inClass: Point]		raise: Error.	self should: [thisContext object: anInterval perform:# species withArguments: OrderedCollection new inClass: Interval]		raise: Error.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:50'!testMirrorSize	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectSize: #(1 2 3)) = 3.	self assert: (thisContext objectSize: '123') = 3.	self assert: (thisContext objectSize: nil) = 0.	self assert: (thisContext objectSize: 1) = 0.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"! !!MockSocketStream methodsFor: 'testing' stamp: 'fbs 3/22/2004 13:08'!atEnd	^self inStream atEnd.! !!MockSocketStream methodsFor: 'accessing' stamp: 'fbs 3/22/2004 12:51'!atEnd: aBoolean	atEnd := aBoolean.! !!MockSocketStream methodsFor: 'accessing' stamp: 'fbs 3/22/2004 13:29'!inStream	^inStream! !!MockSocketStream methodsFor: 'accessing' stamp: 'fbs 3/22/2004 13:08'!outStream	^outStream! !!MockSocketStream methodsFor: 'initialize-release' stamp: 'fbs 3/22/2004 13:29'!initialize	self resetInStream.	self resetOutStream.! !!MockSocketStream methodsFor: 'stream in' stamp: 'fbs 3/22/2004 13:10'!nextLine	^self nextLineCrLf! !!MockSocketStream methodsFor: 'stream in' stamp: 'fbs 3/22/2004 13:09'!nextLineCrLf	^(self upToAll: String crlf).! !!MockSocketStream methodsFor: 'stream in' stamp: 'fbs 3/22/2004 13:28'!resetInStream	inStream := WriteStream on: ''.! !!MockSocketStream methodsFor: 'stream in' stamp: 'fbs 3/22/2004 13:09'!upToAll: delims	^self inStream upToAll: delims.! !!MockSocketStream methodsFor: 'stream out' stamp: 'fbs 3/22/2004 13:28'!resetOutStream	outStream := WriteStream on: ''.! !!MockSocketStream methodsFor: 'stream out' stamp: 'fbs 3/22/2004 13:07'!sendCommand: aString	self outStream		nextPutAll: aString;		nextPutAll: String crlf.! !!MockSocketStream class methodsFor: 'instance creation' stamp: 'fbs 3/22/2004 12:46'!on: socket	^self basicNew initialize! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:05'!close	"This is how we leave the mode." 	modeActive := false.! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:02'!controlInitialize	modeActive := true.	^ super controlInitialize! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:00'!isControlActive	^ modeActive! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:00'!isControlWanted	^ modeActive! !!ModalController commentStamp: '<historical>' prior: 0!I am a controller that puts the poor user into a mode by not relinquishing control. However, I do pass control onto my underlings. Some underling is expected to end the mode by sending me 'close'. Watch out Larry Tesler, the mode lives on...!!ModalSystemWindowView methodsFor: 'label access' stamp: 'acg 2/9/2000 08:35'!backgroundColor	^Color lightYellow! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/18/2000 20:41'!borderWidth: anObject	modalBorder := false.	^super borderWidth: anObject! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 00:50'!initialize 	"Refer to the comment in View|initialize."	super initialize.	self borderWidth: 5.	self noLabel.	modalBorder := true.! !!ModalSystemWindowView methodsFor: 'controller access' stamp: 'dtl 1/24/2010 17:56'!defaultControllerClass	^Smalltalk at: #ModalController! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/18/2000 20:24'!display	super display.	self displayLabelBackground: false.	self displayLabelText.! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/19/2000 00:59'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	modalBorder ifFalse: [^super displayBorder].	Display		border: self displayBox		widthRectangle: (1@1 corner: 2@2)		rule: Form over		fillColor: Color black.	Display		border: (self displayBox insetBy: (1@1 corner: 2@2))		widthRectangle: (4@4 corner: 3@3)		rule: Form over		fillColor: (Color r: 16rEA g: 16rEA b: 16rEA).! !!ModalSystemWindowView methodsFor: 'displaying' stamp: 'acg 2/9/2000 07:21'!displayLabelBoxes	"Modal dialogs don't have closeBox or growBox."! !!ModalSystemWindowView methodsFor: 'modal dialog' stamp: 'BG 12/13/2002 11:33'!doModalDialog	| savedArea |	self resizeInitially.	self resizeTo: 		((self windowBox)			align: self windowBox center			with: Display boundingBox aboveCenter).	savedArea := Form fromDisplay: self windowBox.	self displayEmphasized.	self controller startUp.	self release.	savedArea displayOn: Display at: self windowOrigin.! !!ModalSystemWindowView methodsFor: 'model access' stamp: 'acg 2/9/2000 00:57'!update: aSymbol	aSymbol = #close		ifTrue: [^self controller close].	^super update: aSymbol! !!ModalSystemWindowView commentStamp: '<historical>' prior: 0!I am a view for a Modal System Window.  I vary from StandardSystemView, of which I am a subclass in a few ways:	(1) I use ModalController as my default controller;	(2) When asked to update with the symbol #close, I direct the controller to close;	(3) I display a slightly different title bar with no control boxes.!!MonitorTest methodsFor: 'examples' stamp: 'md 3/19/2006 21:15'!testExample1	| producer1 producer2  monitor goal work counter goalReached finished |	goal := (1 to: 1000) asOrderedCollection.	work := OrderedCollection new.	counter := 0.	goalReached := false.	finished := Semaphore new.	monitor := Monitor new.	producer1 := [       [monitor critical:             [monitor waitUntil: [counter \\5 = 0].              goalReached or: [work add: (counter := counter + 1)].              goalReached := counter >= goal size.              monitor signal            ].           goalReached          ]             whileFalse.         finished signal.	].	producer2 := [         [monitor critical:                [monitor waitWhile: [counter \\5 = 0].                 goalReached or: [work add: (counter := counter + 1)].                 goalReached := counter >= goal size.                 monitor signal].         goalReached       ] whileFalse.     finished signal	].	producer1 forkAt: Processor userBackgroundPriority.	producer2 forkAt: Processor userBackgroundPriority.	finished wait; wait.	self assert: goal = work! !!MonitorTest methodsFor: 'examples' stamp: 'md 3/19/2006 21:19'!testExample2	"Here is a second version that does not use a semaphore to inform the 	forking process about termination of both forked processes"	| producer1 producer2  monitor goal work counter goalReached activeProducers|	goal := (1 to: 1000) asOrderedCollection.	work := OrderedCollection new.	counter := 0.	goalReached := false.	activeProducers := 0.	monitor := Monitor new.  producer1 :=      [ monitor critical: [activeProducers := activeProducers + 1].  [monitor critical:            [monitor waitUntil: [counter \\5 = 0].      goalReached or: [work add: (counter := counter + 1)].     " Transcript show: 'P1  '; show: counter printString; show: '  ';       show: activeProducers printString; cr."      goalReached := counter >= goal size.      monitor signal            ].           goalReached          ]             whileFalse.         monitor critical: [activeProducers := activeProducers - 1.        monitor signal: #finish]. ] . producer2 :=    [monitor critical: [activeProducers := activeProducers + 1].  [monitor critical:          [monitor waitWhile: [counter \\5 = 0].    goalReached or: [work add: (counter := counter + 1)].    goalReached := counter >= goal size.    monitor signal].         goalReached ] whileFalse.     monitor critical: [		activeProducers := activeProducers - 1. 		monitor signal: #finish].	].	producer1 forkAt: Processor userBackgroundPriority.	producer2  forkAt: Processor userBackgroundPriority.	monitor critical: [		monitor waitUntil: [activeProducers = 0 & (goalReached)]				for: #finish.  	].	self assert: goal = work! !!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Month! !!MonthTest methodsFor: 'Coverage' stamp: 'brp 7/26/2003 23:29'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #( #next ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!setUp	super setUp.	month := Month month: 7 year: 1998.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!tearDown	super tearDown.	month := nil.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:52'!testConverting	self assert: month asDate = '1 July 1998' asDate! !!MonthTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:35'!testEnumerating	| weeks |	weeks := OrderedCollection new.	month weeksDo: [ :w | weeks add: w start ].	0 to: 4 do: [ :i | weeks remove: (Week starting:  ('29 June 1998' asDate addDays: i * 7)) start ].	self assert: weeks isEmpty! !!MonthTest methodsFor: 'Tests' stamp: 'it 7/14/2009 01:39'!testIndexOfMonth	| m |	m := #(#January #February #March #April #May #June #July #August #September #October #November #December).		m withIndexDo: [:item :index | self assert: (Month indexOfMonth: item) = index].		self should: [Month indexOfMonth: 1] raise: TestResult error.	self should: [Month indexOfMonth: #1] raise: TestResult error.	self should: [Month indexOfMonth: #Marsh] raise: TestResult error. "notice the misspell!!"	self should: [Month indexOfMonth: #UnexistingMonth] raise: TestResult error.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 16:08'!testInquiries	self 		assert: month index = 7;		assert: month name = #July;		assert: month duration = (31 days).! !!MonthTest methodsFor: 'Tests' stamp: 'nk 7/30/2004 17:52'!testInstanceCreation	| m1 m2 |	m1 := Month starting:  '4 July 1998' asDate.	m2 := Month month: #July year: 1998.	self		assert: month = m1;		assert: month = m2! !!MonthTest methodsFor: 'Tests' stamp: 'it 7/14/2009 01:17'!testNameOfMonth	| m |	m := #(#January #February #March #April #May #June #July #August #September #October #November #December).		m withIndexDo: [:item :index | self assert: (Month nameOfMonth: index) = item].		self should: [Month nameOfMonth: 0] raise: TestResult error.	self should: [Month nameOfMonth: 13] raise: TestResult error.	self should: [Month nameOfMonth: #January] raise: TestResult error.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 23:02'!testPreviousNext	| n p |	n := month next.	p := month previous.	self		assert: n year = 1998;		assert: n index = 8;		assert: p year = 1998;		assert: p index = 6.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:50'!testPrinting	self 		assert: month printString = 'July 1998'.! !!MonthTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:46'!testReadFrom	| m |	m := Month readFrom: 'July 1998' readStream.	self 		assert: m = month! !!MonthTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class Month.!!Morph methodsFor: 'classification' stamp: 'ar 12/18/2008 11:37'!isTextPlusPasteUpMorph	^false! !!Morph methodsFor: 'events-processing' stamp: 'jcg 3/5/2007 13:22'!wantsMetaMenu	^ Preferences cmdGesturesEnabled! !!Morph methodsFor: 'menus' stamp: 'ar 6/21/2010 18:41'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	self mustBeBackmost ifFalse:		[aMenu add: 'send to back' translated action: #goBehind.		aMenu add: 'bring to front' translated action: #comeToFront.		self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.		aMenu addLine].	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addBorderStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu."	self addPlayerItemsTo: aMenu.	"	self addExportMenuItems: aMenu hand: aHandMorph."	self addStackItemsTo: aMenu.	"	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'testing' stamp: 'eem 5/2/2008 14:18'!isPaneButtonMorph	^ false! !!Morph methodsFor: 'testing' stamp: 'eem 5/2/2008 20:52'!isPluggableTextMorph	^false! !!Morph methodsFor: 'testing' stamp: 'ar 12/22/2008 11:38'!isSpeakerMorph	"Am I a speaker morph?"	^false! !!Morph class methodsFor: 'class initialization' stamp: 'bgf 9/28/2007 17:45'!initialize	"Morph initialize"	"this empty array object is shared by all morphs with no submorphs:"	EmptyArray := Array new.	FileList registerFileReader: self.	Preferences		addPreference: #subduedMorphicHilites		categories:  #(morphic)		default: false		balloonHelp: 'if true, morphic uses black-on-blue hilites in lists and gray surrounds in text'		projectLocal:  false		changeInformee:  nil		changeSelector: nil.! !!Morph class methodsFor: 'fileIn/Out' stamp: 'ar 12/18/2008 17:19'!fromFileName: fullName	"Reconstitute a Morph from the file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	aFileStream := (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: fullName) binary contentsOfEntireFile)) binary reset.	morphOrList := aFileStream fileInObjectAndCode.	(morphOrList isSqueakPage) ifTrue: [morphOrList := morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			morphOrList openInWorld]! !!Morph class methodsFor: 'new-morph participation' stamp: 'sw 10/24/2001 15:51'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!Morph class methodsFor: '*MorphicExtras-parts bin' stamp: 'ar 8/9/2010 17:19'!supplementaryPartsDescriptions	"Answer a list of DescriptionForPartsBin objects that characterize objects that this class wishes to contribute to Stationery bins *other* than by the standard default #newStandAlone protocol"	^(Flaps quadsDefiningToolsFlap collect:		[:aQuad | DescriptionForPartsBin fromQuad: aQuad categoryList: #(Tools)])! !!Morph class methodsFor: 'defaults' stamp: 'bgf 12/28/2008 12:18'!buttonFeedbackColor	"The color applied around pressed buttons"	^ self subduedHilites ifTrue: [		Preferences textHighlightColor blacker darker	] ifFalse: [		Color red alpha: 0.6	].! !!Morph class methodsFor: 'defaults' stamp: 'bgf 12/28/2008 12:18'!changedTextSurroundColor	"The color applied to text editors when the contents have been modified and not saved/committed."	^ self subduedHilites ifTrue: [		Color r:0.55 g:0.45 b:0.75	] ifFalse: [		Color red alpha: 0.8	].! !!Morph class methodsFor: 'defaults' stamp: 'bgf 12/28/2008 12:23'!selectionBackground	"The background for selected items in lists and tree-list thingies."	^ self subduedHilites ifTrue: [			Preferences textHighlightColor 		] ifFalse: [			"This is tuned so the red-foreground used for list texts stays somewhat legible."			Color r: 0.8 g:0.8 b: 0.81 alpha: 0.85 		].! !!Morph class methodsFor: 'defaults' stamp: 'bgf 12/28/2008 12:18'!selectionBackgroundFillForBounds: bounds	"The gradient fill for selected list items."	^ (GradientFillStyle colors: (Morph selectionBackground morphicItemSelectionGradient))			origin: bounds topLeft -1;			direction: 0 @ (bounds extent y );			normal: (bounds extent x @0);			yourself.! !!Morph class methodsFor: 'defaults' stamp: 'bgf 12/28/2008 12:26'!selectionForeground		"The foreground for selected entries in lists and tree-list thingies."	^ self subduedHilites ifTrue: [			Color black		] ifFalse: [			Color r: 0.85 g:0.05 b: 0.05		].! !!Morph class methodsFor: 'defaults' stamp: 'bgf 9/28/2007 17:51'!subduedHilites	"Which selection color scheme to use? If true, use the 2007 blue-gray one;	 if false, the tradition red-on-gray one."	^ Preferences		valueOfFlag: #subduedMorphicHilites		ifAbsent: [false]! !!MorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 10/19/2006 00:32'!adhereToEdgeTest"self new adhereToEdgeTest""self run: #adhereToEdgeTest"| r |r := RectangleMorph new openInWorld .self shouldnt: [ [ r adhereToEdge: #eternity ] ensure: [ r delete ] ] raise: Error . r delete .^true ! !!MorphTest methodsFor: 'initialize-release' stamp: 'ar 9/18/2009 20:07'!getWorld	^ world		ifNil: [world := MorphicProject new world]! !!MorphTest methodsFor: 'initialize-release' stamp: 'tak 1/21/2005 11:12'!setUp	morph := Morph new! !!MorphTest methodsFor: 'initialize-release' stamp: 'tak 1/21/2005 11:12'!tearDown	morph delete.	world		ifNotNil: [Project deletingProject: world project]! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/4/2003 00:11'!testIntoWorldCollapseOutOfWorld	| m1 m2 collapsed |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	"add them to basic morph"	morph addMorphFront: m1.	m1 addMorphFront: m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	"open the guy"	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	"collapse it"	collapsed := 	CollapsedMorph new beReplacementFor: morph.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).	"expand it"	collapsed collapseOrExpand.	self assert: (m1 intoWorldCount = 2).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 2).	self assert: (m2 outOfWorldCount = 1).	"delete it"	morph delete.	self assert: (m1 intoWorldCount = 2).	self assert: (m1 outOfWorldCount = 2).	self assert: (m2 intoWorldCount = 2).	self assert: (m2 outOfWorldCount = 2).! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/4/2003 00:12'!testIntoWorldDeleteOutOfWorld	| m1 m2 |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	m1 addMorphFront:  m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph delete.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).	! !!MorphTest methodsFor: 'testing - into/outOf World' stamp: 'ar 8/10/2003 18:30'!testIntoWorldTransferToNewGuy	| m1 m2 |	"Create the guys"	m1 := TestInWorldMorph new.	m2 := TestInWorldMorph new.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	m1 addMorphFront:  m2.	self assert: (m1 intoWorldCount = 0).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 0).	self assert: (m2 outOfWorldCount = 0).	morph openInWorld.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m2.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph addMorphFront: m1.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	m2 addMorphFront: m1.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 0).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 0).	morph delete.	self assert: (m1 intoWorldCount = 1).	self assert: (m1 outOfWorldCount = 1).	self assert: (m2 intoWorldCount = 1).	self assert: (m2 outOfWorldCount = 1).! !!MorphTest methodsFor: 'testing - classification' stamp: 'md 4/16/2003 17:11'!testIsMorph	self assert: (morph isMorph).! !!MorphTest methodsFor: 'testing - initialization' stamp: 'md 4/16/2003 17:10'!testOpenInWorld	self shouldnt: [morph openInWorld] raise: Error.! !!MorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Morph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'eem 6/30/2010 15:52'!buildPluggableWindow: aSpec	| widget children |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec multiWindowStyle) new.	self register: widget id: aSpec name.	widget model: aSpec model.	aSpec label ifNotNil:		[:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'eem 6/30/2010 11:44'!windowClassFor: multiWindowStyle	^multiWindowStyle		caseOf:		{	[nil]				->	[PluggableSystemWindow].			[#labelButton]	->	[PluggableSystemWindowWithLabelButton] }		otherwise:				[PluggableSystemWindowWithLabelButton]! !!MorphicTransform methodsFor: 'transformations' stamp: 'ar 12/8/2002 02:19'!invertPoint: aPoint	^self invert: aPoint! !!MorphicTransform methodsFor: 'transformations' stamp: 'ar 12/8/2002 02:19'!invertRect: aRect	^self invertBoundsRect: aRect! !!MorphicTransform methodsFor: 'transformations' stamp: 'ar 12/8/2002 02:19'!transformRect: aRect	^self transformBoundsRect: aRect! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'testing 7/13/2010 18:04'!findWindowInWorldLabeled: aLabel	^ World submorphs detect: [ :each |		each isSystemWindow			and: [ each label = aLabel ] ] ifNone: [ nil ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 6/11/2007 20:34'!setUp"default. tests will add morphs to list. Teardown will delete."cases := #() .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 1/3/2007 11:25'!tearDown"default. tests will add morphs to list. Teardown will delete."cases do: [ :each | each delete ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ul 1/11/2010 07:54'!testOpenWorkspace	"self new testOpenWorkspace"	"MorphicUIBugTest run: #testOpenWorkspace"		| window myLabel foundWindow myModel |	self assert: Smalltalk isMorphic.	myLabel := 'Workspace from SUnit test' .	foundWindow := self findWindowInWorldLabeled: myLabel .	self assert: foundWindow isNil.	window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel.	window := window.	foundWindow := self findWindowInWorldLabeled: myLabel.	cases := Array with: foundWindow . "For teardown."	myModel := foundWindow submorphs detect: #isMorphicModel.	self assert: myModel model class == Workspace.	self assert: foundWindow model class == Workspace.	foundWindow delete! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testOpenWorkspaceAns"Test if method opening a workspace answers the window opened""MorphicUIBugTest run: #testOpenWorkspaceAns"| window myLabel foundWindow |self assert: ( Smalltalk isMorphic ) .myLabel := 'Workspace from ', 'SUnit test' .foundWindow := self findWindowInWorldLabeled: myLabel .self assert: ( foundWindow isNil ) .window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel .foundWindow := self findWindowInWorldLabeled: myLabel .cases := Array with: foundWindow . "For teardown."self assert: ( window == foundWindow ) .foundWindow delete .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ar 4/7/2010 20:34'!testShowAllBinParts	"self new testShowAllBinParts"	"MorphicUIBugTest run: #testShowAllBinParts"	self assert: ( Smalltalk isMorphic ) .	self shouldnt: [cases := Array with: ObjectsTool  initializedInstance showAll openCenteredInWorld  ] raise: Error .! !!MorphicUIBugTest commentStamp: 'wiz 1/3/2007 13:57' prior: 0!A MorphicUIBugTest is a class for testing the shortcomings and repairs of the MorphicUI manager..Instance Variables	cases:		<aCollection>cases	- a list of morphs that may need to be deleted during teardown.	the tests are expected to fill this list it starts out empty by default.		!!MorphicUIManager methodsFor: 'ui requests' stamp: 'eem 7/1/2010 14:41'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptAction: anAction;		acceptContents:  aText.	^window.! !!MouseButtonEvent methodsFor: 'private' stamp: 'jdm 4/1/2008 11:10'!setType: evtType position: evtPos which: button buttons: evtButtons nrClicks: nClicks  hand: evtHand stamp: stamp	type := evtType.	position := evtPos.	buttons := evtButtons.	nrClicks := nClicks.	source := evtHand.	wasHandled := false.	whichButton := button.	timeStamp := stamp.! !!MouseButtonEvent methodsFor: 'nil' stamp: 'jdm 3/31/2008 12:30'!nrClicks	^nrClicks! !!MouseButtonEvent methodsFor: 'as yet unclassified' stamp: 'jdm 3/31/2008 12:30'!nrClicks: count	nrClicks := count.! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 15:01'!blueButtonActivity	"This normally opens the window menu. It is a no-op here	as only the StandardSystemController deals with that kind	of menus."! !!MouseMenuController methodsFor: 'menu messages'!performMenuMessage: aSelector	"Perform a menu command by sending self the message aSelector.	 Default does nothing special."	^self perform: aSelector! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index := redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:59'!yellowButtonActivity	"This normally opens a popup menu. Determine the selected	item and, if one is selected, then send the corresponding message	to either the model or the receiver."	^ self pluggableYellowButtonActivity: sensor leftShiftDown! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint := sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 11:24'!isControlActive 	"In contrast to class Controller, only blue button but not yellow button	events will end the receiver's control loop."	^ self viewHasCursor and: [sensor blueButtonPressed not]! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:36'!getPluggableYellowButtonMenu: shiftKeyState	^ view getMenu: shiftKeyState! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 2/17/2002 04:35'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu |	(menu := self getPluggableYellowButtonMenu: shiftKeyState)		ifNil:			[sensor waitNoButton]		ifNotNil:			[self terminateAndInitializeAround:				[menu invokeOn: model orSendTo: self]]! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 3/22/2001 12:03'!shiftedTextPaneMenuRequest	"The user chose the more... branch from the text-pane menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!shiftedYellowButtonActivity	"Invoke the model's special popup menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!unshiftedYellowButtonActivity	"Invoke the model's normal popup menu."	^ self pluggableYellowButtonActivity: false! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu := aSystemMenu.	redButtonMessages := anArray! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!release	super release.	redButtonMenu release! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu := nil.	redButtonMessages := nil! !!MouseMenuController commentStamp: '<historical>' prior: 0!I am a Controller that modifies the scheduling of user activities so that the three mouse buttons can be used to make selections or display menus. The menu items are unary messages to the value of sending my instance the message menuMessageReceiver.!!MouseMoveEvent methodsFor: 'private' stamp: 'ar 3/10/2010 21:33'!setTrail: newTrail	trail := newTrail.! !!MultiByteFileStream methodsFor: 'open/close' stamp: 'ar 7/20/2010 10:32'!handle: fileHandle name: fileName forWrite: writeMode	"Initialize the receiver with an explicit file handle and name."	super handle: fileHandle name: fileName forWrite: writeMode.	converter ifNil: [self converter: UTF8TextConverter new].	self lineEndConvention: #crlf.! !!MultiByteFileStreamTest methodsFor: 'as yet unclassified' stamp: 'ul 2/14/2010 13:21'!tearDown	fileName ifNotNil: [		FileDirectory default deleteFileNamed: fileName ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:21'!testAsciiBackChunk		fileName := 'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			lineEndConvention: #cr; 			converter: UTF8TextConverter new;			cr; nextChunkPut: 'test1' printString;			cr; nextChunkPut: 'test2' printString.		self 			assert: file backChunk = (String cr , 'test2' printString);			assert: file backChunk = (String cr , 'test1' printString) ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:26'!testBinaryUpTo	"This is a non regression test for bug http://bugs.squeak.org/view.php?id=6933"		fileName := 'foobug6933'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file			binary;			nextPutAll: #[ 1 2 3 4 ] ].	MultiByteFileStream oldFileNamed: fileName do: [ :file |		file binary.		self assert: (file upTo: 3) = #[ 1 2 ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'nice 12/8/2009 21:07'!testByteTextConverter	| strings converterClasses |	strings := {		String newFrom: ((0 to: 255) collect: [:e | e asCharacter]).	}.		converterClasses := ByteTextConverter allSubclasses.	converterClasses do: [:converterClass | 		strings do: [:string | | converter stream encoded decoded encoded2 |			converter := converterClass new.			stream := string readStream.			encoded := string select: [:e | (converter nextFromStream: stream) notNil].			stream := encoded readStream.			decoded := encoded collect: [:e | converter nextFromStream: stream].			self assert: stream atEnd.			stream := String new writeStream.			converter nextPutAll: decoded toStream: stream.			encoded2 := stream contents.			self assert: (encoded2 collect: [:e | e charCode] as: Array) = (encoded collect: [:e | e charCode] as: Array).			stream := String new writeStream.			decoded do: [:e | converter nextPut: e toStream: stream].			encoded2 := stream contents.			self assert: (encoded2 collect: [:e | e charCode] as: Array) = (encoded collect: [:e | e charCode] as: Array)]]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:27'!testLineEnding	fileName := 'foolinend.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			wantsLineEndConversion: false;			nextPutAll: 'line 1'; cr;			nextPutAll: 'line 2'; crlf;			nextPutAll: 'line 3'; lf;			nextPutAll: 'line 4' ].	{		{#cr.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#lf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#crlf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{nil.  'line 1' , String cr , 'line 2' , String crlf , 'line 3' , String lf , 'line 4'}	} do: [:lineEndingResult |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEndingResult first.			self assert: file upToEnd = lineEndingResult last ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:17'!testMultiByteTextConverter	| strings converterClasses |	strings := {		String newFrom: ((0 to: 255) collect: [:e | Unicode value: e]).		String newFrom: ((0 to: 1023) collect: [:e | Unicode value: e]).	}.		converterClasses := {		UTF8TextConverter . UTF16TextConverter .		"CompoundTextConverter ."		"EUCJPTextConverter . CNGBTextConverter . ShiftJISTextConverter . EUCKRTextConverter"}.	converterClasses do: [:converterClass |		strings do: [:string |			| converter stream |			converter := converterClass new.			stream := String new writeStream.			converter nextPutAll: string toStream: stream.			stream := stream contents readStream.			string do: [:e | | decoded |				decoded := converter nextFromStream: stream.				self assert: e charCode = decoded charCode].			self assert: stream atEnd.				stream := String new writeStream.			string do: [:e | converter nextPut: e toStream: stream].			stream := stream contents readStream.			string do: [:e | | decoded |				decoded := converter nextFromStream: stream.				self assert: e charCode = decoded charCode].			self assert: stream atEnd]]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:23'!testNextLine	fileName := 'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file			wantsLineEndConversion: false;			nextPutAll: 'line 1'; cr;			nextPutAll: 'line 2'; crlf;			nextPutAll: 'line 3'; lf;			nextPutAll: 'line 4' ].	#(cr lf crlf nil) do: [:lineEnding |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEnding.			self				assert: file nextLine = 'line 1';				assert: file nextLine = 'line 2';				assert: file nextLine = 'line 3';				assert: file nextLine = 'line 4';				assert: file nextLine = nil ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:22'!testNonAsciiBackChunk	"Note: this is an expected failure: MultiByteFileStream is not equipped to read back non ASCII String... (no comment)	As a consequence, never use non ASCII in method category nor in your initials. That would make a few tools blind..."		fileName :=  'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			lineEndConvention: #cr; 			converter: UTF8TextConverter new;			cr; nextChunkPut: 'test' printString;			cr; nextChunkPut: 'test' printString.		self assert: file backChunk = (String cr , 'test' printString).		self assert: file backChunk = (String cr , 'test' printString) ]! !!MultiWindowLabelButtonMorph methodsFor: 'drawing' stamp: 'eem 5/6/2008 13:24'!drawOn: aCanvas 	"Be invisible."! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 17:03'!performAction	"Override to interpret the actionSelector as a menu accessor and to activate that menu."	actionSelector ifNotNil:		[(model perform: actionSelector) ifNotNil:			[:menu|			menu				invokeModalAt: self position - (0@5)				in: ActiveWorld				allowKeyboard: Preferences menuKeyboardControl]]! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState	"Answer the value of savedMultiWindowState"	^ savedMultiWindowState! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState: anObject	"Set the value of savedMultiWindowState"	savedMultiWindowState := anObject! !!MultiWindowLabelButtonMorph commentStamp: 'eem 6/30/2010 16:13' prior: 0!A MultiWindowLabelButtonMorph is  a means of implementing tabbed windows.  It cooperates with PluggableSystemWindowWithButton to provide a drop-down menu of windows when clicking in the window label.  It requires the model to create a suitable sub-instance of SavedMultiWindowState for inactive windows.  To specify multi-windows use the multiWindowStyle: setter to customize a PluggableWindowSpec.Instance Variables	savedMultiWindowState:		<SavedMultiWindowState>savedMultiWindowState	- the sequence of models in a multi-window.!!Mutex methodsFor: 'mutual exclusion' stamp: 'eem 3/22/2009 10:39'!critical: aBlock	"Evaluate aBlock protected by the receiver."	^self primitiveEnterCriticalSection		ifTrue: [aBlock value]		ifFalse: [aBlock ensure: [self primitiveExitCriticalSection]]! !!Mutex methodsFor: 'mutual exclusion' stamp: 'ar 3/23/2009 11:53'!critical: aBlock ifLocked: lockedBlock	"Answer the evaluation of aBlock protected by the receiver.  If it is already in a critical	 section on behalf of some other process answer the evaluation of lockedBlock."	^self primitiveTestAndSetOwnershipOfCriticalSection		ifNil: [lockedBlock value]		ifNotNil:[:alreadyOwner|			alreadyOwner				ifTrue: [aBlock value]				ifFalse: [aBlock ensure: [self primitiveExitCriticalSection]]]! !!Mutex methodsFor: 'accessing' stamp: 'ar 3/23/2009 11:53'!owningProcess	"For debugging. Answer the owning process of this mutex.	There is no setter since the owning process is managed by the VM."	^owningProcess! !!Mutex methodsFor: 'private-primitives' stamp: 'eem 9/30/2009 10:30'!primitiveEnterCriticalSection	"Primitive. The receiver must be unowned or owned by the current process to proceed.	 Answer if the process is already owned by the current process."	<primitive: 186>	self primitiveFailed	"In the spirit of the following"	"owner isNil ifTrue:		[owner := Processor activeProcess.		^false].	 owner = Processor activeProcess ifTrue: [^true].	 [self addLast: Processor activeProcess.	  Processor activeProcess suspend] uninterruptiblyDo.	^false"! !!Mutex methodsFor: 'private-primitives' stamp: 'eem 9/30/2009 10:28'!primitiveExitCriticalSection	"Primitive. Set the receiver to unowned and if any processes are waiting on	 the receiver then proceed the first one, indicating that the receiver is unowned."	<primitive: 185>	self primitiveFailed	"In the spirit of the following"	"owner := nil.	 Processor yield.	 [self isEmpty ifFalse:		[process := self removeFirst.		 process resume]] uninterruptiblyDo"! !!Mutex methodsFor: 'private-primitives' stamp: 'eem 8/13/2009 14:26'!primitiveTestAndSetOwnershipOfCriticalSection	"Primitive. Attempt to set the ownership of the receiver.	 If the receiver is unowned set its owningProcess to the	 activeProcess and answer false.  If the receiver is owned	 by the activeProcess answer true.  If the receiver is owned	 by some other process answer nil."	<primitive: 187>	self primitiveFailed	"In the spirit of the following"	"owner isNil ifTrue:		[owningProcess := Processor activeProcess.		 ^false].	 owner = Processor activeProcess ifTrue: [^true].	 ^nil"! !!Mutex commentStamp: '<historical>' prior: 0!I am a guard on code that allows precisely one process past the guard at any one time, and allows the process that is within the guard to reenter as many times as desired.  For example a Mutex will not block when trying the following:	| m |	m := Mutex new.	m critical: [m critical: [#yes]]whereas a Semaphore will deadlock:	| s |	s := Semaphore forMutualExclusion.	s critical: [s critical: [#no]]!!MyResumableTestError methodsFor: 'exceptionDescription' stamp: 'tfei 6/13/1999 00:46'!isResumable	^true! !!NameLookupFailure methodsFor: 'accessing' stamp: 'ar 10/24/2008 15:21'!defaultAction	"If not handled, simply answer nil"	^nil! !!NativeFont methodsFor: 'private-creation' stamp: 'bgf 7/11/2009 17:27'!ascent: aScalar	"Semi-private for fine-tuning."	ascent := aScalar! !!NativeFont methodsFor: 'private-creation' stamp: 'bgf 7/11/2009 17:25'!descent: aScalar	"Semi-private for fine-tuning."	descent := aScalar! !!NativeFont methodsFor: 'private-creation' stamp: 'dvd 4/15/2009 13:12'!fontName: fontName size: ptSize emphasis: emphasisCode	^self fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: self class defaultRanges! !!NativeFont methodsFor: 'private-creation' stamp: 'dvd 4/7/2009 16:50'!fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray	^self fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray quality: self class defaultQuality! !!NativeFont methodsFor: 'private-creation' stamp: 'dvd 4/7/2009 16:44'!fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray quality: quality	^self fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray quality: quality depth: 32! !!NativeFont methodsFor: 'private-creation' stamp: 'dvd 4/14/2009 11:09'!fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray quality: renderQuality depth: bitDepth	"		^NativeFont fontName: ('MS UI Gothic') size: 12 emphasis: 0 rangesArray: EFontBDFFontReaderForRanges basicNew rangesForJapanese.	"	| fontHandle xStart w glyphForm fontHeight fw enc rangesStream currentRange colorMap |	fontHandle := self primitiveCreateFont: fontName size: ptSize emphasis: emphasisCode quality: renderQuality.	fontHandle ifNil:[^nil].	ranges := rangesArray.	ranges ifNil: [ranges := Array with: (Array with: 0 with: 255)].	pointSize := ptSize.	name := fontName.	emphasis := emphasisCode.	minAscii := 0.	maxAscii := ranges last last.	ascent := self primitiveFontAscent: fontHandle.	descent := self primitiveFontDescent: fontHandle.	"The code below successfully imports kerning pairs, but since this information isn't currently being used, it is commented out to save space.""	kernPairs := Array new: (self primitiveFontNumKernPairs: fontHandle).	1 to: kernPairs size do:[:i|		kernPairs at: i put: (self primitiveFont: fontHandle getKernPair: i)]."	fontHeight := ascent + descent.	xTable := Array new: maxAscii + 3.	fullWidth := Array new: maxAscii + 1.	xStart := maxWidth := 0.	rangesStream := ReadStream on: (ranges collect: [:e | (e first to: e second)]).	currentRange := rangesStream next.	0 to: maxAscii do:[:i|		xTable at: i+1 put: xStart.		i > currentRange last ifTrue: [			[rangesStream atEnd not and: [currentRange := rangesStream next. currentRange last < i]] whileTrue.			rangesStream atEnd ifTrue: [].		].		(currentRange includes: i) ifTrue: [			xTable at: i+1 put: xStart.			fw := self primitiveFont: fontHandle fullWidthOfChar: i.			(#(	1 "anchored morph"				9 "tab"				10 "LF"				13 "CR"			) includes: i) ifTrue:[fw := {0. 0. 0}].			fullWidth at: i+1 put: fw.			w := fw at: 2.			(fw at: 1) > 0 ifTrue:[w := w + (fw at: 1)].			(fw at: 3) > 0 ifTrue:[w := w + (fw at: 3)].			w > maxWidth ifTrue:[maxWidth := w].			xStart := xStart + w].		].	xStart = 0 ifTrue:[^nil].	strikeLength := xStart.	xTable at: maxAscii+1 put: xStart.	xTable at: maxAscii+2 put: xStart.	xTable at: maxAscii+3 put: xStart.	glyphs := Form extent: xTable last @ fontHeight depth: 8.	glyphForm := Form extent: maxWidth @ fontHeight depth: 32.	colorMap := ColorMap		shifts: #(-8 0 0 0)		masks: #(16r0000FF00 0 0 0)		colors: ((255 to: 0 by: -1) collect: [ :gray | gray ]).	0 to: maxAscii do: [ :i |		glyphForm fillWhite.		self primitiveFont: fontHandle glyphOfChar: i into: glyphForm.		xStart := xTable at: i+1.		"Create 8-bit inverse gray scale image from Green channel"		(BitBlt toForm: glyphs)			sourceForm: glyphForm;			colorMap: colorMap;			combinationRule: Form over;			destOrigin: xStart@0;			copyBits.		"Uncomment for debugging"		"(ptSize = 10) ifTrue: [			(BitBlt toForm: Display)				sourceForm: glyphs;				destOrigin: xStart@0;				sourceRect: (xStart@0 extent: maxWidth@fontHeight);				combinationRule: Form blend;				colorMap: (ColorMap					colors: ((0 to: 255 ) collect: [ :scale |						(Color black alpha: scale / 255.0) pixelWordForDepth: 32]));				copyBits.		]."		"(ptSize = 10) & (i = $g asciiValue)			ifTrue: [glyphForm deepCopy inspect]."	].	enc := self primitiveFontEncoding: fontHandle.	enc = 1 ifTrue:[characterToGlyphMap := self isoToSqueakMap].	self primitiveDestroyFont: fontHandle.	^self! !!NativeFont methodsFor: 'private-creation' stamp: 'ar 6/18/2010 16:29'!installDerivativeFonts: fontList	"Reset the cache of derivative emphasized fonts.	 Overrides inherited method to use strict size matching to rematch the persistent derivatives."	| font |	fallbackFont class = FixedFaceFont 		ifTrue: [fallbackFont := nil].	derivativeFonts := Array new: 32.	#('B' 'I' 'BI') doWithIndex:[:tag :index | 		(font := fontList detect: [:each | (each name = (self name , tag)) 									and: [each pointSize = self pointSize] ]					ifNone: [nil]) 			  	ifNotNil: [derivativeFonts at: index put: font]].! !!NativeFont methodsFor: 'private-creation' stamp: 'yo 2/13/2004 02:53'!isoToSqueakMap	^nil! !!NativeFont methodsFor: 'accessing' stamp: 'ar 2/2/2002 18:49'!baseKern	^0! !!NativeFont methodsFor: 'accessing' stamp: 'yo 2/13/2004 04:06'!createCharacterToGlyphMap	^ IdentityGlyphMap new.! !!NativeFont methodsFor: 'accessing' stamp: 'ar 2/2/2002 18:49'!descentKern	^0! !!NativeFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 12:03'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta 	^ self displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.! !!NativeFont methodsFor: 'accessing' stamp: 'dvd 3/16/2009 14:03'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY 	^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY.! !!NativeFont methodsFor: 'accessing' stamp: 'ar 2/18/2001 20:01'!getFontData	| fontHandle bufSize buffer |	fontHandle := self primitiveCreateFont: name size: pointSize emphasis: emphasis.	fontHandle ifNil:[^nil].	bufSize := self primitiveFontDataSize: fontHandle.	buffer := ByteArray new: bufSize.	self primitiveFont: fontHandle getData: buffer.	^buffer! !!NativeFont methodsFor: 'accessing' stamp: 'ar 2/18/2001 20:04'!testEmbeddingFlags	"NativeFont basicNew testEmbeddingFlags"	| list fontHandle |	list := self class listFontNames.	list do:[:fName|		fontHandle := self primitiveCreateFont: fName size: 12 emphasis: 0.		fontHandle ifNotNil:[			type := self primitiveFontEmbeddingFlags: fontHandle.			Transcript cr; show: fName,': ', type printString.			self primitiveDestroyFont: fontHandle.		].	].! !!NativeFont methodsFor: 'accessing' stamp: 'dvd 4/14/2009 11:58'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	"Width is glyph size adjusted by any underhang, overhang or insets."	| code |	code := aCharacter charCode.	((code < minAscii or: [maxAscii < code]) 		or: [(xTable at: code + 1) < 0])			ifTrue: [^ self fallbackFont widthOf: aCharacter].	^(fullWidth at: code + 1) inject: 0 into: [ :sum : each | sum + each ]! !!NativeFont methodsFor: 'accessing' stamp: 'yo 2/17/2004 16:23'!widthOfString: aString from: firstIndex to: lastIndex		^ (aString copyFrom: firstIndex to: lastIndex) inject: 0 into: [:s :t | s := s + (self widthOf: t)].! !!NativeFont methodsFor: 'displaying' stamp: 'ar 9/1/2010 20:04'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destX destPt leftX rightX glyphInfo char destY form gfont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do:[:charIndex|		char := aString at: charIndex.		(self hasGlyphOf: char) ifTrue:[			self glyphInfoOf: char into: glyphInfo.			form := glyphInfo at: 1.			leftX := glyphInfo at: 2.			rightX := glyphInfo at: 3.			destY := glyphInfo at: 4.			gfont := glyphInfo at: 5.			(gfont == aBitBlt lastFont) ifFalse: [gfont installOn: aBitBlt].			destX := destX + (self preAdjustFor: char).			destY := baselineY - destY. 			aBitBlt displayGlyph: form at: destX @ destY left: leftX right: rightX font: self.			destX := destX + (self postAdjustFor: char) + kernDelta.		] ifFalse:[			destPt := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: charIndex at: destX @ aPoint y kern: kernDelta baselineY: baselineY.			destPt x = destX ifTrue:[				"In some situations BitBlt doesn't return the advance width from the primitive.				Work around the situation"				destX := destX + (self widthOfString: aString from: charIndex to: charIndex) + kernDelta.			] ifFalse:[destX := destPt x].		].	].	^destX @ aPoint y! !!NativeFont methodsFor: 'displaying' stamp: 'dvd 4/15/2009 14:49'!installOn: aDisplayContext	^aDisplayContext installNativeFont: self.! !!NativeFont methodsFor: 'displaying' stamp: 'dvd 4/15/2009 14:49'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	aDisplayContext		installNativeFont: self			foregroundColor: fgColor			backgroundColor: bgColor! !!NativeFont methodsFor: 'displaying' stamp: 'dvd 4/14/2009 13:51'!postAdjustFor: aCharacter	"Return the amount of advance for aCharacter"	| widthInfo |	widthInfo := fullWidth at: aCharacter charCode + 1.	^(widthInfo first < 0)		ifTrue: [widthInfo second + widthInfo third]		ifFalse: [widthInfo first + widthInfo second + widthInfo third]! !!NativeFont methodsFor: 'displaying' stamp: 'dvd 4/15/2009 15:00'!preAdjustFor: aCharacter	"Return the amount of underhang for aCharacter"	| widthInfo |	widthInfo := fullWidth at: aCharacter charCode + 1.	^(widthInfo first < 0)		ifTrue: [widthInfo first]		ifFalse: [0]! !!NativeFont methodsFor: 'emphasis' stamp: 'ar 8/29/2000 21:18'!emphasized: code	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	derivativeFonts == nil ifTrue:[derivativeFonts := Array new: 32].	derivative := derivativeFonts at: (safeCode := code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis := 1 bitShift: safeCode highBit - 1.	base := self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative := (base copy name: base name) makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative := (base copy name: base name) makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative := (base copy name: base name) makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative := (base copy name: base name) makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative := (base copy name: base name) makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!NativeFont methodsFor: 'emphasis' stamp: 'yo 2/14/2004 01:38'!makeBoldGlyphs	"First check if we can use some OS support for this"	(self class listFontNames includes: name) ifFalse:[^super makeBoldGlyphs].	"Now attempt a direct creation through the appropriate primitives"	(self fontName: name size: pointSize emphasis: (emphasis bitOr: 1) rangesArray: ranges) 		ifNil:[^super makeBoldGlyphs]. "nil means we failed"! !!NativeFont methodsFor: 'emphasis' stamp: 'yo 2/14/2004 01:39'!makeItalicGlyphs	"First check if we can use some OS support for this"	(self class listFontNames includes: name) ifFalse:[^super makeItalicGlyphs].	"Now attempt a direct creation through the appropriate primitives"	(self fontName: name size: pointSize emphasis: (emphasis bitOr: 2) rangesArray: ranges)		ifNil:[^super makeItalicGlyphs]. "nil means we failed"! !!NativeFont methodsFor: 'emphasis' stamp: 'yo 2/14/2004 01:39'!makeStruckOutGlyphs	"First check if we can use some OS support for this"	(self class listFontNames includes: name) ifFalse:[^super makeStruckOutGlyphs].	"Now attempt a direct creation through the appropriate primitives"	(self fontName: name size: pointSize emphasis: (emphasis bitOr: 8) rangesArray: ranges)		ifNil:[^super makeStruckOutGlyphs]. "nil means we failed"! !!NativeFont methodsFor: 'emphasis' stamp: 'yo 2/14/2004 01:40'!makeUnderlinedGlyphs	"First check if we can use some OS support for this"	(self class listFontNames includes: name) ifFalse:[^super makeUnderlinedGlyphs].	"Now attempt a direct creation through the appropriate primitives"	(self fontName: name size: pointSize emphasis: (emphasis bitOr: 4) rangesArray: ranges)		ifNil:[^super makeUnderlinedGlyphs]. "nil means we failed"! !!NativeFont methodsFor: 'primitives' stamp: 'dvd 4/7/2009 16:27'!primitiveCreateFont: fontName size: fontSize emphasis: fontFlags quality: quality	<primitive:'primitiveCreateFont' module:'NativeFontPlugin'>	^nil! !!NativeFont methodsFor: 'primitives' stamp: 'ar 6/4/2000 23:01'!primitiveDestroyFont: fontHandle	<primitive:'primitiveDestroyFont' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'nk 8/31/2004 09:19'!primitiveFont: fontHandle fullWidthOfChar: aCharIndex 	<primitive:'primitiveFontFullWidthOfChar' module:'NativeFontPlugin'>	^Array 		with: 0		with: (self primitiveFont: fontHandle widthOfChar: aCharIndex)		with: 0! !!NativeFont methodsFor: 'primitives' stamp: 'ar 2/18/2001 19:46'!primitiveFont: fontHandle getData: buffer	<primitive:'primitiveGetFontData' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 8/28/2000 16:05'!primitiveFont: fontHandle getKernPair: kernIndex	<primitive:'primitiveFontGetKernPair' module:'NativeFontPlugin'>	^0! !!NativeFont methodsFor: 'primitives' stamp: 'nk 8/31/2004 09:19'!primitiveFont: fontHandle glyphOfChar: aCharIndex into: glyphForm 	<primitive:'primitiveFontGlyphOfChar' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'nk 8/31/2004 09:19'!primitiveFont: fontHandle widthOfChar: aCharIndex 	<primitive:'primitiveFontWidthOfChar' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 6/4/2000 23:01'!primitiveFontAscent: fontHandle	<primitive:'primitiveFontAscent' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 2/18/2001 19:45'!primitiveFontDataSize: fontHandle	<primitive:'primitiveFontDataSize' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 6/4/2000 23:01'!primitiveFontDescent: fontHandle	<primitive:'primitiveFontDescent' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 2/18/2001 20:00'!primitiveFontEmbeddingFlags: fontHandle	<primitive:'primitiveFontEmbeddingFlags' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 6/4/2000 23:02'!primitiveFontEncoding: fontHandle	<primitive:'primitiveFontEncoding' module:'NativeFontPlugin'>	^self primitiveFailed! !!NativeFont methodsFor: 'primitives' stamp: 'ar 8/28/2000 16:04'!primitiveFontNumKernPairs: fontHandle	<primitive:'primitiveFontNumKernPairs' module:'NativeFontPlugin'>	^0! !!NativeFont methodsFor: 'multibyte character methods' stamp: 'bgf 12/3/2009 10:11'!setupDefaultFallbackFontTo: aTextStyle"	Borrowed from TTCFont.	NativeFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'Accuny')]."	| fonts f |	fonts := aTextStyle fontArray.	(aTextStyle defaultFont familyName endsWith: self familyName) ifTrue: [fallbackFont := nil. ^ self].	f := fonts first.	1 to: fonts size do: [:i |		self height >= (fonts at: i) height ifTrue: [f := fonts at: i].	].	self fallbackFont: f.	self reset.! !!NativeFont commentStamp: 'dvd 4/8/2009 13:29' prior: 0!NativeFont imports high-quality, anti-aliased fonts from the underlying OS via a plugin.  Currently, there is only a plugin for Windows.  NativeFont and its Windows plugin are based on Andreas Raab's HostFont.Font bitmaps are imported as black-on-white, 32-bit bitmaps.  In the presence of sub-pixel anti-aliasing (e.g. text rendered using ClearType), the bitmap won't be a grayscale image--there will be color pixels around the edges of each character.  This full color, 32-bit bitmap is then reduced to an 8-bit bitmap that is essentially just an alpha mask by taking the Green channel of the original bitmap and inverting it.  The resulting 8-bit bitmap can then be paired with a ColorMap whose colors are full, 32-bit colors with alpha transparency values to draw fully anti-aliased text on any background.  Taking the Green channel of the original image is a shortcut that appears to work well.  Theoretically, the correct way to generate a grayscale image from a full color image is to calculate the luminance of each pixel, but this calculation is expensive (and, most importantly, not natively supported by BitBlt.)With the exception of the sub-pixel-to-grayscale conversion, the resulting fonts are drawn bit-identical to what the OS draws.By default, NativeFont imports fonts using the OS's default rendering quality.  This means, for example, that under Windows XP ClearType rendering will not be used unless the user has enabled ClearType in the Display preferences.  The rendering quality can be explicitly set by supplying one of the render constants (defined on the class side) to fontName:size:emphasis:rangesArray:quality:.Kerning pairs can be imported via the Windows plugin, but NativeFont does not make use of kerning pairs, so this information is not imported.  Few Windows XP fonts have kerning pairs and the OS itself does not use kerning pair information when rendering text.  (Microsoft Word, for example, must be explicitly told to use kerning pairs.)The Windows plugin retains the ability to import fonts at 1-bit resolution, but NativeFont does not take advantage of that ability.From a design perspective, it would probably make sense to split the font importing code into a separate class (OSFontImporter) and push the remaining functionality up into StrikeFont.  TTCFont could then also be refactored into an importer (TTCFontImporter) and an identical 8-bit alpha mask bitmap that would be more space efficient and obviate the need to render the font in different colors.!!NativeFont class methodsFor: 'render constants' stamp: 'dvd 4/7/2009 16:48'!defaultQuality	"Match the OS's current render quality"	^0! !!NativeFont class methodsFor: 'render constants' stamp: 'dvd 4/7/2009 16:50'!highQuality	"Render with subpixel antialiasing."	^3! !!NativeFont class methodsFor: 'render constants' stamp: 'dvd 4/7/2009 16:49'!lowQuality	"Render 1-bit quality.  No antialiasing."	^1! !!NativeFont class methodsFor: 'render constants' stamp: 'dvd 4/7/2009 16:49'!mediumQuality	"Render with antialiasing."	^2! !!NativeFont class methodsFor: 'accessing' stamp: 'dvd 4/15/2009 13:13'!defaultRanges	^(Array with: (Array with: 0 with: 255))! !!NativeFont class methodsFor: 'accessing' stamp: 'dvd 3/19/2009 13:34'!fontNameFromUser	"NativeFont fontNameFromUser"	| fontNames index |	fontNames := self listFontNames asSortedCollection.	index := (UIManager default chooseFrom: fontNames title: 'Choose your font').	index = 0 ifTrue:[^nil].	^fontNames at: index! !!NativeFont class methodsFor: 'accessing' stamp: 'ar 6/4/2000 23:18'!listFontName: index	<primitive:'primitiveListFont' module:'NativeFontPlugin'>	^nil! !!NativeFont class methodsFor: 'accessing' stamp: 'ar 6/4/2000 23:18'!listFontNames	"NativeFont listFontNames"	"List all the OS font names"	| font fontNames index |	fontNames := WriteStream on: Array new.	index := 0.	[font := self listFontName: index.	font == nil] whileFalse:[		fontNames nextPut: font.		index := index + 1].	^fontNames contents! !!NativeFont class methodsFor: 'accessing' stamp: 'bgf 7/11/2009 14:13'!pbiTextStyleFrom: fontName sizes: ptSizes	"Generate a fat textStyle with explicit bold and italic as well as plain;	 These are generated so that save-time #reset won't scavenge the glyphs,	 so they remain portable to platforms that don't have the underlying font."	^ self pbiTextStyleFrom: fontName sizes: ptSizes ranges: self defaultRanges! !!NativeFont class methodsFor: 'accessing' stamp: 'ar 6/18/2010 16:38'!pbiTextStyleFrom: fontName sizes: ptSizes ranges: ranges	"Generate a fat textStyle with explicit bold and italic as well as plain;	 These are generated so that save-time #reset won't scavenge the glyphs,	 so they remain portable to platforms that don't have the underlying font."	| styleName fonts style derivativeFonts |	fontName ifNil: [^self].	styleName := fontName asSymbol.	derivativeFonts := OrderedCollection new.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) 		displayProgressAt: Sensor cursorPoint		from: 1 to: (ptSizes size *4) 		during:[:bar|						fonts := OrderedCollection new.			ptSizes do: [ : sz |				bar value: (sz-1)*4 + 1.				(self fontName: styleName size: sz emphasis: 0 rangesArray: ranges)					ifNotNilDo: [ : font | fonts add: font ].				bar value: (sz-1)*4 + 2.				(self fontName: styleName size: sz emphasis: 1 rangesArray: ranges)					ifNotNilDo: [ : font | font name: (styleName, 'B').  derivativeFonts add: font ].				bar value: (sz-1)*4 + 3.				(self fontName: styleName size: sz emphasis: 2 rangesArray: ranges)					ifNotNilDo: [ : font |  font name: (styleName, 'I'). derivativeFonts add: font ].				bar value: (sz-1)*4 + 4.				(self fontName: styleName size: sz emphasis: 3 rangesArray: ranges)					ifNotNilDo: [ : font |  font name: (styleName, 'BI'). derivativeFonts add: font ].			]].	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	style := TextConstants			at: styleName			put: ((TextStyle new) leading: 0; newFontArray: fonts asArray).	"This rebuilds the derivative lists to refer to the other persistent font array entries.	  So the bold and italic glyphsets are preserved across save and load."	fonts do: [ : font | font installDerivativeFonts: derivativeFonts ].	.	^ style! !!NativeFont class methodsFor: 'accessing' stamp: 'dvd 4/15/2009 13:14'!textStyleFrom: fontName	self textStyleFrom: fontName sizes: #(10 11 12 13 14 16 18 20 22 24 26 28 30 36 48 60 72 90)! !!NativeFont class methodsFor: 'accessing' stamp: 'bgf 7/11/2009 13:43'!textStyleFrom: fontName sizes: ptSizes	^ self textStyleFrom: fontName sizes: ptSizes ranges: self defaultRanges! !!NativeFont class methodsFor: 'accessing' stamp: 'bgf 7/11/2009 13:43'!textStyleFrom: fontName sizes: ptSizes ranges: ranges	| styleName fonts |	fontName ifNil: [^self].	styleName := fontName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) displayProgressAt: Sensor cursorPoint		from: 1 to: ptSizes size during:[:bar|			fonts := ptSizes				collect:[:ptSize| bar value: (ptSizes indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0 rangesArray: ranges				]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	^ TextConstants		at: styleName		put: ((TextStyle new) leading: 0; newFontArray: fonts).! !!NativeFont class methodsFor: 'accessing' stamp: 'dvd 4/15/2009 13:09'!textStyleFromUser	"NativeFont textStyleFromUser"	self textStyleFrom: self fontNameFromUser.! !!NativeFont class methodsFor: 'instance creation' stamp: 'ar 6/4/2000 23:13'!fontName: fontName size: ptSize emphasis: emphasisCode	"		^NativeFont fontName: (NativeFont fontNameFromUser) size: 12 emphasis: 0.	"	^self new fontName: fontName size: ptSize emphasis: emphasisCode! !!NativeFont class methodsFor: 'instance creation' stamp: 'yo 2/14/2004 01:17'!fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: ranges	"		^NativeFont fontName: (NativeFont fontNameFromUser) size: 12 emphasis: 0.	"	^self new fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: ranges! !!NativeFont class methodsFor: 'system defaults' stamp: 'bgf 12/3/2009 10:12'!initMacOS	"NativeFont initMacOS"	#(		'Lucida Grande'	) do: [ :fontname | NativeFont		textStyleFrom: fontname		sizes: #(9 10 11 12 13 14 16 24)].	TextConstants at: #DefaultTextStyle put: (TextConstants at: #'Lucida Grande').	TextConstants at: #DefaultFixedTextStyle put: (TextConstants at: #BitstreamVeraSansMono).	#(		(setBalloonHelpFontTo: #BitstreamVeraSans 10)		(setButtonFontTo: #'Lucida Grande' 12)		(setCodeFontTo:	#'Lucida Grande' 11)		(setControlFontTo: #'Lucida Grande' 11)		(setEToysFontTo: #'Accuny' 10 1)		(setFlapsFontTo: #BitstreamVeraSans 10)		(setHaloLabelFontTo: #BitstreamVeraSans 10)		(setListFontTo: #'Lucida Grande' 11)		(setMenuFontTo: #'Lucida Grande' 12)		(setPaintBoxButtonFontTo: #BitstreamVeraSans 9 1)		(setSystemFontTo: #'Lucida Grande' 11)		(setWindowTitleFontTo: #'Lucida Grande' 13)	) do: [ :fontspec | Preferences		perform: fontspec first		with: (((TextConstants at: fontspec second) fontOfPointSize: fontspec third)			emphasized: (fontspec at: 4 ifAbsent: [0]))].	NativeFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'Accuny')].! !!NativeFont class methodsFor: 'system defaults' stamp: 'bgf 12/3/2009 10:12'!initWin32	"NativeFont initWin32"	#(		'Arial'		'Lucida Console'		'Microsoft Sans Serif'		'Tahoma'		'Times New Roman'		'Trebuchet MS'	) do: [ :fontname | NativeFont		textStyleFrom: fontname		sizes: #(9 10 11 12 13 14 16 18 20 22 24 26 28 30 36 48 60 72 90)].	TextConstants at: #DefaultTextStyle put: (TextConstants at: #'Arial').	TextConstants at: #DefaultFixedTextStyle put: (TextConstants at: #'Lucida Console').	#(		(setBalloonHelpFontTo: #'Arial' 9)		(setButtonFontTo: #'Microsoft Sans Serif' 9)		(setCodeFontTo:	#'Arial' 10)		(setControlFontTo: #'Microsoft Sans Serif' 10)		(setEToysFontTo: #'Arial' 9 1)		(setFlapsFontTo: #'Times New Roman' 10)		(setHaloLabelFontTo: #'Times New Roman' 10)		(setListFontTo: #'Arial' 9)		(setMenuFontTo: #'Tahoma' 11)		(setPaintBoxButtonFontTo: #'Arial' 9 1)		(setSystemFontTo: #'Times New Roman' 10)		(setWindowTitleFontTo: #'Trebuchet MS' 11)	) do: [ :fontspec | Preferences		perform: fontspec first		with: (((TextConstants at: fontspec second) fontOfPointSize: fontspec third)			emphasized: (fontspec at: 4 ifAbsent: [0]))].	NativeFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'Accuny')].! !!NativeFont class methodsFor: 'system defaults' stamp: 'bgf 12/3/2009 10:12'!installLucidaGrande	"To run on a platform with a nice Lucida Grande,	 capturing the plain, bold, italic glyphs in the image."	"NativeFont installLucidaGrande ."	| style |	Transcript cr; show: 'For best results: Do this on OS-X. Set text to smooth 8-point.'.	style := (NativeFont pbiTextStyleFrom: 'Lucida Grande' sizes: #(8 9 10 11 12 13 14 16 24)).	style fonts do: [ : font |		font descent: (font descent max: 2).			font ascent: (font ascent max: 11).		"Hack to get breathable paras from smaller sizes"	].	style leading: 1.	Preferences restoreDefaultFonts.	TextConstants at: #DefaultTextStyle put: (TextConstants at: #'Lucida Grande').	TextConstants at: #DefaultFixedTextStyle put: (TextConstants at: #BitstreamVeraSansMono).	#(		"Qwaq standard configuration."		(setButtonFontTo: #'Lucida Grande' 12)		(setCodeFontTo:	#'Lucida Grande' 11)		(setControlFontTo: #'Lucida Grande' 11)		(setListFontTo: #'Lucida Grande' 11)		(setMenuFontTo: #'Lucida Grande' 12)		(setSystemFontTo: #'Lucida Grande' 11)		(setWindowTitleFontTo: #'Lucida Grande' 13)		(setFlapsFontTo: #'Lucida Grande' 12)	) do: [ :fontspec | Preferences		perform: fontspec first		with: (((TextConstants at: fontspec second) fontOfPointSize: fontspec third)			emphasized: (fontspec at: 4 ifAbsent: [0]))].	NativeFont allInstances do: [:i | i setupDefaultFallbackFontTo: (TextStyle named: 'Accuny')].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'ar 10/24/2008 15:12'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline result |	self initializeNetwork.	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result := self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex critical: [		(self waitForResolverReadyUntil: deadline) ifTrue: [			self primStartLookupOfName: hostName.			(self waitForCompletionUntil: deadline)				ifTrue: [result := self primNameLookupResult]]].	result ifNil:[		(NameLookupFailure hostName: hostName) 			signal: 'Could not resolve the server named: ', hostName].	^result! !!NetNameResolver class methodsFor: 'lookups' stamp: 'ar 10/24/2008 15:12'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.2')		timeout: 30"	| deadline result |	self initializeNetwork.	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex critical: [		(self waitForResolverReadyUntil: deadline) ifTrue: [			self primStartLookupOfAddress: hostAddress.			(self waitForCompletionUntil: deadline)				ifTrue: [result := self primAddressLookupResult]]].	^result! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!NoController methodsFor: 'control defaults'!isControlActive 	"Refer to the comment in Controller|isControlActive."	^false! !!NoController methodsFor: 'control defaults'!isControlWanted 	"Refer to the comment in Controller|isControlWanted."	^false! !!NoController methodsFor: 'basic control sequence'!startUp	"I do nothing."	^self! !!NoController commentStamp: '<historical>' prior: 0!I represent a controller that never wants control. I am the controller for views that are non-interactive.!!Notification methodsFor: 'testing' stamp: 'eem 5/16/2008 14:28'!isNotification	^true! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!class: aClass recategorizedFrom: oldCategory to: newCategory! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classAdded: aClass inCategory: aCategoryName! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classCommented: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classCommented: aClass inCategory: aCategoryName! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classDefinitionChangedFrom: oldClass to: newClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classRemoved: aClass fromCategory: aCategoryName! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classRenamed: aClass from: oldClassName to: newClassName inCategory: aCategoryName! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!classReorganized: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!evaluated: textOrStream! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!evaluated: expression context: aContext! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodAdded: aMethod selector: aSymbol inClass: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodAdded: aMethod selector: aSymbol inClass: aClass requestor: requestor! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodAdded: aMethod selector: aSymbol inProtocol: aCategoryName class: aClass requestor: requestor! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodChangedFrom: oldMethod to: newMethod selector: aSymbol inClass: aClass requestor: requestor! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodRemoved: aMethod selector: aSymbol class: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!methodRemoved: aMethod selector: aSymbol inProtocol: protocol class: aClass! !!NullSystemChangeNotifier methodsFor: 'system triggers' stamp: 'eem 5/25/2009 10:43'!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass! !!NullSystemChangeNotifier methodsFor: 'public' stamp: 'eem 5/25/2009 10:43'!doSilently: aBlock	"Perform the block, and ensure that no system notification are broadcasted while doing so."	^aBlock value! !!NullSystemChangeNotifier methodsFor: 'public' stamp: 'eem 5/25/2009 10:43'!noMoreNotificationsFor: anObject! !!NullSystemChangeNotifier methodsFor: 'public' stamp: 'eem 5/25/2009 10:43'!notify: anObject ofAllSystemChangesUsing: oneArgumentSelector 	"Notifies an object of any system changes."! !!NullSystemChangeNotifier methodsFor: 'initialize' stamp: 'eem 5/25/2009 10:43'!releaseAll	"Release all the dependents so that nobody receives notifications anymore."	"Done for cleaning up the system."	"No-op for NullSystemChangeNotifier"! !!NullSystemChangeNotifier class methodsFor: 'private' stamp: 'NS 1/27/2004 16:23'!createInstance	^self basicNew initialize! !!NullSystemChangeNotifier class methodsFor: 'private' stamp: 'rw 6/28/2003 09:41'!instanceCreationErrorString	^'This is a singleton implementation, so you are not allowed to create instances yourself. Use #uniqueInstance to access the instance.'! !!NullSystemChangeNotifier class methodsFor: 'private' stamp: 'eem 5/25/2009 10:43'!resetUniqueInstance	"self resetUniqueInstance"	UniqueInstance ifNotNil:		[UniqueInstance releaseAll.		 UniqueInstance := nil]! !!NullSystemChangeNotifier class methodsFor: 'private' stamp: 'NS 1/27/2004 16:23'!uniqueInstance	UniqueInstance ifNil: [UniqueInstance := self createInstance].	^UniqueInstance! !!NullSystemChangeNotifier class methodsFor: 'instance creation' stamp: 'rw 6/28/2003 09:41'!new	^self error: self instanceCreationErrorString! !!Number methodsFor: 'comparing' stamp: 'bgf 4/25/2009 14:38'!within: nDegrees degreesOf: aNumber	"Is the given other number within nDegrees of myself, on a circle,	 treating us both as angles in degrees ?"	| rawDelta |	rawDelta :=  (self asSmallAngleDegrees - aNumber asSmallAngleDegrees) abs.	^ rawDelta <= nDegrees or: [ rawDelta >= (360-nDegrees) ] 	"Tests...	(360 within: 1 degreesOf: 1) ifFalse: [ self error: '360 = 0' ].	(180 within: 1 degreesOf: -181) ifFalse: [ self error: ' 180 / -180 ' ].	(10 within: 5 degreesOf: 355) ifTrue: [ self error: ' 10 / 5 / 355 ' ].	(10 within: 15 degreesOf: 356) ifFalse: [ self error: ' 10 / 15 /356' ].	(45 within: 4 degreesOf: 48) ifFalse: [ self error: ' 45 / 4 / 48 ' ].	(45 within: 4 degreesOf: 50) ifTrue: [ self error: ' 45 / 4 / 50 ' ].	"! !!Number methodsFor: 'converting' stamp: 'tk 8/13/2004 15:30'!@ y 	"The @ message takes two numbers and makes a Point out of them.  The first number is the horizontal distance x, and the second is the vertical distance y.  Larger y is further down the screen.[general]	Primitive. Answer a Point whose x value is the receiver and whose y value is the argument. Optional. No Lookup. See Object documentation whatIsAPrimitive.[geeky]"	<primitive: 18>	^Point x: self y: y! !!Number methodsFor: 'converting' stamp: 'sw 2/16/1999 18:15'!asPoint	"Answer a Point with the receiver as both coordinates; often used to 	supply the same value in two dimensions, as with symmetrical gridding 	or scaling."	^self @ self! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!degreesToRadians	"The receiver is assumed to represent degrees. Answer the conversion to 	radians."	^self asFloat degreesToRadians! !!Number methodsFor: 'converting' stamp: 'bgf 4/25/2008 16:45'!withSignOf: anotherNumber	"Copy me, but with the sign of anotherNumber: 	   return  self abs if anotherNumber is positive OR zero.	   return  self abs negated if anotherNumber is negative."	^ (anotherNumber >= 0)			ifTrue: [ self abs ]			ifFalse: [ self abs negated ]! !!Number methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:23'!hypot: arg	"hypot(x,y) returns sqrt(x^2+y^2) with error less  than 1 ulps"	^self asFloat hypot: arg asFloat! !!Number methodsFor: 'testing' stamp: 'sw 4/25/1998 12:50'!even	"Answer whether the receiver is an even number."	^self \\ 2 = 0! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isNumber	^ true! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isZero	^self = 0! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 14:29'!testFloatFromStreamAsNumber	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '10r-12.3456' readStream.	aFloat := Number readFrom: rs.	self assert: -12.3456 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2e2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs upToEnd = 'e2'.	rs := '10r-12.3456d2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '-12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: 1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456z2' readStream.	aFloat := Number readFrom: rs.	self assert: 12.3456 = aFloat.	self assert: rs upToEnd = 'z2'.! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'nice 2/22/2010 22:17'!testFloatFromStreamWithExponent	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '1.0e-14' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs atEnd.	rs := '1.0e-14 1' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = ' 1'.	rs := '1.0e-14eee' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = 'eee'.	rs := '1.0e14e10' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e14 = aFloat.	self assert: rs upToEnd = 'e10'.	rs := '1.0e+14e' readStream. "Plus sign is parseable too"	aFloat := Number readFrom: rs.	self assert: 1.0e14 = aFloat.	self assert: rs upToEnd = 'e'.	rs := '1.0e' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0 = aFloat.	self assert: rs upToEnd = 'e'.! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 14:07'!testFloatFromStringAsNumber	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '10r-12.3456' asNumber.	self assert: -12.3456 = aFloat.	aFloat := '10r-12.3456e2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456d2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '12.3456q2' asNumber.	self assert: 1234.56 = aFloat.! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'nice 2/22/2010 22:17'!testFloatFromStringWithExponent	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '1.0e-14' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e-14 1' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e-14e' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e14e' asNumber.	self assert: 1.0e14 = aFloat.	aFloat := '1.0e+14e' asNumber. "Plus sign is parseable too"	self assert: 1.0e14 = aFloat.! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'jcg 4/23/2010 16:13'!testFloatReadWithImplicitLeadingZero	"Test support for implicit leading zeroes when reading numbers from Strings."	self should: [-0.22 = '-.22' asNumber].	self should: [0.22 = '.22' asNumber].! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 18:16'!testFloatReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1.0101e9' asNumber.	self assert: 672.0 = aNumber.	self assert: (Number readFrom: '2r1.0101e9') = (1.3125 * (2 raisedTo: 9)).	rs := ReadStream on: '2r1.0101e9e9'.	self assert: (Number readFrom: rs) = 672.0.	self assert: rs upToEnd = 'e9'! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'nice 2/22/2010 22:18'!testIntegerFromString	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	self assert: ('123' asNumber == 123).	self assert: ('-123' asNumber == -123).	self assert: ('123.' asNumber = 123).	self assert: ('123.' asNumber) isFloat.	self assert: ('-123.' asNumber = -123).	self assert: ('-123.' asNumber) isFloat.	self assert: ('123This is not to be read' asNumber == 123).	self assert: ('123s could be confused with a ScaledDecimal' asNumber == 123).	self assert: ('123e could be confused with a Float' asNumber == 123).! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'nice 2/22/2010 22:19'!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123sA has unary message sA'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 'sA has unary message sA' = s.		rs := ReadStream on: '123sB has unary message sB'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 'sB has unary message sB' = s.! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'dtl 11/24/2004 18:18'!testIntegerReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1e26' asNumber.	self assert: 67108864 = aNumber.	self assert: (Number readFrom: '2r1e26') = (2 raisedTo: 26).	rs := '2r1e26eee' readStream.	self assert: (Number readFrom: rs) = 67108864.	self assert: rs upToEnd = 'eee'! !!NumberParsingTest methodsFor: 'tests - ScaledDecimal' stamp: 'nice 8/29/2008 22:04'!testScaledDecimalWithTrailingZeroes	"This is a non regression tests for http://bugs.squeak.org/view.php?id=7169"		self assert: (Number readFrom: '0.50s2') = (1/2).	self assert: (Number readFrom: '0.500s3') = (1/2).	self assert: (Number readFrom: '0.050s3') = (1/20).! !!NumberParsingTest commentStamp: 'dtl 11/24/2004 15:35' prior: 0!Tests to verify parsing of numbers from streams and strings.Note: ScaledDecimalTest contains related tests for parsing ScaledDecimal.!!NumberTest methodsFor: 'failures' stamp: 'ar 7/27/2010 12:12'!expectedFailures	"Issues with Cogit"	^Smalltalk isRunningCogit 		ifTrue:[#(testRaisedToIntegerWithFloats)]		ifFalse:[#()]! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/26/2009 21:57'!testFractionPart	self 		assert: 2 fractionPart = 0;		assert: (1/2) fractionPart = (1/2);		assert: (4/3) fractionPart = (1/3);		assert: 2.0 fractionPart = 0.0;		assert: 0.5 fractionPart = 0.5;		assert: 2.5 fractionPart = 0.5! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/26/2009 21:55'!testIntegerPart	self 		assert: 2 integerPart = 2;		assert: (1/2) integerPart = 0;		assert: (4/3) integerPart = 1;		assert: 2.0 integerPart = 2.0;		assert: 0.5 integerPart = 0.0;		assert: 2.5 integerPart = 2.0! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/23/2009 20:49'!testOne	self 		assert: Integer one = 1;		assert: Float one = 1.0;		assert: Fraction one = 1! !!NumberTest methodsFor: 'tests' stamp: 'fcs 12/13/2006 17:26'!testPrintShowingDecimalPlaces	self assert: (111.2 printShowingDecimalPlaces: 2) = '111.20'.	self assert: (111.2 printShowingDecimalPlaces: 0) = '111'.	self assert: (111 printShowingDecimalPlaces: 0) = '111'.	self assert: (111111111111111 printShowingDecimalPlaces: 2) = '111111111111111.00'.	self assert: (10 printShowingDecimalPlaces: 20) ='10.00000000000000000000'.	self assert: (0.98 printShowingDecimalPlaces: 2) = '0.98'.	self assert: (-0.98 printShowingDecimalPlaces: 2) = '-0.98'.	self assert: (2.567 printShowingDecimalPlaces: 2) = '2.57'.	self assert: (-2.567 printShowingDecimalPlaces: 2) = '-2.57'.	"self assert: (Number categoryForSelector: #printShowingDecimalPlaces:) = 'printing'."! !!NumberTest methodsFor: 'tests' stamp: 'nice 3/24/2008 16:50'!testPrintShowingDecimalPlaces2	"This tests problems related to Float>>rounded and Float>>roundTo::	- Float>>#rounded is inexact	- Float>>#roundTo: might overflow"	"5000000000000001.0 asTrueFraction = 5000000000000001.	5000000000000001 highBit = 53.	This number is represented exactly asFloat, it should print exactly"	self assert: (5000000000000001.0 printShowingDecimalPlaces: 0) = '5000000000000001'.		"50000000000001.25 asTrueFraction = (200000000000005/4).	200000000000005 highBit = 48, 4 isPowerOfTwo,	So this number is also represented exactly as Float, it should print exactly.	Beware: (50000000000001.25 / 0.01) rounded exhibit the same problem as above."	self assert: (50000000000001.25 printShowingDecimalPlaces: 2) = '50000000000001.25'.		"This number is close to maximum float value"	self shouldnt: [1.0e306 printShowingDecimalPlaces: 3] raise: Error.! !!NumberTest methodsFor: 'tests' stamp: 'nice 4/24/2008 00:58'!testPrintShowingDecimalPlaces3	"This problem were reported at http://bugs.squeak.org/view.php?id=7028	unfortunate inversion of left / right padding"	self assert: (1.009 printShowingDecimalPlaces: 3) = '1.009'.	self assert: (35.900 printShowingDecimalPlaces: 3) = '35.900'.	self assert: (-0.097 printShowingDecimalPlaces: 3) = '-0.097'.! !!NumberTest methodsFor: 'tests' stamp: 'nice 12/6/2007 21:24'!testRaisedTo	"this is a test related to http://bugs.squeak.org/view.php?id=6781"		self should: [0 raisedTo: -1] raise: ZeroDivide.	self should: [0 raisedTo: -1.0] raise: ZeroDivide.! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/25/2009 16:41'!testRaisedToInteger	self 		assert: (2 raisedToInteger: 0) = 1;		assert: (2 raisedToInteger: 1) = 2;		assert: (2 raisedToInteger: 4) = 16;		assert: (0 raisedToInteger: 0) = 1;		assert: (0 raisedToInteger: 2) = 0;		assert: (2 raisedToInteger: -1) = (1/2);		assert: (2 raisedToInteger: -4) = (1/16).		self 		assert: (-3 raisedTo: 0) = 1;		assert: (-3 raisedTo: 1) = -3;		assert: (-3 raisedTo: 2) = 9;		assert: (-3 raisedTo: 3) = -27;		assert: (-3 raisedTo: -2) = (1/9);		assert: (-3 raisedTo: -3) = (-1/27).		self should: [ 0 raisedTo: -1 ] raise: ZeroDivide! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/25/2009 16:46'!testRaisedToIntegerWithFloats	self 		assert: (2.0 raisedToInteger: 0) = 1.0;		assert: (2.0 raisedToInteger: 1) = 2.0;		assert: (2.0 raisedToInteger: 4) = 16.0;		assert: (0.0 raisedToInteger: 0) = 1.0;		assert: (0.0 raisedToInteger: 2) = 0.0;		assert: (2.0 raisedToInteger: -1) = 0.5;		assert: (2.0 raisedToInteger: -4) = 0.0625.		self 		assert: (-3.0 raisedTo: 0) = 1.0;		assert: (-3.0 raisedTo: 1) = -3.0;		assert: (-3.0 raisedTo: 2) = 9.0;		assert: (-3.0 raisedTo: 3) = -27.0;		assert: (-2.0 raisedTo: -2) = 0.25;		assert: (-2.0 raisedTo: -3) = -0.125.		self should: [ 0.0 raisedTo: -1 ] raise: ZeroDivide! !!NumberTest methodsFor: 'tests' stamp: 'sd 6/5/2005 08:56'!testReadFrom		self assert: 1.0e-14	= (Number readFrom: '1.0e-14').	self assert: 2r1e26	= (Number readFrom: '2r1e26').! !!NumberTest methodsFor: 'tests' stamp: 'GabrielOmarCotelli 5/23/2009 19:26'!testReciprocal	self 		assert: 1 reciprocal = 1;		assert: 2 reciprocal = (1/2);		assert: -1 reciprocal = -1;		assert: -3 reciprocal = (-1/3).			self should: [ 0 reciprocal ] raise: ZeroDivide! !!Object methodsFor: 'copying' stamp: 'RAA 3/31/1999 12:13'!clone	<primitive: 148>	self primitiveFailed! !!Object methodsFor: 'error handling' stamp: 'das 4/14/2008 09:13'!error: aString tag: aTag	"Throw a generic Error exception."	^Error new signal: aString tag: aTag.! !!Object methodsFor: 'error handling' stamp: 'eem 11/23/2009 14:34'!externalCallFailedWith: err	"A call to an external function has failed."	^(Smalltalk at: #ExternalFunction ifAbsent:[^self error: 'FFI not installed'])		externalCallFailedWith: err! !!Object methodsFor: 'error handling' stamp: 'ar 3/30/2010 10:27'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	PrimitiveFailed signal: self class name, '>>',thisContext sender method selector! !!Object methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 01:31'!encodePostscriptOn:aStream	self byteEncode:aStream.! !!Object methodsFor: 'message handling' stamp: 'eem 1/16/2009 17:11'!perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not four.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject with: fourthObject)! !!Object methodsFor: 'message handling' stamp: 'eem 2/17/2009 12:24'!perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not five.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject)! !!Object methodsFor: 'message handling' stamp: 'eem 4/8/2009 19:04'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	<primitive: 188>	self primitiveFailed! !!Object methodsFor: 'testing' stamp: 'rhi 8/14/2003 08:51'!isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing' stamp: 'ar 2/28/2006 18:43'!isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'ar 9/13/2000 15:37'!isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'ar 12/18/2008 16:52'!isSqueakPage	"Whether the receiver is a SqueakPage"	^false! !!Object methodsFor: 'updating' stamp: 'eem 6/15/2008 16:02'!okToClose	"Allows a controller to ask this of any model"	^self okToChange! !!Object methodsFor: 'user interface' stamp: 'bf 6/23/2007 15:04'!asExplorerString	^ self printStringLimitedTo: 200! !!Object methodsFor: 'inspecting' stamp: 'ar 6/23/2010 11:31'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^ToolSet inspect: self! !!Object methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^false! !!ObjectFinalizerTests methodsFor: 'finalization handling' stamp: 'apb 9/14/2005 08:33'!finalize: anObject	log addLast: anObject asString, ' ', 'finalized'.! !!ObjectFinalizerTests methodsFor: 'running' stamp: 'apb 9/14/2005 08:39'!setUp	super setUp.	log := OrderedCollection new.! !!ObjectFinalizerTests methodsFor: 'tests' stamp: 'stephaneducasse 10/28/2005 21:15'!testFinalization	"self run: #testFinalization"		| repetitions |	repetitions := 100.	1 to: repetitions		do: [:i | 			log addLast: 'o' , i asString , ' created'.			Object new				toFinalizeSend: #finalize:				to: self				with: 'o' , i asString].	Smalltalk garbageCollect.	self finalizationRegistry finalizeValues.	1 to: repetitions		do: [:i | 			self assert: (log includes: 'o' , i asString , ' created').			self assert: (log includes: 'o' , i asString , ' finalized')]! !!ObjectTest methodsFor: 'private' stamp: 'md 10/15/2004 13:45'!a	self b.! !!ObjectTest methodsFor: 'private' stamp: 'md 10/15/2004 13:46'!a1	self b1.! !!ObjectTest methodsFor: 'private' stamp: 'md 10/15/2004 13:45'!b	self haltIf: #testHaltIf.! !!ObjectTest methodsFor: 'private' stamp: 'md 10/15/2004 13:46'!b1	self haltIf: #testasdasdfHaltIf.! !!ObjectTest methodsFor: 'tests - debugging' stamp: 'sd 6/5/2005 09:05'!testAssert	self shouldnt: [Object assert: [true]] raise: Error.	self shouldnt: [Object assert: true] raise: Error.	self should: [Object assert: [false]] raise: AssertionFailure.	self should: [Object assert: false] raise: AssertionFailure.! !!ObjectTest methodsFor: 'tests' stamp: 'md 11/26/2004 16:37'!testBecome	"self debug: #testBecome"	"this test should that all the variables pointing to an object are pointing now to another one, and all      object pointing to the other are pointing to the object"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 become: pt3.	self assert: pt2 = (100@100).	self assert: pt3 = (0@0).	self assert: pt1 = (100@100).! !!ObjectTest methodsFor: 'tests' stamp: 'md 11/26/2004 16:36'!testBecomeForward	"self debug: #testBecomeForward"	"this test should that all the variables pointing to an object are pointing now to another one.	Not that this inverse is not true. This kind of become is called oneWayBecome in VW"	| pt1 pt2 pt3 |	pt1 := 0@0.	pt2 := pt1.	pt3 := 100@100.	pt1 becomeForward: pt3.	self assert: pt2 = (100@100).	self assert: pt3 == pt2.	self assert: pt1 = (100@100)! !!ObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:05'!testHaltIf	self should: [self haltIf: true] raise: Halt.	self shouldnt: [self haltIf: false] raise: Halt.	self should: [self haltIf: [true]] raise: Halt.	self shouldnt: [self haltIf: [false]] raise: Halt.	self should: [self haltIf: #testHaltIf.] raise: Halt.	self shouldnt: [self haltIf: #teadfasdfltIf.] raise: Halt.	self should: [self a] raise: Halt.	self shouldnt: [self a1] raise: Halt.	self should: [self haltIf: [:o | o class = self class]] raise: Halt.	self shouldnt: [self haltIf: [:o | o class ~= self class]] raise: Halt.! !!ObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:43'!testNotNil	self assert: Object new notNil! !!ObjectsAsMethodsExample methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:16'!add: a with: b	^a + b! !!ObjectsAsMethodsExample methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2003 20:16'!answer42	^42! !!ObjectsAsMethodsExample methodsFor: 'as yet unclassified' stamp: 'md 3/1/2006 19:37'!run: oldSelector with: arguments in: aReceiver	^self perform: oldSelector withArguments: arguments! !!OldSocket methodsFor: 'connection open/close' stamp: 'ar 9/23/2009 15:17'!listenOn: port	"Listen for a connection on the given port."	^self listenOn: port backlogSize: 4.! !!OneOnSwitch methodsFor: 'connection'!connection	"Answer the object that connects the receiver to other Switches."	^connection! !!OneOnSwitch methodsFor: 'connection'!connection: anObject 	"Set anObject to be the connection among two or more Switches. Make the 	receiver a dependent of the argument, anObject."	connection := anObject.	connection addDependent: self! !!OneOnSwitch methodsFor: 'connection'!isConnectionSet	"Answer whether the receiver is connected to an object that coordinates 	updates among switches."	connection == nil		ifTrue: [^false]		ifFalse: [^true]! !!OneOnSwitch methodsFor: 'connection'!notifyConnection	"Send the receiver's connection (if it exists) the message 'changed: self' in 	order for the connection to broadcast the change to other objects 	connected by the connection."		self isConnectionSet ifTrue: [self connection changed: self]! !!OneOnSwitch methodsFor: 'initialize-release'!release	super release.	self isConnectionSet ifTrue: [connection removeDependent: self]! !!OneOnSwitch methodsFor: 'state'!turnOn	"Does nothing if it is already on. If it is not, it is set to 'on', its	dependents are 	notified of the change, its connection is notified, and	its action is executed."	self isOff		ifTrue: 			[on := true.			self changed.			self notifyConnection.			self doAction: onAction]! !!OneOnSwitch methodsFor: 'updating'!update: aOneOnSwitch 	"Does nothing if aOneOnSwitch is identical to this object. If it is not, this 	object is turned off. This message is sent by the connection (an Object)	when some related OneOnSwitch (possibly this one) has changed. This	allows a group of related OneOnSwitches to maintain the constraint that	at most one will be on at any time."	self ~~ aOneOnSwitch ifTrue: [self turnOff]! !!OneOnSwitch commentStamp: '<historical>' prior: 0!I am a kind of Switch that can be connected to some related object, typically to a collection of my instances. When my instance is created, its connection is set to a particular object. When the object changes because an Switch it refers to is turned on, an update message is broadcasted. All the connected OneOnSwitches, except the changed one, turn off. This allows OneOnSwitches to maintain the constraint that at most one of them will be on at any time. OneOnSwitches can thus be made to act like "car radio" switches.!!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 19:00'!testAdd	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 88.	self assert: (l =  #(1 2 3 4 88) asOrderedCollection).	l add: 99.	self assert: (l =  #(1 2 3 4 88 99) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 18:52'!testAddAfter	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 88 after: 1.	self assert: (l =  #(1 88 2 3 4) asOrderedCollection).	l add: 99 after: 2.	self assert: (l =  #(1 88 2 99 3 4) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 3/21/2006 22:36'!testAddAll	"Allows one to add each element of an orderedCollection at the end of another	orderedCollection "	"self run:#testAddAll" 		| c1 c2 |	c1 := #(1 2 3 4 ) asOrderedCollection.	c2 := #(5 6 7 8 9 ) asOrderedCollection.	c1 addAll: c2.	self assert: c1 = #(1 2 3 4 5 6 7 8 9) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 3/21/2006 22:36'!testAddAllFirst	"Allows one to add each element of an orderedCollection at the beginning of another	orderedCollection "	"self run:#testAddAllFirst" 		| c1 c2 |	c1 := #(1 2 3 4 ) asOrderedCollection.	c2 := #(5 6 7 8 9 ) asOrderedCollection.	c2 addAllFirst: c1.	self assert: c2 = #(1 2 3 4 5 6 7 8 9) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 3/21/2006 22:36'!testAddAllFirstUnlessAlreadyPresent	"Allows one to add each element of an orderedCollection at the beginning of	another orderedCollection preserving the order but no duplicate element"	"self run:#testAddAllFirstUnlessAlreadyPresent" 		| c1 c2 c3 |	c1 := #(1 2 3 4 ) asOrderedCollection.	c2 := #(5 6 7 8 9 ) asOrderedCollection.	c3 := #(0 1 ) asOrderedCollection.	c2 addAllFirstUnlessAlreadyPresent: c1.	self assert: c2 = #(1 2 3 4 5 6 7 8 9 ) asOrderedCollection.	c1 addAllFirstUnlessAlreadyPresent: c3.	self deny: c1 = #(0 1 1 2 3 4 ) asOrderedCollection.	self assert: c1 = #(0 1 2 3 4 ) asOrderedCollection.	! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 3/21/2006 22:36'!testAddAllLast	"Allows one to add each element of an orderedCollection at the beginning of another	orderedCollection "	"self run:#testAddAllLast" 		| c1 c2 |	c1 := #(1 2 3 4 ) asOrderedCollection.	c2 := #(5 6 7 8 9 ) asOrderedCollection.	c1 addAllLast: c2.	self assert: c1 = #(1 2 3 4 5 6 7 8 9) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 18:57'!testAddBefore	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 88 before: 1.	self assert: (l =  #(88 1 2 3 4) asOrderedCollection).	l add: 99 before: 2.	self assert: (l =  #(88 1 99 2 3 4) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 13:42'!testAddBeforeAndRemove	| l initialCollection |	l := #(1 2 3 4) asOrderedCollection.	initialCollection := l shallowCopy.	l add: 88 before: 1.	self assert: (l =  #(88 1 2 3 4) asOrderedCollection).	l add: 99 before: 2.	self assert: (l =  #(88 1 99 2 3 4) asOrderedCollection). 	l remove: 99.	l remove: 88.	self assert: l = initialCollection.! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 13:43'!testAddDuplicateItem1	| collection |	collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.	collection add: 'John' before: 'John'.	self		assert: ((collection asBag occurrencesOf: 'John')					= 2				and: [(collection at: (collection indexOf: 'John')							+ 1)						= (collection								at: (collection indexOf: 'John'))])! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 18:58'!testAddFirst	| l |	l := #(1 2 3 4) asOrderedCollection.	l addFirst: 88.	self assert: (l =  #(88 1 2 3 4) asOrderedCollection).	l addFirst: 99.	self assert: (l =  #(99 88 1 2 3 4) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 6/5/2005 09:21'!testAddItem1   | collection size |   collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.   size := collection size.   collection add: 'James' before: 'Jim'.   collection add: 'Margaret' before: 'Andrew'.   self assert: size + 2 = collection size.! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 19:07'!testAddItem2	| collection |	collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.	collection add: 'James' before: 'Jim'.	collection add: 'Margaret' before: 'Andrew'.	self assert: (collection indexOf: 'James')			+ 1			= (collection indexOf: 'Jim').	self assert: (collection indexOf: 'Margaret')			+ 1			= (collection indexOf: 'Andrew')! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'zz 12/7/2005 18:59'!testAddLast	| l |	l := #(1 2 3 4) asOrderedCollection.	l addLast: 88.	self assert: (l =  #(1 2 3 4 88) asOrderedCollection).	l addLast: 99.	self assert: (l =  #(1 2 3 4 88 99) asOrderedCollection). ! !!OrderedCollectionTest methodsFor: 'testsAdding' stamp: 'sd 3/21/2006 22:37'!testAtIfAbsentPut	"Allows one to add an element at an index if no element exist at this index"	"self run:#testAtIfAbsentPut" 		| c |	c := #(1 2 3 4 ) asOrderedCollection.	self		shouldnt: [c at: 2 ifAbsentPut: [5]]		raise: Error.	self assert: c = #(1 2 3 4 ) asOrderedCollection.	c at: 5 ifAbsentPut: [5].	self assert: c = #(1 2 3 4 5 ) asOrderedCollection.	c at: 7 ifAbsentPut: [7].	self assert: c = #(1 2 3 4 5 nil 7 ) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'ul 3/21/2010 17:46'!testAddAfterIndex	"self run: #testAddAfterIndex"	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 77 afterIndex: 0.	self assert: (l =  #(77 1 2 3 4) asOrderedCollection).	l add: 88 afterIndex: 2.	self assert: (l =  #(77 1 88 2 3 4) asOrderedCollection). 	l add: 99 afterIndex: l size.	self assert: (l =  #(77 1 88 2 3 4 99) asOrderedCollection). 	self should:[l add: 666 afterIndex: -1] raise: Error.	self should:[l add: 666 afterIndex: l size+1] raise: Error.		"Now make room by removing first two and last two elements,	and see if the illegal bounds test still fails"	(l first: 2) , (l last: 2) reversed do: [:e | l remove: e].	self should: [l add: 666 afterIndex: -1] raise: Error.	self should: [l add: 666 afterIndex: l size+1] raise: Error.! !!OrderedCollectionTest methodsFor: 'testing-public methods' stamp: 'ul 3/21/2010 17:46'!testAddBeforeIndex	"self run: #testAddBeforeIndex"	| l |	l := #(1 2 3 4) asOrderedCollection.	l add: 77 beforeIndex: 1.	self assert: (l =  #(77 1 2 3 4) asOrderedCollection).	l add: 88 beforeIndex: 3.	self assert: (l =  #(77 1 88 2 3 4) asOrderedCollection). 	l add: 99 beforeIndex: l size+1.	self assert: (l =  #(77 1 88 2 3 4 99) asOrderedCollection). 	self should:[l add: 666 beforeIndex: 0] raise: Error.	self should:[l add: 666 beforeIndex: l size+2] raise: Error.		"Now make room by removing first two and last two elements,	and see if the illegal bounds test still fails"	(l first: 2) , (l last: 2) reversed do: [:e | l remove: e].	self should:[l add: 666 beforeIndex: 0] raise: Error.	self should:[l add: 666 beforeIndex: l size+2] raise: Error.! !!OrderedCollectionTest methodsFor: 'testsAccessing' stamp: 'zz 12/7/2005 18:50'!testAt	| collection |	collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.	self assert: (collection at:1) = 'Jim'.	self assert: (collection at:2) = 'Mary'! !!OrderedCollectionTest methodsFor: 'testsAccessing' stamp: 'sd 3/21/2006 22:38'!testAtPut	"Allows one to replace an element but not at an off range index"	"self run:#testAtPut"	| c |	c := #(1 2 3 4 ) asOrderedCollection.	c at: 2 put: 5.	self assert: c = #(1 5 3 4 ) asOrderedCollection.	self		should: [c at: 5 put: 8]		raise: Error.	self deny: c = #(1 5 3 4 8 ) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testsAccessing' stamp: 'sd 3/21/2006 22:39'!testCapacity	"Allows one to check the current capacity of an Ordered collection"	"self run:#testCapacity"		| c1 c2 c3 |	c1 := #(1 2 ) asOrderedCollection.	self assert: (c1 capacity =  2).	c2 := OrderedCollection new: 10.	c2 add: 3.	self assert: (c2 capacity = 10).		c3 := OrderedCollection new.	self deny: (c3 capacity =  0).	! !!OrderedCollectionTest methodsFor: 'testsAccessing' stamp: 'sd 3/21/2006 22:38'!testSize	"Allows one to check the size of an Ordered collection"	"self run:#testSize"		| c1 c2 |	c1 := #(1 2 ) asOrderedCollection.	self assert: (c1 size =  2).		c2 := OrderedCollection new.	self assert: (c2 size = 0)	! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'sd 3/21/2006 22:41'!testCollect	"Allows one to collect some element of a collection into another collection"	"self run: #testCollect"	 	| c1 c2 res |	c1 := #(-1 2 -3 4) asOrderedCollection.	c2 := #(1 2 3 4) asOrderedCollection.	res := c1 collect: [:each | each abs].	self assert: (c2 = res).! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'cm 3/8/2006 09:09'!testCollectFromTo	"Allows one to collect some element of a collection into another collection between a first index and an end index for the collect"	"self run: #testCollectFromTo"		| c1 res |	c1 := #(-1 2 -3 4 -5 6 -7 8) asOrderedCollection.	res := c1 collect: [:each | each abs] from: 1 to: 3.	self assert: (res = #(1 2 3) asOrderedCollection).	self should: [c1 collect: [:each | each abs] from: 10 to: 13] raise: Error.	self should: [c1 collect: [:each | each abs] from: 5 to: 2] raise: Error.! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'zz 12/7/2005 19:06'!testIndexOf	| collection indices |	collection := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.	indices := collection				collect: [:item | collection indexOf: item].	self assert: (1 to: 4) asOrderedCollection = indices! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'sd 6/5/2005 09:21'!testIndexOfWithDuplicates   | collection indices bagOfIndices |   collection := #('Jim' 'Mary' 'John' 'Andrew' 'Mary' 'John' 'Jim' 'Micheal') asOrderedCollection.   indices := collection collect: [:item | collection indexOf: item].   self assert: indices asSet size = collection asSet size.   bagOfIndices := indices asBag.   self assert: (indices asSet                     allSatisfy: [:index | (bagOfIndices occurrencesOf: index)	                                       = (collection occurrencesOf: (collection at: index))]).  "  indexOf:  returns the index of the first occurrence of an item.     For an item with n occurrences, the index of its first occurrence     is found  n  times. "! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'cm 3/8/2006 10:02'!testWithCollect	"Allows one to collect some element of two collections into another collection with element corresponding to the condition in the blocks"	"self run: #testWithCollect"		| c1 c2 res |	c1 := #(-1 2 -3 4 -5 6 -7 8) asOrderedCollection.	c2 := #(-9 10 -11 12 -13 14 -15 16) asOrderedCollection.	res := c1 with: c2 collect: [:each1 :each2 | each1 < each2		ifTrue: [each1]		ifFalse: [each2]].	self assert: (res = #(-9 2 -11 4 -13 6 -15 8) asOrderedCollection).	! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'sd 3/21/2006 22:40'!testCopyEmpty	"Allows one to create a copy of the receiver that contains no elements"	"self run:#testCopyEmpty"		| c1 c2 |	c1 := #(1 2 3 4 ) asOrderedCollection.	c2 := c1 copyEmpty.	self assert: (c2 size = 0).! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'sd 3/21/2006 22:41'!testCopyFromTo	"Allows one to create a copy of the receiver that contains elements from position start to end"	"self run: #testCopyFromTo"		| c1 c2 c3 | 	c1 := #(1 2 3 4) asOrderedCollection.	c2 := (c1 copyFrom: 1 to: 2).	self assert: c2 = #(1 2) asOrderedCollection.	self should: [c1 copyFrom: 10 to: 20] raise: Error.		c3 := c1 copyFrom: 4 to: 2.	self assert: c3 isEmpty.		self should: [c1 copyFrom: 4 to: 5 ] raise: Error.			! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'sd 3/21/2006 22:41'!testCopyReplaceFromToWith	"Allows one to create a copy from the receiver which elements between start and end of the 	receiver being replace by 	element of the collection after with:"	"self run:#testCopyReplaceFromToWith"	| c1 c2 c3 c4 |	c1 := #(1 2 3 4) asOrderedCollection.	c2 := #(5 6 7 8 9) asOrderedCollection.	c3 := (c2 copyReplaceFrom: 1 to: 2 with: c1).	self assert: c3 = #(1 2 3 4 7 8 9) asOrderedCollection.	self should: [c2 copyReplaceFrom: 3 to: 1 with: c1] raise: Error.		c4 := (c2 copyReplaceFrom: 10 to: 25 with: c1).	self assert: c4 = #(5 6 7 8 9 1 2 3 4) asOrderedCollection.		! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'sd 3/21/2006 22:41'!testCopyWith	"Allows one to create a copy of the receiver that contains the new element at the end"	"self run: #testCopyWith"		| c1 | 	c1 := #(1 2 3 4) asOrderedCollection.	c1 := c1 copyWith: 6.	self assert: c1 = #(1 2 3 4 6) asOrderedCollection.					! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'nice 2/26/2009 11:54'!testForceToPadding	"This is a non regression bug for http://bugs.squeak.org/view.php?id=7296"		| c1 c2 paddingElement |	"source collection"	c1 := #(5 3 7 2 ) asOrderedCollection.	paddingElement := nil.		"force length to longer"	self shouldnt: [c2 := c1 forceTo: 10 paddingWith: paddingElement] raise: Error.	self assert: (c1 ~~ c2) description: 'forceTo:paddingWith: should modify a copy'.	self assert: (c2 size = 10).	self assert: (c2 copyFrom: 1 to: c1 size) = c1.	self assert: ((c1 size + 1 to: c2 size) allSatisfy: [:i | (c2 at: i) = paddingElement]).		"force length to shorter"	self shouldnt: [c2 := c1 forceTo: 3 paddingWith: paddingElement] raise: Error.	self assert: (c1 ~~ c2) description: 'forceTo:paddingWith: should modify a copy'.	self assert: (c2 size = 3).	self assert: (c2 copyFrom: 1 to: 3) = (c1 copyFrom: 1 to: 3).		"SAME TEST BUT PADDING AT START FOLLOWING..."		"force length to longer"	self shouldnt: [c2 := c1 forceTo: 10 paddingStartWith: paddingElement] raise: Error.	self assert: (c1 ~~ c2) description: 'forceTo:paddingStartWith: should modify a copy'.	self assert: (c2 size = 10).	self assert: (c2 copyFrom: c2 size - c1 size + 1 to: c2 size) = c1.	self assert: ((1 to: c2 size - c1 size) allSatisfy: [:i | (c2 at: i) = paddingElement]).		"force length to shorter"	self shouldnt: [c2 := c1 forceTo: 3 paddingStartWith: paddingElement] raise: Error.	self assert: (c1 ~~ c2) description: 'forceTo:paddingStartWith: should modify a copy'.	self assert: (c2 size = 3).	self assert: (c2 copyFrom: 1 to: 3) = (c1 copyFrom: 1 to: 3).! !!OrderedCollectionTest methodsFor: 'testsCopying' stamp: 'zz 12/7/2005 13:47'!testReversed	| collection1 collection2 |	collection1 := #('Jim' 'Mary' 'John' 'Andrew' ) asOrderedCollection.	collection2 := collection1 reversed.	self assert: collection2 first = 'Andrew'.	self assert: collection2 last = 'Jim'! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'nice 9/14/2009 20:57'!testRemoveAll	"Allows one to remove all elements of a collection" 		| c1 c2 s2 |	c1 := #(2 3 4 6) asOrderedCollection.	c1 addAll: (1 to: 200).	c2 := c1 copy.	s2 := c2 size.		c1 removeAll.		self assert: c1 size = 0.	self assert: c2 size = s2 description: 'the copy has not been modified'	! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'zz 12/7/2005 19:05'!testRemoveAllSuchThat	| collection |	collection := (1 to: 10) asOrderedCollection.	collection		removeAllSuchThat: [:e | e even].	self assert: collection = (1 to: 10 by: 2) asOrderedCollection! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'sd 3/21/2006 22:39'!testRemoveAt	"Allows one to remove an element from a collection at an index"	"self run:#testRemoveAt" 		| c1 |	c1 := #(2 3 4 6) asOrderedCollection.	c1 removeAt: 2.	self assert: (c1 = #(2 4 6) asOrderedCollection).	self should: [c1 removeAt: 10] raise: Error.	self should: [c1 removeAt: -1] raise: Error.	! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'sd 3/21/2006 22:39'!testRemoveFirst	"Allows one to remove n element of a collection at the first"	"self run:#testRemoveFirst" 		| c1 |	c1 := #(2 3 4 6) asOrderedCollection.	c1 removeFirst: 1.	self assert: (c1 = #(3 4 6) asOrderedCollection).	c1 removeFirst: 2.	self assert: (c1 = #(6) asOrderedCollection).	self should: [c1 removeFirst: 10] raise: Error.		! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'sd 3/21/2006 22:39'!testRemoveIfAbsent	"Allows one to remove an element from a collection and to copy it in another collection."	"If the element isn't in the first collection, the second collection copy the element after ifAbsent"	"self run:#testRemoveIfAbsent"		| c1 c2 |	c1 := #(1 2 3 4) asOrderedCollection.	c2 := OrderedCollection new.		c2 add: (c1 remove: 2 ifAbsent: [6]).	self assert: (c1 = #(1 3 4) asOrderedCollection).	self assert: (c2 = #(2) asOrderedCollection).		c2 add: (c1 remove: 18 ifAbsent: [6]).	self assert: (c1 = #(1 3 4) asOrderedCollection).	self assert: (c2 = #(2 6) asOrderedCollection).! !!OrderedCollectionTest methodsFor: 'testsRemoving' stamp: 'sd 3/21/2006 22:39'!testRemoveLast	"Allows one to remove n element of a collection at the end"	"self run:#testRemoveLast" 		| c1 |	c1 := #(2 3 4 6) asOrderedCollection.	c1 removeLast: 1.	self assert: (c1 = #(2 3 4) asOrderedCollection).	c1 removeLast: 2.	self assert: (c1 = #(2) asOrderedCollection).	self should: [c1 removeLast: 10] raise: Error.! !!OrderedCollectionTest methodsFor: 'testStreaming' stamp: 'nice 2/26/2009 11:35'!testStreamContents	| oc |	self shouldnt: [oc := OrderedCollection streamContents: [:stream | 1 to: 3 do: [:i | stream nextPut: i]]]		raise: Error		description: 'it should be possible to stream over an OrderedCollection'.	self assert: oc class = OrderedCollection.	self assert: oc = (1 to: 3) asOrderedCollection.! !!OrderedCollectionTest commentStamp: 'BG 1/10/2004 22:07' prior: 0!These test cases demonstrate addition of items into an OrderedCollection as well as item removal.Some of the assertions are quite complicated and use a lot of collection protocol. Such methods do not test one single method, but protocol in general.!!PBBooleanPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:23'!enabledButton	| aButton aLabel |	aButton := UpdatingThreePhaseButtonMorph checkBox		target: self preference;		actionSelector: #togglePreferenceValue;		getSelector: #preferenceValue;		yourself.	aLabel := (StringMorph contents: 'enabled' translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).	^self horizontalPanel		addMorphBack: aButton;		addMorphBack: aLabel;		yourself.! !!PBBooleanPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:27'!localToProjectButton	| aButton aLabel |	aButton := UpdatingThreePhaseButtonMorph checkBox		target: self preference;		actionSelector: #toggleProjectLocalness;		getSelector: #localToProject;		yourself.	aLabel := (StringMorph contents: 'local' translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).			^self horizontalPanel		addMorphBack: aButton;		addMorphBack: aLabel;		yourself.! !!PBBooleanPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:25'!representativeButtonWithColor: aColor inPanel: aPreferencesPanel	^self horizontalPanel		layoutInset: 2;		cellInset: 7;		color: aColor;		addMorphBack: (StringMorph contents: self preference name);		addMorphBack: self horizontalFiller; 		addMorphBack: self enabledButton;		addMorphBack: self localToProjectButton;		yourself.! !!PBBooleanPreferenceView commentStamp: '<historical>' prior: 0!I am responsible for building the visual representation of a preference that accepts true and false values. This view is aimed to be used inside a PreferenceBrowser panel.!!PBBooleanPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 9/26/2004 15:47'!initialize	PreferenceViewRegistry ofBooleanPreferences register: self.! !!PBBooleanPreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:32'!unload	"Unload order is not guaranteed so guard against failure"	[PreferenceViewRegistry ofBooleanPreferences unregister: self] on Error do:[].! !!PBColorPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/6/2004 21:24'!colorSwatch	^UpdatingRectangleMorph new		target: self preference;		getSelector: #preferenceValue;		putSelector: #preferenceValue:;		extent: 22@22;		setBalloonText: 'click here to change the color' translated;		yourself.! !!PBColorPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/6/2004 21:12'!representativeButtonWithColor: aColor inPanel: aPreferenceBrowser	^self horizontalPanel		layoutInset: 2;		color: aColor;		cellInset: 20;		cellPositioning: #center;		addMorphBack: (StringMorph contents: self preference name);		addMorphBack: self horizontalFiller;		addMorphBack: self colorSwatch;		yourself! !!PBColorPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 12/6/2004 20:49'!initialize	PreferenceViewRegistry ofColorPreferences register: self.! !!PBColorPreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:33'!unload	"Unload order is not guaranteed so guard against failure"	[PreferenceViewRegistry ofColorPreferences unregister: self] on: Error do:[]! !!PBHaloThemePreferenceView methodsFor: 'user interface' stamp: 'nice 12/26/2009 19:01'!haloThemeRadioButtons	"Answer a column of butons representing the choices of halo theme"	| buttonColumn |	buttonColumn := self verticalPanel.	#(	(iconicHaloSpecifications iconic iconicHalosInForce	'circular halos with icons inside')		(classicHaloSpecs	classic	classicHalosInForce		'plain circular halos')		(simpleFullHaloSpecifications		simple	simpleHalosInForce	'fewer, larger halos')		(customHaloSpecs	custom	customHalosInForce		'customizable halos')) do:		[:quad |			| aRow aRadioButton aLabel |			aRadioButton := UpdatingThreePhaseButtonMorph radioButton				target: Preferences;				setBalloonText: quad fourth;				actionSelector: #installHaloTheme:;				getSelector: quad third;				arguments: (Array with: quad first);				yourself.			aLabel := (StringMorph contents: quad second asString)						setBalloonText: quad fourth;						yourself.			aRow := self horizontalPanel				cellInset: 4;				addMorphBack: aRadioButton;				addMorphBack: aLabel.			buttonColumn addMorphBack: aRow].	^ buttonColumn	"(Preferences preferenceAt: #haloTheme) view tearOffButton"! !!PBHaloThemePreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:45'!representativeButtonWithColor: aColor inPanel: aPreferencesPanel	| innerPanel |	innerPanel := self horizontalPanel		addMorphBack: (self blankSpaceOf: 10@0);		addMorphBack: self haloThemeRadioButtons;		yourself.	^self verticalPanel		color: aColor;		layoutInset: 2;		addMorphBack: (StringMorph contents: self preference name);		addMorphBack: innerPanel.! !!PBHaloThemePreferenceView methodsFor: 'initialization' stamp: 'hpt 12/8/2004 18:12'!initialize	self addActionTitled: 'edit custom halos' 		target: Preferences 		selector:  #editCustomHalos 		arguments: {} 		balloonText: 'Click here to edit the method that defines the custom halos' translated.! !!PBHaloThemePreferenceView commentStamp: '<historical>' prior: 0!I am responsible for building the button for the Halo Theme preference!!PBHaloThemePreferenceView class methodsFor: 'class initialization' stamp: 'hpt 9/26/2004 15:48'!initialize	PreferenceViewRegistry ofHaloThemePreferences register: self.! !!PBHaloThemePreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:33'!unload	"Unload order is not guaranteed so guard against failure"	[PreferenceViewRegistry ofHaloThemePreferences unregister: self] on: Error do:[]! !!PBNumericPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/9/2004 22:23'!preferenceValue	^self preference preferenceValue asString! !!PBNumericPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/10/2004 22:53'!preferenceValue: aTextOrString	(aTextOrString notEmpty and: [aTextOrString asString isAllDigits])		ifFalse: [^false].	self preference preferenceValue: aTextOrString asNumber.	^true.! !!PBNumericPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/9/2004 22:19'!representativeButtonWithColor: aColor inPanel: aPreferenceBrowser	^self horizontalPanel		layoutInset: 2;		color: aColor;		cellInset: 20;		cellPositioning: #center;		addMorphBack: (StringMorph contents: self preference name);		addMorphBack: self textField;		yourself.! !!PBNumericPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/9/2004 22:19'!textField	^(PluggableTextMorph		on: self		text: #preferenceValue		accept: #preferenceValue:)			hideVScrollBarIndefinitely: true;			borderColor: #inset;			acceptOnCR: true;			color: Color gray veryMuchLighter;			vResizing: #rigid;			hResizing: #spaceFill;			height: TextStyle defaultFont height + 6;			yourself.! !!PBNumericPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 12/9/2004 22:21'!initialize	PreferenceViewRegistry ofNumericPreferences register: self.! !!PBNumericPreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:33'!unload	"Unload order is not guaranteed so guard against failure"	[PreferenceViewRegistry ofNumericPreferences unregister: self] on: Error do:[].! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'hpt 12/8/2004 18:15'!actionButtons	^self preferenceView actions collect: [:aTuple |		self basicButton				label: aTuple first;				target: aTuple second;				actionSelector: aTuple third;				arguments: aTuple fourth;				setBalloonText: aTuple fifth ]! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'hpt 8/24/2005 20:33'!addExtraControls	| m |	m := self horizontalPanel		cellInset: 3;		addAllMorphs: self actionButtons;		addMorphBack: self horizontalFiller;		addMorphBack: self moreButton;		yourself.	self 		addMorphBack: (self blankSpaceOf: 2@2);		addMorphBack: self preferenceHelpTextMorph;		fullBounds; "to force a layout compute needed by the textMorphs's autoFit"		addMorphBack: m! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'hpt 12/8/2004 17:16'!advancedOptionsSelected	self preferenceView offerPreferenceNameMenu: self model! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'hpt 12/8/2004 18:17'!moreButton	^moreButton ifNil: 		[moreButton := self basicButton 						label: 'more' translated; 						setBalloonText: 							'Click here for advanced options'translated;						actionSelector: #advancedOptionsSelected]! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'stephaneducasse 2/4/2006 20:39'!preferenceHelpTextMorph	| text tm |	text := self preferenceHelpText.	tm := TextMorph new		contents: text;		wrapOnOff;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		lock: true;		visible: text notEmpty;		yourself. "we don't want an empty textmorph showing"	tm isAutoFit		ifFalse: [tm autoFitOnOff].	^tm.! !!PBPreferenceButtonMorph methodsFor: 'extra controls' stamp: 'hpt 12/8/2004 16:40'!removeExtraControls	self submorphs copyWithoutFirst do: [:ea | ea delete]! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 17:06'!basicButton	| button |	button := SimpleButtonMorph new.	button		borderWidth: 1;		borderColor: self paneColor;		on: #mouseEnter send: #value to: [button borderWidth: 2];		on: #mouseLeave send: #value to: [button borderWidth: 1];		vResizing: #rigid;		height: (TextStyle defaultFont height + 4);		useSquareCorners;		clipSubmorphs: true;		color: self paneColor muchLighter;		target: self.	^button! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 15:59'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 0;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		yourself! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 15:29'!blankSpaceOf: aPoint	^Morph new 		beTransparent;		extent: aPoint; 		yourself! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 15:43'!caseInsensitiveBeginsWith: prefix in: string	^(string findString: prefix startingAt: 1 caseSensitive: false) = 1! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 16:42'!horizontalFiller	^self horizontalPanel		hResizing: #spaceFill;		yourself.! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 16:42'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'stephaneducasse 2/4/2006 20:39'!paneColor	| browser |	browser := (self ownerChain 		detect: [:ea | ea isKindOf: PreferenceBrowserMorph] 		ifNone: [^Color black]) .	^browser paneColor! !!PBPreferenceButtonMorph methodsFor: 'utility methods' stamp: 'hpt 12/8/2004 15:27'!verticalPanel	^self basicPanel		cellPositioning: #topLeft;		listDirection: #topToBottom;		yourself.! !!PBPreferenceButtonMorph methodsFor: 'highlighting' stamp: 'hpt 12/8/2004 15:55'!highlightOff	self beTransparent.	self label color: Color black.	self removeExtraControls.! !!PBPreferenceButtonMorph methodsFor: 'highlighting' stamp: 'MAD 10/6/2009 19:35'!highlightOn		self color: (Color gray alpha: 0.1).		self addExtraControls.! !!PBPreferenceButtonMorph methodsFor: 'initialization' stamp: 'hpt 12/8/2004 15:38'!initializeLayout	self layoutPolicy: TableLayout new;		beTransparent;		layoutInset: 0;		cellInset: 0;		listCentering: #topLeft;		cellPositioning: #topLeft;		listDirection: #topToBottom;		hResizing: #spaceFill;		vResizing: #shrinkWrap.		! !!PBPreferenceButtonMorph methodsFor: 'initialization' stamp: 'hpt 12/8/2004 15:38'!initializeWithPreference: aPreference model: aModel	preference := aPreference.	model := aModel.	self initializeLayout.	self addMorphBack: self preferenceMorphicView.	self highlightOff.! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'hpt 12/8/2004 15:42'!label	^self preferenceMorphicView firstSubmorph! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'hpt 12/8/2004 15:13'!preference	^preference! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'hpt 12/8/2004 15:56'!preferenceHelp	| help name |	help := self preference helpString withBlanksTrimmed.	name := self preference name.	(self caseInsensitiveBeginsWith: name  in: help)		ifTrue: [help := help allButFirst: name size].	(help notEmpty and: [help first = $:])		ifTrue: [help := help allButFirst].	^help withBlanksTrimmed.! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'hpt 12/8/2004 15:25'!preferenceHelpText	^self preferenceHelp asText		addAttribute: TextEmphasis italic;		yourself.! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'hpt 12/8/2004 15:48'!preferenceMorphicView	^preferenceMorphicView		ifNil: 			[preferenceMorphicView := self preferenceView				representativeButtonWithColor: Color transparent inPanel: self model.			preferenceMorphicView hResizing: #spaceFill.			^preferenceMorphicView]! !!PBPreferenceButtonMorph methodsFor: 'preference accessing' stamp: 'stephaneducasse 2/4/2006 20:39'!preferenceView	^preferenceView		ifNil: [preferenceView := self preference viewForPanel: self model.]! !!PBPreferenceButtonMorph methodsFor: 'accessing' stamp: 'hpt 12/8/2004 15:34'!model	^model! !!PBPreferenceButtonMorph class methodsFor: 'instance creation' stamp: 'hpt 12/8/2004 15:20'!preference: aPreference	^self preference: aPreference model: nil! !!PBPreferenceButtonMorph class methodsFor: 'instance creation' stamp: 'hpt 12/8/2004 15:19'!preference: aPreference model: aModel	^self new		initializeWithPreference: aPreference model: aModel;		yourself.! !!PBPreferenceView methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:39'!actions	^actions ifNil: [actions := OrderedCollection new.]! !!PBPreferenceView methodsFor: 'actions' stamp: 'hpt 12/8/2004 18:13'!addActionTitled: aTitle target: aTarget selector: aSelector arguments: aCollection balloonText: aText	self actions add: { aTitle. aTarget. aSelector. aCollection. aText }! !!PBPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:42'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 2;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		yourself! !!PBPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:15'!blankSpaceOf: aPoint	^Morph new 		beTransparent;		extent: aPoint; 		yourself! !!PBPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 00:13'!horizontalFiller	^self horizontalPanel		hResizing: #spaceFill;		yourself.! !!PBPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:43'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PBPreferenceView methodsFor: 'user interface' stamp: 'bf 3/4/2010 12:14'!offerPreferenceNameMenu: aPreferenceBrowser	"the user clicked on a preference name -- put up a menu"	| aMenu |				aMenu := MenuMorph new 		defaultTarget: self preference;		addTitle: self preference name.	(Preferences okayToChangeProjectLocalnessOf: self preference name) ifTrue:		[aMenu addUpdating: #isProjectLocalString target: self preference action: #toggleProjectLocalness.		aMenu balloonTextForLastItem: 'Some preferences are best applied uniformly to all projects, and others are best set by each individual project.  If this item is checked, then this preference will be printed in bold and will have a separate value for each project'].	aMenu add: 'browse senders' translated target: self systemNavigation selector: #browseAllSelect:name:autoSelect: argumentList: {[:m | self preference selectors anySatisfy: [:sel | m hasLiteralThorough: sel]]. 'Preference senders: {1}' translated format: {self preference name}. self preference selectors first}.	aMenu balloonTextForLastItem: 'This will open a method-list browser on all methods that the send the preference "', self preference name, '".'. 	aMenu add: 'show category...' target: aPreferenceBrowser selector: #findCategoryFromPreference: argument: self preference name.	aMenu balloonTextForLastItem: 'Allows you to find out which category, or categories, this preference belongs to.'.	Smalltalk isMorphic ifTrue:		[aMenu add: 'hand me a button for this preference' target: self selector: #tearOffButton.		aMenu balloonTextForLastItem: 'Will give you a button that governs this preference, which you may deposit wherever you wish'].	aMenu add: 'copy this name to clipboard' target: self preference selector: #copyName.	aMenu balloonTextForLastItem: 'Copy the name of the preference to the text clipboard, so that you can paste into code somewhere'.	aMenu popUpInWorld! !!PBPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:43'!verticalPanel	^self basicPanel		cellPositioning: #topLeft;		listDirection: #topToBottom;		yourself.! !!PBPreferenceView commentStamp: '<historical>' prior: 0!I am just a refactor of all the common method of the PreferenceBrowser preference views!!PBPreferenceView class methodsFor: 'view registry' stamp: 'hpt 9/26/2004 16:09'!handlesPanel: aPreferencePanel	^aPreferencePanel isKindOf: PreferenceBrowser! !!PBTextPreferenceView methodsFor: 'user interface' stamp: 'hpt 12/10/2004 22:46'!preferenceValue	^self preference preferenceValue ifNil: ['']! !!PBTextPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:38'!preferenceValue: aTextOrString	self preference preferenceValue: aTextOrString asString.	^true.! !!PBTextPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:41'!representativeButtonWithColor: aColor inPanel: aPreferenceBrowser	^self horizontalPanel		layoutInset: 2;		color: aColor;		cellInset: 20;		cellPositioning: #center;		addMorphBack: (StringMorph contents: self preference name);		addMorphBack: self textField;		yourself.! !!PBTextPreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 11:41'!textField	^(PluggableTextMorph		on: self		text: #preferenceValue		accept: #preferenceValue:)			hideVScrollBarIndefinitely: true;			borderColor: #inset;			acceptOnCR: true;			color: Color gray veryMuchLighter;			vResizing: #rigid;			hResizing: #spaceFill;			height: TextStyle defaultFont height + 6;			yourself.! !!PBTextPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 9/26/2004 17:01'!initialize	PreferenceViewRegistry ofTextPreferences register: self.! !!PBTextPreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:33'!unload	"Unload order is not guaranteed so guard against failure"	[PreferenceViewRegistry ofTextPreferences unregister: self] on: Error do:[]! !!PBWindowColorPreferenceView methodsFor: 'initialization' stamp: 'hpt 12/8/2004 18:38'!initialize	super initialize.	self addActionTitled: 'Bright' target: Preferences selector: #installBrightWindowColors arguments: {} balloonText: 'Use standard bright colors for all windows' translated.	self addActionTitled: 'Pastel' target: Preferences selector: #installPastelWindowColors arguments: {} balloonText: 'Use standard pastel colors for all windows' translated.		self addActionTitled: 'White' target: Preferences selector: #installUniformWindowColors arguments: {} balloonText: 'Use white backgrounds for all standard windows' translated.! !!PBWindowColorPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 12/8/2004 18:40'!initialize	self viewRegistry register: self.! !!PBWindowColorPreferenceView class methodsFor: 'class initialization' stamp: 'ar 1/2/2010 16:34'!unload	"Unload order is not guaranteed so guard against failure"	[self viewRegistry unregister: self] on: Error do:[]! !!PBWindowColorPreferenceView class methodsFor: 'class initialization' stamp: 'hpt 12/8/2004 18:40'!viewRegistry	^(PreferenceViewRegistry registryOf: #windowColorPreferences)		viewOrder: 6;		yourself.! !!PCCByCompilation methodsFor: 'string constants' stamp: 'sr 6/7/2004 03:30'!comment	^ '{prim disabled by ', self className, '} '! !!PCCByCompilation methodsFor: 'string constants' stamp: 'sr 6/7/2004 03:31'!disabledPrimStartString	^ '"', self comment, self enabledPrimStartString! !!PCCByCompilation methodsFor: 'string constants' stamp: 'sr 6/7/2004 03:31'!disabledPrimStopChar	"end of disabling comment"	^ $"! !!PCCByCompilation methodsFor: 'string constants' stamp: 'sr 6/7/2004 03:31'!enabledPrimStartString	^ '<primitive:'! !!PCCByCompilation methodsFor: 'string constants' stamp: 'sr 6/7/2004 03:31'!enabledPrimStopChar	^ $>! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:26'!disabled2EnabledPrimMethodString: aSourceString 	| start stop primString extract |	extract := self extractDisabledPrimStringFrom: aSourceString.	primString := extract at: 1.	start := extract at: 2.	stop := start + primString size - 1.	^ aSourceString		copyReplaceFrom: start		to: stop		with: (self disabled2EnabledPrimString: primString)! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:26'!disabled2EnabledPrimString: aDisabledPrimString	"remove comment quotes and comment after first comment quote"	| enabledPrimString |	enabledPrimString := aDisabledPrimString copyFrom: self comment size + 2 to: aDisabledPrimString size - 1.	^ enabledPrimString! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:28'!enabled2DisabledPrimMethodString: aSourceString 	| start stop primString extract |	extract := self extractEnabledPrimStringFrom: aSourceString.	primString := extract at: 1.	start := extract at: 2.	stop := start + primString size - 1.	^ aSourceString		copyReplaceFrom: start		to: stop		with: (self enabled2DisabledPrimString: primString)! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:28'!enabled2DisabledPrimString: anEnabledPrimString 	| disabledPrimString |	disabledPrimString := '"' , self comment , anEnabledPrimString , '"'.	^ disabledPrimString! !!PCCByCompilation methodsFor: 'private' stamp: 'stephaneducasse 2/3/2006 22:39'!extractCallNamesFromPrimString: aString	"method works for both enabled and disabled prim strings"	"<primitive: 'doSomething' module:'ModuleFoo'"	| tokens |	tokens := aString findTokens: ''''.	^ (tokens at: 2) -> (tokens at: 4 ifAbsent: [nil])! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/11/2004 07:10'!extractDisabledPrimStringFrom: aSourceString 	| startString start stop |	startString := self disabledPrimStartString.	start := aSourceString findString: startString.	start = 0		ifTrue: [^ nil].	stop := aSourceString indexOf: self disabledPrimStopChar startingAt: start + startString size.	stop = 0		ifTrue: [^ nil].	^ {aSourceString copyFrom: start to: stop. start}! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:29'!extractEnabledPrimStringFrom: aSourceString 	| startString start stop |	startString := self enabledPrimStartString.	start := aSourceString findString: startString.	start = 0		ifTrue: [^ nil].	stop := aSourceString indexOf: self enabledPrimStopChar startingAt: start + startString size.	stop = 0		ifTrue: [^ nil].	^ {aSourceString copyFrom: start to: stop. start}! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/7/2004 03:29'!higherPriority	"this priority seems to be necessary to avoid source file accessing errors"	^ Processor userSchedulingPriority + 1! !!PCCByCompilation methodsFor: 'private' stamp: 'sr 6/11/2004 07:06'!methodSourceContainsDisabledCall: methodSource 	^ (methodSource findString: self disabledPrimStartString)		~= 0! !!PCCByCompilation methodsFor: 'ui testing' stamp: 'sr 6/11/2004 07:26'!existsCallIn: aMethodRef 	"Here existsCompiledCallIn: (see also comment there) is sufficient to 	query for enabled and failed, but not for disabled prim calls: so check 	for disabled ones in sources, too."	^ (self existsCompiledCallIn: aMethodRef)		or: [self existsDisabledCallIn: aMethodRef]! !!PCCByCompilation methodsFor: 'ui testing' stamp: 'nice 12/26/2009 19:02'!existsDisabledCallIn: aMethodRef 	| src |	^ (self existsCompiledCallIn: aMethodRef) not		and: ["higher priority to avoid source file accessing errors"			src := [aMethodRef sourceString]				valueAt: self higherPriority.			self methodSourceContainsDisabledCall: src]! !!PCCByCompilation methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:33'!extractCallModuleNames: aMethodRef 	^ (self existsCompiledCallIn: aMethodRef)		ifTrue: [self extractCallModuleNamesFromLiterals: aMethodRef]		ifFalse: [| src | 			"try source"			"higher priority to avoid source file accessing errors"			[src := aMethodRef sourceString]				valueAt: self higherPriority.			self extractCallNamesFromPrimString: ((self extractDisabledPrimStringFrom: src)					ifNil: ["no disabled prim string found"						^ nil]) first]! !!PCCByCompilation methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:38'!methodsWithCall	"Expensive!! For just querying the system unaffected by an instance of 	this class use PCCByLiterals instead."	^ self methodsWithCompiledCall , self methodsWithDisabledCall! !!PCCByCompilation methodsFor: 'ui querying' stamp: 'nice 12/27/2009 03:11'!methodsWithDisabledCall	"Answer a SortedCollection of all the methods that contain, in source  	code, the substring indicating a disabled prim."	"The alternative implementation  		^ SystemNavigation new allMethodsWithSourceString: self disabledPrimStartString									matchCase: true  	also searches in class comments."	| list string |	string := self disabledPrimStartString.	list := Set new.	'Searching all method source code...'		displayProgressAt: Sensor cursorPoint		from: 0		to: Smalltalk classNames size * 2 "classes with their metaclasses"		during: [:bar | | classCount |			classCount := 0.			SystemNavigation default				allBehaviorsDo: [:class | 					bar value: (classCount := classCount + 1).					class						selectorsDo: [:sel | 							| src | 							"higher priority to avoid source file accessing  							errors"							src := [class sourceCodeAt: sel]								valueAt: self higherPriority.							(src								findString: string								startingAt: 1								caseSensitive: true) > 0								ifTrue: [sel isDoIt ifFalse: [											list add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]]].	^ list asSortedCollection! !!PCCByCompilation methodsFor: 'private user interface' stamp: 'nice 12/26/2009 19:03'!privateDisableCallIn: aMethodRef 	"Disables enabled or failed external prim call by recompiling method 	with prim call commented out, will be called by superclass."	| src newMethodSource |	"higher priority to avoid source file accessing errors"	src := [aMethodRef sourceString]		valueAt: self higherPriority.	newMethodSource := self enabled2DisabledPrimMethodString: src.	"higher priority to avoid source file accessing errors"	[aMethodRef actualClass		compile: newMethodSource		classified: (aMethodRef actualClass whichCategoryIncludesSelector: aMethodRef methodSymbol)		notifying: nil]		valueAt: self higherPriority! !!PCCByCompilation methodsFor: 'private user interface' stamp: 'nice 12/26/2009 19:03'!privateEnableCallIn: aMethodRef 	"Enables disabled external prim call by recompiling method with prim  	call taken from disabling comment, will be called by superclass."	| src newMethodSource |	"higher priority to avoid source file accessing errors"	src := [aMethodRef sourceString]		valueAt: self higherPriority.	newMethodSource := self disabled2EnabledPrimMethodString: src.	"higher priority to avoid source file accessing errors"	[aMethodRef actualClass		compile: newMethodSource		classified: (aMethodRef actualClass whichCategoryIncludesSelector: aMethodRef methodSymbol)		notifying: nil]		valueAt: self higherPriority! !!PCCByCompilation commentStamp: 'sr 6/16/2004 09:00' prior: 0!This class is for switching external prim calls (primitiveExternalCall) on and off.It is best suited for permanently switching plugin calls off while preserving the possibility to switch them on later. For plugin testing purposes you probably should use PCCByLiterals for temporarily switch on/off them instead.It works on a source code basis by compilation:	Disabling works by putting an enabled prim call into a special comment followed by a recompile to transform it into a disabled one.	Enabling works by pulling the disabled prim call out of the special comment followed by a recompile to transform it into an enabled one.As a consequence, enabling of prims only works with method sources containing the mentioned special comment, which normally has been generated by this tool for disabling the corresponding prim.Please look into superclass PrimCallControllerAbstract for more info and the user interface.Structure: No instVars here: look into superclass.Implementation note:To harden it for sunit testing purposes some special accessing of the source code has been necessary: to avoid accessing different processes a sources file at once, followed by generating garbage, the process priority of actions leading to these accesses has been increased (sunit tests run in the background). A better solution would be to introduce a source file locking mechanism.!!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/11/2004 05:36'!cDisabledExternalCallWithoutModule	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName'>"	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 23:54'!cDisabledRealExternalCall	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'LargeIntegers'>"	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 23:54'!cDisabledRealExternalCallNaked	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'LargeIntegers'>"! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 23:54'!cDisabledRealExternalCallOrPrimitiveFailed	"{prim disabled by PCCByCompilation} <primitive: 'primGetModuleName' module:'LargeIntegers'>"	self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 09:48'!cExternalCallWithoutModule	<primitive: 'primGetModuleName'>	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'mha 7/30/2009 11:28'!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 09:48'!cNoExternalCall	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!cRealExternalCall	<primitive: 'primGetModuleName' module:'LargeIntegers'>	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!cRealExternalCallNaked	<primitive: 'primGetModuleName' module:'LargeIntegers'>! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'mha 7/30/2009 11:28'!cRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'>	self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 04:35'!cSingularExternalCall	<primitive: 'cSingularExternalCall' module:'COne'>	^ 'Hello World!!'! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'mha 7/30/2009 11:28'!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'mha 7/30/2009 11:28'!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/11/2004 05:22'!classToBeTested	^ PCCByCompilation! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:36'!disabledCallSelectors	^ #(#cDisabledRealExternalCall #cDisabledRealExternalCallNaked #cDisabledRealExternalCallOrPrimitiveFailed #cDisabledExternalCallWithoutModule )! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:34'!enabledCallSelectors	^ #(#cRealExternalCall #cRealExternalCallNaked #cRealExternalCallOrPrimitiveFailed #cExternalCallWithoutModule )! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:44'!exampleModuleName	^ 'CPCCT'! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/15/2004 02:42'!failModuleName	^ 'CFailModule'! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/14/2004 00:14'!failedCallSelector	^ #cFailedCall! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:40'!methodSelectorsToExampleModule	^ #(#cExternalCall1 #cExternalCall2 )! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:47'!moduleNameNotWithSingularCallName	^ 'CNotOne'! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:47'!moduleNameWithSingularCallName	^ 'COne'! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 09:52'!noExternalCallSelector	^ #cNoExternalCall! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:28'!realExternalCallOrPrimitiveFailedSelector	^ #cRealExternalCallOrPrimitiveFailed! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:54'!singularCallName	"occurrs exactly once as prim call name in >>cSingularExternalCall"	^ 'cSingularExternalCall'! !!PCCByCompilationTest methodsFor: 'constants' stamp: 'sr 6/14/2004 23:33'!singularCallSelector	^ #cSingularExternalCall! !!PCCByCompilationTest commentStamp: 'sr 6/14/2004 22:05' prior: 0!PCCByCompilation tests.Tests are in the superclass and inherited from there.!!PCCByCompilationTest class methodsFor: 'Testing' stamp: 'sr 6/7/2004 12:01'!isAbstract	^ false! !!PCCByLiterals methodsFor: 'ui testing' stamp: 'sr 6/11/2004 07:04'!existsCallIn: aMethodRef 	"Here >>existsCompiledCallIn: (see also comment there) is sufficient to 	query for all enabled, failed and disabled prim calls; for the by 	compiler version it is not sufficient for disabled ones."	^ self existsCompiledCallIn: aMethodRef! !!PCCByLiterals methodsFor: 'ui testing' stamp: 'sr 6/11/2004 07:30'!existsDisabledCallIn: aMethodRef 	^ (self existsCompiledCallIn: aMethodRef)		and: [(aMethodRef compiledMethod literals first at: 4)				= -2]! !!PCCByLiterals methodsFor: 'ui querying' stamp: 'sr 6/11/2004 07:04'!extractCallModuleNames: aMethodRef 	^ (self existsCallIn: aMethodRef)		ifTrue: [self extractCallModuleNamesFromLiterals: aMethodRef]! !!PCCByLiterals methodsFor: 'ui querying' stamp: 'sr 6/11/2004 07:05'!methodsWithCall	^ self methodsWithCompiledCall! !!PCCByLiterals methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:24'!methodsWithDisabledCall	^ self methodsWithCompiledCall		select: [:mRef | (mRef compiledMethod literals first at: 4)				= -2]! !!PCCByLiterals methodsFor: 'private user interface' stamp: 'sr 6/14/2004 01:35'!privateDisableCallIn: aMethodRef 	"Disables enabled or failed external prim call by filling function ref 	literal with special fail value, will be called by superclass."	aMethodRef compiledMethod literals first at: 4 put: -2! !!PCCByLiterals methodsFor: 'private user interface' stamp: 'sr 6/14/2004 02:07'!privateEnableCallIn: aMethodRef	"Enables disabled external prim call."	self privateEnableViaLiteralIn: aMethodRef! !!PCCByLiterals commentStamp: 'sr 6/16/2004 09:14' prior: 0!This class is for switching external prim calls (primitiveExternalCall) on and off.It is best suited for plugin testing purposes with temporarily switching plugin calls off and on. For permanently switching plugin calls off while preserving the possibility to switch them on later, you should use PCCByCompilation instead.It works by manipulating literals in the CompiledMethods:	Disabling works by changing the function index in the first literal of the CompiledMethod to a negative value (-2). This leads to a fast fail (value -2 is used for disabling to make a difference to the standard failed value of -1).	Enabling works by changing the function index in the first literal of the CompiledMethod to 0, followed by flushing the method cache. This enforces a fresh lookup.Please look into superclass PrimCallControllerAbstract for more info and the user interface.Structure: No instVars here: look into superclass.!!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/11/2004 05:23'!classToBeTested	^ PCCByLiterals! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:37'!disabledCallSelectors	^ #(#lDisabledRealExternalCall #lDisabledRealExternalCallNaked #lDisabledRealExternalCallOrPrimitiveFailed #lDisabledExternalCallWithoutModule )! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:34'!enabledCallSelectors	^ #(#lRealExternalCall #lRealExternalCallNaked #lRealExternalCallOrPrimitiveFailed #lExternalCallWithoutModule )! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:45'!exampleModuleName	^ 'LPCCT'! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/15/2004 02:42'!failModuleName	^ 'LFailModule'! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/14/2004 00:12'!failedCallSelector	^ #lFailedCall! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:41'!methodSelectorsToExampleModule	^ #(#lExternalCall1 #lExternalCall2 )! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:47'!moduleNameNotWithSingularCallName	^ 'LNotOne'! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:47'!moduleNameWithSingularCallName	^ 'LOne'! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:16'!noExternalCallSelector	^ #lNoExternalCall! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:29'!realExternalCallOrPrimitiveFailedSelector	^ #lRealExternalCallOrPrimitiveFailed! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/7/2004 10:54'!singularCallName	"occurrs exactly once as prim call name in >>lSingularExternalCall"	^ 'lSingularExternalCall'! !!PCCByLiteralsTest methodsFor: 'constants' stamp: 'sr 6/14/2004 23:32'!singularCallSelector	^ #lSingularExternalCall! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 08:51'!lDisabledExternalCallWithoutModule	<primitive: 'primGetModuleName'>	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lDisabledRealExternalCall	<primitive: 'primGetModuleName' module:'LargeIntegers'>	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lDisabledRealExternalCallNaked	<primitive: 'primGetModuleName' module:'LargeIntegers'>! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lDisabledRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'> "primitiveExternalCall" 	self primitiveFailed! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 09:59'!lExternalCallWithoutModule	<primitive: 'primGetModuleName'> "primitiveExternalCall" 	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/15/2004 02:41'!lFailedCall	<primitive: 'primGetModuleName' module:'LFailModule'>	^ 'failed call'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 09:57'!lNoExternalCall	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lRealExternalCall	<primitive: 'primGetModuleName' module:'LargeIntegers'>	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lRealExternalCallNaked	<primitive: 'primGetModuleName' module:'LargeIntegers'>! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/13/2004 21:14'!lRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'>	self primitiveFailed! !!PCCByLiteralsTest methodsFor: 'test methods' stamp: 'sr 6/7/2004 10:52'!lSingularExternalCall	<primitive: 'lSingularExternalCall' module:'LOne'>	^ 'Hello World!!'! !!PCCByLiteralsTest methodsFor: 'example module' stamp: 'sr 6/7/2004 08:39'!lExternalCall1	<primitive: 'prim1' module: 'LPCCT'>! !!PCCByLiteralsTest methodsFor: 'example module' stamp: 'sr 6/7/2004 08:39'!lExternalCall2		<primitive:'prim2'module:'LPCCT'>		self primitiveFailed! !!PCCByLiteralsTest methodsFor: 'tests' stamp: 'sr 6/7/2004 11:30'!setUp	super setUp.	"disable external calls"	(self class selectors		select: [:sel | sel beginsWith: 'lDisabled'])		do: [:sel | (self class >> sel) literals first at: 4 put: -2]! !!PCCByLiteralsTest commentStamp: 'sr 6/14/2004 22:05' prior: 0!PCCByLiterals tests.Tests are in the superclass and inherited from there.!!PCCByLiteralsTest class methodsFor: 'Testing' stamp: 'sr 6/7/2004 12:01'!isAbstract	^ false! !!PNGReadWriter methodsFor: 'accessing' stamp: 'ar 10/8/2008 17:40'!nextImage	bigEndian := SmalltalkImage current isBigEndian.	filtersSeen := Bag new.	globalDataChunk := nil.	transparentPixelValue := nil.	unknownChunks := Set new.	stream reset.	stream binary.	stream skip: 8.	"Try the fast version if we have a plugin"	self pngPluginVersion ifNotNil:[		form := self nextImageWithPlugin.		form ifNotNil:[^form].	].	[stream atEnd] whileFalse: [self processNextChunk].	"Set up our form"	palette ifNotNil: 			["Dump the palette if it's the same as our standard palette"			palette = (StandardColors copyFrom: 1 to: palette size) 				ifTrue: [palette := nil]].	(depth <= 8 and: [palette notNil]) 		ifTrue: 			[form := ColorForm extent: width @ height depth: depth.			form colors: palette]		ifFalse: [form := Form extent: width @ height depth: depth].	backColor ifNotNil: [form fillColor: backColor].	chunk := globalDataChunk ifNil: [self error: 'image data is missing'].	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty 		ifFalse: 			["Transcript show: ' ',unknownChunks asSortedCollection asArray printString."			].	self debugging 		ifTrue: 			[Transcript				cr;				show: 'form = ' , form printString.			Transcript				cr;				show: 'colorType = ' , colorType printString.			Transcript				cr;				show: 'interlaceMethod = ' , interlaceMethod printString.			Transcript				cr;				show: 'filters = ' , filtersSeen sortedCounts asArray printString].	^form! !!PNGReadWriter methodsFor: 'accessing' stamp: 'ar 7/13/2010 14:36'!nextImageWithPlugin	"Read enough data so we can construct the form, then pass on to libpng"	UsingPNGPlugin ifFalse:[^nil].	"We have to be *very* picky here about the types of streams that we can use,	since we need the raw data and we may not be able to seek back (zlib streams)	and FileStream is a ReadWriteStream itself."	((stream isMemberOf: ReadStream) 		or:[(stream isMemberOf: ReadWriteStream)		or:[(stream isMemberOf: RWBinaryOrTextStream)]])			ifFalse:[^nil].	[width notNil or:[stream atEnd]] whileFalse:[self processNextChunk].	"The first version only allows for regular 32bit rgba forms"	(depth = 32 and:[bitsPerChannel = 8 and:[colorType = 2 or:[colorType = 6]]]) ifTrue:[		form := Form extent: width@height depth: depth.		form := self pngPluginRead: stream originalContents into: form.		form ifNotNil:[^form].	].	^nil. "bail and let the slow version deal with it"! !!PNGReadWriter methodsFor: 'primitives' stamp: 'ar 10/8/2008 16:53'!pngPluginRead: data into: form	"Answer the plugin version, nil if not available"	<primitive: 'primitiveReadImage' module: 'PNGLibPlugin'>	^nil! !!PNGReadWriter methodsFor: 'primitives' stamp: 'ar 10/8/2008 17:54'!pngPluginVersion	"Answer the plugin version, nil if not available"	<primitive: 'primitivePngPluginVersion' module: 'PNGLibPlugin'>	^nil! !!PNGReadWriter commentStamp: '<historical>' prior: 0!I am a subclass of ImageReadWriter that decodes Portable Network Graphics(PNG) images.Submitted by Duane Maxwell!!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'ar 7/13/2010 14:37'!initialize	"	PNGReadWriter initialize	"	UsingPNGPlugin := true.	BPP := {	#(1 2 4 8 16).			#(0 0 0 0 0).			#(0 0 0 24 48).			#(1 2 4 8 0).			#(0 0 0 16 32).			#(0 0 0 0 0).			#(0 0 0 32 64).			#(0 0 0 0 0) }.	BlockHeight := #(8 8 4 4 2 2 1).	BlockWidth := #(8 4 4 2 2 1 1).	StandardColors := Color indexedColors collect:[:aColor|		Color 			r: (aColor red * 255) truncated / 255			g: (aColor green * 255) truncated / 255			b: (aColor blue * 255) truncated / 255.	].	StandardSwizzleMaps := Array new: 4.	#(1 2 4) do:[:i| StandardSwizzleMaps at: i put: (self computeSwizzleMapForDepth: i)].! !!PNGReadWriter class methodsFor: 'benchmark' stamp: 'ar 10/8/2008 18:15'!benchRead: baseDir	"PNGReadWriter benchRead: FileDirectory cacheDirectory"	"PNGReadWriter benchRead: FileDirectory default"	| fd file reader data totalTime pngCount readTime form display |	display := true. "set to false to suppress display"	totalTime := 0.	pngCount := 0.	baseDir directoryNames do:[:dn|		fd := baseDir directoryNamed: dn.		fd fileNames do:[:fn|			file := fd readOnlyFileNamed: fn.			file binary.			reader := PNGReadWriter on: file.			reader understandsImageFormat ifTrue:[				data := file reset; contents.				readTime := [					form := (PNGReadWriter on: data readStream) nextImage.				] timeToRun.				display ifTrue:[form displayOn: Display at: 0@0 rule: Form blend].				Transcript cr; show: fn, ' => ', readTime.				totalTime := totalTime + readTime.				pngCount := pngCount + 1.			].		].	].	Transcript cr; show: '#####################'.	Transcript cr; show: 'PNG files read: ', pngCount.	Transcript cr; show: 'Total read time: ', totalTime.	Display restore.! !!PNGReadWriter class methodsFor: 'accessing' stamp: 'ar 7/13/2010 15:26'!usePNGPlugin	"Whether to use the plugin version or not"	^UsingPNGPlugin! !!PNGReadWriter class methodsFor: 'accessing' stamp: 'ar 7/13/2010 15:26'!usePNGPlugin: aBool	"Whether to use the plugin version or not"	UsingPNGPlugin := aBool! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:25'!coloredFiles16	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 16.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{Color red-> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADZJREFUeF7lziEBAAAMAjD6J8b9MRAT80uT65Af8AN+wA/4AT/gB/yAH/ADfsAP+AE/4AfmgQdcz9xqBS2pdAAAAABJRU5ErkJggg=='.	Color green->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjD6J77jMRAT80sunfIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA68HyT3Gqf2I6NAAAAAElFTkSuQmCC'.		Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjD6J77jMRAT80ty3fIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA48JxX3GpYhihrAAAAAElFTkSuQmCC'.	Color black->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQFBQUBSsjp7wAAADVJREFUeF7lziEBAAAMAjDk+xfmMRAT80ty3fIDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA48LbTHD3MKH3GAAAAAElFTkSuQmCC'}! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:24'!coloredFiles32	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 32.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{		Color red -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANUlEQVR4XuXOIQEAAAwEoe9f+hZjAoFnbfVo+QE/4Af8gB/wA37AD/gBP+AH/IAf8AN+4DlwVA34ajP6EEoAAAAASUVORK5CYII='.		Color green -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAM0lEQVR4XuXOMQ0AAAACIPuX1hgejAIkPfMDfsAP+AE/4Af8gB/wA37AD/gBP+AH/MA7MFfR+Grvv2BdAAAAAElFTkSuQmCC'.	Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANElEQVR4XuXOIQEAAAACIP+f1hkGAp0k7Zcf8AN+wA/4AT/gB/yAH/ADfsAP+AE/4AfOgQFblfhqnnPWHAAAAABJRU5ErkJggg=='.		Color black -> 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAANUlEQVR4XuXOMQEAAAwCINc/tIvhwcFPkuuWH/ADfsAP+AE/4Af8gB/wA37AD/gBP+AHxoEH95UAPU59TTMAAAAASUVORK5CYII='}! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:19'!coloredFiles8	"Created by		{Color red. Color green. Color blue. Color black} collect:[:fillC|			| ff bytes |			ff := Form extent: 32@32 depth: 8.			ff fillColor: fillC.			bytes := WriteStream on: ByteArray new.			PNGReadWriter putForm: ff onStream: bytes.			fillC ->				(Base64MimeConverter mimeEncode: (bytes contents readStream)) contents		].	"	^{Color red->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGklEQVR4XmO4cwc/YLgz8hWMfAUjX8EIVQAAbnlwLukXXkcAAAAASUVORK5CYII='.	Color green->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmPQ1cUPGHRHvoKRr2DkKxihCgBZ3bQBCq5u/AAAAABJRU5ErkJggg=='.	Color blue->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmNwc8MPGNxGvoKRr2DkKxihCgCl7xgQRbPxcwAAAABJRU5ErkJggg=='.	Color black->'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAADAFBMVEX///8AAAD///9/f3//AAAA/wAAAP8A/////wD/AP8fHx8/Pz9fX1+fn5+/v7/f398HBwcPDw8XFxcnJycvLy83NzdHR0dPT09XV1dnZ2dvb293d3eHh4ePj4+Xl5enp6evr6+3t7fHx8fPz8/X19fn5+fv7+/39/cAAAAAMgAAZQAAmAAAywAA/wAAADIAMjIAZTIAmDIAyzIA/zIAAGUAMmUAZWUAmGUAy2UA/2UAAJgAMpgAZZgAmJgAy5gA/5gAAMsAMssAZcsAmMsAy8sA/8sAAP8AMv8AZf8AmP8Ay/8A//8yAAAyMgAyZQAymAAyywAy/wAyADIyMjIyZTIymDIyyzIy/zIyAGUyMmUyZWUymGUyy2Uy/2UyAJgyMpgyZZgymJgyy5gy/5gyAMsyMssyZcsymMsyy8sy/8syAP8yMv8yZf8ymP8yy/8y//9lAABlMgBlZQBlmABlywBl/wBlADJlMjJlZTJlmDJlyzJl/zJlAGVlMmVlZWVlmGVly2Vl/2VlAJhlMphlZZhlmJhly5hl/5hlAMtlMstlZctlmMtly8tl/8tlAP9lMv9lZf9lmP9ly/9l//+YAACYMgCYZQCYmACYywCY/wCYADKYMjKYZTKYmDKYyzKY/zKYAGWYMmWYZWWYmGWYy2WY/2WYAJiYMpiYZZiYmJiYy5iY/5iYAMuYMsuYZcuYmMuYy8uY/8uYAP+YMv+YZf+YmP+Yy/+Y///LAADLMgDLZQDLmADLywDL/wDLADLLMjLLZTLLmDLLyzLL/zLLAGXLMmXLZWXLmGXLy2XL/2XLAJjLMpjLZZjLmJjLy5jL/5jLAMvLMsvLZcvLmMvLy8vL/8vLAP/LMv/LZf/LmP/Ly//L////AAD/MgD/ZQD/mAD/ywD//wD/ADL/MjL/ZTL/mDL/yzL//zL/AGX/MmX/ZWX/mGX/y2X//2X/AJj/Mpj/ZZj/mJj/y5j//5j/AMv/Msv/Zcv/mMv/y8v//8v/AP//Mv//Zf//mP//y/////9ECiHUAAAAGUlEQVR4XmNgZMQPGBhHvoKRr2DkKxihCgBEmAQBphO0cAAAAABJRU5ErkJggg=='}! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'nice 12/27/2009 03:11'!decodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | form color bytes |		color := assoc key.		bytes := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		form := PNGReadWriter formFromStream: bytes.		self assert: form depth = requiredDepth.		self assert: (form pixelValueAt: 1@1) = (color pixelValueForDepth: requiredDepth).	].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'nice 12/27/2009 03:11'!encodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | ff color original encoded |		color := assoc key.		original := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		ff := Form extent: 32@32 depth: requiredDepth.		ff fillColor: color.		encoded := WriteStream on: ByteArray new.		PNGReadWriter putForm: ff onStream: encoded.		self assert: (encoded contents = original contents).	].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 7/13/2010 14:40'!testPngDecodingColors16	[PNGReadWriter usePNGPlugin: false.	self decodeColors: self coloredFiles16 depth: 16	] ensure:[PNGReadWriter usePNGPlugin: true].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:20'!testPngDecodingColors32	self decodeColors: self coloredFiles32 depth: 32.! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:20'!testPngDecodingColors8	self decodeColors: self coloredFiles8 depth: 8.! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors16	self encodeColors: self coloredFiles16 depth: 16.! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors32	self encodeColors: self coloredFiles32 depth: 32.! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'ar 2/19/2004 00:28'!testPngEncodingColors8	self encodeColors: self coloredFiles8 depth: 8.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/11/2004 00:42'!drawStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1@1 corner: aForm extent - 15) fillColor: Color red borderWidth: 3 borderColor: Color green.	canvas fillOval: (aForm boundingBox topRight - (15@-5) extent: 20@20) color: Color blue borderWidth: 1 borderColor: Color white.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32@32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/11/2004 00:42'!drawTransparentStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1@1 corner: aForm extent - 15) fillColor: (Color red alpha: 0.25) borderWidth: 3 borderColor: (Color green alpha: 0.5).	canvas fillOval: (aForm boundingBox topRight - (15@-5) extent: 20@20) color: (Color white alpha: 0.75) borderWidth: 1 borderColor: Color blue.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32@32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 12/27/2009 03:11'!encodeAndDecode: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded |	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: original; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := self readEncoded: bytes.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2| | maxErr |			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:49'!encodeAndDecodeAlpha: original	fileName := 'testAlpha', original depth printString,'.png'.	self encodeAndDecode: original.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/18/2004 23:49'!encodeAndDecodeColor: aColor depth: aDepth	| aForm |	fileName := 'testColor', aColor name, aDepth printString,'.png'.	aForm := Form extent: 32@32 depth: aDepth.	aForm fillColor: aColor.	self encodeAndDecode: aForm.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:02'!encodeAndDecodeDisplay: depth	| form |	fileName := 'testDisplay', depth printString,'.png'.	form := Form extent: (Display extent min: 560@560) depth: depth.	Smalltalk isMorphic 		ifTrue:[World fullDrawOn: form getCanvas]		ifFalse:[Display displayOn: form].	self encodeAndDecode: form.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:50'!encodeAndDecodeForm: original	fileName := 'testForm', original depth printString,'.png'.	self encodeAndDecode: original.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 12/27/2009 03:11'!encodeAndDecodeReverse: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded reversed |	fileName := 'testReverse', original depth printString,'.png'.	self assert: original class == Form. "won't work with ColorForm"	"Switch pixel order"	reversed := Form extent: original extent depth: original depth negated.	original displayOn: reversed.	self assert: original width = reversed width.	self assert: original height = reversed height.	self assert: original depth = reversed depth.	self deny: original nativeDepth = reversed nativeDepth.	original depth = 32		ifTrue:[self assert: original bits = reversed bits]		ifFalse:[self deny: original bits = reversed bits].	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: reversed; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := bytes readStream.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2| | maxErr |			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 18:18'!encodeAndDecodeStream: file	| aForm |	file reset.	(PNGReadWriter new on: file) understandsImageFormat ifFalse:[^self error: 'don''t understand format!!' ].	file reset.	aForm := (PNGReadWriter new on: file) nextImage.	aForm ifNil:[^self error: 'nil form' ].	aForm display.	self encodeAndDecode: aForm.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:36'!encodeAndDecodeWithColors: aColorForm	"Screw around with aColorForm colors"	| colors nColors indexedColors max myRandom |	fileName := 'testColors', aColorForm depth printString,'.png'.	indexedColors := Color indexedColors.	nColors := 1 bitShift: aColorForm depth.	colors := WriteStream on: Array new.	"Make first half translucent"	max := nColors // 2.	1 to: max do:[:i|		colors nextPut: ((indexedColors at: i) alpha: i / max asFloat).	].	"Make random choices for second half"	myRandom := Random seed: 42315.	max to: nColors do:[:i|		colors nextPut: (indexedColors atRandom: myRandom).	].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/29/2004 03:55'!encodeAndDecodeWithError: aStream	self should:[self encodeAndDecodeStream: aStream] raise: Error! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nk 2/17/2004 11:10'!readEncoded: bytes	"Answer a ReadStream on the file named by fileName, if possible; else a ReadStream on bytes"	fileName ifNil:[^ bytes readStream ].	^(FileStream oldFileOrNoneNamed: fileName) ifNil: [ 		Transcript nextPutAll: 'can''t open ', fileName; cr.		bytes readStream ].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'ar 2/12/2004 22:45'!setUp	fileName := nil.! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'rej 11/24/2006 18:24'!tearDown	World changed.	fileName notNil ifTrue: [FileDirectory default deleteFileNamed: fileName]! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 1/13/2010 08:21'!writeEncoded: bytes	fileName ifNil:[^self].	false ifTrue:[^self].	FileStream forceNewFileNamed: fileName do: [:file | file nextPutAll: bytes]! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test16Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 16))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test16BitDisplay	self encodeAndDecodeDisplay: 16! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 7/13/2010 14:39'!test16BitReversed	PNGReadWriter usePNGPlugin: false.	[self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 16))]		ensure:[PNGReadWriter usePNGPlugin: true].! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test1Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:43'!test1BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test1BitDisplay	self encodeAndDecodeDisplay: 1! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 01:56'!test1BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 1))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test2Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:43'!test2BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test2BitDisplay	self encodeAndDecodeDisplay: 2! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 01:56'!test2BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 2))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test32Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test32BitDisplay	self encodeAndDecodeDisplay: 32! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 01:57'!test32BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test4Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:44'!test4BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test4BitDisplay	self encodeAndDecodeDisplay: 4! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 01:56'!test4BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 4))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:50'!test8Bit	self encodeAndDecodeForm: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:44'!test8BitColors	self encodeAndDecodeWithColors: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 00:39'!test8BitDisplay	self encodeAndDecodeDisplay: 8! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/11/2004 01:57'!test8BitReversed	self encodeAndDecodeReverse: (self drawStuffOn: (Form extent: 33@33 depth: 8))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'ar 2/12/2004 22:49'!testAlphaCoding	self encodeAndDecodeAlpha: (self drawTransparentStuffOn: (Form extent: 33@33 depth: 32))! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'nice 1/18/2010 19:03'!testPngSuite	"Requires the suite from 		ftp://swrinde.nde.swri.edu/pub/png/images/suite/PngSuite.zip	to be present as PngSuite.zip"	| file |	file := [FileStream readOnlyFileNamed: 'PngSuite.zip'] on: Error do:[nil].	file ifNil:[^self].	[ | zip entries |	zip := ZipArchive new readFrom: file.	entries := zip members select:[:mbr| mbr fileName asLowercase endsWith: '.png'].	entries do:[:mbr| 		(mbr fileName asLowercase first = $x)			ifTrue: [self encodeAndDecodeWithError: mbr contentStream ]			ifFalse: [self encodeAndDecodeStream: mbr contentStream ] ].	] ensure:[file close].! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlack16	self encodeAndDecodeColor: Color blue depth: 16! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlack32	self encodeAndDecodeColor: Color blue depth: 32! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlack8	self encodeAndDecodeColor: Color blue depth: 8! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlue16	self encodeAndDecodeColor: Color blue depth: 16! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlue32	self encodeAndDecodeColor: Color blue depth: 32! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testBlue8	self encodeAndDecodeColor: Color blue depth: 8! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testGreen16	self encodeAndDecodeColor: Color green depth: 16! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:50'!testGreen32	self encodeAndDecodeColor: Color green depth: 32! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:49'!testGreen8	self encodeAndDecodeColor: Color green depth: 8! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:49'!testRed16	self encodeAndDecodeColor: Color red depth: 16! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:48'!testRed32	self encodeAndDecodeColor: Color red depth: 32! !!PNGReadWriterTest methodsFor: 'tests - colors' stamp: 'ar 2/18/2004 23:49'!testRed8	self encodeAndDecodeColor: Color red depth: 8! !!PNMReadWriter methodsFor: 'reading' stamp: 'ar 4/5/2006 01:21'!nextImage	"read one image"	| data p |	first ifNil:[		first := false.		data := stream contentsOfEntireFile.		stream := (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p := stream next.	type := (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testBalloon	self testPackage: 'Balloon' dependsExactlyOn: #(		Kernel Collections Graphics Morphic System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testCollections	self testPackage: 'Collections' dependsExactlyOn: #(		Balloon		Compiler		Kernel		Compression		Exceptions		Files		Graphics		Morphic		MorphicExtras		Multilingual		Network		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:45'!testCompiler	self testPackage: 'Compiler' dependsExactlyOn: #(		Collections		Exceptions		Graphics		Kernel		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testCompression	self testPackage: 'Compression' dependsExactlyOn: #(		Collections		Exceptions		Files		Graphics		Kernel		Multilingual		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testEtoys	self testPackage: 'EToys' dependsExactlyOn: #(		Balloon		Collections		Compiler		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		Protocols		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:45'!testExceptions	self testPackage: 'Exceptions' dependsExactlyOn: #(		Collections		Graphics		Kernel		Morphic		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testFiles	self testPackage: 'Files' dependsExactlyOn: #(		Collections		Compression		Exceptions		Graphics		Kernel		Multilingual		Network		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testGraphics	self testPackage: 'Graphics' dependsExactlyOn: #(		Collections		Compression		Exceptions		Files		Kernel		Morphic		MorphicExtras		Multilingual		Network		System		'ToolBuilder-Kernel'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testInstaller	self testPackage: 'Installer' dependsExactlyOn: #(		Collections		Compression		Exceptions		Files		Kernel		Monticello		MonticelloConfigurations		Multilingual		Network		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testKernel	self testPackage: 'Kernel' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Morphic		MorphicExtras		Multilingual		System		'ToolBuilder-Kernel'		Tools		Traits	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testMonticello	self testPackage: 'Monticello' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		Network		PackageInfo		System		Tests		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:44'!testMorphic	self testPackage: 'Morphic' dependsExactlyOn: #(		Balloon		Collections		Compiler		EToys		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		'Morphic-TrueType'			"????"		MorphicExtras		Multilingual		Network		ST80		Sound		System		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:33'!testMorphicExtras	self testPackage: 'MorphicExtras' dependsExactlyOn: #(		Balloon		Collections		Compiler		Exceptions		Files		Graphics		Kernel		Morphic		Network		Sound		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testMultilingual	self testPackage: 'Multilingual' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		Network		System		'ToolBuilder-Kernel'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testNebraska	self testPackage: 'Nebraska' dependsExactlyOn: #(		Balloon		Collections		EToys		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Multilingual		Network		SUnit		Sound		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testNetwork	self testPackage: 'Network' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testPackageInfo	self testPackage: 'PackageInfo' dependsExactlyOn: #(		Collections		Compiler		Graphics		Kernel		Morphic		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testPreferenceBrowser	self testPackage: 'PreferenceBrowser' dependsExactlyOn: #(		Collections		EToys		Exceptions		Graphics		Kernel		Morphic		MorphicExtras		System		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testProtocols	self testPackage: 'Protocols' dependsExactlyOn: #(		Collections		Graphics		Kernel		Morphic		MorphicExtras		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 4/5/2010 21:08'!testST80	self testPackage: 'ST80' dependsExactlyOn: #(		Collections		Compiler		Files		Graphics		Kernel		Morphic		Multilingual		Network		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testSUnit	self testPackage: 'SUnit' dependsExactlyOn: #(		Collections		Exceptions		Kernel		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 4/5/2010 21:02'!testSUnitGUI	self testPackage: 'SUnitGUI' dependsExactlyOn: #(		Collections		Graphics		Kernel		PackageInfo		SUnit		System		'ToolBuilder-Kernel'		Tools		Morphic	"WindowColorSpec"	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testServices	self testPackage: 'Services-Base' dependsExactlyOn: #(		Collections		Compiler		Exceptions		Graphics		Kernel		Morphic		PackageInfo		PreferenceBrowser		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testShoutCore	self testPackage: 'ShoutCore' dependsExactlyOn: #(		Collections		Graphics		Kernel		Monticello		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testSound	self testPackage: 'Sound' dependsExactlyOn: #(		Collections		Balloon		EToys		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testSystem	self testPackage: 'System' dependsExactlyOn: #(		Collections		Balloon		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		Morphic		MorphicExtras		Multilingual		Network		PackageInfo		Sound		'ToolBuilder-Kernel'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testToolBuilder	self testPackage: 'ToolBuilder-Kernel' dependsExactlyOn: #(		Collections		Files		Graphics		Kernel		SUnit	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testToolBuilderMVC	self testPackage: 'ToolBuilder-MVC' dependsExactlyOn: #(		Collections		Exceptions		Graphics		ST80		ToolBuilder		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testToolBuilderMorphic	self testPackage: 'ToolBuilder-Morphic' dependsExactlyOn: #(		Collections		Exceptions		Graphics		Kernel		Morphic		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testToolBuilderSUnit	self testPackage: 'ToolBuilder-SUnit' dependsExactlyOn: #(		Collections		Kernel		ToolBuilder		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testTools	self testPackage: 'Tools' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Multilingual		Network		PackageInfo		ST80		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testTraits	self testPackage: 'Traits' dependsExactlyOn: #(		Collections		Compiler		Exceptions		Files		Kernel		Monticello		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testTrueType	self testPackage: 'TrueType' dependsExactlyOn: #(		Collections		Balloon		Exceptions		Files		Graphics		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testVersionNumber	self testPackage: 'VersionNumber' dependsExactlyOn: #(		Collections		Kernel	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 3/8/2010 01:34'!testXML	self testPackage: 'XML' dependsExactlyOn: #(		Collections		Exceptions		Files		Kernel		Multilingual		System		Tests	).! !!PackageDependencyTest methodsFor: 'utilities' stamp: 'ul 3/8/2010 01:44'!testPackage: pkgName dependsExactlyOn: pkgList	"Ensure that the package with the given name depends only on the packages in pkgList.	NOTE: If you use this for fixing dependencies, classDeps includes the classes	and users from the package(s) not declared as dependents. Basically, you need	to fix all the references in classDeps to make the test pass."	| classDeps pi pkgDeps |	classDeps := IdentityDictionary new.	pi := PackageOrganizer default packageNamed: pkgName ifAbsent:[^self]. "unloaded"	pi classes do:[:pkgClass| 		(classDeps at: (pkgClass superclass ifNil:[ProtoObject]) 			ifAbsentPut:[OrderedCollection new]) add: pkgClass name, ' superclass'.	].	pi methods do:[:mref| | cm |		cm := mref compiledMethod.		1 to: cm numLiterals do:[:i| | lit |			((lit := cm literalAt: i) isVariableBinding 				and:[lit value isBehavior]) ifTrue:[(classDeps at: lit value ifAbsentPut:[OrderedCollection new]) add: cm methodClass asString, '>>', cm selector]]].	pkgDeps := Dictionary new.	classDeps keys do:[:aClass| | pkg |		pkg := PackageOrganizer default packageOfClass: aClass ifNone:[nil].		pkg ifNil:[			Transcript cr; show: 'WARNING: No package for ', aClass.			(classDeps removeKey: aClass) do:[:each| Transcript crtab; show: each].		] ifNotNil:[			(pkgDeps at: pkg name ifAbsentPut:[OrderedCollection new]) add: aClass.		].	].	(pkgDeps removeKey: pkgName ifAbsent:[#()]) 		do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	pkgList do:[:pkg|		self assert: (pkgDeps includesKey: pkg).		(pkgDeps removeKey: pkg ifAbsent: [#()]) 			do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	].	classDeps keysAndValuesDo:[:class :deps|		Transcript cr; show: class name, ' dependencies:'.		deps do:[:each| Transcript crtab; show: each].	].	self assert: pkgDeps isEmpty.! !!PackageInfo methodsFor: 'enumerating' stamp: 'eem 8/30/2010 10:28'!actualMethodsDo: aBlock	"Evaluate aBlock with the actual method objects in this package."	| enum |	self extensionMethods do:		[:mr|		aBlock value: mr compiledMethod].	enum := [:behavior|			behavior organization categories do:				[:cat|				(self isForeignClassExtension: cat) ifFalse:					[(behavior organization listAtCategoryNamed: cat) do:						[:s|						aBlock value: (behavior compiledMethodAt: s)]]]].	self classes do:		[:c| enum value: c; value: c classSide]		! !!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 14:54'!flushObsoletePackages: aBlock	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/1/2010 10:22'!labelString	^self package		ifNil: [super labelString]		ifNotNil:			[:pkg| | label |			label := self defaultBrowserTitle, ': ', pkg, (self selectedClass														ifNil: ['']														ifNotNil: [' ', self selectedClass printString]).			(multiWindowState notNil			 and: [multiWindowState models size > 1]) ifTrue:				[label := (multiWindowState models indexOf: self) printString, '. ', label].			label]! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/6/2010 11:52'!openEditString: aString        "Create a pluggable version of all the views for a Browser, including views and controllers."	"Example: 		PackagePaneBrowser fullOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	^self buildWindowWith: builder specs: {		(0@0 corner: 0.15@max) -> [self buildPackageListWith: builder].		(0.15@0 corner: 0.35@max) -> [self buildSystemCategoryListWith: builder].		(0.35@0 corner: 0.6@(max-0.1)) -> [self buildClassListWith: builder].		(0.35@(max-0.1) corner: 0.6@max) -> [self buildSwitchesWith: builder].		(0.6@0 corner: 0.75@max) -> [self buildMessageCategoryListWith: builder].		(0.75@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder editString: aString].	}! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^true! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:36'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 self selectedClass					ifNil: [self selectedSystemCategoryName							ifNil: [s nextPutAll: pkg]							ifNotNil: [:cat| s nextPutAll: cat]]					ifNotNil:						[:class|						 s nextPutAll: pkg; space; print: class.						 self metaClassIndicated ifTrue:							[s nextPutAll: ' class']]].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:31'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'restoreToPackage:')			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg.				(getarg value: 'className:')					ifNil: [(getarg value: 'category:') ifNotNil:							[:categoryName| s nextPut: $-; nextPutAll: categoryName]]					ifNotNil:						[:className|						s space; nextPutAll: className.						(getarg value: 'meta:') ifTrue:							[s nextPutAll: ' class'].						  self isHierarchy ifTrue:							[s space; nextPutAll: ' Hierarchy'].						(getarg value: 'selector:')							ifNil: [(getarg value: 'protocol:') ifNotNil:									[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]							ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:meta:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!Paragraph methodsFor: 'converting' stamp: 'yo 6/23/2003 19:05'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	textStyle isTTCStyle ifTrue: [		theForm :=  (Form extent: compositionRectangle extent depth: 32)		offset: offset.	] ifFalse: [		theForm := (ColorForm extent: compositionRectangle extent)			offset: offset;			colors: (Array				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	].	oldBackColor := backColor.	oldForeColor := foreColor.	backColor := Color white.	foreColor := Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor := oldBackColor.	foreColor := oldForeColor.	^ theForm"Example:| p |p := 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'converting'!asString	"Answer the string of characters of the receiver's text."	^text string! !!Paragraph methodsFor: 'converting'!asText	"Answer the receiver's text."	^text! !!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor! !!Paragraph methodsFor: 'accessing'!clippingRectangle 	"Answer the rectangle, defined in absolute coordinates, whose 	intersection with the destinationForm is the area in which the characters 	are constrained to display."	^clippingRectangle! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle := clipRect! !!Paragraph methodsFor: 'accessing'!compositionRectangle	"Answer the rectangle whose width is the dimension, modified by 	indents and tabsLevels, against which line wraparound is measured. The 	height of the compositionRectangle is reset each time recomposition is 	required."	^compositionRectangle! !!Paragraph methodsFor: 'accessing'!compositionRectangle: compRectangle 	"Set the rectangle whose width is the dimension, modified by indents and 	tabsLevels, against which line wraparound is measured."	compositionRectangle := compRectangle.	self composeAll! !!Paragraph methodsFor: 'accessing'!destinationForm 	 "Answer the Form into which the characters are scanned."	^destinationForm! !!Paragraph methodsFor: 'accessing'!fillColor 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!fillColor: maskForm 	"Set the argument, maskForm, to be the form with which each character 	is combined by the scanner before applying the rule for display."	mask := maskForm! !!Paragraph methodsFor: 'accessing'!height 	"Answer the height of the composition rectangle."	^compositionRectangle height! !!Paragraph methodsFor: 'accessing' stamp: 'nice 11/16/2009 10:25'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator lf tab ch |	lf := Character lf.	tab := Character tab.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ CR and: [(text string at: first - 1) ~~ lf]]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: lastLine) last.	reader := ReadStream on: text string from: first to: last.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) == tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ CR and: [ch ~~ lf]]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	(lastSeparator = last or: [ch == CR or: [ch == lf]])		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!Paragraph methodsFor: 'accessing'!mask 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!numberOfLines 	"Answer the number of lines of text in the receiver."	^lastLine! !!Paragraph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines := lines copy.	obsoleteLastLine := lastLine.	"find the starting and stopping lines"	firstLineIndex := startLine := self lineIndexOfCharacterIndex: start.	stopLine := self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange := aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle := compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle := (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner := CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex := (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine := compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine := startLine - 1.							self lineAt: startLine put: newLine.							startIndex := newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done := false.	lastLineIndex := stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine := compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop := (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY := self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY := self topAtLineIndex: firstLineIndex + 1.						stopLine := firstLineIndex.						done := true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex := lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex := firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex := lastLineIndex + 1]].		startIndex := newLine last + 1.		firstLineIndex := firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine := firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle :=				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing'!rule 	"Answer the rule according to which character display behaves. For 	example, rule may equal over, under, reverse."	^rule! !!Paragraph methodsFor: 'accessing'!rule: ruleInteger 	"Set the rule according to which character display behaves."	rule := ruleInteger! !!Paragraph methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:37'!stringAtLineNumber: aNumber	(aNumber > lastLine or: [aNumber < 1]) ifTrue: [^ nil].	^ (text string copyFrom: (lines at: aNumber) first to: (lines at: aNumber) last) copyWithoutAll: CharacterSet crlf! !!Paragraph methodsFor: 'accessing'!text: aText 	"Set the argument, aText, to be the text for the receiver."	text := aText.	self composeAll! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle := compositionRect copy.	text := aText.	textStyle := aTextStyle.	rule := DefaultRule.	mask := nil.		"was DefaultMask "	marginTabsLevel := 0.	destinationForm := Display.	offset := aPoint.	^self composeAll! !!Paragraph methodsFor: 'private'!compositionRectangleDelta	"A handy number -- mostly for scrolling."	^compositionRectangle top - clippingRectangle top! !!Paragraph methodsFor: 'private'!displayLines: linesInterval 	^ self displayLines: linesInterval		affectedRectangle: self visibleRectangle! !!Paragraph methodsFor: 'private' stamp: 'yo 1/23/2003 22:48'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex := self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex := linesInterval first].	lastLineIndex := self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex := lastLine]		  		ifFalse: [lastLineIndex := linesInterval last]].	lastLineIndexBottom := (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY := self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				MultiDisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	saveDestinationForm := destinationForm.	destinationForm := aDisplayMedium.	self displayLines: lineInterval.	destinationForm := saveDestinationForm! !!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex 	"Build the left margin for composition of a line. Depends upon	marginTabsLevel and the indent."	| indent |	lineIndex = 1		ifTrue: [indent := textStyle firstIndent]		ifFalse: [indent := textStyle restIndent].	^indent + (textStyle leftMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private' stamp: 'ar 12/15/2001 23:29'!leftMarginForDisplayForLine: lineIndex alignment: alignment	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(alignment = LeftFlush or: [alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad := (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad := 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineAt: indexInteger put: aTextLineInterval 	"Store a line, track last, and grow lines if necessary."	indexInteger > lastLine ifTrue: [lastLine := indexInteger].	lastLine > lines size ifTrue: [lines := lines , (Array new: lines size)].	^lines at: indexInteger put: aTextLineInterval! !!Paragraph methodsFor: 'private'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	1 to: lastLine do: 		[:lineIndex | 		(lines at: lineIndex) last >= characterIndex ifTrue: [^lineIndex]].	^lastLine! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y := compositionRectangle top.	1 to: lastLine do:		[:i | line := lines at: i.		(y := y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!lines	^lines! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle := compositionRectangle translateBy: delta.	clippingRectangle := clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!rightMarginForComposition	"Build the right margin for a line. Depends upon compositionRectangle	width, marginTabsLevel, and right indent."	^compositionRectangle width 		- (textStyle rightMarginTabAt: marginTabsLevel) 		- textStyle rightIndent! !!Paragraph methodsFor: 'private'!rightMarginForDisplay 	"Build the right margin for a line. Depends upon compositionRectangle	rightSide, marginTabsLevel, and right indent."	^compositionRectangle right - 		textStyle rightIndent - (textStyle rightMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded := Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth := self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle := compositionRectangle withWidth: compositionWidth.	clippingRectangle := compositionRectangle copy.	shrink := unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	^self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: cf backColor: cb	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	self foregroundColor: cf backgroundColor: cb.	^ self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y := compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y := y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!trimLinesTo: lastLineInteger	(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].	(lastLine := lastLineInteger) < (lines size // 2) 		ifTrue: [lines := lines copyFrom: 1 to: lines size - (lines size // 2)]! !!Paragraph methodsFor: 'private' stamp: 'nice 11/17/2009 01:02'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle := compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR or: [(text at: text size) = Character lf]])		ifTrue: [compositionRectangle := compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip := clippingRectangle.	clippingRectangle := clipRect.		aBlock value.	clippingRectangle := saveClip! !!Paragraph methodsFor: 'display box access'!boundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'display box access'!computeBoundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'selecting' stamp: 'ar 5/28/2000 12:10'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box := CaretForm boundingBox.	f := Form extent: box extent depth: depth.	map := (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb := BitBlt current toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'nice 12/26/2009 19:08'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[| range boxes box |				range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model in: self at: clickPoint editor: aController) ifTrue: [action := true]]]]].	^ action! !!Paragraph methodsFor: 'selecting'!extendSelectionAt: beginBlock endBlock: endBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."		(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock		ifTrue: [^self mouseMovedFrom: beginBlock 					pivotBlock: endBlock					showingCaret: (beginBlock = endBlock)]		ifFalse: [^self mouseMovedFrom: endBlock 					pivotBlock: beginBlock					showingCaret: (beginBlock = endBlock)]! !!Paragraph methodsFor: 'selecting' stamp: 'th 9/19/2002 17:27'!extendSelectionMark: markBlock pointBlock: pointBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."	true 		ifTrue:[^self mouseMovedFrom: pointBlock					pivotBlock: markBlock					showingCaret:(pointBlock = markBlock)]		ifFalse:		[	| beginBlock endBlock |			beginBlock := markBlock min: pointBlock.			endBlock := markBlock max: endBlock.				(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock				ifTrue: [^self mouseMovedFrom: beginBlock 							pivotBlock: endBlock							showingCaret: (beginBlock = endBlock)]				ifFalse: [^self mouseMovedFrom: endBlock 							pivotBlock: beginBlock							showingCaret: (beginBlock = endBlock)]		]! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/1/1999 12:31'!hiliteRect: rect	| highlightColor |	highlightColor := Color quickHighLight: destinationForm depth.	rect ifNotNil: [		destinationForm			fill: rect			rule: Form reverse			fillColor: highlightColor.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: highlightColor" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock := startBlock := beginBlock.	showingCaret := caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock := self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret := false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock := stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock := stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!mouseSelect	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes.  Return quickly if the button is noticed up	to make double-click more responsive."	| pivotBlock startBlock stopBlock origPoint stillDown |	stillDown := Sensor redButtonPressed.	pivotBlock := startBlock := stopBlock :=		self characterBlockAtPoint: (origPoint := Sensor cursorPoint).	stillDown := stillDown and: [Sensor redButtonPressed].	self reverseFrom: startBlock to: startBlock.	[stillDown and: [Sensor cursorPoint = origPoint]] whileTrue:		[stillDown := Sensor redButtonPressed].	(stillDown and: [clippingRectangle containsPoint: Sensor cursorPoint])		ifFalse: [^Array with: pivotBlock with: stopBlock].	^ self mouseMovedFrom: startBlock 		pivotBlock: pivotBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!mouseSelect: clickPoint 	"Track text selection and answer with an Array of two CharacterBlocks."	| startBlock |	startBlock := self characterBlockAtPoint: clickPoint.	self reverseFrom: startBlock to: startBlock.	^ self mouseMovedFrom: startBlock 		pivotBlock: startBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret := self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle := 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle := clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'alignment'!centered 	"Set the alignment for the style with which the receiver displays its text 	so that text is centered in the composition rectangle."	textStyle alignment: Centered! !!Paragraph methodsFor: 'alignment'!justified 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle."	textStyle alignment: Justified! !!Paragraph methodsFor: 'alignment'!leftFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text begin on an even border in the 	composition rectangle. This is also known as ragged-right."	textStyle alignment: LeftFlush! !!Paragraph methodsFor: 'alignment'!rightFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle but the beginning of each line does not. This is 	also known as ragged-left."	textStyle alignment: RightFlush! !!Paragraph methodsFor: 'alignment'!toggleAlignment 	"Set the alignment for the style with which the receiver displays its text 	so that it moves from centered to justified to leftFlush to rightFlush and 	back to centered again."	textStyle alignment: textStyle alignment + 1! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for characters in the text at point aPoint. It is 	assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockAtPoint: aPoint in: self! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'utilities'!clearVisibleRectangle 	"Display the area in which the receiver presents its text so that the area 	is all one tone--in this case, all white."	destinationForm	  fill: clippingRectangle	  rule: rule	  fillColor: self backgroundColor! !!Paragraph methodsFor: 'utilities'!deepCopy	"Don't want to copy the destForm (Display) or fonts in the TextStyle.  9/13/96 tk"	| new |	new := self copy.	new textStyle: textStyle copy.	new destinationForm: destinationForm.	new lines: lines copy.	new text: text deepCopy.	^ new! !!Paragraph methodsFor: 'utilities'!destinationForm: destForm	destinationForm := destForm! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle := clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'utilities'!lines: lineArray	lines := lineArray! !!Paragraph methodsFor: 'utilities'!visibleRectangle 	"May be less than the clippingRectangle if text ends part way down.	Also some fearful history includes Display intersection;	it shouldn't be necessary"	^ (clippingRectangle intersect: compositionRectangle)		intersect: destinationForm boundingBox! !!Paragraph methodsFor: 'composition' stamp: 'yo 1/23/2003 22:47'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines := Array new: 32.	lastLine := 0.	maximumRightX := 0.	text size = 0		ifTrue:			[compositionRectangle := compositionRectangle withHeight: 0.			^maximumRightX].	startIndex := lineIndex := 1.	stopIndex := text size.	compositionScanner := MultiCompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX := compositionScanner rightX max: maximumRightX.		 startIndex := (lines at: lineIndex) last + 1.		 lineIndex := lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'composition'!wrappingBox: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap 	within the rectangle, compositionRect, and the display of the text is 	clipped by the rectangle, clippingRect."	self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset.	clippingRectangle := clippingRect copy! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium	"Because Paragraphs cache so much information, computation is avoided	and displayAt: 0@0 is not appropriate here."	self displayOn: aDisplayMedium		at: compositionRectangle topLeft		clippingBox: clippingRectangle		rule: rule		fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint	"Use internal clippingRect; destination cliping is done during actual display."	self displayOn: aDisplayMedium at: aPoint		clippingBox: (clippingRectangle translateBy: aPoint - compositionRectangle topLeft)		rule: rule fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule := ruleInteger.	mask := aForm.	clippingRectangle := clipRectangle.	compositionRectangle := aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	self				"Assumes offset has been set!!!!!!!!!!"	  displayOn: aDisplayMedium	  at: (offset 			+ (displayTransformation applyTo: relativePoint) 			- alignmentPoint) rounded	  clippingBox: clipRectangle	  rule: ruleInteger	  fillColor: aForm.	! !!Paragraph methodsFor: 'indicating'!flash 	"Complement twice the visible area in which the receiver displays."	Display flash: clippingRectangle! !!Paragraph methodsFor: 'indicating'!outline 	"Display a border around the visible area in which the receiver presents 	its text."	clippingRectangle bottom <= compositionRectangle bottom	  ifTrue: [Display 				border: (clippingRectangle intersect: compositionRectangle) 				width: 2]	  ifFalse: [Display 				border: (clippingRectangle intersect: destinationForm boundingBox)				width: 2].	! !!Paragraph methodsFor: 'scrolling'!scrollBy: heightToMove 	^ self scrollBy: heightToMove withSelectionFrom: nil to: nil! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max := 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min := 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount := ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!Paragraph methodsFor: 'scrolling'!scrollDelta	"By comparing this before and after, you know if scrolling happened"	^ clippingRectangle top - compositionRectangle top! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta := 0 @ (0 - heightToMove).	compositionRectangle := compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle := clippingRectangle.	clippingRectangle := clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle := heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle := savedClippingRectangle! !!Paragraph commentStamp: '<historical>' prior: 0!I represent displayable text that has been decoraged with margin alignment, line leading, and tab settings.!!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point := Sensor waitButton.	para := 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !!Paragraph class methodsFor: 'instance creation'!new	"Do not allow an uninitialized view. Create with text that has no	characters."	^self withText: '' asText! !!Paragraph class methodsFor: 'instance creation'!withText: aText 	"Answer an instance of me with text set to aText and style set to the 	system's default text style."	^self withText: aText style: DefaultTextStyle copy! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle 	"Answer an instance of me with text set to aText and style set to 	aTextStyle."	^super new setWithText: aText style: aTextStyle! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: c1 backColor: c2	"Answer an instance of me with text set to aText and style set to 	aTextStyle, composition rectangle is compRect and the clipping rectangle 	is clipRect."	| para |	para := super new.	para setWithText: aText		style: aTextStyle		compositionRectangle: compRect		clippingRectangle: clipRect		foreColor: c1 backColor: c2.	^para! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ar 10/5/2009 21:38'!abandonChangeText	^self class abandonChangeText! !!ParagraphEditor methodsFor: 'editing keys'!align: characterStream 	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	sensor keyboard.		"flush character"	self align.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'hpt 8/5/2004 20:21'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:40'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw	 1/22/96 sw: put in control terminate/init"	sensor keyboard.	self terminateAndInitializeAround: [self cancel].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'dgd 4/4/2006 15:46'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to	accept characters with the change in emphasis. Emphasis	change amounts to a font change. Keeps typeahead."		| keyCode attribute oldAttributes index thisSel colors extras |	"control 0..9 -> 0..9"	keyCode := ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue: [		attribute := TextFontChange fontNumber: keyCode	].	keyCode = 6 ifTrue: [		| labels lines | 		colors := #(#black #magenta #red #yellow #green #blue #cyan #white ).		extras := (self class name = #TextMorphEditor and: [(self morph isKindOf: TextMorphForEditView) not])						ifTrue: ["not a system window" #()]						ifFalse: [#('Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' )].		Preferences noviceMode ifTrue: [			labels := colors , #('choose color...' ).			lines := #()		]		ifFalse: [			labels := colors , #('choose color...' 'Do it' 'Print it' ) , extras , #('be a web URL link' 'Edit hidden info' 'Copy hidden info' ).			lines := Array with: colors size + 1		].		"index := (PopUpMenu labelArray: labels lines: lines) startUp. "		index := UIManager default chooseFrom: labels lines: lines.		index = 0			ifTrue: [ ^ true].					index <= colors size ifTrue: [			attribute := TextColor color: (Color perform: (colors at: index))		]		ifFalse: [			index := index - colors size - 1. "Re-number!!!!!!"			index = 0 ifTrue: [				attribute := self chooseColor			].			index = 1 ifTrue: [				attribute := TextDoIt new.				thisSel := attribute analyze: self selection asString			].			index = 2 ifTrue: [				attribute := TextPrintIt new.				thisSel := attribute analyze: self selection asString			].			extras size = 0 & (index > 2) ifTrue: [				index := index + 4 "skip those"			].			index = 3 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Comment'			].			index = 4 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Definition'			].			index = 5 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Hierarchy'			].			index = 6 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString			].					index = 7 ifTrue: [				attribute := TextURL new.				thisSel := attribute analyze: self selection asString			].					index = 8 ifTrue: [				"Edit hidden info"				thisSel := self hiddenInfo. "includes selection"				attribute := TextEmphasis normal			].			index = 9 ifTrue: [				"Copy hidden info"				self copyHiddenInfo.				^ true			].					"no other action"			thisSel				ifNil: [ ^ true ]		]	].	(keyCode between: 7 and: 11) ifTrue: [		sensor leftShiftDown ifTrue: [			keyCode = 10 ifTrue: [				attribute := TextKern kern: -1			].			keyCode = 11 ifTrue: [				attribute := TextKern kern: 1			]		]		ifFalse: [			attribute := TextEmphasis perform: (#(#bold #italic #narrow #underlined #struckOut ) at: keyCode - 6).			oldAttributes						do: [:att | (att dominates: attribute) ifTrue: [attribute turnOff]]		]	].	keyCode = 0		ifTrue: [attribute := TextEmphasis normal].	beginTypeInBlock ~~ nil ifTrue: [		"only change emphasisHere while typing"		self insertTypeAhead: characterStream.		emphasisHere := Text addAttribute: attribute toArray: oldAttributes.		^ true	].	self		replaceSelectionWith: (thisSel asText addAttribute: attribute).			^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 11/16/2009 16:19'!changeLfToCr: characterStream 	"Replace all LFs by CRs, and CR-LF pairs by single CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString:			(self selection string withSqueakLineEndings)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 09:11'!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute.  This is the non-Morphic version."	^ TextColor color: (Color fromUser)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:31'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self terminateAndInitializeAround: [self compareToClipboard].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 08:47'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	^ self clipboardTextPut: self hiddenInfo asText! !!ParagraphEditor methodsFor: 'editing keys'!copySelection: characterStream 	"Copy the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self copySelection.	^true! !!ParagraphEditor methodsFor: 'editing keys'!cut: characterStream 	"Cut out the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self cut.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:23'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self terminateAndInitializeAround: [self doIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/20/2002 11:41'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[view flash].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [ ^true ].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys'!exchange: characterStream	"Exchange the current and prior selections.  Keeps typeahead."	sensor keyboard.	 "Flush character"	self closeTypeIn: characterStream.	self exchange.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'acg 12/7/1999 07:56'!exploreIt: characterStream 	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self exploreIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 4/24/2001 12:28'!fileItIn: characterStream 	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self fileItIn].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:31'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList := paragraph text attributesAt: (self pointIndex +self markIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!ParagraphEditor methodsFor: 'editing keys'!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 2/9/2010 09:32'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| realStart realStop lines startLine stopLine start stop adjustStart indentation numLines oldString newString newSize |	sensor keyboard.  "Flush typeahead"	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == Character cr or: [(paragraph string at: realStart - 1) == Character lf]]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	"start on a real line, not a wrapped line"	[startLine = 1 or: [CharacterSet crlf includes: (paragraph string at: (lines at: startLine-1) last)]] whileFalse: [startLine := startLine - 1].	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].	indentation + delta <= 0 ifTrue: ["^false"].	numLines := stopLine + 1 - startLine.	oldString := paragraph string copyFrom: start to: stop.	newString := oldString species new: oldString size + ((numLines * delta) max: 0).		"Do the actual work"	newSize := 0.	delta > 0		ifTrue: [| tabs |			tabs := oldString species new: delta withAll: Character tab.			oldString lineIndicesDo: [:startL :endWithoutDelimiters :endL |				startL < endWithoutDelimiters ifTrue: [newString replaceFrom: 1 + newSize to: (newSize := newSize + delta) with: tabs startingAt: 1].				newString replaceFrom: 1 + newSize to: (newSize := 1 + newSize + endL - startL) with: oldString startingAt: startL]]		ifFalse: [| tab |			tab := Character tab.			oldString lineIndicesDo: [:startL :endWithoutDelimiters :endL |				| i |				i := 0.				[i + delta < 0 and: [ i + startL <= endWithoutDelimiters and: [(oldString at: i + startL) == tab]]] whileTrue: [i := i + 1].				newString replaceFrom: 1 + newSize to: (newSize := 1 + newSize + endL - (i + startL)) with: oldString startingAt: i + startL]].	newSize < newString size ifTrue: [newString := newString copyFrom: 1 to: newSize].		"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + newSize - oldString size.	"Replace selection"	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: newString asText.	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'editing keys'!indent: characterStream	"Add a tab at the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: characterStream delta: 1! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self inspectIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'md 1/18/2006 23:42'!makeCapitalized: characterStream 	"Force the current selection to be capitalized. Triggered by Cmd-Z."	| prev |	sensor keyboard.		"Flush the triggering cmd-key character"	prev := $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:21'!makeProjectLink: characterStream 	""	| attribute oldAttributes thisSel |		sensor keyboard.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	attribute := TextSqkProjectLink new. 	thisSel := attribute analyze: self selection asString.	thisSel ifNil: [^ true].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere := Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ls 11/10/2002 12:11'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-Y."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 15:18'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 9/9/97 16:44'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!noop: characterStream 	"Unimplemented keyboard command; just ignore it."	sensor keyboard.	  "flush character"	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/19/2000 11:14'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := paragraph textStyle fontNamesWithPointSizes.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys'!offerFontMenu: characterStream 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw	 Keeps typeahead.  (?? should flush?)"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self offerFontMenu.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!outdent: characterStream	"Remove a tab from the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: characterStream delta: -1! !!ParagraphEditor methodsFor: 'editing keys'!paste: characterStream 	"Replace the current text selection by the text in the shared buffer.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self paste.	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:48'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self printIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys'!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self terminateAndInitializeAround: [self accept].	^ true! !!ParagraphEditor methodsFor: 'editing keys'!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'yo 5/27/2004 13:56'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes := paragraph text attributesAt: self selectionInterval first forStyle: paragraph textStyle.	attribute := TextEmphasis perform: emphasisSymbol.	(emphasisSymbol == #normal) 		ifFalse:	[oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:20'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	char = $9 ifTrue: [ char := $( ].	char = $, ifTrue: [ char := $< ].	char = $[ ifTrue: [ char := ${ ].	char = $' ifTrue: [ char := $" ].	char asciiValue = 27 ifTrue: [ char := ${ ].	"ctrl-["	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [1].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self terminateAndInitializeAround: [self spawn].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:00'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars := self selection) size == 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!ParagraphEditor methodsFor: 'editing keys'!undo: characterStream 	"Undo the last edit.  Keeps typeahead, so undo twice is a full redo."	sensor keyboard. 	"flush character"	self closeTypeIn: characterStream.	self undo.	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 19:19'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText := paragraph text copy.! !!ParagraphEditor methodsFor: 'menu messages'!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made.	Undoer & Redoer: #undoAgain:andReselect:typedKey:."	"If last command was also 'again', use same keys as before"	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:)! !!ParagraphEditor methodsFor: 'menu messages'!align	"Align text according to the next greater alignment value--cycling among 	left flush, right flush, center, justified.  No effect on the undoability of the pre	preceding command."	paragraph toggleAlignment.	paragraph displayOn: Display.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:09'!browseClassFromIt	"Launch a browser for the class indicated by the current selection. 	If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self		lineSelectAndEmptyCheck: [^ self].	aClass := Utilities				classFromPattern: (self selection string copyWithoutAll: CharacterSet separators)				withCaption: 'choose a class to browse...'.	aClass		ifNil: [^ view flash].	self		terminateAndInitializeAround: 			[| aBrow |			aBrow := SystemBrowser default new.			aBrow setClass: aClass selector: nil.			aBrow class				openBrowserView: (aBrow openEditString: nil) label: 'System Browser'].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'eem 7/6/2010 13:10'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol maybeBrowseInstVar |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	maybeBrowseInstVar :=		[| selectionString |		selectionString := self selection asString.		 ([model selectedClass] on: Error do: [:ex|]) ifNotNil:			[:class|			(class allInstVarNames includes: selectionString) ifTrue:				[self systemNavigation					browseAllAccessesTo: selectionString					from: (class classThatDefinesInstanceVariable: selectionString).				 ^nil]]].	(aSymbol := self selectedSymbol) ifNil:		[maybeBrowseInstVar value.		 ^view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[| anEntry |				([model selectedClass theNonMetaClass] on: Error do: [:ex|]) ifNotNil:					[:class| "If selection is a class or pool var (a binding exists but not in the environment)"					(class bindingOf: aSymbol) ifNotNil:						[:binding| "then browse its references"						 (class environment bindingOf: aSymbol) ~~ binding ifTrue:							[self systemNavigation browseAllCallsOn: binding.							 ^nil]]].				anEntry := (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isBehavior or: [ anEntry isTrait ])					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil]			ifFalse:				[self systemNavigation browseAllImplementorsOf: aSymbol.				 maybeBrowseInstVar value]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection := paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph := paragraph.	otherInterval := UndoInterval := 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 2/17/2005 17:53'!changeAlignment	| aList reply  |	aList := #(leftFlush centered justified rightFlush).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	self mvcRedisplay.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 3/14/2005 13:03'!changeEmphasis	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'fc 2/19/2004 22:09'!changeEmphasisOrAlignment	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).	reply := (SelectionMenu labelList: aList lines: #(6) selections: aList) startUp.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[paragraph perform: reply.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 10/22/2003 15:27'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNotNil:		[(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'RAA 3/15/2001 12:10'!changeStyleTo: aNewStyle	paragraph textStyle: aNewStyle.	paragraph composeAll.	self recomputeSelection.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/27/1999 11:54'!chooseAlignment	self changeAlignment! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/15/2003 22:40'!classCommentsContainingIt	"Open a browser class comments which contain the current selection somewhere in them."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [		self systemNavigation browseClassCommentsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dvf 8/23/2003 11:51'!classNamesContainingIt	"Open a browser on classes whose names contain the selected string"	self lineSelectAndEmptyCheck: [^self].	self systemNavigation 		browseClassesWithNamesContaining: self selection string		caseSensitive: Sensor leftShiftDown! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:37'!clipboardText	^ Clipboard clipboardText! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardText: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardTextPut: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 := self clipboardText string.	s2 := paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection := self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval := self selectionInterval.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:33'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages'!exchange	"See comment in exchangeWith:"	self exchangeWith: otherInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:34'!experimentalCommand	"Use for experimental command-key implementation.  Using this, 	you can try things out without forever needing to reinitialize the 	ParagraphEditor."	self prettyPrint.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 03:59'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	Cursor execute showWhile: 			[ | symbol string delimitors reply numbers tiVars selectors sorry cgVars |			sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:41'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection := self selection.	self terminateAndInitializeAround:		[(ReadWriteStream on: selection string from: 1 to: selection size) fileIn].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'CdG 10/17/2005 20:49'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply := UIManager default request: 'Find what? ' translated initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText := FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages'!findAgain	"Find the text-to-find again.  1/24/96 sw"	self againOrSame: true! !!ParagraphEditor methodsFor: 'menu messages'!fit	"Make the bounding rectangle of the paragraph contain all the text while 	 not changing the width of the view of the paragraph.  No effect on undoability	 of the preceding command."	paragraph clearVisibleRectangle.	paragraph fit.	paragraph displayOn: Display; outline.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 09:42'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ self systemNavigation browseAllImplementorsOf: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:12'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dgd 11/25/2004 18:03'!makeProjectLink		| attribute thisSel |		thisSel := self selection.	attribute := TextSqkProjectLink new. 	thisSel := attribute analyze: self selection asString.	thisSel ifNil: [^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:31'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[self terminateAndInitializeAround: [self systemNavigation browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed]].	Cursor normal show! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 9/6/2005 18:45'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source). Slow!!"	self lineSelectAndEmptyCheck: [^ self].	self systemNavigation browseMethodsWithSourceString: self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:28'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [self systemNavigation browseMethodsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:34'!mvcRedisplay	"Overridable by subclasses that do their own display"	Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"	self display! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/20/2002 11:21'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: self pointIndex]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:36'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self paste! !!ParagraphEditor methodsFor: 'menu messages'!performMenuMessage: aSelector	"If a menu command is invoked, typeIn must be closed first, the selection	 must be unhighlighted before and rehighlighted after, and the marker	 must be updated."	self closeTypeIn.	self deselect.	super performMenuMessage: aSelector.	self selectAndScroll.	self updateMarker! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:12'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	self terminateAndInitializeAround:		[| reply items |		reply := (UIManager default chooseFrom: (items := self specialMenuItems) lines: #()).		reply = 0 ifTrue: [^ self].		Compiler new evaluate: (items at: reply) in: [] to: self]	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrint	self prettyPrint: false! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 7/13/2006 16:00'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageCategoryName ifNil: [^ view flash].	selectedClass := model selectedClassOrMetaClass.	newText := selectedClass prettyPrinterClass		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrintWithColor	self prettyPrint: true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dew 3/7/2000 21:06'!printerSetup		TextPrinter defaultTextPrinter inspect! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 3/5/2010 20:26'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol := self selectedSymbol) == nil or:		[(Smalltalk globals includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: (Smalltalk globals associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 03:12'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName |	stringToSave := paragraph text string.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow := self model dependents						detect: [:dep | dep isKindOf: SystemWindow orOf: StandardSystemView]						ifNone: [nil].	labelToUse := parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName := nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer | | lastIndex |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName := labelToUse, '.text'].				fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'bf 10/13/1999 09:09'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 2/8/2010 10:48'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := self selection string copyWithoutAll: CharacterSet separators.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'gm 2/16/2003 20:38'!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size == 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:30'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/18/2002 17:28'!setAlignment: aSymbol	| attr interval |	attr := TextAlignment perform: aSymbol.	interval := self encompassLine: self selectionInterval.	paragraph replaceFrom: interval first to: interval last with:		((paragraph text copyFrom: interval first to: interval last) addAttribute: attr) displaying: true.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!setSearchString	"Make the current selection, if any, be the current search string."	self hasCaret ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dgd 8/28/2004 13:59'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code := paragraph text string.	self cancel.	model notNil ifTrue:[model spawn: code].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:44'!spawnWorkspace	| toUse |	self selectLine.	toUse := self selection asString.	toUse size > 0 ifFalse:		[toUse := paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self terminateAndInitializeAround:		[Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/29/96'!specialMenuItems	"Refer to comment under #presentSpecialMenu.  .	 : added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'SqR 11/14/2000 12:15'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	sensor flushKeyboard. "a way to flush stuck keys"	self closeTypeIn.	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage := Message selector: #undoReplace.		UndoInterval := 1 to: 0.		Undone := true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph := Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph := paragraph! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'dvf 7/28/2003 14:54'!activateTextActions	(paragraph text attributesAt: startBlock stringIndex) 		do: [:att | att actOnClickFor: model in: paragraph]! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'BG 6/1/2003 09:43'!offerMenuFromEsc: aStream   sensor keyboard. " consume the character "   self yellowButtonActivity.  ^true "tell the caller that the character was processed "! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:40'!totalTextHeight	^paragraph boundingBox height! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:33'!visibleHeight	^paragraph clippingRectangle height! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:37'!adjustSelection: directionBlock	"Helper function for Cursor movement. Always moves point thus allowing selections to shrink. "	"See also expandSelection:"	"Accepts a one argument Block that computes the new postion given an old one."	| newPosition |	newPosition := directionBlock value: self pointIndex.	self selectMark: self markIndex point: newPosition.	^true.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 10/28/2003 12:11'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: self stopIndex ! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/17/2002 16:11'!computeIntervalFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self setMark: start.	self setPoint: stop + 1.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:21'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc := start.		[(loc := loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc := loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing := selectionShowing) ifTrue: [ self reverseSelection ].	userSelection := self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta := aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!ParagraphEditor methodsFor: 'new selection' stamp: 'nice 11/16/2009 14:41'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string := paragraph text string.	left := (string lastIndexOfAnyOf: CharacterSet crlf startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (string indexOfAnyOf: CharacterSet crlf startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 12/17/1998 09:41'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:25'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc := start + dir.	str := paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc := loc + dir].	^ loc! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/20/1998 08:31'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	self insertAndSelect: aString at: (anInteger max: 1)! !!ParagraphEditor methodsFor: 'new selection'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:50'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[self deselect.		self selectInvisiblyFrom: start to: stop].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: anInterval first to: anInterval last! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/9/1998 20:59'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: start to: stop! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:17'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: mark to: point! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:17'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self encompassLine: self selectionInterval)! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:18'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse:		[self deselect.		self selectInvisiblyMark: mark point: point].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 18:49'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok := false.	string := paragraph text string.	stop := self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].	sep := stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:51'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string := paragraph text string.	here := self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters := '([{<''"'.	rightDelimiters := ')]}>''"'.	openDelimiter := string at: here - 1.	match := leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start := here.			direction := 1.			here := here - 1.			closeDelimiter := rightDelimiters at: match]		ifFalse: 			[openDelimiter := string at: here.			match := rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop := here - 1.					direction := -1.					closeDelimiter := leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction := -1]].	level := 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar := string at: (here := here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start := 1.									"go right if hit string start"									direction := 1]]						ifFalse: [direction < 0								ifTrue: 									[start := here + 1.									"go right if hit non-token"									direction := 1]								ifFalse: [level := 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level := level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level := level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here := here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:48'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where := paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor methodsFor: 'private'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	^ self againOrSame: useOldKeys many: sensor leftShiftDown! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:53'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home := self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText := UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText := ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey := FindText size = 0)		ifTrue: "just inserted at a caret"			[home := self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText := ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices := WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home := self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:16'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime := self isRedoing		ifTrue: [prior := sym := selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret := self startIndex.			self selectPrecedingIdentifier.			input := self selection]		ifFalse: "Repeated Ctrl-q"			[caret := UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input := hintText.			prior := selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym := Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart := self startIndex.			outStream := WriteStream on: (String new: 2 * sym size).			1 to: (kwds := sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret := newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection := input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection := self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone := true].			view flash].	self selectAt: caret! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:49'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start := self startIndex.	stop := self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before := prior last < start.			selection := self selection.			priorSelection := paragraph text copyFrom: prior first to: prior last.			delta := before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta := before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval := prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval := start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!ParagraphEditor methodsFor: 'private' stamp: 'raok 11/15/2001 14:01'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str := string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!ParagraphEditor methodsFor: 'private' stamp: 'tk 7/14/2000 12:15'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^ ((view ~~ nil) and: [(customMenu := view getMenu: shiftKeyState) notNil])		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!ParagraphEditor methodsFor: 'private' stamp: 'cmm 4/9/2004 14:00'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge := anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!ParagraphEditor methodsFor: 'private' stamp: 'nice 12/25/2009 16:00'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string lineIndex |	string := paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	lines := OrderedCollection new: (string size // 15).	lineIndex := 0.	string lineIndicesDo: [:start :endWithoutDelimiters :end |		lines addLast: {start. (lineIndex := lineIndex + 1). end}].	"Special workaround for last line empty."	(string last == Character cr or: [string last == Character lf])		ifTrue: [lines addLast: {string size + 1. lineIndex + 1. string size}].	^lines! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:57'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift := sensor leftShiftDown.	indices := self setIndices: shift forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index + 1].	^ index! !!ParagraphEditor methodsFor: 'private'!nullText	^Text string: '' emphasis: emphasisHere! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/20/2002 11:09'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines := paragraph numberOfLines.	visibleHeight := self visibleHeight.	totalHeight := self totalTextHeight.	ratio := visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index - 1].	^ index + 1! !!ParagraphEditor methodsFor: 'private' stamp: 'BG 4/29/2004 11:19'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle := Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines := paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  := paragraph lineIndexOfCharacterIndex: start.			currentLine := lines at: currentLineNumber]		ifFalse: [			lines := self lines.			numberOfLines := lines size.			currentLine := lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber := currentLine second].	column := start - currentLine first.	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine := (lines at: targetLineNumber) first.	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber == numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber == currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor methodsFor: 'private' stamp: 'md 2/22/2006 21:17'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices := Dictionary new.	shiftPressed ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:22'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start := paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start := paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 10/21/2003 15:46'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex := 1 max: self markIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex := startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex := self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'ktt 11/28/2005 12:16'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	startIndex := self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex := 1 max: startIndex - 1.			].	self backTo: startIndex.			^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!changeStyle: characterStream 	"Put up the style-change menu"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self changeStyle.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'nice 2/8/2010 10:56'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s := paragraph string.	i := self stopIndex.	tabCount := 0.	[(i := i-1) > 0 and: [(char := s at: i) ~= Character cr and: [char ~= Character lf]]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount := tabCount + 1].		char = $[ ifTrue: [tabCount := tabCount + 1].		char = $] ifTrue: [tabCount := tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 4/30/2001 21:20'!cursorTopHome: characterStream 	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."		sensor keyboard.	self selectAt: 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainMany: characterStream 	"Do the previous thing again repeatedly. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!find: characterStream	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self find.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!findAgain: characterStream 	"Find the desired text again.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self findAgain.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/18/2002 11:39'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex := self mark.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection := self nullText].	uinterval := UndoInterval deepCopy.	upara := UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph := upara.  UndoInterval := uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel := UndoSelection.			ind := startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!normalCharacter: characterStream 	"A nonspecial character is to be added to the stream of characters."	characterStream nextPut: sensor keyboard.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:25'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[view flash].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!search: characterStream	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: true. "true means use same keys"	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 8/29/2000 14:58'!selectAll	"Make the selection be all the characters of the receiver"	self selectFrom: 1 to: paragraph text string size! !!ParagraphEditor methodsFor: 'typing/selecting keys'!selectAll: characterStream 	"select everything, invoked by cmd-a.  1/17/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectFrom: 1 to: paragraph text string size.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 17:34'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex := self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).	startIndex := 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'yo 3/16/2004 13:05'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit := beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection := self nullText. self stopIndex]		ifFalse: [self startOfTyping].	self setMark: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers := self startOfTyping - startIndex.		beginTypeInBlock := self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:40'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin := self startOfTyping.			stop := self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval := begin to: stop - 1].		beginTypeInBlock := nil]! !!ParagraphEditor methodsFor: 'typing support'!closeTypeIn: characterStream	"Call instead of closeTypeIn when you want typeahead to be inserted before the	 control character is executed, e.g., from Ctrl-V."	self insertTypeAhead: characterStream.	self closeTypeIn! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 9/7/1999 11:26'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	self terminateAndInitializeAround: [	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock := nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:48'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection := self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock := self startIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'yo 10/10/2007 20:32'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead := WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char := sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				self setEmphasisHere.				^self selectAndScroll; updateMarker].			self openTypeIn].		self hasSelection ifTrue: "save highlighted characters"			[UndoSelection := self selection]. 		self zapSelectionWithCompositionWith: typeAhead contents.		typeAhead reset.		self unselect.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:49'!setEmphasisHere	emphasisHere := (paragraph text attributesAt: (self pointIndex - 1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	self markBlock = self pointBlock ifFalse: [UndoSelection := self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	self unselect.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ar 8/18/2009 00:18'!blinkParen	"Highlight the last parenthesis in the text"	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'mir 8/3/2004 13:31'!blinkParenAt: parenLocation 	self text		addAttribute: TextEmphasis bold		from: parenLocation		to: parenLocation.	lastParentLocation := parenLocation.! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/7/2002 04:03'!blinkPrevParen	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := startBlock stringIndex.	openDelimiter := sensor keyboardPeek.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]].! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ar 8/18/2009 00:18'!clearParens	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				removeAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]].	lastParentLocation := nil.! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'nice 8/21/2008 18:27'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	self clearParens.  	"mikki 1/3/2005 21:31 Preference for auto-indent on return added."	char asciiValue = 13 ifTrue: [		^Preferences autoIndent 			ifTrue: [				sensor controlKeyPressed					ifTrue: [self normalCharacter: typeAheadStream]					ifFalse: [self crWithIndent: typeAheadStream]]			ifFalse: [				sensor controlKeyPressed					ifTrue: [self crWithIndent: typeAheadStream]					ifFalse: [self normalCharacter: typeAheadStream]]].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].			"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'initialize-release'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph := nil].	paragraph := aParagraph.	self resetState! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'th 10/21/2003 15:49'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	stopBlock := paragraph defaultCharacterBlock.	self pointBlock: stopBlock copy.	beginTypeInBlock := nil.	UndoInterval := otherInterval := 1 to: 0.	self setEmphasisHere.	selectionShowing := false.	initialText := paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 5/15/2000 13:51'!stateArray	^ {ChangeText.		FindText.		UndoInterval.		UndoMessage.		UndoParagraph.		UndoSelection.		Undone.		self selectionInterval.		self startOfTyping.		emphasisHere}! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText := stateArray at: 1.	FindText := stateArray at: 2.	UndoInterval := stateArray at: 3.	UndoMessage := stateArray at: 4.	UndoParagraph := stateArray at: 5.	UndoSelection := stateArray at: 6.	Undone := stateArray at: 7.	sel := stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock := stateArray at: 9.	emphasisHere := stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 10/10/2007 20:13'!charBefore	| start |	(start := self startIndex) > 1 ifTrue: [^ paragraph text at: start - 1].	^ nil.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasCaret	^self markBlock = self pointBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasSelection	^self hasCaret not! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:13'!mark	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock	^ stopBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock: aCharacterBlock	stopBlock := aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!markIndex	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock	^ startBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock: aCharacterBlock	startBlock := aCharacterBlock.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!pointIndex	^ self pointBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 7/31/2004 16:27'!selection	"Answer the text in the paragraph that is currently selected."	| t |	t := paragraph text copyFrom: self startIndex to: self stopIndex - 1.	t string isOctetString ifTrue: [t asOctetStringText].	^ t.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:10'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadWriteStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 16:18'!selectionInterval	"Answer the interval that is currently selected."	^self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setMark: anIndex	self markBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setPoint: anIndex	self pointBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:10'!startBlock	^ self pointBlock min: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!startBlock: aCharacterBlock	self markBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!startIndex	^ self startBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:14'!stopBlock	^ self pointBlock max: self markBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!stopBlock: aCharacterBlock	self pointBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!stopIndex	^ self stopBlock stringIndex! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:23'!unselect	self markBlock: self pointBlock copy.! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 10/10/2007 20:24'!wasComposition	^ wasComposition ifNil: [^ false].! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 10/10/2007 20:34'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start := self startIndex.	stop := self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		self wasComposition ifTrue: [wasComposition := false. self setPoint: start + 1].		UndoInterval := otherInterval := self selectionInterval]! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 10/16/2007 21:01'!zapSelectionWithCompositionWith: aString	"Deselect, and replace the selection text by aString.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| stream newString aText beforeChar |	wasComposition := false.	((aString isEmpty or: [(beforeChar := self charBefore) isNil]) or: [		aString size = 1 and: [(Unicode isComposition: aString first) not]]) ifTrue: [			^ self zapSelectionWith: (Text string: aString emphasis: emphasisHere)].	stream := UnicodeCompositionStream on: (String new: 16).	stream nextPut: beforeChar.	stream nextPutAll: aString.	newString := stream contents.	aText := Text string: newString emphasis: emphasisHere.	self markBlock < self pointBlock		ifTrue: [self setMark: self markBlock stringIndex - 1]		ifFalse: [self setPoint: self  pointBlock stringIndex - 1].	wasComposition := true. 	self zapSelectionWith: aText.! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:51'!comment	"All key actions that are neither editing nor typing actions have to	send closeTypeIn at first. See comment in openTypeIn closeTypeIn"! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:08'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 11/16/2009 10:38'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string := paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine := paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lines last						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOfAnyOf: CharacterSet crlf						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 11/16/2009 14:39'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string := paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOfAnyOf: CharacterSet crlf						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:07'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self closeTypeIn: characterStream.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		specialBlock:[:position | self previousWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageDown: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageUp: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:01'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn: characterStream.	self		moveCursor: [:position | position + 1]		forward: true		specialBlock:[:position | self nextWord: position].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:15'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	self closeTypeIn: characterStream.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'di 12/3/2001 21:49'!escapeToDesktop: characterStream 	"Pop up a morph to field keyboard input in the context of the desktop"	Smalltalk isMorphic ifTrue: [ActiveWorld putUpWorldMenuFromEscapeKey].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'dvf 12/8/2001 00:46'!raiseContextMenu: characterStream 	"AFAIK, this is never called in morphic, because a subclass overrides it. Which is good, because a ParagraphEditor doesn't know about Morphic and thus duplicates the text-editing actions that really belong in the specific application, not the controller. So the context menu this would raise is likely to be out of date."	self yellowButtonActivity.	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior := otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval := prior.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sma 12/15/1999 11:46'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'do-its' stamp: 'Igor.Stasenko 12/20/2009 07:26'!compileSelectionFor: anObject in: evalContext	| methodNode |	methodNode := [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	^ methodNode generateWithTempNames.! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:38'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection.! !!ParagraphEditor methodsFor: 'do-its' stamp: 'gk 3/3/2004 17:15'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'acg 12/7/1999 07:53'!exploreIt	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result explore].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 11:25'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 12/27/2009 03:12'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "		self terminateAndInitializeAround: [ | result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:52'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 5/22/2007 11:28'!tallyIt	^ self tallySelection! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ul 2/1/2010 01:41'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt valueAsString v |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [ | cm |		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: #() ].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!ParagraphEditor methodsFor: 'scrolling'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'scrolling'!markerDelta	^marker top - scrollBar top - ((paragraph clippingRectangle top -		paragraph compositionRectangle top) asFloat /			(self scrollRectangleHeight max: 1) asFloat *				scrollBar height asFloat) rounded! !!ParagraphEditor methodsFor: 'scrolling'!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar top! !!ParagraphEditor methodsFor: 'scrolling'!scrollBar	^ scrollBar! !!ParagraphEditor methodsFor: 'scrolling' stamp: 'BG 12/12/2003 15:31'!scrollBy: heightToMove	"Move the paragraph by heightToMove, and reset the text selection."	^ paragraph scrollBy: heightToMove withSelectionFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'scrolling'!scrollRectangleHeight	^paragraph compositionRectangle height 		+ paragraph lineGrid! !!ParagraphEditor methodsFor: 'scrolling'!scrollToBottom	"Scroll so that the tail end of the text is visible in the view.  5/6/96 sw"	self scrollView: (paragraph clippingRectangle bottom 		- paragraph compositionRectangle bottom)! !!ParagraphEditor methodsFor: 'scrolling'!scrollToTop	"Scroll so that the paragraph is at the top of the view."	self scrollView: (paragraph clippingRectangle top 		- paragraph compositionRectangle top)! !!ParagraphEditor methodsFor: 'scrolling'!scrollView: anInteger 	"Paragraph scrolling uses opposite polarity"	^ self scrollBy: anInteger negated! !!ParagraphEditor methodsFor: 'scrolling'!updateMarker	"A variation of computeMarkerRegion--only redisplay the marker in the scrollbar if an actual change has occurred in the positioning of the paragraph."	self moveMarkerTo: self computeMarkerRegion! !!ParagraphEditor methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	^paragraph clippingRectangle top 		- paragraph compositionRectangle top 		- ((marker top - scrollBar inside top) asFloat 				/ scrollBar inside height asFloat * self scrollRectangleHeight asFloat)			roundTo: paragraph lineGrid! !!ParagraphEditor methodsFor: 'controlling'!controlInitialize	super controlInitialize.	self recomputeInterval.	self initializeSelection.	beginTypeInBlock := nil! !!ParagraphEditor methodsFor: 'controlling'!controlTerminate	self closeTypeIn.  "Must call to establish UndoInterval"	super controlTerminate.	self deselect! !!ParagraphEditor methodsFor: 'controlling' stamp: 'sma 3/11/2000 15:17'!normalActivity	self processKeyboard.	self processMouseButtons! !!ParagraphEditor methodsFor: 'current selection'!deselect	"If the text selection is visible on the screen, reverse its highlight."	selectionShowing ifTrue: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection'!initializeSelection	"Do the initial activity when starting up the receiver. For example, in the 	ParagraphEditor highlight the current selection."	self select! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/20/2002 11:41'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self computeIntervalFrom: self mark to: self pointIndex - 1! !!ParagraphEditor methodsFor: 'current selection'!recomputeSelection	"Redetermine the selection according to the start and stop block indices; 	do not highlight."	self deselect; recomputeInterval! !!ParagraphEditor methodsFor: 'current selection' stamp: 'BG 12/12/2003 12:50'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing := selectionShowing not.	paragraph reverseFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'current selection'!select	"If the text selection is visible on the screen, highlight it."	selectionShowing ifFalse: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:47'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle endBlock |	self select.	endBlock := self stopBlock.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := endBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY := endBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:48'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := self stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'displaying'!display	"Redisplay the paragraph."	| selectionState |	selectionState := selectionShowing.	self deselect.	paragraph foregroundColor: view foregroundColor			backgroundColor: view backgroundColor;			displayOn: Display.	selectionState ifTrue: [self select]! !!ParagraphEditor methodsFor: 'displaying'!flash	"Causes the view of the paragraph to complement twice in succession."	paragraph flash! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/26/2003 22:02'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list := self systemNavigation allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply := ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply := ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'SystemNavigation new browseAllImplementorsOf: #' , symbol! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 11/16/2009 16:14'!explainChar: string	"Does string start with a special character?"	| char |	char := string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	char = Character lf ifTrue: [^'"the line feed Character"'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'ar 3/5/2010 20:42'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class := model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class := class soleInstance].	classes := (Array with: class)				, class allSuperclasses.	"class variables"	reply := classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply := pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes := WriteStream on: Array new.			self systemNavigation				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk globals keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk globals keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'sw 5/3/1998 14:32'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply := '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply := '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply := '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply := '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes := cls withAllSubclasses.			classes size > 12				ifTrue: [text := cls printString , ' or a subclass']				ifFalse: 					[classes := classes printString.					text := 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply := '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply := '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/29/2003 20:07'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply := Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes := Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes := classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/12/2004 16:22'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes := (Array with: cls)				, cls allSuperclasses.	classes := classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes := classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	classes := self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!ParagraphEditor methodsFor: 'explain' stamp: 'apb 1/5/2000 16:56'!explainNumber: string 	"Is string a Number?"	| strm c |	(c := string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm := ReadStream on: string.	c := Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits := Array with: msg.	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply := ', which is the selector of this very method!!'.			s := '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply := '.'.			s := '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes := self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 11/16/2009 17:09'!explainScan: string 	"Remove beginning and trailing separators (space, tab, cr,...)"	^string withBlanksTrimmed! !!ParagraphEditor methodsFor: 'explain' stamp: 'eem 8/15/2010 09:08'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode node |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	node := methodNode encoder lookupVariable: string ifAbsent: [^nil].	^node isTemp ifTrue:		[(node isArg			ifTrue: ['"is an argument to this ']			ifFalse: ['"is a temporary variable in this ']),		   (node isDeclaredAtMethodLevel			ifTrue: ['method"']			ifFalse: ['block"'])]! !!ParagraphEditor methodsFor: 'accessing' stamp: 'tk 4/21/1998 09:55'!initialText	^ initialText! !!ParagraphEditor methodsFor: 'accessing'!replace: oldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval := self selectionInterval.	undoInterval = oldInterval ifFalse: [self selectInterval: oldInterval].	UndoSelection := self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval := self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!ParagraphEditor methodsFor: 'accessing'!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection := self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!ParagraphEditor methodsFor: 'accessing'!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText := ChangeText := aString asText]! !!ParagraphEditor methodsFor: 'accessing'!text	"Answer the text of the paragraph being edited."	^paragraph text! !!ParagraphEditor methodsFor: 'accessing' stamp: 'jm 3/18/98 20:38'!userHasEdited	"Note that the user has edited my text. Here it is just a noop so that the Character Recognizer won't fail when used with a vanilla ParagrahEditor."! !!ParagraphEditor methodsFor: 'undo support'!isDoing	"Call from a doer/undoer/redoer any time to see which it is."	^(self isUndoing | self isRedoing) not! !!ParagraphEditor methodsFor: 'undo support'!isRedoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #redoing! !!ParagraphEditor methodsFor: 'undo support'!isUndoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #undoing! !!ParagraphEditor methodsFor: 'undo support'!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage := Message selector: #noUndoer! !!ParagraphEditor methodsFor: 'undo support'!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph := paragraph].	UndoMessage := aMessage.	Undone := aBoolean! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector	"See comment in undoMessage:.  Use this version when aSelector has no arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1	"See comment in undoMessage:.  Use this version when aSelector has one argument, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector argument: arg1) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2	"See comment in undoMessage:.  Use this version when aSelector has two arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2)) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2 with: arg3	"See comment in undoMessage:.  Use this version when aSelector has three arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2 with: arg3)) forRedo: false! !!ParagraphEditor methodsFor: 'sensor access'!processBlueButton	"The user pressed the blue button on the mouse. Determine what action 	to take."	^self! !!ParagraphEditor methodsFor: 'sensor access'!processKeyboard	"Determine whether the user pressed the keyboard. If so, read the keys."	sensor keyboardPressed ifTrue: [self readKeyboard]! !!ParagraphEditor methodsFor: 'sensor access'!processMouseButtons	"Determine whether the user pressed any mouse button. For each possible 	button, determine what actions to take."	sensor redButtonPressed ifTrue: [self processRedButton].	sensor yellowButtonPressed ifTrue: [self processYellowButton].	sensor blueButtonPressed ifTrue: [self processBlueButton]! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'th 9/19/2002 18:24'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	|  selectionBlocks clickPoint oldDelta oldInterval previousMarkBlock previousPointBlock |	clickPoint := sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval := self selectionInterval.	previousMarkBlock := self markBlock.	previousPointBlock := self pointBlock.	oldDelta := paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks := paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks := paragraph extendSelectionMark: self markBlock pointBlock: self pointBlock.			self closeTypeIn].	selectionShowing := true.	self markBlock: (selectionBlocks at: 1).	self pointBlock: (selectionBlocks at: 2).	(self hasCaret		and: [previousMarkBlock = self markBlock and: [previousPointBlock = self pointBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval := oldInterval]! !!ParagraphEditor methodsFor: 'sensor access'!processYellowButton	"User pressed the yellow button on the mouse. Determine what actions to 	take."	self yellowButtonActivity! !!ParagraphEditor methodsFor: 'undoers' stamp: 'nice 12/27/2009 03:12'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize := (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText := self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i | | index subject |		index := indices at: i.		(subject := index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoAndReselect: undoHighlight redoAndReselect: redoHighlight	"Undo typing, cancel, paste, and other operations that are like replaces	 but the selection is not the whole restored text after undo, redo, or both.	 undoHighlight is selected after this phase and redoHighlight after the next phase.	Redoer: itself."	self replace: self selectionInterval with: UndoSelection and:		[self selectInterval: undoHighlight].	self undoMessage: (UndoMessage argument: redoHighlight) forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut := self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!ParagraphEditor methodsFor: 'undoers' stamp: 'th 9/19/2002 18:46'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!ParagraphEditor methodsFor: 'undoers'!undoReplace	"Undo of any command that replaced a selection by other text that it left	 highlighted, and that is undone and redone by simple reversal of the	 operation.  This is the most common Undoer; call replaceSelectionWith:	 to get this setup.  Redoer: itself, so never isRedoing."	self replaceSelectionWith: UndoSelection! !!ParagraphEditor methodsFor: '*Tools' stamp: 'sd 11/20/2005 21:26'!browseChangeSetsWithSelector	"Determine which, if any, change sets have at least one change for the selected selector, independent of class"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ChangeSorter browseChangeSetsWithSelector: aSelector]! !!ParagraphEditor methodsFor: '*Tools' stamp: 'nice 12/26/2009 19:10'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol b |	(((b := model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol := self selectedSymbol) ifNil: [^ view flash].	self terminateAndInitializeAround:		[| foundClass |		foundClass := (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass ifNil: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: '*Tools' stamp: 'eem 3/31/2009 10:01'!debug: aCompiledMethod receiver: anObject in: evalContext	| guineaPig debugger |	guineaPig := [anObject					withArgs: (evalContext ifNil: [#()] ifNotNil: [{evalContext}])					executeMethod: aCompiledMethod] newProcess.	(debugger := Debugger new)		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: guineaPig suspendedContext		isolationHead: nil.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod] whileFalse:		[debugger send].	debugger toggleContextStackIndex: 1;  toggleContextStackIndex: 1! !!ParagraphEditor methodsFor: '*Tools' stamp: 'sd 11/20/2005 21:26'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[FakeClassPool adopt: model selectedClass.			receiver := model doItReceiver.			context := model doItContext]		ifFalse:			[receiver := context := nil].	self lineSelectAndEmptyCheck: [^self].	method := self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].	FakeClassPool adopt: nil! !!ParagraphEditor commentStamp: '<historical>' prior: 0!I am a Controller for editing a Paragraph. I am a kind of ScrollController, so that more text can be created for the Paragraph than can be viewed on the screen. Editing messages are sent by issuing commands from a yellow button menu or from keys on the keyboard. My instances keep control as long as the cursor is within the view when the red or yellow mouse button is pressed; they give up control if the blue button is pressed.!!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 5/27/2000 00:03'!abandonChangeText	"Call this to get out of the maddening situation in which the system keeps aggressively trying to do a replacement that you no longer wish to make, every time you make choose a new method in a list."	ChangeText := FindText	"ParagraphEditor abandonChangeText"! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 10/1/2004 11:00'!initialize	"Initialize the keyboard shortcut maps and the shared buffers 	for copying text across views and managing again and undo. 	Marked this method changed to trigger reinit"	"ParagraphEditor initialize"	UndoSelection := FindText := ChangeText := Text new.	UndoMessage := Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ar 10/5/2009 23:20'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ SelectionMenu fromArray: StringHolder shiftedYellowButtonMenuItems! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ar 10/5/2009 23:18'!yellowButtonExpertMenu	^ SelectionMenu fromArray: StringHolder yellowButtonMenuItems.! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 10/1/2004 10:59'!yellowButtonMenu	^ Preferences noviceMode			ifTrue: [self yellowButtonNoviceMenu]			ifFalse: [self yellowButtonExpertMenu]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 11/25/2004 17:33'!yellowButtonNoviceMenu	^ MenuMorph fromArray: {			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.		}.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 4/4/2006 16:04'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.			"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.		"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.			"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.			"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.			"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"	'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].	'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	"triplet = {character. comment selector. novice appropiated}"	#(		($a		#selectAll:				true)		($b		#browseIt:				false)		($c		#copySelection:			true)		($d		#doIt:						false)		($e		#exchange:				true)		($f		#find:						true)		($g		#findAgain:				true)		($h		#setSearchString:		true)		($i		#inspectIt:				false)		($j		#doAgainOnce:			true)		($k		#offerFontMenu:		true)		($l		#cancel:					true)		($m	#implementorsOfIt:		false)		($n		#sendersOfIt:			false)		($o		#spawnIt:				false)		($p		#printIt:					false)		($q		#querySymbol:			false)		($s		#save:					true)		($t		#tempCommand:		false)		($u		#align:					true)		($v		#paste:					true)		($w	#backWord:				true)		($x		#cut:						true)		($y		#swapChars:				true)		($z		#undo:					true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet | cmdMap at: triplet first asciiValue + 1 put: triplet second].	CmdActions := cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 10/4/2004 13:53'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap |	"shift-command and control shortcuts"	cmdMap := Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.				"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.				"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.				"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.				"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	"triplet = {character. comment selector. novice appropiated}"	#(		($a		argAdvance:						false)		($b		browseItHere:					false)		($c		compareToClipboard:			false)		($d		duplicate:							true)		($e		methodStringsContainingIt:	false)		($f		displayIfFalse:					false)		($g		fileItIn:							false)		($h		cursorTopHome:					true)		($i		exploreIt:							false)		($j		doAgainMany:					true)		($k		changeStyle:						true)		($l		outdent:							true)		($m	selectCurrentTypeIn:			true)		($n		referencesToIt:					false)		($p		makeProjectLink:				true)		($r		indent:							true)		($s		search:							true)		($t		displayIfTrue:					false)		($u		changeLfToCr:					false)		($v		pasteInitials:						false)		($w	methodNamesContainingIt:	false)		($x		makeLowercase:					true)		($y		makeUppercase:					true)		($z		makeCapitalized:				true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet |			cmdMap at: (triplet first asciiValue         + 1) put: triplet second.		"plain keys"			cmdMap at: (triplet first asciiValue - 32 + 1) put: triplet second.		"shifted keys"			cmdMap at: (triplet first asciiValue - 96 + 1) put: triplet second.		"ctrl keys"		].	ShiftCmdActions := cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sps 7/24/2003 17:25'!multiRedoOverride"Call this to set meta-r to perform the multilevel redo (or tweak the code below to have it bound to some other key sequence).""ParagraphEditor multiRedoOverride."	CmdActions at: $r asciiValue + 1 put: #multiRedo: ! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sbw 10/8/1999 21:42'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParagraphEditor class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 14:10'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'instance creation'!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:37'!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:39'!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:52'!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:53'!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:57'!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!ParseNode methodsFor: 'testing' stamp: 'di 4/5/2000 11:14'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"See comment in MessageNode."	^false! !!ParseNode methodsFor: 'testing' stamp: 'eem 8/31/2010 11:34'!isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.	 Assumes that aSubtree is in fact a subnode of aParseTree."	| isSubnode |	isSubnode := false.	aSubtree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).	isSubnode ifFalse:		[^false].	aParseTree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [^false]]							select: [:node| node ~= aSubtree]).	^true! !!ParseNode methodsFor: 'testing' stamp: 'di 10/12/1999 15:28'!isUndefTemp	^ false! !!ParseNode methodsFor: 'testing' stamp: 'di 10/12/1999 15:28'!isUnusedTemp	^ false! !!ParseNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableReference	^false! !!ParseNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!nowHasDef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNodeEnumerator methodsFor: 'initialize-release' stamp: 'eem 8/31/2010 11:24'!ofBlock: aBlock select: aSelectBlock	theBlock := aBlock.	theSelectBlock := aSelectBlock! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitAssignmentNode: anAssignmentNode	(theSelectBlock isNil or: [theSelectBlock value: anAssignmentNode]) ifFalse:		[^nil].	theBlock value: anAssignmentNode.	^super visitAssignmentNode: anAssignmentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitBlockNode: aBlockNode	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:		[^nil].	theBlock value: aBlockNode.	^super visitBlockNode: aBlockNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitBraceNode: aBraceNode	(theSelectBlock isNil or: [theSelectBlock value: aBraceNode]) ifFalse:		[^nil].	theBlock value: aBraceNode.	^super visitBraceNode: aBraceNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitCascadeNode: aCascadeNode	(theSelectBlock isNil or: [theSelectBlock value: aCascadeNode]) ifFalse:		[^nil].	theBlock value: aCascadeNode.	^super visitCascadeNode: aCascadeNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitCommentNode: aCommentNode	(theSelectBlock isNil or: [theSelectBlock value: aCommentNode]) ifFalse:		[^nil].	theBlock value: aCommentNode.	^super visitCommentNode: aCommentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitFieldNode: aFieldNode	(theSelectBlock isNil or: [theSelectBlock value: aFieldNode]) ifFalse:		[^nil].	theBlock value: aFieldNode.	^super visitFieldNode: aFieldNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitFutureNode: aFutureNode	(theSelectBlock isNil or: [theSelectBlock value: aFutureNode]) ifFalse:		[^nil].	theBlock value: aFutureNode.	^super visitFutureNode: aFutureNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitInstanceVariableNode: anInstanceVariableNode	(theSelectBlock isNil or: [theSelectBlock value: anInstanceVariableNode]) ifFalse:		[^nil].	theBlock value: anInstanceVariableNode.	^super visitInstanceVariableNode: anInstanceVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitLiteralNode: aLiteralNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralNode]) ifFalse:		[^nil].	theBlock value: aLiteralNode.	^super visitLiteralNode: aLiteralNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitLiteralVariableNode: aLiteralVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralVariableNode]) ifFalse:		[^nil].	theBlock value: aLiteralVariableNode.	^super visitLiteralVariableNode: aLiteralVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMessageNode: aMessageNode	(theSelectBlock isNil or: [theSelectBlock value: aMessageNode]) ifFalse:		[^nil].	theBlock value: aMessageNode.	^super visitMessageNode: aMessageNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMessageNodeInCascade: aMessageNodeInCascade	(theSelectBlock isNil or: [theSelectBlock value: aMessageNodeInCascade]) ifFalse:		[^nil].	theBlock value: aMessageNodeInCascade.	^super visitMessageNodeInCascade: aMessageNodeInCascade! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMethodNode: aMethodNode	(theSelectBlock isNil or: [theSelectBlock value: aMethodNode]) ifFalse:		[^nil].	theBlock value: aMethodNode.	^super visitMethodNode: aMethodNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitNewArrayNode: aNewArrayNode	(theSelectBlock isNil or: [theSelectBlock value: aNewArrayNode]) ifFalse:		[^nil].	theBlock value: aNewArrayNode.	^super visitNewArrayNode: aNewArrayNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitRemoteTempVectorNode: aRemoteTempVectorNode	(theSelectBlock isNil or: [theSelectBlock value: aRemoteTempVectorNode]) ifFalse:		[^nil].	theBlock value: aRemoteTempVectorNode.	^super visitRemoteTempVectorNode: aRemoteTempVectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitReturnNode: aReturnNode	(theSelectBlock isNil or: [theSelectBlock value: aReturnNode]) ifFalse:		[^nil].	theBlock value: aReturnNode.	^super visitReturnNode: aReturnNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitSelectorNode: aSelectorNode	(theSelectBlock isNil or: [theSelectBlock value: aSelectorNode]) ifFalse:		[^nil].	theBlock value: aSelectorNode.	^super visitSelectorNode: aSelectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitTempVariableNode: aTempVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aTempVariableNode]) ifFalse:		[^nil].	theBlock value: aTempVariableNode.	^super visitTempVariableNode: aTempVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitVariableNode: aVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aVariableNode]) ifFalse:		[^nil].	theBlock value: aVariableNode.	^super visitVariableNode: aVariableNode! !!ParseNodeEnumerator commentStamp: 'eem 8/31/2010 11:41' prior: 0!ParseNodeEnumerator implements ParseNode>>nodesDo:.  It can be used to enumerate an entire tree via	aParseNode accept: (ParseNodeEnumerator ofBlock: aBlock)or selectively, excluding the node and subnodes for which selectBlock answers false, via	aParseNode accept: (ParseNodeEnumerator							ofBlock: aBlock							select: selectBlock)Here's a doIt that generates and compiles the visiting methods:self superclass selectors do:	[:s|	self compile: (String streamContents:		[:str| | arg |		arg := 'a', (s allButFirst: 5) allButLast.		str nextPutAll: s, ' ', arg; crtab;			nextPutAll: '(theSelectBlock isNil or: [theSelectBlock value: '; nextPutAll: arg; nextPutAll: ']) ifFalse:'; crtab;			tab: 2; nextPutAll: '[^nil].'; crtab;			nextPutAll: 'theBlock value: '; nextPutAll: arg; nextPut: $.; crtab;			nextPutAll: '^super '; nextPutAll: s, ' ', arg])]!!ParseNodeEnumerator class methodsFor: 'instance creation' stamp: 'eem 8/31/2010 11:43'!ofBlock: aBlock select: selectBlock	^self new ofBlock: aBlock select: selectBlock! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 20:08'!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode! !!Parser methodsFor: 'error correction' stamp: 'jcg 6/23/2010 11:46'!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding := requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Parser methodsFor: 'error correction' stamp: 'eem 7/6/2010 15:07'!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	Smalltalk logChange: class definition.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 5/6/2010 21:14'!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	Smalltalk logChange: encoder classEncoding definition.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:35'!declareTemp: name at: levelTag	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^(encoder bindUndeclaredTemp: name)		tag: levelTag;		yourself! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 19:34'!declareTempAndPaste: name	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^encoder bindUndeclaredTemp: name! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:37'!declareUndeclaredTemps: methodNode	"Declare any undeclared temps, declaring them at the smallest enclosing scope."	| undeclared userSelection blocksToVars |	(undeclared := encoder undeclaredTemps) isEmpty ifTrue:		[^self].	userSelection := requestor selectionInterval.	blocksToVars := IdentityDictionary new.	undeclared do:		[:var|		(blocksToVars			at: (var tag == #method					ifTrue: [methodNode block]					ifFalse: [methodNode accept: (VariableScopeFinder new ofVariable: var)])			ifAbsentPut: [SortedCollection new]) add: var name].	(blocksToVars removeKey: methodNode block ifAbsent: []) ifNotNil:		[:rootVars|		rootVars do: [:varName| self pasteTempAtMethodLevel: varName]].	(blocksToVars keys sorted: [:a :b| a tempsMark < b tempsMark]) do:		[:block| | decl |		decl := (blocksToVars at: block) reduce: [:a :b| a, ' ', b].		block temporaries isEmpty			ifTrue:				[self substituteWord: ' | ', decl, ' |'					wordInterval: (block tempsMark + 1 to: block tempsMark)					offset: requestorOffset]			ifFalse:				[self substituteWord: decl, ' '					wordInterval: (block tempsMark to: block tempsMark - 1)					offset: requestorOffset]].	requestor selectInvisiblyFrom: userSelection first to: userSelection last + requestorOffset.	ReparseAfterSourceEditing signal! !!Parser methodsFor: 'error correction' stamp: 'eem 8/13/2010 19:34'!pasteTempAtMethodLevel: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!Parser methodsFor: 'error correction' stamp: 'eem 8/15/2010 08:56'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str madeChanges | 	madeChanges := false.	str := requestor text asString.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp | | start end |		(UnusedVariable name: temp) ifTrue:			[(encoder lookupVariable: temp ifAbsent: []) isUndefTemp				ifTrue:					[end := tempsMark.					["Beginning at right temp marker..."					start := end - temp size + 1.					end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]						whileFalse:							["Search left for the unused temp"							end := requestor nextTokenFrom: end direction: -1].					end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start := start-1].						requestor correctFrom: start to: end with: ''.						str := str copyReplaceFrom: start to: end with: ''. 						madeChanges := true.						tempsMark := tempsMark - (end-start+1)]]				ifFalse:					[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 10:32'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presumed interactive) receiver.	 Update requestorOffset based on the delta size and answer the updated offset."	requestor correctFrom: spot first + o to: spot last + o with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^o + correctWord size - spot size! !!Parser methodsFor: 'expression types' stamp: 'ar 2/6/2004 21:06'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	(hereType == #word and: [tokenType == #leftBracket])		ifTrue:[^self matrixExpression: false].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types' stamp: 'ar 2/6/2004 21:06'!matrixExpression: primary	"primaryExpression [ ... ] -> index node"	| start rcvrNode selector args msgStart msgStop |	self primaryExpression ifFalse:[^false].	(hereType == #leftBracket) ifFalse:[^primary].	start := self startOfNextToken.	rcvrNode := parseNode.	selector := WriteStream on: (String new: 32).	args := OrderedCollection new.	[	self advance.		parseNode := nil.		self primaryExpression ifFalse:[^self expected:'expression'].		args size = 0 			ifTrue:[selector nextPutAll:'matrixAt:']			ifFalse:[selector nextPutAll:'at:'].		args add: parseNode.	here == #, ] whileTrue.	(self match: #rightBracket) ifFalse:[^self expected:']'].	msgStart := start.	msgStop := self endOfLastToken.	(primary not and:[hereType == #leftArrow]) ifTrue:[		selector nextPutAll:'put:'.		start := self startOfNextToken.		self advance.		self expression ifFalse: [^self expected: 'Expression'].		(parseNode isKindOf: BlockNode) ifFalse:[			parseNode := BlockNode new						arguments: #()						statements: (OrderedCollection with: parseNode)						returns: false						from: encoder.		].		args add: parseNode].	parseNode := MessageNode new				receiver: rcvrNode				selector: selector contents asSymbol				arguments: args				precedence: 1				from: encoder				sourceRange: (msgStart to: msgStop).	primary ifTrue:[^true].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 16:48'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps].	^methodNode! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 15:57'!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[aBlockNode tempsMark: prevMark + requestorOffset.		 ^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	(self match: #verticalBar) ifFalse:		[^self expected: 'Vertical bar'].	aBlockNode tempsMark: prevMark + requestorOffset.	^variables! !!Parser methodsFor: 'expression types' stamp: 'ar 2/7/2004 16:38'!variable	| varName varStart varEnd result |	varStart := self startOfNextToken + requestorOffset.	varName := self advance.	varEnd := self endOfLastToken + requestorOffset.	[result := encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [nil].	result ifNil:[		result := (UndeclaredVariableReference new)				parser: self;				varName: varName;				varStart: varStart;				varEnd: varEnd;				signal	].	result isString] whileTrue:[varName := result].	^result! !!Parser methodsFor: 'primitives' stamp: 'eem 10/28/2009 17:09'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType modifier retType externalName args argType module fn |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	[modifier := descriptorClass callingConventionModifierFor: token.	 modifier notNil] whileTrue:		[self advance.		 callType := callType bitOr: modifier].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken: #')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	(self matchToken: 'error:')		ifTrue:			[| errorCodeVariable |			 errorCodeVariable := here.			(hereType == #string			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].			 self advance.			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]		ifFalse:			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].	^true! !!Parser methodsFor: 'public access' stamp: 'eem 8/16/2010 18:08'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p subSelection |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 subSelection := req notNil and: [req selectionInterval = (p + 1 to: p + s size)].	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := subSelection							ifTrue:								[ReadStream									on: requestor text string									from: requestor selectionInterval first									to: requestor selectionInterval last]							ifFalse:								[ReadStream on: requestor text string]].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!Parser methodsFor: 'properties' stamp: 'eem 8/14/2010 10:30'!correctProperty: proposedName interval: spot	"Correct the proposedName to a known type.	Spot is the interval within the test stream of the variable."	| alternatives choice userSelection |	"If we can't ask the user for correction, make it undefined"	self interactive ifFalse:		[Transcript cr; show: 'Property value ', proposedName, ' is undefined (ignored).'.		^nil].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives := encoder possibleNamesFor: proposedName.	choice := UIManager default				chooseFrom: alternatives, {'cancel'}				lines: (Array with: (alternatives size))				title:(('Unknown global: ', proposedName, 'please correct, or cancel:') asText makeBoldFrom: 16 to: 16 + proposedName size).	(choice between: 1 and: alternatives size) ifFalse:		[self fail.		 ^nil].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	"Spelling correction"	self substituteWord: (alternatives at: choice)		wordInterval: spot		offset: requestorOffset.	^(alternatives at: choice)! !!Parser methodsFor: 'properties' stamp: 'ar 2/7/2004 16:39'!eventSignaler	self notify: 'unsupported property'! !!Parser methodsFor: 'properties' stamp: 'ar 2/7/2004 16:39'!eventTrigger	self notify: 'unsupported property'! !!Parser methodsFor: 'positional messages' stamp: 'ar 12/4/2003 18:36'!positionalArgs	"Parse a series of positional arguments, separated by comma."	| args |	(hereType == #rightParenthesis) ifTrue:[self advance. ^#()].	args := WriteStream on: (Array new: 3).	[		self positionalArgsExpression ifFalse:[^self expected: 'argument'].		args nextPut: parseNode.		hereType == #rightParenthesis ifTrue:[self advance. ^args contents].		here == #, ifFalse:[^self expected: 'comma'].		self advance.	] repeat.! !!Parser methodsFor: 'positional messages' stamp: 'ar 12/3/2003 19:09'!positionalArgsExpression	"Just like #expression just keep track of commas"	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(here == #, or:[hereType == #rightParenthesis]) ifTrue:[^true].	^self positionalMessagePart: 3 repeat: true! !!Parser methodsFor: 'positional messages' stamp: 'ar 12/3/2003 19:27'!positionalMessagePart: level repeat: repeat	"Just like #messagePart but keep track of comma"	| start receiver selector args precedence words keywordStart type |	[receiver := parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start := self startOfNextToken.			selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			words := OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart := self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])				ifFalse: [ selector := self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence := 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2 and:[here ~= #,]])				ifTrue: 					[start := self startOfNextToken.					selector := self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args := Array with: parseNode.					precedence := 2]				ifFalse: [(hereType == #word or:[hereType == #positionalMessage])						ifTrue: 							[start := self startOfNextToken.							type := hereType.							selector := self advance.							type == #word ifTrue:[								args := #().							] ifFalse:[								args := self positionalArgs.								selector := selector,'/', args size printString.							].							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])								ifFalse: [ selector := self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence := 1]						ifFalse: [^args notNil]]].	parseNode := MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 6/17/2010 17:28'!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'ar 6/17/2010 14:50'!addStackMenuItems: menu hand: aHandMorph	"Add appropriate stack-related items to the given menu"! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 6/17/2010 15:58'!canvas: x	worldState canvas: x.! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'tak 11/7/2004 18:29'!testCursorWrapped	"self debug: #testCursorWrapped"	| holder |	holder := PasteUpMorph new.	self assert: holder cursor = 1.	holder cursorWrapped: 2.	self assert: holder cursor = 1.	holder addMorph: Morph new;		 addMorph: Morph new;		 addMorph: Morph new.	holder cursorWrapped: 3.	self assert: holder cursor = 3.	holder cursorWrapped: 5.	self assert: holder cursor = 2.	holder cursorWrapped: 0.	self assert: holder cursor = 3.	holder cursorWrapped: -1.	self assert: holder cursor = 2.! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'tak 11/7/2004 18:34'!testCursorWrappedWithFraction	"self debug: #testCursorWrappedWithFraction"	| holder |	holder := PasteUpMorph new.	holder addMorph: Morph new;		 addMorph: Morph new;		 addMorph: Morph new.	holder cursorWrapped: 3.5.	self assert: holder cursor = 3.5.	holder cursorWrapped: 5.5.	self assert: holder cursor = 2.5.	holder cursorWrapped: 0.5.	self assert: holder cursor = 3.5.	holder cursorWrapped: -0.5.	self assert: holder cursor = 2.5.! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'mjr 3/6/2003 11:34'!testGridToGradient	"A trivial test for checking that you can change from a grid to a  	gradient background. A recent [FIX] will make this pass."	| pum |	pum := PasteUpMorph new.	pum setStandardTexture.	"The following should fail without the fix"	self		shouldnt: [pum gradientFillColor: Color red]		raise: MessageNotUnderstood! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'wiz 7/19/2007 10:56'!testPlayWithMe1Romoval	"A trivial test for checking that PlayWithMe classes are all removed"	self deny: ( Smalltalk hasClassNamed: 'PlayWithMe1' ) .! !!PasteUpMorphTest commentStamp: '<historical>' prior: 0!I am a TestCase for PasteUpMorph.!!Path methodsFor: 'adding' stamp: 'nice 3/20/2010 08:02'!add: aPoint 	"Include aPoint as one of the receiver's elements."	^collectionOfPoints add: aPoint! !!Path methodsFor: 'accessing'!at: index 	"Answer the point on the receiver's path at position index."	^collectionOfPoints at: index! !!Path methodsFor: 'accessing'!at: index put: aPoint 	"Store the argument, aPoint, as the point on the receiver's path at position	index."	^collectionOfPoints at: index put: aPoint! !!Path methodsFor: 'accessing'!first	"Answer the first point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint	"Answer the first point on the receiver's path."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint: aPoint 	"Replace the first element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 1 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!form	"Answer the receiver's form, or, if form is nil, then answer a 1 x 1 black 	form (a black dot)."	| aForm |	form == nil		ifTrue: 			[aForm := Form extent: 1 @ 1.			aForm fillBlack.			^aForm]		ifFalse: 			[^form]! !!Path methodsFor: 'accessing'!form: aForm 	"Make the argument, aForm, be the receiver's form."	form := aForm! !!Path methodsFor: 'accessing'!last	"Answer the last point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints last! !!Path methodsFor: 'accessing'!offset	"There are basically two kinds of display objects in the system: those	that, when asked to transform themselves, create a new object; and those	that side effect themselves by maintaining a record of the transformation	request (typically an offset). Path, like Rectangle and Point, is a display	object of the first kind."	self shouldNotImplement! !!Path methodsFor: 'accessing'!secondPoint	"Answer the second element of the receiver."	^collectionOfPoints at: 2! !!Path methodsFor: 'accessing'!secondPoint: aPoint 	"Replace the second element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 2 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!size	"Answer the length of the receiver."	^collectionOfPoints size! !!Path methodsFor: 'accessing'!thirdPoint	"Answer the third element of the receiver."	^collectionOfPoints at: 3! !!Path methodsFor: 'accessing'!thirdPoint: aPoint 	"Replace the third element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 3 put: aPoint.	^aPoint! !!Path methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect the resulting values into a path that is like the receiver. Answer 	the new path."	| newCollection |	newCollection := collectionOfPoints collect: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new path like the receiver only those elements for which 	aBlock evaluates to true. Answer the new path."	| newCollection |	newCollection := collectionOfPoints select: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'display box access' stamp: 'nice 12/27/2009 22:38'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	| box |	box := Rectangle origin: (self at: 1) extent: 0 @ 0.	collectionOfPoints do: 		[:aPoint | box swallow: (Rectangle origin: aPoint extent: 0 @ 0)].	^box! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Display this Path--offset by aPoint, clipped by clipRect and the form 	associated with this Path will be displayedr according to one of the sixteen 	functions of two logical variables (rule). Also the source form will be first 	anded with aForm as a mask. Does not effect the state of the Path"	collectionOfPoints do: 		[:element | 		self form			displayOn: aDisplayMedium			at: element + aDisplayPoint			clippingBox: clipRectangle			rule: ruleInteger			fillColor: aForm]! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Displays this path, translated and scaled by aTransformation. Get the	scaled and translated Path."	| newPath transformedPath |	transformedPath := displayTransformation applyTo: self.	newPath := Path new.	transformedPath do: [:point | newPath add: point].	newPath form: self form.	newPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Path methodsFor: 'private'!initializeCollectionOfPoints	collectionOfPoints := OrderedCollection new! !!Path methodsFor: 'private'!initializeCollectionOfPoints: anInteger	collectionOfPoints := OrderedCollection new: anInteger! !!Path methodsFor: 'testing'!isEmpty	^collectionOfPoints isEmpty! !!Path methodsFor: 'removing' stamp: 'di 4/4/2000 12:33'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element of the receiver.	Remove each element for which aBlock evaluates to true."	collectionOfPoints removeAllSuchThat: aBlock.! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:26'!scaleBy: aPoint 	"Answers a new Path scaled by aPoint. Does not affect the current data in 	this Path."	| newPath | 	newPath := self species new: self size. 	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element scaleBy: aPoint)].	^newPath! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:28'!translateBy: aPoint 	"Answers a new Path whose elements are translated by aPoint. Does not	affect the elements of this Path."	| newPath |	newPath := self species new: self size.	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element translateBy: aPoint)].	^newPath! !!Path commentStamp: '<historical>' prior: 0!I am the abstract superclass of the Graphic spatial primitives. I represent an ordered sequence of Points. Spatial primitives are used to generate "trajectories" such as lines and circles.!!Path class methodsFor: 'examples'!example	"Creates a Path from mousePoints and displays it several ways on the display screen. Messes up the display. For learning about class Path, just select the code below and execute it to create a path and see it redisplayed in another place on the screen. Each path displays using a different form. A path is indicated by pressing the red mouse button in a sequence; press any other mouse button to terminate. "	| aPath aForm pl fl flag |	aForm := Form extent: 2 @ 40.		"creates a form one inch long"	aForm fillBlack.							"turns it black"	aPath := Path new.	aPath form: aForm.						"use the long black form for displaying"	flag := true.	[flag]		whileTrue: 			[Sensor waitButton.			Sensor redButtonPressed				ifTrue: 					[aPath add: Sensor waitButton.					Sensor waitNoButton.					aForm displayOn: Display at: aPath last]				ifFalse: [flag := false]].	Display fillWhite.	aPath displayOn: Display.			"the original path"	pl := aPath translateBy: 0 @ 100.	fl := Form extent: 40 @ 40.	fl fillGray.	pl form: fl.	pl displayOn: Display.				"the translated path"	Sensor waitNoButton	"Path example"! !!Path class methodsFor: 'instance creation'!new	^self basicNew initializeCollectionOfPoints! !!Path class methodsFor: 'instance creation'!new: anInteger	^self basicNew initializeCollectionOfPoints: anInteger! !!PluckedSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #ring declareC: 'short int *ring'>	lastIndex := (startIndex + n) - 1.	scaledThisIndex := scaledNextIndex := scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex := scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex := ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average :=			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample := (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex := scaledNextIndex.		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	scaledIndex := scaledNextIndex.	count := count - n.! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'sma 5/28/2000 16:29'!controlActivity 	shownAsComplemented ifNil: [^ self].	shownAsComplemented = self viewHasCursor		ifFalse:			[view ifNotNil: [view toggleMouseOverFeedback]. 			shownAsComplemented := shownAsComplemented not]! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'acg 3/13/2000 08:26'!isControlActive 	^ sensor anyButtonPressed! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'tk 4/29/1998 10:47'!isControlWanted	"sensor flushKeyboard."	self viewHasCursor & sensor anyButtonPressed ifFalse: [^ false].	view askBeforeChanging		ifTrue: [^ model okToChange]  "ask before changing"		ifFalse: [^ true].! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:49'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback.				 shownAsComplemented := true]! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:44'!controlTerminate 	"Reverse the feedback displayed by controlInitialize, if any. Perform the button action if necessary."	view ifNotNil:		[view triggerOnMouseDown			ifFalse:				[shownAsComplemented ifTrue: [view toggleMouseOverFeedback].				self viewHasCursor ifTrue: [view performAction]]]! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 9/7/1999 08:44'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu := view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self terminateAndInitializeAround: [menu invokeOn: model]].! !!PluggableButtonController commentStamp: '<historical>' prior: 0!The controller for Buttons.  Not meant to be used with buttons that have mouseOver feeback when the button is not pressed.  Use mouseEnter/mouseLeave for that. !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'tfel 4/16/2010 09:34'!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self class roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!PluggableButtonMorph methodsFor: 'initialization' stamp: 'bgf 9/28/2007 21:46'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom.	self hResizing: #shrinkWrap.	"<--so naked buttons work right"	self vResizing: #shrinkWrap.	self wrapCentering: #center;		 cellPositioning: #topCenter.	model := nil.	label := nil.	getStateSelector := nil.	actionSelector := nil.	getLabelSelector := nil.	getMenuSelector := nil.	shortcutCharacter := nil.	askBeforeChanging := false.	triggerOnMouseDown := false.	onColor := self color darker.	offColor := self color.	feedbackColor := Morph buttonFeedbackColor.	showSelectionFeedback := false.	allButtons := nil.	argumentsProvider := nil.	argumentsSelector := nil.	self extent: 20 @ 15! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector := aSymbol! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 18:53'!askBeforeChanging	^ askBeforeChanging! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging := aBoolean.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:38'!label	"Answer the DisplayObject used as this button's label."	^ label! !!PluggableButtonView methodsFor: 'accessing' stamp: 'nk 4/17/2004 19:49'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	((aStringOrDisplayObject isKindOf: Paragraph)	or: [aStringOrDisplayObject isForm])		ifTrue: [label := aStringOrDisplayObject]		ifFalse: [label := aStringOrDisplayObject asParagraph].	self centerLabel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter	"Return the Character to be used as a shortcut to turn on this switch, or nil if this switch doesn't have a keyboard shortcut."	^ shortcutCharacter! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter := aCharacter.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 19:26'!triggerOnMouseDown	^ triggerOnMouseDown! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown := aBoolean.! !!PluggableButtonView methodsFor: 'private' stamp: 'nk 4/17/2004 19:49'!centerAlignLabelWith: aPoint	"Align the center of the label with aPoint."	| alignPt |	alignPt := label boundingBox center.	(label isKindOf: Paragraph) ifTrue: 		[alignPt := alignPt + (0@(label textStyle leading))]. 	(label isForm)	  ifTrue: [label offset: 0 @ 0].	label align: alignPt with: aPoint! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:10'!centerLabel	"If there is a label, align its center with the center of the insetDisplayBox"	label ifNotNil: 		[self centerAlignLabelWith: self insetDisplayBox center].! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'jm 4/4/98 20:50'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	getStateSelector == nil		ifTrue: [^ false]		ifFalse: [^ model perform: getStateSelector].! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:09'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: 		[insetDisplayBox := self computeInsetDisplayBox.		 self centerLabel].	^insetDisplayBox! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:49'!deEmphasizeView 	self getModelState ifTrue: [self displayNormal].! !!PluggableButtonView methodsFor: 'displaying'!display	"Sets the PluggableButtonView mode to 'normal', displays the border, displays the inside and, if its model is 'on', complements the inside."	self displayBorder.	self displayView.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:49'!displayComplemented	"Complement the receiver if it isn't already."	complemented ifFalse: [		complemented := true.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:43'!displayNormal	"Complement the receiver if its mode is 'complemented'."	complemented ifTrue: [		complemented := false.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display				at: label boundingBox topLeft				clippingBox: self insetDisplayBox].	complemented := false.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:41'!emphasizeView 	self getModelState ifTrue: [self displayComplemented].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/5/98 12:54'!toggleMouseOverFeedback	"Complement the label (or a portion of the displayBox if no label is defined) to show that the mouse is over this button. This feedback can be removed by a second call to this method."	Display reverse: self insetDisplayBox fillColor: Color gray.	Display reverse: (self insetDisplayBox insetBy: 2) fillColor: Color gray.! !!PluggableButtonView methodsFor: 'controller access' stamp: 'jm 4/2/98 17:39'!defaultControllerClass 	^ PluggableButtonController! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!defaultWindow	"Return a rectangle large enough to contain this button's label. If this button is label-less, just return the standard View default window."	label == nil		ifTrue: [^ super defaultWindow]		ifFalse: [^ label boundingBox expandBy: 6].! !!PluggableButtonView methodsFor: 'other' stamp: 'sw 2/17/2002 05:32'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."	argumentsSelector		ifNil:			[actionSelector ifNotNil:				[model perform: actionSelector]]		ifNotNil:			[model perform: actionSelector				withArguments:					(Array with: (argumentsProvider perform: argumentsSelector))]! !!PluggableButtonView methodsFor: 'other' stamp: 'tk 4/27/1998 21:23'!update: aParameter 	aParameter == getLabelSelector ifTrue: [		getLabelSelector ifNotNil: [			self label: (model perform: getLabelSelector).			self displayView]].	self getModelState 		ifTrue: [self displayComplemented]		ifFalse: [self displayNormal].! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!window: aWindow	"Center my label when my window changes."	super window: aWindow.	self centerLabel.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'jm 5/2/1998 15:20'!initialize 	super initialize.	label := nil.	getStateSelector := nil.	actionSelector := nil.	getLabelSelector := nil.	getMenuSelector := nil.	shortcutCharacter := nil.	askBeforeChanging := false.	triggerOnMouseDown := false.	complemented := false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'sw 2/17/2002 05:32'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	argumentsSelector := getArgumentsSel.	argumentsProvider := argsProvidor.	getLabelSelector := labelSel.	getMenuSelector := menuSel! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	getLabelSelector := labelSel.	getMenuSelector := menuSel.! !!PluggableButtonView commentStamp: '<historical>' prior: 0!A PluggableButtonView is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the modelEither of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs a pluggable view of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.Options:	askBeforeChanging		have model ask user before allowing change that could lose edits	triggerOnMouseDown	do button action on mouse down (vs. up) transition	shortcutCharacter		a place to record an optional shortcut key!!PluggableButtonView class methodsFor: 'example' stamp: 'jm 4/7/98 19:55'!example	"PluggableButtonView example"	| s1 s2 s3 b1 b2 b3 topView |	s1 := Switch new.	s2 := Switch new turnOn.	s3 := Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 := (PluggableButtonView on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 := (PluggableButtonView on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 := (PluggableButtonView on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1 borderWidth: 1.	b2 borderWidth: 1.	b3 borderWidth: 1.	topView := StandardSystemView new		label: 'Switch Test';		addSubView: b1;		addSubView: b2 toRightOf: b1;		addSubView: b3 toRightOf: b2.	topView controller open.! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: nil		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'sumim 2/15/2002 17:18'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor	^ self new		on: anObject		getState: getStateSel		action: actionSel		getArguments: getArgumentsSel		from: argsProvidor		label: nil		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: menuSel! !!PluggableCodePaneSpec methodsFor: 'building' stamp: 'eem 7/6/2010 11:45'!buildWith: builder	| codePane |	codePane := builder buildPluggableCodePane: self.	initialTextOrNil ifNotNil:		[codePane 			editString: initialTextOrNil;			hasUnacceptedEdits: true].	^codePane! !!PluggableCodePaneSpec methodsFor: 'accessing' stamp: 'eem 7/6/2010 11:43'!initialText	^initialTextOrNil! !!PluggableCodePaneSpec methodsFor: 'accessing' stamp: 'eem 7/6/2010 11:42'!initialText: aText	initialTextOrNil := aText! !!PluggableCodePaneSpec commentStamp: 'ar 8/18/2009 00:02' prior: 0!A PluggableTextSpec specifically intended to edit code. Uses Syntax-Highlighting.!!PluggableFileList methodsFor: 'initialize-release' stamp: 'BG 8/27/2003 22:58'!openAsMorphLabel: aString inWorld: aWorld	"Open a view of an instance of me."	"PluggableFileList new openAsMorphLabel: 'foo' inWorld: World"	| windowMorph volListMorph templateMorph fileListMorph leftButtonMorph middleButtonMorph rightButtonMorph |		self directory: directory.	windowMorph := (SystemWindow labelled: aString) model: self.	volListMorph := PluggableListMorph on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListMorph autoDeselect: false.	windowMorph addMorph: volListMorph frame: (0@0 corner: 0.4@0.5625).	templateMorph := PluggableTextMorph on: self		text: #pattern		accept: #pattern:.	templateMorph askBeforeDiscardingEdits: false.	windowMorph addMorph: templateMorph frame: (0@0.5625 corner: 0.4@0.75).	fileListMorph := PluggableListMorph on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	windowMorph addMorph: fileListMorph frame: (0.4@0 corner: 1.0@0.75).	leftButtonMorph := PluggableButtonMorph 		on: self		getState: #leftButtonState		action: #leftButtonPressed.	leftButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'Cancel';		onColor: Color red offColor: Color red;		feedbackColor: Color orange;		borderWidth: 3.	middleButtonMorph := PluggableButtonMorph		on: self		getState: nil		action: nil.	middleButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: prompt;		onColor: Color lightYellow offColor: Color lightYellow;		feedbackColor: Color lightYellow;		borderWidth: 1.	rightButtonMorph := PluggableButtonMorph		on: self		getState: #rightButtonState		action: #rightButtonPressed.	rightButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'Accept';		onColor: Color green offColor: Color lightYellow;		feedbackColor: Color black;		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]).	"self canAccept ifFalse: [rightButtonMorph controller: NoController new]."	windowMorph		addMorph: leftButtonMorph frame: (0@0.75 corner: 0.25@1.0);		addMorph: middleButtonMorph frame: (0.25@0.75 corner: 0.75@1.0);		addMorph: rightButtonMorph frame: (0.75@0.75 corner: 1.0@1.0).	self changed: #getSelectionSel.    windowMorph openInWorld: aWorld.    [windowMorph model notNil]       whileTrue: [aWorld doOneCycle].    ^self result! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 01:10'!openLabel: aString	"Open a view of an instance of me."	"StandardFileDialog new open"	| topView volListView templateView fileListView fileStringView leftButtonView middleButtonView rightButtonView |		self directory: directory.	topView := (PluggableFileListView new)		model: self.	volListView := PluggableListView on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView := PluggableTextView on: self		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView := PluggableListView on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	"fileStringView := PluggableTextView on: self		text: #fileString		accept: #fileString:.	fileStringView askBeforeDiscardingEdits: false.	fileStringView window: (0@0 extent: 200@15).	topView addSubView: fileStringView below: templateView."	fileStringView := templateView.	leftButtonView := PluggableButtonView 		on: self		getState: nil		action: #leftButtonPressed.	leftButtonView		label: 'Cancel';		backgroundColor: Color red;		borderWidth: 3;		window: (0@0 extent: 50@15).	middleButtonView := PluggableButtonView		on: self		getState: nil		action: nil.	middleButtonView		label: prompt;		window: (0@0 extent: 100@15);		borderWidth: 1;		controller: NoController new.	rightButtonView := PluggableButtonView		on: self		getState: nil		action: #rightButtonPressed.	rightButtonView		label: 'Accept';		backgroundColor: (self canAccept ifTrue: [Color green] ifFalse: [Color lightYellow]);		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]);		window: (0@0 extent: 50@15).	self canAccept ifFalse: [rightButtonView controller: NoController new].	topView acceptButtonView: rightButtonView.	topView		addSubView: leftButtonView below: fileStringView;		addSubView: middleButtonView toRightOf: leftButtonView;		addSubView: rightButtonView toRightOf: middleButtonView.	self changed: #getSelectionSel.	topView doModalDialog.		^self result! !!PluggableFileList methodsFor: '*ST80-Pluggable Views' stamp: 'dtl 2/2/2010 21:13'!mvcOpenLabel: ignored in: aWorld	"Open a view of an instance of me."	"PluggableFileList new open"	| topView volListView templateView fileListView fileStringView leftButtonView middleButtonView rightButtonView |		self directory: directory.	topView := (PluggableFileListView new)		model: self.	volListView := PluggableListView on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView := PluggableTextView on: self		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView := PluggableListView on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	"fileStringView := PluggableTextView on: self		text: #fileString		accept: #fileString:.	fileStringView askBeforeDiscardingEdits: false.	fileStringView window: (0@0 extent: 200@15).	topView addSubView: fileStringView below: templateView."	fileStringView := templateView.	leftButtonView := PluggableButtonView 		on: self		getState: nil		action: #leftButtonPressed.	leftButtonView		label: 'Cancel';		backgroundColor: Color red;		borderWidth: 3;		window: (0@0 extent: 50@15).	middleButtonView := PluggableButtonView		on: self		getState: nil		action: nil.	middleButtonView		label: prompt;		window: (0@0 extent: 100@15);		borderWidth: 1;		controller: NoController new.	rightButtonView := PluggableButtonView		on: self		getState: nil		action: #rightButtonPressed.	rightButtonView		label: 'Accept';		backgroundColor: (self canAccept ifTrue: [Color green] ifFalse: [Color lightYellow]);		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]);		window: (0@0 extent: 50@15).	self canAccept ifFalse: [rightButtonView controller: NoController new].	topView acceptButtonView: rightButtonView.	topView		addSubView: leftButtonView below: fileStringView;		addSubView: middleButtonView toRightOf: leftButtonView;		addSubView: rightButtonView toRightOf: middleButtonView.	self changed: #getSelectionSel.	topView doModalDialog.		^self result! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:57'!acceptButtonView: aView	^acceptButtonView := aView! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/18/2000 20:52'!label: aString	super label: aString.	self noLabel! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:55'!update: aSymbol	(aSymbol = #volumeListIndex or: [aSymbol = #fileListIndex])		ifTrue: [self updateAcceptButton].	^super update: aSymbol! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 09:40'!updateAcceptButton	self model canAccept		ifTrue:			[acceptButtonView				backgroundColor: Color green;				borderWidth: 3;				controller: acceptButtonView defaultController]		ifFalse:			[acceptButtonView				backgroundColor: Color lightYellow;				borderWidth: 1;				controller: NoController new].	acceptButtonView display.! !!PluggableFileListView commentStamp: '<historical>' prior: 0!I provide aview for PluggableFileList!!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'private' stamp: 'sma 3/11/2000 15:38'!processKeyboard	sensor keyboardPressed		ifTrue: [view handleKeystroke: sensor keyboard]		ifFalse: [super processKeyboard]! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect := trueOrFalse! !!PluggableListController methodsFor: 'initialization' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'control defaults' stamp: 'tk 4/1/98 09:40'!redButtonActivity	model okToChange   "Don't change selection if model refuses to unlock"		ifTrue: [^ super redButtonActivity]! !!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tpr 10/4/2001 22:19'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit := true.	scrollFlag := false.	lastSelection := 0.	[sensor redButtonPressed] whileTrue: 		[selection := view findSelection: (pt := sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag := true.				selection := view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag := true.				selection := view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit := false.				turningOn := (view listSelectionAt: selection) not].			view selection: selection.			(view listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				view listSelectionAt: selection put: turningOn].			lastSelection := selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		view listSelectionAt: selection put: (view listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListControllerOfMany methodsFor: 'scrolling' stamp: 'tk 4/8/98 11:09'!scrollView: anInteger 	"Need to minimize the selections which get recomputed"	| oldLimit |	oldLimit := anInteger > 0		ifTrue: [view firstShown]		ifFalse: [view lastShown].	(view scrollBy: anInteger)		ifTrue: [anInteger > 0  "Highlight selections brought into view"					ifTrue: [view highlightFrom: view firstShown								to: (oldLimit-1 min: view lastShown)]					ifFalse: [view highlightFrom: (oldLimit+1 max: view firstShown)								to: view lastShown].				^ true]		ifFalse: [^ false]! !!PluggableListMorph methodsFor: 'initialization' stamp: 'bgf 9/28/2007 16:25'!textHighlightColor	"Answer my default text highlight color."	^self valueOfProperty: #textHighlightColor ifAbsent: [ Morph selectionForeground ].! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:56'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect := trueOrFalse.! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'di 6/20/2001 09:58'!list: arrayOfStrings	"Set the receivers items to be the given list of strings	The instance variable 'items' holds the original list. The instance variable 'list' is a paragraph constructed from this list."	((items == arrayOfStrings) "fastest" or: [items = arrayOfStrings]) ifTrue: [^ self].	items := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do:					[:item | item == nil ifFalse:						[(item isMemberOf: MethodReference)  "A very specific fix for MVC"							ifTrue: [s nextPut: item asStringOrText]							ifFalse: [s nextPut: item]]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'tk 4/12/1998 08:25'!menu: getMenuSel	getMenuSelector := getMenuSel! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector := getMenuTitleSel! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:55'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector := getListSel.	getSelectionSelector := getSelectionSel.	setSelectionSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	| newIndex |	newIndex := anInteger.	(autoDeselect == nil or: [autoDeselect]) ifTrue:		[getSelectionSelector ifNotNil:			[(model perform: getSelectionSelector) = anInteger ifTrue:				["Click on existing selection deselects"				newIndex := 0]]].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: newIndex].! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!getCurrentSelectionIndex	"Answer the index of the current selection."	getSelectionSelector == nil ifTrue: [^ 0].	^ model perform: getSelectionSelector! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst := model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access' stamp: 'tk 4/2/98 13:36'!getListSelector	^ getListSelector! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu := model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu := model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:45'!handleKeystroke: aChar	"Answer the menu for this list view."	| args aSpecialKey |	aSpecialKey := aChar asciiValue.	aSpecialKey < 32 ifTrue: [ self specialKeyPressed: aSpecialKey. ^nil ].	keystrokeActionSelector ifNil: [^ nil].	controller controlTerminate.	(args := keystrokeActionSelector numArgs) = 1		ifTrue: [model perform: keystrokeActionSelector with: aChar.				^ controller controlInitialize].	args = 2		ifTrue: [model perform: keystrokeActionSelector with: aChar with: self.				^ controller controlInitialize].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'sw 10/9/1998 08:24'!setSelectionSelectorIs: aSelector	^ aSelector == setSelectionSelector! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:42'!specialKeyPressed: keyEvent	"Process the up and down arrows in a list pane."     | oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: keyEvent) ifFalse: [ ^ false ].     oldSelection := self getCurrentSelectionIndex.     nextSelection := oldSelection.     max := self maximumSelection.     min := self minimumSelection.     howMany := self numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				"self controller moveMarker"]].		^true			! !!PluggableListView methodsFor: 'controller access' stamp: 'jm 3/11/98 17:17'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating' stamp: 'dtl 2/10/2010 13:01'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].	aSymbol == #startNewBrowser ifTrue:		[(self setSelectionSelectorIs: #classListIndex:) ifTrue: [			"A SelectorBrowser is about to open a new Browser on a class"			self controller controlTerminate]]! !!PluggableListView methodsFor: 'updating' stamp: 'BG 1/22/2004 13:15'!verifyContents	| newItems existingSelection anIndex |	"Called on window reactivation to react to possible structural changes.  Update contents if necessary."	newItems := self getList.	((items == newItems) "fastest" or: [items = newItems]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection := list stringAtLineNumber: (selection + (topDelimiter ifNil: [0] ifNotNil: [1])).  "account for cursed ------ row"	self list: newItems.	(newItems size > 0 and: [newItems first isKindOf: Symbol]) ifTrue:		[existingSelection := existingSelection asSymbol].	(anIndex := newItems indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.]		ifNil:			[self changeModelSelection: 0].	selection := 0. " to display the list without selection "	self displayView.	self update: getSelectionSelector.! !!PluggableListView commentStamp: '<historical>' prior: 0!A pluggable list view gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific, 'yellow-button' menu		keyActionSel	process a keystroke typed in this pane (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!!	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song.	AutoDeselect is a feature, normally set to true, that will tell the model that there is no selection if you click on an item that is currently selected.  If autoDeselect is false, then the model will simply be told to select the same item again.!!PluggableListView class methodsFor: 'instance creation' stamp: 'md 7/13/2005 16:34'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation' stamp: 'md 7/13/2005 16:34'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation' stamp: 'md 7/13/2005 16:33'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:28'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ifNotNil: [		item := (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setSelectionSelector with: item].! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:27'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item := model perform: getSelectionSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'sw 12/9/1999 18:07'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection := 0.	1 to: self maximumSelection do:		[:i | selection := i.		(self listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection := i.		(self listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 20:42'!scrollBy: anInteger	"This is a possible way to intercept what ListOfManyController did to get multiple selections to show.  Feel to replace this."	| ans |	ans := super scrollBy: anInteger."	self displaySelectionBox."	^ ans! !!PluggableListViewOfMany methodsFor: 'controller access' stamp: 'di 5/17/1998 22:48'!defaultControllerClass 	^ PluggableListControllerOfMany! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tpr 10/4/2001 22:17'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[selection := anInteger.			self displaySelectionBox]! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!selection	"Have to override normal controller smarts about deselection"	^ 0! !!PluggableListViewOfMany methodsFor: 'initialization' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListViewOfMany methodsFor: 'updating' stamp: 'tk 4/8/98 13:12'!update: aSymbol 	aSymbol == getListSelector		ifTrue: [self list: self getList.			^ self displayView; emphasizeView].	aSymbol == getSelectionSelector		ifTrue: [^ self displayView; emphasizeView].	aSymbol == #allSelections		ifTrue: [^ self displayView; emphasizeView].	^ super update: aSymbol! !!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListViewOfMany class methodsFor: 'instance creation' stamp: 'tpr 10/8/2001 20:52'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!PluggableSystemWindowWithLabelButton methodsFor: 'resize/collapse' stamp: 'eem 5/6/2008 12:58'!adjustExtraButton	labelButton ifNil: [^self].	labelButton		position: self innerBounds topLeft + (20 @ -3);		extent: self innerBounds extent * (0.4@1)! !!PluggableSystemWindowWithLabelButton methodsFor: 'geometry' stamp: 'eem 5/6/2008 10:45'!extent: newExtent	super extent: newExtent.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton methodsFor: 'events' stamp: 'eem 6/30/2010 16:47'!mouseDown: evt	| wasInactive |	wasInactive := TopWindow ~~ self.	self valueOfProperty: #clickPoint ifPresentDo: 		[:firstClick |		(labelButton containsPoint: evt cursorPoint) ifTrue:			[^labelButton mouseDown: evt]].	super mouseDown: evt.	(wasInactive	 and: [model windowActiveOnFirstClick not	 and: [labelButton containsPoint: evt cursorPoint]]) ifTrue:		[^labelButton mouseDown: evt]! !!PluggableSystemWindowWithLabelButton methodsFor: 'top window' stamp: 'eem 5/6/2008 11:39'!passivate	super passivate.	self removeProperty: #clickPoint! !!PluggableSystemWindowWithLabelButton methodsFor: 'accessing' stamp: 'eem 6/30/2010 18:56'!savedMultiWindowState: aSavedMultiWindowState	labelButton := MultiWindowLabelButtonMorph						on: aSavedMultiWindowState						getState: nil						action: #selectWindowsMenu.	labelButton		triggerOnMouseDown: true;		savedMultiWindowState: aSavedMultiWindowState.	labelButton		layoutFrame: (LayoutFrame "i.e. in the left 40% of the title bar"						fractions: (0@0 corner: 0.4@0)						offsets: (20@ -20 corner: 0@0));		hResizing: #spaceFill;		vResizing: #spaceFill.	self addMorphFront: labelButton.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton commentStamp: 'eem 6/29/2010 19:02' prior: 0!A PluggableSystemWindowWithLabelButton provides the pull-down menu of browser panes in the multi-pane browser.Instance Variables	labelButton:		<BrowserPaneButtonMorph>labelButton	- the labelButton is a hack to hold onto the panes of a multi-paned browser so that an inst var doesn't have to be added to the Browser hierarchy.!!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist	^ artistIndex! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist: anInteger	artistIndex := anInteger.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:14'!artistKeystroke: aCharacter	self artistList doWithIndex: [:artist :i |		(artist first asLowercase = aCharacter asLowercase) ifTrue: [			self artist: i]].! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:21'!artistList	((musicTypeIndex ~= nil) and:	 [musicTypeIndex between: 1 and: artistList size])		ifTrue: [^ artistList at: musicTypeIndex]		ifFalse: [^ #()].! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artistName	"Answer the name of the currently selected artist, or nil if no artist is selected."	| artistsForCurrentType |	artistsForCurrentType := self artistList.	(artistIndex between: 1 and: artistsForCurrentType size)		ifTrue: [^ artistsForCurrentType at: artistIndex]		ifFalse: [^ nil].! !!PluggableTest methodsFor: 'menu commands' stamp: 'jm 5/3/1998 16:00'!earlyCmd	self musicType: (musicTypeList indexOf: 'early').! !!PluggableTest methodsFor: 'menu commands'!flashCmd	Display reverse; reverse.! !!PluggableTest methodsFor: 'menu commands'!grungeCmd	SelectionMenu confirm:		'You mean, like those strange bands from Seattle?'! !!PluggableTest methodsFor: 'menu commands' stamp: 'sw 8/18/1998 12:29'!perform: sel orSendTo: otherObject	(self respondsTo: sel) ifTrue: [self perform: sel] ifFalse: [otherObject perform: sel]! !!PluggableTest methodsFor: 'menu commands' stamp: 'jm 5/3/1998 15:59'!reggaeCmd	self musicType: (musicTypeList indexOf: 'reggae').! !!PluggableTest methodsFor: 'initialization' stamp: 'jm 5/3/1998 16:20'!initialize	musicTypeList := #('reggae' 'classical' 'early').	artistList := #(		('alpha blondy' 'black uhuru' 'bob marley' 'burning spear')		('bach' 'beethoven' 'josquin' 'morley' 'mozart' 'telemann')		('josquin' 'morley' 'telemann')).	musicTypeIndex := 0.	artistIndex := 0.! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType	^ musicTypeIndex! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType: anInteger	| oldArtist |	oldArtist := self artistName.	musicTypeIndex := anInteger.  "this changes artists list"	artistIndex := self artistList indexOf: oldArtist.	self changed: #musicType.	self changed: #artistList.! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/2/1998 15:18'!musicTypeKeystroke: aCharacter	musicTypeList doWithIndex: [:type :i |		(type first asLowercase = aCharacter asLowercase)			ifTrue: [self musicType: i]].! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:11'!musicTypeList	^ musicTypeList! !!PluggableTest methodsFor: 'music type pane' stamp: 'sw 8/18/1998 12:31'!musicTypeListTitle	^ 'Choose a command'! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:00'!musicTypeMenu: aMenu	^ aMenu addList: #(		(reggae reggaeCmd)		(early earlyCmd)		(grunge grungeCmd)		-		(flash flashCmd))! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicTypeName	"Answer the name of the currently selected music type, or nil if no music type is selected."	(musicTypeIndex between: 1 and: musicTypeList size)		ifTrue: [^ musicTypeList at: musicTypeIndex]		ifFalse: [^ nil].! !!PluggableTest commentStamp: '<historical>' prior: 0!This class demonstrates how to use PluggableListViews.!!PluggableTest class methodsFor: 'example' stamp: 'nk 7/30/2004 21:50'!open	"PluggableTest open"	| model listView1 topView listView2 |	model := self new.	listView1 := PluggableListView 				on: model				list: #musicTypeList				selected: #musicType				changeSelected: #musicType:				menu: #musicTypeMenu:				keystroke: #musicTypeKeystroke:.	listView1 menuTitleSelector: #musicTypeListTitle.	listView2 := PluggableListView 				on: model				list: #artistList				selected: #artist				changeSelected: #artist:				menu: nil				keystroke: #artistKeystroke:.	topView := (StandardSystemView new)				label: 'Pluggable Test';				minimumSize: 300 @ 200;				borderWidth: 1;				addSubView: listView1;				addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'dgd 9/21/2003 17:47'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	view hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]]    .! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 20:49'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 20:49'!userHasNotEdited	"Note that my text is free of user edits."	view hasUnacceptedEdits: false! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'sma 3/15/2000 21:39'!bsText	self changeText: (self text copyFrom: 1 to: (self text size - 1 max: 0))! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/13/1998 14:16'!changeText: aText	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self selectAndScroll.	self deselect! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect := paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet := self visibleAreas.	bottomStrip := paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'transcript' stamp: 'th 9/20/2002 11:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY := self stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY := self stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'transcript' stamp: 'nice 12/27/2009 03:59'!visibleAreas	"Transcript dependents last controller visibleAreas"	| myTopController visibleAreas |	myTopController := self view topView controller.	visibleAreas := Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | | remnants rect |		c == myTopController ifTrue: [^ visibleAreas].		rect := c view windowBox.		remnants := OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas := remnants].	^ visibleAreas! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectForTopFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScrollToTop! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:37'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: start to: stop scroll: #selectAndScroll! !!PluggableTextController methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:35'!selectFrom: start to: stop scroll: scrollCommand	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[view superView ifNotNil: [self deselect].		self selectInvisiblyFrom: start to: stop].	view superView ifNotNil: [self perform: scrollCommand]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 6/20/2008 17:29'!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := self acceptTextInModel.	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNilDo:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'eem 8/20/2008 18:20'!doIt	^self handleEdit: [textMorph editor evaluateSelection]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'bgf 7/10/2006 14:17'!setTextStyle: aStyle	"Set the style of my text to the given style"	textMorph setTextStyle: aStyle! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'eem 6/20/2008 18:04'!appendEntry	"Append the text in the model's writeStream to the editable text. "	textMorph asText size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: textMorph asText size - model characterLimit.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: textMorph asText size + 1 to: textMorph asText size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: textMorph asText size + 1 to: textMorph asText size! !!PluggableTextMorph methodsFor: 'updating' stamp: 'test 7/13/2010 10:26'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == getTextSelector 		ifTrue: 			[self setText: self getText.			^self setSelection: self getSelection].	aSymbol == getSelectionSelector 		ifTrue: [^self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector notNil]) 		ifTrue: 			[self handleEdit: 					[(textMorph editor)						abandonChangeText; "no replacement!!"						setSearch: model autoSelectString;						againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #wantToChange 		ifTrue: 			[self canDiscardEdits ifFalse: [^self promptForCancel].			^self].	(aSymbol == #appendEntry and:[self isInWorld])		ifTrue: 			[self handleEdit: [self appendEntry].			^self refreshWorld].	aSymbol == #clearText 		ifTrue: 			[self handleEdit: [self changeText: Text new].			^self refreshWorld].	aSymbol == #bs 		ifTrue: 			[self handleEdit: [self bsText].			^self refreshWorld].	aSymbol == #codeChangedElsewhere 		ifTrue: 			[self hasEditingConflicts: true.			^self changed].	aSymbol == #saveContents		ifTrue:			[^self saveContentsInFile]! !!PluggableTextMorph methodsFor: 'testing' stamp: 'eem 5/2/2008 20:36'!isPluggableTextMorph	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:56'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [self text]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 21:05'!unacceptedEditState: stateOrNil	stateOrNil		ifNotNil:			[self setText: stateOrNil.			 hasUnacceptedEdits := true "setText: clears hasUnacceptedEdits, so must do this post setText:"]		ifNil: [hasUnacceptedEdits := false]! !!PluggableTextView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasEditingConflicts ifNil: [hasEditingConflicts := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:24'!defaultControllerClass 	^ PluggableTextController! !!PluggableTextView methodsFor: 'initialization' stamp: 'sw 10/29/1999 21:02'!initialize 	super initialize.	hasEditingConflicts := false! !!PluggableTextView methodsFor: 'initialization' stamp: 'tk 4/6/98 10:51'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector := getTextSel.	setTextSelector := setTextSel.	getSelectionSelector := getSelectionSel.	getMenuSelector := getMenuSel.	self borderWidth: 1.	self editString: self getText.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:25'!setSelection: sel	controller selectFrom: sel first to: sel last.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'sw 1/16/1999 14:31'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ getSelectionSelector ifNotNil: [model perform: getSelectionSelector]! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 4/1/98 08:32'!getText 	"Answer the list to be displayed."	| txt |	getTextSelector == nil ifTrue: [^ Text new].	txt := model perform: getTextSelector.	txt == nil ifTrue: [^ Text new].	self hasUnacceptedEdits: false.	"clean now"	^ txt! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 3/31/98 15:58'!getTextSelector	"This is sent to the model to find out what text to display"	^ getTextSelector! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 5/3/1998 19:29'!isReadOnlyView	^ setTextSelector == nil! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 3/10/98 13:51'!setText: textToAccept from: ctlr	"Inform the model of text to be accepted, and return true if OK.	Any errors should be reported to the controller, ctlr."	setTextSelector == nil ifTrue: [^ true].	setTextSelector numArgs = 2		ifTrue: [^ model perform: setTextSelector with: textToAccept with: ctlr]		ifFalse: [^ model perform: setTextSelector with: textToAccept]! !!PluggableTextView methodsFor: 'model access' stamp: 'di 4/27/1998 12:46'!updateDisplayContents	self editString: self getText.	self displayView.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:03'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasEditingConflicts: aBoolean	hasEditingConflicts := aBoolean! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	aBoolean ifFalse: [hasEditingConflicts := false]! !!PluggableTextView methodsFor: 'updating' stamp: 'dtl 2/10/2010 17:15'!update: aSymbol	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action. "	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [self promptForCancel].  ^ self].	aSymbol == #flash ifTrue: [^ controller flash].	aSymbol == getTextSelector ifTrue: [^ self updateDisplayContents].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[ParagraphEditor abandonChangeText.	"no replacement!!"			^ controller setSearch: model autoSelectString;					againOrSame: true].	aSymbol == #appendEntry ifTrue:			[^ controller doOccluded: [controller appendEntry]].	aSymbol == #clearText ifTrue:			[^ controller doOccluded:				[controller changeText: Text new]].	aSymbol == #bs ifTrue:			[^ controller doOccluded:				[controller bsText]].	aSymbol == #codeChangedElsewhere ifTrue:			[^ self hasEditingConflicts: true].	aSymbol == #saveContents ifTrue:			[^self controller saveContentsInFile].	aSymbol == #close ifTrue:			[^self topView controller closeAndUnscheduleNoTerminate]! !!PluggableTextView methodsFor: 'updating' stamp: 'ar 1/19/2010 20:28'!update: aSymbol with: arg1	aSymbol == #editString ifTrue:[		self editString: arg1.		^self hasUnacceptedEdits: true.	].	^super update: aSymbol with: arg1! !!PluggableTextView methodsFor: 'testing' stamp: 'dtl 2/10/2010 17:28'!isTextView	"True if the reciever is a view on a text model, such as a view on a TranscriptStream"	^true! !!PluggableTextView methodsFor: 'controller access' stamp: 'BG 11/26/2003 16:06'!selectionInterval  ^self controller selectionInterval! !!PluggableTextView commentStamp: '<historical>' prior: 0!A PluggableTextView gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. See the class comment for PluggableListView.Selectors are:		getTextSel		fetch the original text from the model		setTextSel		submit new text to the model when user "accepts"		getSelectionSel	get the current text selection range		getMenuSel		get the pane-specific, 'yellow-button' menu	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if setTextSel is nil then this view is consider read-only.	The model informs a pluggable view of changes by sending #changed: to itself with getTextSel as a parameter. The view informs the model of selection changes by sending setTextSel to it with the newly selected item as a parameter, and invokes menu actions on the model via getMenuSel.!!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel	^ self on: anObject		text: getTextSel		accept: setTextSel		readSelection: nil		menu: nil! !!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	^ self new on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:12'!isDialog	^isDialog ifNil: [false]! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:43'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !!PluggableWindowSpec commentStamp: '<historical>' prior: 0!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!Point methodsFor: 'transforming' stamp: 'bgf 1/31/2009 11:42'!scaledWithin: aPoint	"Treating the points as rectangle dimensions, 	 return a point scaled to have the same aspect ratio as me,	 but that is in both dimensions <= aPoint.	 Does not enlarge me."	| xFactor yFactor |	aPoint x = 0 ifTrue: [ xFactor := ((x = 0) ifTrue: [ 1] ifFalse: [0]) ]				   ifFalse: [ xFactor := (x / aPoint x asFloat ) ].	aPoint y = 0 ifTrue: [ yFactor :=  ((y = 0) ifTrue: [ 1] ifFalse: [0]) ] 				    ifFalse: [ yFactor := (y / aPoint y asFloat ) ].	^ (self / ((xFactor max: yFactor) max:1)) rounded.! !!PointTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 10:16'!testBearingToPoint	self assert: (0@0 bearingToPoint: 0@0) = 0.	self assert: (0@0 bearingToPoint: 0@-1) = 0.	self assert: (0@0 bearingToPoint: 1@0) = 90.	self assert: (0@0 bearingToPoint: 0@1) = 180.	self assert: (0@0 bearingToPoint: -1@0) = 270.	self assert: (0@0 bearingToPoint: 1@1) = 135.	self assert: (0@0 bearingToPoint: 0.01@0) = 90.	self assert: (0@0 bearingToPoint: -2@-3) = 326.	self assert: (0@0 bearingToPoint: -0@0) = 0.		self assert: (-2@-3 bearingToPoint: 0@0) = 146.! !!PointTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 10:16'!testIsZero	self assert: (0@0) isZero.		self deny:  (0@1) isZero.	self deny:  (1@0) isZero.	self deny:  (1@1) isZero.! !!PointTest methodsFor: 'testing - testing' stamp: 'hk 11/10/2005 10:09'!testTheta      | result dir tan x y |	self assert: ((0@1) theta - 90.0 degreesToRadians) abs < 1e-15.	self assert: ((0@-1) theta - 270.0 degreesToRadians) abs < 1e-15.	" See code of old and new theta"	x := 1.0 . y := -1.0.	tan := y  / x .	dir := tan arcTan.      result :=  360.0 degreesToRadians + dir.      self assert: ((x@y) theta - result) abs < 1e-15.	x := -1.0. "Don't reuse old results whenyou want numeric precision!!"	tan := y  / x .	dir := tan arcTan.      result :=  180.0 degreesToRadians + dir.      self assert: ((x@y) theta - result) abs < 1e-15.	! !!PointTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Point. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!PointerFinder methodsFor: 'application' stamp: 'eem 5/23/2008 11:05'!buildList	| list obj parent object key |	list := OrderedCollection new.	obj := goal.		[list addFirst: obj.	obj := parents at: obj ifAbsent: [].	obj == nil] whileFalse.	list removeFirst.	parent := Smalltalk.	objectList := OrderedCollection new.	pointerList := OrderedCollection new.	[list isEmpty]		whileFalse: 			[object := list removeFirst.			key := nil.			(parent isKindOf: Dictionary)				ifTrue: [list size >= 2						ifTrue: 							[key := parent keyAtValue: list second ifAbsent: [].							key == nil								ifFalse: 									[object := list removeFirst; removeFirst.									pointerList add: key printString , ' -> ' , object class name]]].			key == nil				ifTrue: 					[parent class == object ifTrue: [key := 'CLASS'].					key == nil ifTrue: [1 to: parent class instSize do: [:i | key == nil ifTrue: [(parent instVarAt: i)									== object ifTrue: [key := parent class instVarNameForIndex: i]]]].					key == nil ifTrue: [1 to: parent basicSize do: [:i | key == nil ifTrue: [(parent basicAt: i)									== object ifTrue: [key := i printString]]]].					key == nil ifTrue: [(parent isMorph and: [object isKindOf: Array]) ifTrue: [key := 'submorphs?']].					key == nil ifTrue: [key := '???'].					pointerList add: key , ': ' , object class name].			objectList add: object.			parent := object]! !!PointerFinder methodsFor: 'application' stamp: 'ar 6/27/2007 12:56'!follow: anObject from: parentObject	anObject == goal		ifTrue: 			[parents at: anObject put: parentObject.			^ true].	anObject isLiteral ifTrue: [^ false].	anObject class == CompiledMethod ifFalse:[		anObject class isPointers ifFalse: [^ false].		anObject class isWeak ifTrue: [^ false].	].	(parents includesKey: anObject)		ifTrue: [^ false].	parents at: anObject put: parentObject.	toDoNext add: anObject.	^ false! !!PointerFinder methodsFor: 'application' stamp: 'ar 6/27/2007 12:56'!followObject: anObject	(self follow: anObject class from: anObject)		ifTrue: [^ true].	anObject class == CompiledMethod ifTrue:[		1 to: anObject numLiterals do:[:i|			(self follow: (anObject literalAt: i) from: anObject) ifTrue: [^ true]]].	1 to: anObject class instSize do:		[:i |		(self follow: (anObject instVarAt: i) from: anObject)			ifTrue: [^ true]].	1 to: anObject basicSize do:		[:i |		(self follow: (anObject basicAt: i) from: anObject)			ifTrue: [^ true]].	^ false! !!PolygonMorphTest methodsFor: 'bounds' stamp: 'nice 2/16/2008 02:31'!testBoundsBug1035	"This is a non regression test for http://bugs.squeak.org/view.php?id=1035	PolygonMorph used to position badly when container bounds were growing"		| submorph aMorph |		submorph := (PolygonMorph		vertices: {0@0. 100@0. 0@100}		color: Color red borderWidth: 0 borderColor: Color transparent)			color: Color red.	submorph bounds. "0@0 corner: 100@100"	aMorph := Morph new		color: Color blue;		layoutPolicy: ProportionalLayout new;		addMorph: submorph		fullFrame: (LayoutFrame fractions: (0.1 @ 0.1 corner: 0.9 @ 0.9)).	submorph bounds. "0@0 corner: 100@100 NOT YET UPDATED"	aMorph fullBounds. "0@0 corner: 50@40. CORRECT"	submorph bounds. "5@4 corner: 45@36 NOW UPDATED OK"	aMorph extent: 100@100.	submorph bounds. "5@4 corner: 45@36 NOT YET UPDATED"	aMorph fullBounds. "-10@-14 corner: 100@100 WRONG"	submorph bounds. "-10@-14 corner: 70@66 NOW WRONG POSITION (BUT RIGHT EXTENT)"	self assert: aMorph fullBounds = (0 @ 0 extent: 100@100).	self assert: submorph bounds = (10 @ 10 corner: 90@90).! !!PolygonMorphTest commentStamp: 'nice 2/16/2008 02:13' prior: 0!This class holds tests for PolygonMorph!!PopUpMenu methodsFor: '*ST80-Menus' stamp: 'dtl 1/30/2010 16:14'!mvcStartUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	| saveAlignment |	saveAlignment := PopUpMenu alignment.		PopUpMenu leftFlush.	^[self startUp] ensure:		[PopUpMenu alignment: saveAlignment]! !!PopUpMenu methodsFor: '*ST80-Menus' stamp: 'dtl 1/30/2010 15:56'!mvcStartUpWithCaption: captionOrNil icon: aForm at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: '*ST80-Support'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'eem 3/31/2009 10:03'!fileInSilentlyAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	[self atEnd] whileFalse:		[self skipSeparators.		[val := (self peekFor: $!!) 					ifTrue: [(Compiler evaluate: self nextChunk logged: false) scanFrom: self]					ifFalse: 						[chunk := self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk logged: true]] 				on: InMidstOfFileinNotification				do: [:ex | ex resume: true].		self skipStyleChunk].	self close.	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current  logChange: '----End fileIn of ' , self name , '----'.	^val! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'eem 5/15/2009 14:23'!skipSeparators	| next |	[(next := self next) == nil] whileFalse:		[next isSeparator ifFalse:			[^self position: self position - 1]]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ar 1/14/2006 23:54'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	^(self next: 4) longAt: 1 bigEndian: true! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ar 1/14/2006 23:54'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	^self nextPutAll: ((ByteArray new: 4) longAt: 1 put: int32 bigEndian: true; yourself).! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ar 4/15/2007 21:41'!nextWordsInto: aBitmap 	"Fill the word based buffer from my collection. 	Stored on stream as Big Endian. Optimized for speed. 	Read in BigEndian, then restoreEndianness."	| blt pos source byteSize |	collection class isBytes ifFalse: [		^ self next: aBitmap size into: aBitmap startingAt: 1.	].	byteSize := aBitmap byteSize.	((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0]) ifTrue: [		source := collection.		pos := self position.		self skip: byteSize.	] ifFalse:[		"forced to copy it into a buffer"		source := self next: byteSize.		pos := 0	].	"Now use BitBlt to copy the bytes to the bitmap."	blt := (BitBlt toForm: (Form new hackBits: aBitmap))				sourceForm: (Form new hackBits: source).	blt combinationRule: Form over.	"store"	blt sourceX: 0; sourceY: pos // 4; height: byteSize // 4; width: 4.	blt destX: 0; destY: 0.	blt copyBits.	"And do whatever the bitmap needs to do to convert from big-endian order."	aBitmap restoreEndianness.	"May be WordArray, ColorArray, etc"	^ aBitmap! !!PositionableStream methodsFor: 'testing' stamp: 'bgf 5/23/2008 18:10'!atEnd	"Primitive. Answer whether the receiver can access any more objects.	Optional. See Object documentation whatIsAPrimitive."	"<primitive: 67>  Doesn't pay its way."	^position >= readLimit! !!PragmaPreference methodsFor: '*PreferenceBrowser' stamp: 'bf 3/4/2010 11:45'!selectors	"for browsing senders"	^ {getter. setter}! !!Preference methodsFor: '*PreferenceBrowser' stamp: 'hpt 9/26/2004 16:58'!representativeButtonWithColor: aColor inPanel: aPanel	| view |	view := self viewForPanel: aPanel.	^view ifNotNil: [view representativeButtonWithColor: aColor inPanel: aPanel]! !!Preference methodsFor: '*PreferenceBrowser' stamp: 'bf 3/4/2010 11:46'!selectors	"for browsing senders"	^{name}! !!Preference methodsFor: '*PreferenceBrowser' stamp: 'hpt 9/26/2004 15:42'!viewClassForPanel: aPreferencePanel	^self viewRegistry viewClassFor: aPreferencePanel! !!Preference methodsFor: '*PreferenceBrowser' stamp: 'hpt 9/26/2004 16:58'!viewForPanel: aPreferencePanel	| viewClass |	viewClass := self viewClassForPanel: aPreferencePanel.	^viewClass ifNotNil: [viewClass preference: self]! !!Preference methodsFor: '*PreferenceBrowser' stamp: 'ar 8/9/2009 15:21'!viewRegistry	^PreferenceViewRegistry forType: self type! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'hpt 9/19/2004 02:30'!allCategoryLabel	^'-- all --' translated! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'md 2/28/2006 17:28'!initialExtent	^ 520@440! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'cmm 2/13/2010 20:08'!representsSameBrowseeAs: anotherModel	"If an existing Preference browser is on-screen, use it."	^ self class = anotherModel class! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'hpt 9/19/2004 02:30'!searchResultsCategoryLabel	^'-- search results --' translated! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'rr 1/8/2006 12:35'!windowTitle	^ title translated! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 17:59'!allCategorySelected	^self selectedCategory = self allCategoryLabel! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'rr 10/1/2005 15:05'!allPreferences	^ preferences allPreferenceObjects  asSortedCollection:			[:pref1 :pref2 | 			pref1 viewRegistry viewOrder  <pref2 viewRegistry viewOrder  or:					[pref1 viewRegistry viewOrder  =pref2 viewRegistry viewOrder 						 &(pref1 name  <pref2 name)]]! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'rr 10/1/2005 15:05'!categoryList	^OrderedCollection new		add:  self allCategoryLabel;		addAll: preferences categoryNames asSortedCollection;		add: self searchResultsCategoryLabel;		yourself.		! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 8/27/2005 23:35'!lastExecutedSearch	^lastExecutedSearch! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:39'!lastExecutedSearch: aTextOrString	^lastExecutedSearch:= aTextOrString! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 18:01'!nonSpecialCategorySelected	^self allCategorySelected not & self searchResultsCategorySelected not! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'rr 10/11/2005 17:14'!preferences	^ preferences! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'ar 8/9/2009 15:20'!preferencesInCategory: aCategory	^(preferences preferenceObjectsInCategory: aCategory) asSortedCollection:		[:pref1 :pref2 | 				pref1 viewRegistry viewOrder  <pref2 viewRegistry viewOrder  or:						[pref1 viewRegistry viewOrder  =pref2 viewRegistry viewOrder 							 &(pref1 name  <pref2 name)]]! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 7/8/2006 17:50'!searchFieldLegend	^''.! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 8/27/2005 23:39'!searchPattern	^searchPattern ifNil: [searchPattern := self searchFieldLegend]! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:39'!searchPattern: aStringOrText	aStringOrText 		ifEmpty: [searchPattern := self searchFieldLegend]		ifNotEmpty: [searchPattern := aStringOrText asString].	self changed: #searchPattern.	^true! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'kb 11/12/2009 14:51'!searchPatternNeverTriggered	^self searchPattern! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:39'!searchResults	^searchResults ifNil: [searchResults := #()]! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 18:01'!searchResultsCategorySelected	^self selectedCategory = self searchResultsCategoryLabel! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:39'!selectFirstPreferenceOrNil	| prefs |	self selectedCategory		ifNil: [^self selectedPreference: nil].	prefs := self preferencesInCategory: self selectedCategory.	prefs isEmpty		ifTrue: [^self selectedPreference: nil].	self selectedPreference: prefs first.! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/19/2004 03:23'!selectSearchResultsCategory	self selectedCategoryIndex: (self categoryList indexOf: self searchResultsCategoryLabel)! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/19/2004 00:01'!selectedCategory	^self categoryList at: selectedCategoryIndex ifAbsent: []! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/25/2004 17:09'!selectedCategory: aCategorySymbol	self selectedCategoryIndex: (self categoryList indexOf: aCategorySymbol ifAbsent: [0]).! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 20:49'!selectedCategoryIndex	^selectedCategoryIndex ifNil: [selectedCategoryIndex := 0].! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 23:45'!selectedCategoryIndex: anIndex	anIndex = 0		ifTrue: [^self].	self selectedPreference: nil.	selectedCategoryIndex := anIndex.	self changed: #selectedCategoryIndex.! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/19/2004 03:27'!selectedCategoryPreferences	self allCategorySelected		ifTrue: [^self allPreferences].	self searchResultsCategorySelected 		ifTrue: [^self searchResults].	^self preferencesInCategory: self selectedCategory.	! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 20:53'!selectedPreference	^selectedPreference! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/19/2004 00:39'!selectedPreference: aPreference	selectedPreference := aPreference.	self changed: #selectedPreference.	self changed: #selectedPreferenceIndex.	self changed: #selectedPreferenceHelpText.! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 12/8/2004 15:22'!selectedPreferenceHelpText	self selectedPreference		ifNil: [^''].	^self selectedPreference helpString withBlanksTrimmed.! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 21:17'!selectedPreferenceIndex	^self selectedCategoryPreferences indexOf: self selectedPreference ifAbsent: [0]! !!PreferenceBrowser methodsFor: 'accessing' stamp: 'hpt 9/18/2004 23:41'!selectedPreferenceIndex: anIndex	anIndex = 0		ifTrue: [^self].	self selectedPreference: (self selectedCategoryPreferences at: anIndex).! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'hpt 9/19/2004 12:01'!defaultSelected	Preferences chooseInitialSettings! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'hpt 8/27/2005 13:18'!helpSelected 	"Open up a workspace with explanatory info in it about the Preference Browser"	Workspace new		contents: self helpText;		openLabel: self windowTitle.! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'hpt 8/27/2005 13:42'!helpText	^(String streamContents: [:str |		str nextPutAll:'Many aspects of the system are goberned by the settings of various ''Preferences''.Click on any of the categories shown at the left list to see all the preferences in that category. Or type into the search box at the bottom of the window, then hit Search, and all Preferences matching whatever you typed in will appear in the ''search results'' category. A preference is considered to match your search if either its name matches the text *or* if anything in the preference''s help text does.To find out more about any particular Preference just select it and its help text will appear.Some preferences can be ''local'' instead of global. When a preference is set as global its value will apply to whatever project you are in. A local preference will only be valid in the project that you set it in.The ''Save'' button allow you to quickly save your current settings so it can later be restored with the ''Load'' button.To carry your settings to another Squeak you might want to use the ''Save to disk'' and ''Load from disk'' buttons. The save to disk option will store all your settings in a ''my.prefs'' file in your Squeak''s current directory.Lastly, you can use the "theme..." button to set multiple preferences all at once; click on the "theme..." button and try the themes already provided with your Squeak image.']) translated! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'rr 10/1/2005 15:05'!loadFromDiskSelected 	preferences restorePreferencesFromDisk! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'rr 10/1/2005 15:05'!loadSelected	preferences restorePersonalPreferences ! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'rr 10/1/2005 15:05'!saveSelected	preferences savePersonalPreferences ! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'rr 10/1/2005 15:05'!saveToDiskSelected 	preferences storePreferencesToDisk! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'hpt 8/27/2005 23:36'!searchPreferencesFor: pattern	| result |	result := pattern asString asLowercase withBlanksTrimmed.	result ifEmpty: [^self].	searchResults := self allPreferences select: [:aPreference |		(aPreference name includesSubstring: result caseSensitive: false) or:				[aPreference helpString includesSubstring: result caseSensitive: false]].			self selectSearchResultsCategory.	self lastExecutedSearch: pattern.! !!PreferenceBrowser methodsFor: 'preferences search' stamp: 'rr 10/1/2005 15:06'!themeSelected 	preferences offerThemesMenu! !!PreferenceBrowser methodsFor: 'find' stamp: 'rr 10/1/2005 15:05'!findCategoryFromPreference: prefSymbol	"Find all categories in which the preference occurs"	| aMenu| 	aMenu := MenuMorph new defaultTarget: self.	(preferences categoriesContainingPreference: prefSymbol) do:		[:aCategory | aMenu add: aCategory target: self selector: #selectedCategory: argument: aCategory].	aMenu popUpInWorld! !!PreferenceBrowser methodsFor: 'initialize-release' stamp: 'rr 10/1/2005 15:25'!initialize	preferences := Preferences.	title := 'Preference Browser'.! !!PreferenceBrowser methodsFor: 'buttons callbacks' stamp: 'hpt 9/19/2004 03:21'!searchSelected	self searchPreferencesFor: self searchPattern.! !!PreferenceBrowser methodsFor: 'stepping' stamp: 'hpt 8/27/2005 23:35'!stepAt: millisecondClockValue in: aWindow	super stepAt: millisecondClockValue in: aWindow.	self searchPattern ~= self lastExecutedSearch		ifTrue: [self searchPreferencesFor: self searchPattern].! !!PreferenceBrowser methodsFor: 'stepping' stamp: 'hpt 8/27/2005 23:41'!wantsStepsIn: aWindow	^true.! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:45'!initialize	self		registerWindowColor;		registerInOpenMenu;		registerInFlaps! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:48'!registerInFlaps	Flaps 		registerQuad: 			{ #PreferenceBrowser. 			#prototypicalToolWindow.			'Preference Browser' translated.			'A tool for expressing personal preferences for numerous options' translated }	 	forFlapNamed: 'Tools' translated.	Flaps replaceToolsFlap! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:40'!registerInOpenMenu	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: [		TheWorldMenu unregisterOpenCommand: 'Preference Browser'.		TheWorldMenu registerOpenCommand: {'Preference Browser'. {self. #open}}].		! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:39'!registerWindowColor	(Preferences windowColorFor: self name) = Color white		ifTrue: [ Preferences setWindowColorFor: self name to: (Color colorFrom: self windowColorSpecification brightColor) ].! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:45'!unload	self 		unregisterFromOpenMenu;		unregisterFromFlaps.! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:47'!unregisterFromFlaps	Flaps 		unregisterQuadsWithReceiver: self;		replaceToolsFlap! !!PreferenceBrowser class methodsFor: 'class initialization' stamp: 'hpt 9/19/2004 12:44'!unregisterFromOpenMenu	 (TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: 'Preference Browser'].! !!PreferenceBrowser class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:39'!open	| browser |	browser := self new.	(PreferenceBrowserMorph withModel: browser)		openInWorld.	^browser.	! !!PreferenceBrowser class methodsFor: 'instance creation' stamp: 'hpt 9/19/2004 12:51'!prototypicalToolWindow	| window |	window := PreferenceBrowserMorph withModel: self new.	window applyModelExtent.	^window! !!PreferenceBrowser class methodsFor: 'window color' stamp: 'hpt 9/18/2004 15:46'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Preference Browser' brightColor: #(0.645 1.0 1.0)	pastelColor: #(0.886 1.0 1.0) helpMessage: 'A tool for expressing personal preferences for numerous options.'! !!PreferenceBrowserMorph methodsFor: 'updating' stamp: 'hpt 9/20/2004 23:31'!adjustPreferenceListItemsWidth	| panel |	self preferenceList scroller submorphs 		ifEmpty: [^self].	panel := self preferenceListInnerPanel. 	panel width: self preferenceList width - (self preferenceList scrollBarThickness*2).	panel submorphsDo: [:ea | ea hResizing: #rigid; width: panel width].	self preferenceList setScrollDeltas.! !!PreferenceBrowserMorph methodsFor: 'updating' stamp: 'hpt 9/18/2004 21:16'!update: aSymbol	super update: aSymbol.	aSymbol == #selectedPreference		ifTrue: [self updateSelectedPreference].	aSymbol == #selectedCategoryIndex		ifTrue: [self updateSelectedCategoryPreferences].! !!PreferenceBrowserMorph methodsFor: 'updating' stamp: 'hpt 12/8/2004 19:10'!updateSelectedCategoryPreferences	Cursor wait showWhile: 		[self preferenceList 				hScrollBarValue: 0;				vScrollBarValue: 0.		self preferenceList scroller removeAllMorphs.		self preferenceList scroller addMorphBack: self newPreferenceListInnerPanel.		self adjustPreferenceListItemsWidth]! !!PreferenceBrowserMorph methodsFor: 'updating' stamp: 'hpt 9/19/2004 00:08'!updateSelectedPreference	| index |	self selectedCategory ifNotNil: [self turnOffSelectedPreference].	index := self selectedPreferenceIndex.	index = 0		ifTrue: [^self].	self turnOnSelectedPreference.! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 8/27/2005 23:58'!basicButton	| button |	button := SimpleButtonMorph new.	button		borderWidth: 2;		borderColor: #raised;		on: #mouseEnter send: #value to: [button borderColor: self paneColor];		on: #mouseLeave send: #value to: [button borderColor: #raised];		vResizing: #spaceFill;		useRoundedCorners;		clipSubmorphs: true;		color: self paneColor muchLighter;		target: self model.	^button! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 8/28/2005 00:04'!buttonRowLayoutFrame 	^LayoutFrame fractions: (0@0 corner: 1@0) offsets: (0@0 corner: 0@ (TextStyle defaultFont height * 2.5))! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:55'!defaultButton	^defaultButton ifNil: 		[defaultButton := self basicButton 						label: 'default' translated; 						actionSelector: #defaultSelected;												setBalloonText: 							'Click here to reset all the preferences to their standard ',							'default values.' translated]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!helpButton	^helpButton ifNil: 		[helpButton := self basicButton 						label: 'help' translated; 						setBalloonText: 							'Click here to get some hints on use of this Preferences ',							'Panel' translated;						actionSelector: #helpSelected]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!loadButton	^loadButton ifNil: 		[loadButton := self basicButton 						label: 'load' translated; 						actionSelector: #loadSelected;												setBalloonText: 							'Click here to reset all the preferences to their values ',							'in your Personal Preferences.' translated]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!loadFromDiskButton	^loadFromDiskButton ifNil: 		[loadFromDiskButton := self basicButton 						label: 'load from disk' translated; 						actionSelector: #loadFromDiskSelected;												setBalloonText: 							'Click here to load all the preferences from ',							'their saved values on disk.' translated]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 8/27/2005 23:59'!newButtonRow	^BorderedMorph new		color: Color transparent;		cellInset: 2;		layoutInset: 2;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		listCentering: #topLeft;		cellPositioning: #topLeft;		on: #mouseEnter send: #paneTransition: to: self;		on: #mouseLeave send: #paneTransition: to: self;		addMorphBack: self defaultButton;		addMorphBack: self newSeparator;		addMorphBack: self saveButton;		addMorphBack: self loadButton;		addMorphBack: self newSeparator;		addMorphBack: self saveToDiskButton;		addMorphBack: self loadFromDiskButton;		addMorphBack: self newSeparator;		addMorphBack: self themeButton;		addMorphBack: self newTransparentFiller;		addMorphBack: self helpButton;		yourself.! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:51'!newSeparator	^BorderedMorph new		borderWidth: 2;		borderColor: Color transparent;		color: self paneColor;		hResizing: #rigid;		width: 5;		vResizing: #spaceFill;		yourself! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:49'!newTransparentFiller	^Morph new		color: Color transparent;		vResizing: #spaceFill;		hResizing: #spaceFill;		yourself.! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!saveButton	^saveButton ifNil: 		[saveButton := self basicButton 						label: 'save' translated; 						actionSelector: #saveSelected;												setBalloonText: 							'Click here to save the current constellation of Preferences ',							'settings as your personal defaults; you can get them all ',							'reinstalled with a single gesture by clicking the "Restore ',							'my Personal Preferences".' translated]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!saveToDiskButton	^saveToDiskButton ifNil: 		[saveToDiskButton := self basicButton 						label: 'save to disk' translated; 						actionSelector: #saveToDiskSelected;												setBalloonText: 							'Click here to save the current constellation of Preferences ',							'settings to a file; you can get them all reinstalled with a ', 							'single gesture by clicking "Restore Settings From Disk".'								 translated]! !!PreferenceBrowserMorph methodsFor: 'submorphs - buttons' stamp: 'hpt 9/18/2004 16:56'!themeButton	^themeButton ifNil: 		[themeButton := self basicButton 						label: 'theme...' translated; 						actionSelector: #themeSelected;						setBalloonText: 							'Numerous "Preferences" govern many things about the ',							'way Squeak looks and behaves.  Set individual preferences ',							'using a "Preferences" panel.  Set an entire "theme" of many ',							'Preferences all at the same time by pressing this "change ',							'theme" button and choosing a theme to install.  Look in ',							'category "themes" in Preferences class to see what each ', 							'theme does; add your own methods to the "themes" ',							'category and they will show up in the list of theme ',							'choices.' translated].! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:12'!basicKeyPressed: anEvent	| aChar oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionPref |	aChar := anEvent keyCharacter.	nextSelection := oldSelection := self selectedPreferenceIndex.	max := self selectedCategoryPreferences size.	milliSeconds := Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes := ''].	lastKeystrokes := lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime := milliSeconds.	nextSelectionList := OrderedCollection newFrom: (self selectedCategoryPreferences copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self selectedCategoryPreferences copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionPref := nextSelectionList detect: [:a | a name withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self preferenceList flash"match not found"].	nextSelection := self selectedCategoryPreferences findFirst: [:a | a  = nextSelectionPref].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self preferenceList flash].	^ self selectedPreferenceIndex: nextSelection! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:16'!downKeyPressed: anEvent	self selectedPreferenceIndex:		(self selectedPreferenceIndex + 1 				min: self selectedCategoryPreferences size)! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:17'!endKeyPressed: anEvent	self selectedPreferenceIndex: self selectedCategoryPreferences size.! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:16'!homeKeyPressed: anEvent	self selectedPreferenceIndex: 1.! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:19'!keyPressed: anEvent	self selectedCategory 		ifNil: [^self].	anEvent keyValue = 30		ifTrue: [^self upKeyPressed: anEvent].	anEvent keyValue = 31		ifTrue: [^self downKeyPressed: anEvent].	anEvent keyValue = 1 		ifTrue: [^self homeKeyPressed: anEvent].	anEvent keyValue = 4		ifTrue: [^self endKeyPressed: anEvent].	anEvent keyValue = 11		ifTrue: [^self pageUpKeyPressed: anEvent].	anEvent keyValue = 12		ifTrue: [^self pageDownKeyPressed: anEvent].	self basicKeyPressed: anEvent.! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/26/2004 23:01'!mouseDownOn: aPreferenceView event: anEvent	anEvent hand newKeyboardFocus: self preferenceList scroller.	anEvent yellowButtonPressed		ifTrue: [aPreferenceView offerPreferenceNameMenu: self model]! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:24'!pageDownKeyPressed: anEvent	self selectedPreferenceIndex: (self selectedPreferenceIndex + self preferencesShowing size min: self selectedCategoryPreferences size).! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:30'!pageUpKeyPressed: anEvent	self selectedPreferenceIndex: (self selectedPreferenceIndex - self preferencesShowing size max: 1).! !!PreferenceBrowserMorph methodsFor: 'event handling' stamp: 'hpt 9/19/2004 00:16'!upKeyPressed: anEvent	self selectedPreferenceIndex: 			(self selectedPreferenceIndex - 1 max: 1).! !!PreferenceBrowserMorph methodsFor: 'geometry' stamp: 'hpt 9/18/2004 21:05'!extent: aPoint	super extent: aPoint.	self fullBounds.	self adjustPreferenceListItemsWidth.! !!PreferenceBrowserMorph methodsFor: 'initialization' stamp: 'hpt 9/19/2004 02:52'!initializeWithModel: aPreferenceBrowser	lastKeystrokeTime := 0.	lastKeystrokes := ''.	self 		model: aPreferenceBrowser;		clipSubmorphs: true;		setLabel: self model windowTitle;		name: 'PreferenceBrowser';		addMorph: self rootPanel fullFrame: self rootPanelLayoutFrame;		addMorph: self newButtonRow fullFrame: self buttonRowLayoutFrame.! !!PreferenceBrowserMorph methodsFor: 'submorphs - main panel' stamp: 'hpt 9/19/2004 03:01'!mainPanel	^mainPanel ifNil: 		[mainPanel := Morph new			color: Color transparent;			hResizing: #spaceFill;			vResizing: #spaceFill;			cellInset: 5;			layoutPolicy: TableLayout new;			listCentering: #topLeft;			listDirection: #leftToRight;			cellPositioning: #topLeft;			clipSubmorphs: true;			on: #mouseEnter send: #paneTransition: to: self;			addMorphBack: self newCategoryListPanel;			addMorphBack: self newPreferenceListPanel;			yourself].! !!PreferenceBrowserMorph methodsFor: 'submorphs - category list' stamp: 'hpt 9/18/2004 16:07'!newCategoryList 	^(PluggableListMorph		on: self model		list: #categoryList		selected: #selectedCategoryIndex		changeSelected: #selectedCategoryIndex:)			color: Color white;			borderInset;			vResizing: #spaceFill;			hResizing: #rigid;			width: 150;			yourself.! !!PreferenceBrowserMorph methodsFor: 'submorphs - category list' stamp: 'hpt 8/27/2005 23:44'!newCategoryListPanel	^Morph new		hResizing: #shrinkWrap;		vResizing: #spaceFill;		color: Color transparent;		layoutPolicy: TableLayout new;		cellInset: 3;		listCentering: #topLeft;		listDirection: #topToBottom;		cellPositioning: #topLeft;		clipSubmorphs: true;		addMorphBack: self newCategoryListPanelLabel;		addMorphBack: self newCategoryList! !!PreferenceBrowserMorph methodsFor: 'submorphs - category list' stamp: 'hpt 9/19/2004 02:29'!newCategoryListPanelLabel 	^StringMorph contents: 'Categories' translated.! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 12/8/2004 17:20'!newPreferenceButtonFor: aPreference 	| button |	button := PBPreferenceButtonMorph preference: aPreference model: self model.	button 		on: #mouseDown		send: #value:		to: 			[:anEvent | 			self				selectedPreference: aPreference;				mouseDownOn: button preferenceView event: anEvent].	^button! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 12/8/2004 17:20'!newPreferenceListInnerPanel	| panel maxWidth totalHeight |	panel := (Morph new)				color: Color transparent;				layoutPolicy: TableLayout new;				listDirection: #topToBottom;				cellPositioning: #topLeft;				yourself.	self selectedCategoryPreferences 		do: [:aPref | panel addMorphBack: (self newPreferenceButtonFor: aPref)].	panel submorphs size = 0 ifTrue: [^panel].	maxWidth := (panel submorphs detectMax: [:m | m width]) width.	panel width: maxWidth.	totalHeight := (panel submorphs collect: [:ea | ea height]) inject: 0				into: [:h :tot | h + tot].	panel height: totalHeight.	panel fullBounds.	^panel! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 8/27/2005 23:44'!newPreferenceListPanel	| panel |	panel := Morph new		hResizing: #spaceFill;		vResizing: #spaceFill;		color: Color transparent;		layoutPolicy: TableLayout new;		cellInset: 3;		listCentering: #topLeft;		listDirection: #topToBottom;		cellPositioning: #topLeft;		clipSubmorphs: true;		addMorphBack: self newPreferenceListPanelLabel;		addMorphBack: self preferenceList.	^panel.! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 9/19/2004 02:29'!newPreferenceListPanelLabel 	^StringMorph contents: 'Preferences' translated.! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 9/25/2004 17:49'!preferenceList 	^preferenceList ifNil:		[preferenceList := ScrollPane new			color: Color white;			borderInset;			vResizing: #spaceFill;			hResizing: #spaceFill.		preferenceList scroller			on: #mouseEnter send: #value: 				to: [:event | event hand newKeyboardFocus: preferenceList scroller];			on: #keyStroke send: #keyPressed: to: self.		preferenceList.]! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 9/18/2004 21:19'!preferenceListInnerPanel	^self preferenceList scroller submorphs first! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 9/19/2004 00:29'!preferencesShowing	| prefs |	prefs := self preferenceListInnerPanel submorphs					copyFrom: (self selectedPreferenceIndex max: 1)					to: self selectedCategoryPreferences size.	^prefs reject: [:ea | (ea top - prefs first top) > self preferenceList scroller height].! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 12/8/2004 15:50'!selectedPreferenceButton	^(self preferenceListInnerPanel submorphs at: self selectedPreferenceIndex)! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'hpt 12/8/2004 15:54'!turnOffSelectedPreference	highlightedPreferenceButton 		ifNil: [^self].	highlightedPreferenceButton highlightOff.	highlightedPreferenceButton := nil.! !!PreferenceBrowserMorph methodsFor: 'submorphs - preference list' stamp: 'ul 12/12/2009 14:07'!turnOnSelectedPreference	highlightedPreferenceButton 		ifNotNil: [:m | m highlightOff].	highlightedPreferenceButton := self selectedPreferenceButton		highlightOn;		yourself.	self preferenceList scrollToShow: highlightedPreferenceButton bounds.! !!PreferenceBrowserMorph methodsFor: 'submorphs - search panel' stamp: 'hpt 9/19/2004 02:55'!newSearchButton	^self basicButton			label: 'search' translated; 			actionSelector: #searchSelected;			setBalloonText: 				'Type what you want to search for here, then hit ',				'the "Search" button, or else hit RETURN or ENTER' translated.! !!PreferenceBrowserMorph methodsFor: 'submorphs - search panel' stamp: 'hpt 8/27/2005 23:44'!newSearchPanel	| bottom |	bottom := Morph new		color: Color transparent;		cellInset: 5;		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		listCentering: #topLeft;		cellPositioning: #topLeft;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		addMorphBack: self newSearchTextField		yourself.	^Morph new		color: Color transparent;		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		listCentering: #topLeft;		cellPositioning: #topLeft;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		cellInset: 3;		addMorphBack: (StringMorph contents: 'Search preferences for: ');		addMorphBack: bottom;		yourself.! !!PreferenceBrowserMorph methodsFor: 'submorphs - search panel' stamp: 'kb 11/12/2009 14:51'!newSearchTextField	| ptm |	ptm := PluggableTextMorph		on: self model		text: #searchPatternNeverTriggered		accept: #searchPattern:.	ptm		hideVScrollBarIndefinitely: true;		borderInset;		color: Color white;		vResizing: #rigid;		hResizing: #spaceFill;		height: TextStyle defaultFont height * 2;		acceptOnCR: true;		onKeyStrokeSend: #value to: [ ptm hasUnacceptedEdits ifTrue: [ ptm accept ] ].	^ptm.! !!PreferenceBrowserMorph methodsFor: 'submorphs - root panel' stamp: 'hpt 8/27/2005 23:06'!rootPanel	^BorderedMorph new		color: Color transparent;		layoutInset: 10;		cellInset: 10;		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		listCentering: #topLeft;		cellPositioning: #topLeft;		addMorphBack: self newSearchPanel;		addMorphBack: self mainPanel;		yourself.! !!PreferenceBrowserMorph methodsFor: 'submorphs - root panel' stamp: 'stephaneducasse 2/4/2006 20:39'!rootPanelLayoutFrame 	| frame |	frame := self buttonRowLayoutFrame.	^LayoutFrame fractions: (0@0 corner: 1@1) offsets: (0@(frame bottomOffset) corner: 0@0)! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:05'!selectedCategory	^self model selectedCategory! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:05'!selectedCategoryIndex	^self model selectedCategoryIndex! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:05'!selectedCategoryIndex: anIndex	^self model selectedCategoryIndex: anIndex! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:05'!selectedCategoryPreferences	^self model selectedCategoryPreferences! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:05'!selectedPreference	^self model selectedPreference! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:06'!selectedPreference: aPreference	^self model selectedPreference: aPreference! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:10'!selectedPreferenceIndex	^self model selectedPreferenceIndex! !!PreferenceBrowserMorph methodsFor: 'model access' stamp: 'hpt 9/19/2004 00:10'!selectedPreferenceIndex: anIndex	^self model selectedPreferenceIndex: anIndex! !!PreferenceBrowserMorph class methodsFor: 'instance creation' stamp: 'hpt 9/18/2004 15:31'!withModel: aPreferenceBrowser	^self new initializeWithModel: aPreferenceBrowser;		yourself.! !!PreferenceView methodsFor: 'initialization' stamp: 'hpt 9/24/2004 22:25'!initializeWithPreference: aPreference	preference := aPreference! !!PreferenceView methodsFor: 'accessing' stamp: 'hpt 9/24/2004 22:25'!preference	^preference! !!PreferenceView methodsFor: 'user interface' stamp: 'hpt 9/24/2004 22:56'!representativeButtonWithColor: aColor inPanel: aPreferencesPanel	self subclassResponsibility ! !!PreferenceView methodsFor: 'user interface' stamp: 'hpt 9/26/2004 16:14'!tearOffButton	"Hand the user a button the can control this"	| aButton |	aButton := self representativeButtonWithColor: self preference defaultBackgroundColor inPanel: nil.	aButton borderWidth: 1; borderColor:  Color black; useRoundedCorners.	aButton openInHand! !!PreferenceView commentStamp: '<historical>' prior: 0!My subclasses instances are responsible for building the visual representation of each kind of preference.!!PreferenceView class methodsFor: 'view registry' stamp: 'hpt 9/26/2004 16:09'!handlesPanel: aPreferencePanel	self subclassResponsibility ! !!PreferenceView class methodsFor: 'instance creation' stamp: 'hpt 9/24/2004 22:25'!preference: aPreference	^self new		initializeWithPreference: aPreference;		yourself! !!PreferenceViewRegistry methodsFor: 'initialize-release' stamp: 'hpt 9/26/2004 16:22'!initialize	viewOrder := 1.! !!PreferenceViewRegistry methodsFor: 'view registry' stamp: 'hpt 9/26/2004 15:26'!register: aProviderClass	(self registeredClasses includes: aProviderClass) 		ifFalse: [self registeredClasses add: aProviderClass].! !!PreferenceViewRegistry methodsFor: 'view registry' stamp: 'hpt 9/26/2004 15:26'!registeredClasses	^registeredClasses ifNil: [registeredClasses := OrderedCollection new]! !!PreferenceViewRegistry methodsFor: 'view registry' stamp: 'hpt 9/26/2004 15:26'!unregister: aProviderClass	self registeredClasses remove: aProviderClass ifAbsent: []! !!PreferenceViewRegistry methodsFor: 'view registry' stamp: 'hpt 9/26/2004 15:26'!viewClassFor: aPreferencePanel	^self registeredClasses 		detect: [:aViewClass| aViewClass handlesPanel: aPreferencePanel]		ifNone: [].! !!PreferenceViewRegistry methodsFor: 'view order' stamp: 'hpt 9/26/2004 16:22'!viewOrder	"answer the order in which the registered views should appear relative to the other views"	^viewOrder! !!PreferenceViewRegistry methodsFor: 'view order' stamp: 'hpt 9/26/2004 16:22'!viewOrder: aNumber	viewOrder := aNumber! !!PreferenceViewRegistry commentStamp: '<historical>' prior: 0!PreferenceViewRegistry is much like the AppRegistry classes.  Its purpose is to allow PreferenceBrowser implementers to register its own views for each kind of preference.!!PreferenceViewRegistry class methodsFor: 'accessing' stamp: 'ar 8/25/2009 19:38'!forType: typeName	"Answer the preference registry for the given type name"	^typeName caseOf:{		[#Boolean]	->	[self ofBooleanPreferences].		[#Color]	->	[self ofColorPreferences].		[#Font]		->	[self ofFontPreferences].		[#Number]	->	[self ofNumericPreferences].		[#String]	->	[self ofTextPreferences].		[#Halo]		->	[self ofHaloThemePreferences].		[#WindowColor]	-> [self registryOf: #windowColorPreferences]	} otherwise:[self registryOf: typeName].! !!PreferenceViewRegistry class methodsFor: 'accessing' stamp: 'ar 8/25/2009 19:38'!typeOfRegistry: aRegistry	"Answer the type name for a particular view registry"	^aRegistry caseOf:{		[self ofBooleanPreferences]	-> [#Boolean].		[self ofColorPreferences]		-> [#Color].		[self ofFontPreferences]		-> [#Font].		[self ofNumericPreferences]	-> [#Number].		[self ofTextPreferences]		-> [#String].		[self ofHaloThemePreferences]	-> [#Halo].		[self registryOf: #windowColorPreferences]	-> [#WindowColor].	} otherwise:[self registries keyAtIdentityValue: aRegistry ifAbsent:[nil]].! !!PreferenceViewRegistry class methodsFor: 'class initialization' stamp: 'ar 8/9/2009 16:40'!initialize	"Ensure we aren't carrying obsolete references"	self removeObsolete.! !!PreferenceViewRegistry class methodsFor: 'class initialization' stamp: 'ar 8/9/2009 16:42'!removeObsolete	"PreferenceViewRegistry removeObsolete"	"Remove obsolete entries from the registries"	self registries do:[:viewRegistry|		viewRegistry registeredClasses copy do:[:rClass|			rClass isObsolete ifTrue:[viewRegistry unregister: rClass]]].! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 16:23'!ofBooleanPreferences	^(self registryOf: #booleanPreferences)		viewOrder: 1; 		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 16:24'!ofColorPreferences	^(self registryOf: #colorPreferences)		viewOrder: 5;		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 16:24'!ofFontPreferences	^(self registryOf: #fontPreferences)		viewOrder: 4;		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 16:23'!ofHaloThemePreferences	^(self registryOf: #haloThemePreferences)		viewOrder: 2;		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 12/9/2004 22:16'!ofNumericPreferences	^(self registryOf: #numericPreferences)		viewOrder: 3;		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 16:23'!ofTextPreferences	^(self registryOf: #textPreferences)		viewOrder: 3;		yourself.! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 15:28'!registries	^registries ifNil: [registries := Dictionary new]! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 15:33'!registryOf: aSymbol	^self registries at: aSymbol ifAbsentPut: [self new]! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:53'!chooseControlFont	self chooseFontWithPrompt: 'Choose the standard control font' translated andSendTo: self withSelector: #setControlFontTo: highlight: self standardControlFont! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:59'!fontConfigurationMenu	| aMenu |	aMenu := MenuMorph new defaultTarget: Preferences.	aMenu addTitle: 'Standard System Fonts' translated.		aMenu addStayUpIcons.		aMenu add: 'default text font...' translated action: #chooseSystemFont.	aMenu balloonTextForLastItem: 'Choose the default font to be used for code and  in workspaces, transcripts, etc.' translated.	aMenu lastItem font: Preferences standardDefaultTextFont.		aMenu add: 'list font...' translated action: #chooseListFont.	aMenu lastItem font: Preferences standardListFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in list panes' translated.		aMenu add: 'flaps font...' translated action: #chooseFlapsFont.	aMenu lastItem font: Preferences standardFlapFont.	aMenu balloonTextForLastItem: 'Choose the font to be used on textual flap tabs' translated.	aMenu add: 'eToys font...' translated action: #chooseEToysFont.	aMenu lastItem font: Preferences standardEToysFont.	aMenu balloonTextForLastItem: 'Choose the font to be used on eToys environment' translated.	aMenu add: 'halo label font...' translated action: #chooseHaloLabelFont.	aMenu lastItem font: Preferences standardHaloLabelFont.	aMenu balloonTextForLastItem: 'Choose the font to be used on labels ih halo' translated.	aMenu add: 'control font...' translated action: #chooseControlFont.	aMenu lastItem font: Preferences standardControlFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in pushbuttons' translated.	aMenu add: 'menu font...' translated action: #chooseMenuFont.	aMenu lastItem font: Preferences standardMenuFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in menus' translated.		aMenu add: 'window-title font...' translated action: #chooseWindowTitleFont.	aMenu lastItem font: Preferences windowTitleFont emphasis: 1.	aMenu balloonTextForLastItem: 'Choose the font to be used in window titles.' translated.	aMenu add: 'balloon-help font...' translated action: #chooseBalloonHelpFont.	aMenu lastItem font: Preferences standardBalloonHelpFont.	aMenu balloonTextForLastItem: 'choose the font to be used when presenting balloon help.' translated.		aMenu add: 'code font...' translated action: #chooseCodeFont. 	aMenu lastItem font: Preferences standardCodeFont. 	aMenu balloonTextForLastItem: 'Choose the font to be used in code panes.' translated.		aMenu addLine.	aMenu add: 'restore default font choices' translated action: #restoreDefaultFonts.	aMenu balloonTextForLastItem: 'Use the standard system font defaults' translated.		aMenu add: 'print default font choices' translated action: #printStandardSystemFonts.	aMenu balloonTextForLastItem: 'Print the standard system font defaults to the Transcript' translated.	^ aMenu! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 12:00'!presentMvcFontConfigurationMenu	| aMenu result |	aMenu := CustomMenu new.	aMenu title: 'Standard System Fonts'.	aMenu add: 'default text font...' action: #chooseSystemFont.	aMenu add: 'list font...' action: #chooseListFont.	aMenu add: 'flaps font...' action: #chooseFlapsFont.	aMenu add: 'control font...' action: #chooseControlFont.	aMenu add: 'menu font...' action: #chooseMenuFont.	aMenu add: 'window-title font...' action: #chooseWindowTitleFont.	"aMenu add: 'code font...' action: #chooseCodeFont."	aMenu addLine.	aMenu add: 'restore default font choices' action: #restoreDefaultFonts.	(result := aMenu startUp) ifNotNil:		[self perform: result]! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:53'!refreshFontSettings	"Try to update all the current font settings to make things consistent."	self setFlapsFontTo: (self standardFlapFont);		setEToysFontTo: (self standardEToysFont);		setWindowTitleFontTo: (self windowTitleFont);		setListFontTo: (self standardListFont);		setMenuFontTo: (self standardMenuFont);		setControlFontTo:(self standardControlFont);		setSystemFontTo: (TextStyle defaultFont);		setCodeFontTo: (self standardCodeFont);		setBalloonHelpFontTo: (BalloonMorph balloonFont).	SystemWindow allSubInstancesDo: [ :s | | rawLabel |		rawLabel := s getRawLabel.		rawLabel owner vResizing: #spaceFill.		rawLabel font: rawLabel font.		s setLabel: s label.		s replaceBoxes ].! !!Preferences class methodsFor: 'fonts' stamp: 'ul 11/25/2010 23:37'!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	self setDefaultFonts: #(		(setSystemFontTo:			'Bitmap DejaVu Sans'		9)		(setListFontTo:				'Bitmap DejaVu Sans'		9)		(setFlapsFontTo:			Accushi						12)		(setEToysFontTo:			BitstreamVeraSansBold		9)		(setPaintBoxButtonFontTo:	BitstreamVeraSansBold		9)		(setMenuFontTo:			'Bitmap DejaVu Sans'		9)		(setWindowTitleFontTo:		'Bitmap DejaVu Sans Bold'	9)		(setBalloonHelpFontTo:		'Bitmap DejaVu Sans'		7)		(setCodeFontTo:			'Bitmap DejaVu Sans'		9)		(setButtonFontTo:			'Bitmap DejaVu Sans'	7)	)! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:55'!restoreDefaultFontsForJapanese	"Preferences restoreDefaultFontsForJapanese"	#(	"(setButtonFontTo:		ComicBold		15)"		"(setTextButtonFontTo:		NewYork		12)"		"(setCodeFontTo:			NewYork		12)"  "Later"		(setFlapsFontTo:			NewYork		15)		(setListFontTo:			NewYork		12)		(setMenuFontTo:			NewYork		12)		(setControlFontTo:		NewYork		12)		(setWindowTitleFontTo:	NewYork		15)		(setSystemFontTo:		NewYork		12)) do:			[:triplet |				self perform: triplet first with: (StrikeFontSet familyName: triplet second size: triplet third)].	self setButtonFontTo: (StrikeFont familyName: #ComicBold size: 16).	Smalltalk at: #BalloonMorph ifPresent:		[:thatClass | thatClass setBalloonFontTo: (StrikeFontSet familyName: #NewYork size: 12)].	"Note:  The standardCodeFont is not currently used -- the default font is instead; later hopefully we can split the code font out as  a separate choice, but only after we're able to have the protocols reorganized such that we can know whether it's code or not when we launch the text object.	Note:  The standard button font is reset by this code but is not otherwise settable by a public UI (too many things can go afoul) "! !!Preferences class methodsFor: 'fonts' stamp: 'ar 7/13/2010 15:09'!restoreFontsAfter: aBlock	"Restore the currently chosen set of standard fonts after 	evaluating aBlock. Used for tests that modify the default fonts."	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont standardControlFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	standardControlFont := Preferences standardControlFont.	^aBlock ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont.		Preferences setControlFontTo: standardControlFont.	].! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:57'!setControlFontTo: aFont	Parameters at: #standardControlFont put: aFont.! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 6/18/2010 14:56'!setSystemFontTo: aFont	"Establish the default text font and style"	| aStyle newDefaultStyle |	aFont ifNil: [^ self].	aStyle := aFont textStyle ifNil: [^ self].	newDefaultStyle := aStyle copy.	newDefaultStyle defaultFontIndex: (aStyle fontIndexOf: aFont).	TextConstants at: #DefaultTextStyle put: newDefaultStyle.	Flaps replaceToolsFlap.! !!Preferences class methodsFor: 'fonts' stamp: 'bgf 4/30/2007 11:52'!standardControlFont	"Answer the font to be used in pushbuttons and the like."	 ^ Parameters at: #standardControlFont ifAbsent:		[Parameters at: #standardControlFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'reacting to change' stamp: 'ar 7/13/2010 18:15'!displaySizeChanged	self flag: #todo.	"only change font on small-land image"	self smallLandFonts.	self tinyDisplay		ifTrue: [self enable: #scrollBarsNarrow]		ifFalse: [self disable: #scrollBarsNarrow].	self tinyDisplay 		ifTrue:[self disable: #biggerHandles] 		ifFalse:[self enable: #biggerHandles].! !!Preferences class methodsFor: 'standard queries'!autoKeyboardFocus	^ self		valueOfFlag: #autoKeyboardFocus		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!automaticLookAdjustments	^ self		valueOfFlag: #automaticLookAdjustments		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!automaticProgressDelay	^ self		valueOfFlag: #automaticProgressDelay		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!defaultWindowCloseBox	^ self		valueOfFlag: #defaultWindowCloseBox		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!defaultWindowCollapseBox	^ self		valueOfFlag: #defaultWindowCollapseBox		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!defaultWindowExpandBox	^ self		valueOfFlag: #defaultWindowExpandBox		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!doubleClickOnLabelToEdit	^ self		valueOfFlag: #doubleClickOnLabelToEdit		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!enableProgressAbort	^ self		valueOfFlag: #enableProgressAbort		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!enableProgressDebug	^ self		valueOfFlag: #enableProgressDebug		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!hideTypeInCursor	^ self		valueOfFlag: #hideTypeInCursor		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!innerBorderStyle	^ self		valueOfFlag: #innerBorderStyle		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!projectSpaceAnalysis	^ self		valueOfFlag: #projectSpaceAnalysis		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!resizeWithContents	^ self		valueOfFlag: #resizeWithContents		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!texturedWindowFrame	^ self		valueOfFlag: #texturedWindowFrame		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries'!thickWindowFrame	^ self		valueOfFlag: #thickWindowFrame		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries'!useFormsInPaintBox	^ self		valueOfFlag: #useFormsInPaintBox		ifAbsent: [true]! !!Preferences class methodsFor: 'text highlighting' stamp: 'bgf 8/21/2007 22:26'!initializeTextHighlightingParameters	"Preferences initializeTextHighlightingParameters"	Parameters at: #insertionPointColor put: (Color r: 0.15 g: 0.2 b: 0.25).	Parameters at: #textHighlightColor put: (Color r: 0.75 g: 0.8 b: 0.95).! !!Preferences class methodsFor: '*PreferenceBrowser' stamp: 'ar 8/9/2009 16:12'!addPreference: aName categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector viewRegistry: aViewRegistry	"For compatibility with the old set of protocols"	^self addPreference: aName categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector type: (PreferenceViewRegistry typeOfRegistry: aViewRegistry).! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 19:49'!blockSelectCallName: callName	^ [:mRef | (self extractCallModuleNames: mRef) key = callName]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 20:45'!blockSelectFailedCall	"Precondition: mRef references compiledCall."	^ [:mRef | (mRef compiledMethod literals first at: 4)		= -1]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 19:50'!blockSelectModuleName: moduleNameOrNil	^ [:mRef | (self extractCallModuleNames: mRef) value = moduleNameOrNil]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'md 2/16/2006 14:02'!changeCallCompiledMethod: aCompiledMethod enable: enableFlag 	"Enables disabled or disables enabled external prim call by recompiling 	method with prim call taken from comment."	|  methodRef |	methodRef := aCompiledMethod methodReference.	enableFlag		ifTrue: [self enableCallIn: methodRef]		ifFalse: [self disableCallIn: methodRef]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 17:31'!changeCallMethod: selector class: classOrSymbol enable: enableFlag 	"Enables disabled or disables enabled external prim call by recompiling  	method with prim call taken from comment."	| methodRef |	methodRef := MethodReference new				setStandardClass: (classOrSymbol isSymbol						ifTrue: [Smalltalk at: classOrSymbol]						ifFalse: [classOrSymbol])				methodSymbol: selector.	enableFlag		ifTrue: [self enableCallIn: methodRef]		ifFalse: [self disableCallIn: methodRef]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/11/2004 06:31'!existsCompiledCallIn: aMethodRef 	"This just means that there is a compiled in external prim call: from the 	by compiler subclass point of view disabled prim calls not visible by 	this method are also prim calls."	^ aMethodRef compiledMethod primitive = 117! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 19:59'!methodsWithCall: callName enabled: enabledFlag 	^ (self methodsWithCallEnabled: enabledFlag)		select: (self blockSelectCallName: callName)! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 20:24'!methodsWithCall: callName intoModule: moduleNameOrNil enabled: enabledFlag 	^ ((self methodsWithCallEnabled: enabledFlag)		select: (self blockSelectCallName: callName))		select: (self blockSelectModuleName: moduleNameOrNil)! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/14/2004 19:17'!methodsWithCallEnabled: enabledFlag 	^ enabledFlag		ifNil: [self methodsWithCall]		ifNotNil: [enabledFlag				ifTrue: [self methodsWithEnabledCall]				ifFalse: [self methodsWithDisabledCall]]! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/14/2004 19:19'!methodsWithCallForClass: class enabled: enabledFlag 	^ class selectors		collect: [:sel | MethodReference new setStandardClass: class methodSymbol: sel]		thenSelect: (enabledFlag				ifNil: [[:mRef | self existsCallIn: mRef]]				ifNotNil: [enabledFlag						ifTrue: [[:mRef | self existsEnabledCallIn: mRef]]						ifFalse: [[:mRef | self existsDisabledCallIn: mRef]]])! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/13/2004 20:00'!methodsWithCallForClasses: classes enabled: enabledFlag 	| result |	result := OrderedCollection new.	classes		do: [:class | result				addAll: (self methodsWithCallForClass: class enabled: enabledFlag)].	^ result! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 19:55'!methodsWithCallIntoModule: moduleNameOrNil enabled: enabledFlag 	^ (self methodsWithCallEnabled: enabledFlag)		select: (self blockSelectModuleName: moduleNameOrNil)! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/15/2004 19:57'!methodsWithCallIntoModule: moduleNameOrNil forClasses: classes enabled: enabledFlag 	^ (self methodsWithCallForClasses: classes enabled: enabledFlag)		select: (self blockSelectModuleName: moduleNameOrNil)! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/14/2004 01:34'!privateDisableCallIn: aMethodRefWithExternalCall	"Disables enabled or failed external prim call."	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/14/2004 01:33'!privateEnableCallIn: aMethodRefWithExternalCall	"Enables disabled external prim call."	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'private user interface' stamp: 'sr 6/14/2004 02:09'!privateEnableViaLiteralIn: aMethodRef 	"Enables external prim call by filling function ref literal with zero for 	'non called'."	aMethodRef compiledMethod literals first at: 4 put: 0.	Object flushCache! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:39'!changeStatusOfFailedCalls	"En/dis-able not only dis/en-abled calls, but also failed ones. Using this 	feature can hide serious problems."	changeStatusOfFailedCallsFlag := true! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 01:15'!disableCallIn: aMethodRef 	"Disables enabled external prim call."	(self existsEnabledCallIn: aMethodRef)		ifFalse: [self changeStatusOfFailedCallsFlag				ifTrue: [(self existsFailedCallIn: aMethodRef)						ifFalse: [^ self error: 'no enabled or failed prim call found']]				ifFalse: [^ self error: 'no enabled prim call found']].	self privateDisableCallIn: aMethodRef.	self treatedMethods at: aMethodRef put: #disabled.	self logStream		ifNotNil: [self log: 'Call ' , (self extractCallModuleNames: aMethodRef) printString , ' in ' , aMethodRef actualClass name , '>>' , aMethodRef methodSymbol , ' disabled.']! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:30'!disableCallInCompiledMethod: aCompiledMethod 	"Disables external prim call."	self changeCallCompiledMethod: aCompiledMethod enable: false! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:31'!disableCallInMethod: selector class: classOrSymbol 	"Disables external prim call."	self		changeCallMethod: selector		class: classOrSymbol		enable: false! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 01:35'!disableCallsIntoModule: aModule 	"Disables enabled external prim calls in aModule."	| methods |	methods := self methodsWithEnabledCallIntoModule: aModule.	self changeStatusOfFailedCallsFlag		ifTrue: [methods				addAll: (self methodsWithFailedCallIntoModule: aModule)].	methods isEmpty		ifTrue: [^ self error: 'no enabled '					, (self changeStatusOfFailedCallsFlag	ifTrue: ['or failed ']	ifFalse: [''])					, 'prim calls for module ' , aModule , ' found'].	methods		do: [:mRef | self disableCallIn: mRef]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 02:01'!disableCallsIntoModule: aModule forClasses: classes 	"Disables enabled external prim calls in aModule for classes."	| methods |	methods := self methodsWithEnabledCallIntoModule: aModule forClasses: classes.	self changeStatusOfFailedCallsFlag		ifTrue: [methods				addAll: (self methodsWithFailedCallIntoModule: aModule forClasses: classes)].	methods isEmpty		ifTrue: [^ self error: 'no enabled '					, (self changeStatusOfFailedCallsFlag	ifTrue: ['or failed ']	ifFalse: [''])					, 'prim calls for module ' , aModule , ' in given classes found'].	methods		do: [:mRef | self disableCallIn: mRef]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/11/2004 06:44'!disableEnabled	"Disables these external prim calls, which are formerly enabled by self."	self treatedMethods		keysAndValuesDo: [:mRef :status | status == #enabled				ifTrue: [self disableCallIn: mRef]]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/14/2004 02:05'!enableCallIn: aMethodRef 	"Enables disabled external prim call."	(self existsDisabledCallIn: aMethodRef)		ifTrue: [self privateEnableCallIn: aMethodRef]		ifFalse: [self changeStatusOfFailedCallsFlag				ifTrue: [(self existsFailedCallIn: aMethodRef)						ifTrue: [self privateEnableViaLiteralIn: aMethodRef]						ifFalse: [^ self error: 'no disabled or failed prim call found']]				ifFalse: [^ self error: 'no disabled prim call found']].	self treatedMethods at: aMethodRef put: #enabled.	self logStream		ifNotNil: [self log: 'Call ' , (self extractCallModuleNames: aMethodRef) printString , ' in ' , aMethodRef actualClass name , '>>' , aMethodRef methodSymbol , ' enabled.']! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:31'!enableCallInCompiledMethod: aCompiledMethod 	"Enables disabled external prim call."	self changeCallCompiledMethod: aCompiledMethod enable: true! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:31'!enableCallInMethod: selector class: classOrSymbol 	"Enables disabled external prim call."	self		changeCallMethod: selector		class: classOrSymbol		enable: true! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 01:36'!enableCallsIntoModule: aModule 	"Enables disabled external prim calls in aModule."	| methods |	methods := self methodsWithDisabledCallIntoModule: aModule.	self changeStatusOfFailedCallsFlag		ifTrue: [methods				addAll: (self methodsWithFailedCallIntoModule: aModule)].	methods isEmpty		ifTrue: [^ self error: 'no disabled '					, (self changeStatusOfFailedCallsFlag	ifTrue: ['or failed ']	ifFalse: [''])					, 'prim calls for module ' , aModule , ' found'].	methods		do: [:mRef | self enableCallIn: mRef]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 02:01'!enableCallsIntoModule: aModule forClasses: classes 	"Enables disabled external prim calls in aModule for classes."	| methods |	methods := self methodsWithDisabledCallIntoModule: aModule forClasses: classes.	self changeStatusOfFailedCallsFlag		ifTrue: [methods				addAll: (self methodsWithFailedCallIntoModule: aModule forClasses: classes)].	methods isEmpty		ifTrue: [^ self error: 'no disabled '					, (self changeStatusOfFailedCallsFlag	ifTrue: ['or failed ']	ifFalse: [''])					, 'prim calls for module ' , aModule , ' in given classes found'].	methods		do: [:mRef | self enableCallIn: mRef]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/11/2004 06:42'!enableDisabled	"Enables these external prim calls, which are formerly disabled by self."	self treatedMethods		keysAndValuesDo: [:mRef :status | status == #disabled				ifTrue: [self enableCallIn: mRef]]! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/15/2004 17:41'!preserveStatusOfFailedCalls	"Do not en/dis-able failed calls (default)."	changeStatusOfFailedCallsFlag := false! !!PrimCallControllerAbstract methodsFor: 'ui controlling' stamp: 'sr 6/11/2004 06:45'!switchStored	"Disables enabled and enables disabled (see corresponding method 	comments). "	self treatedMethods		keysAndValuesDo: [:mRef :status | status == #enabled				ifTrue: [self disableCallIn: mRef]				ifFalse: [self enableCallIn: mRef]]! !!PrimCallControllerAbstract methodsFor: 'accessing' stamp: 'sr 6/11/2004 04:52'!changeStatusOfFailedCallsFlag	^changeStatusOfFailedCallsFlag! !!PrimCallControllerAbstract methodsFor: 'accessing' stamp: 'sr 6/11/2004 04:12'!logStream	^logStream! !!PrimCallControllerAbstract methodsFor: 'accessing' stamp: 'sr 6/2/2004 05:27'!treatedMethods	^treatedMethods! !!PrimCallControllerAbstract methodsFor: 'ui testing' stamp: 'sr 6/11/2004 07:31'!existsCallIn: aMethodRef	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'ui testing' stamp: 'sr 6/9/2004 02:12'!existsDisabledCallIn: aMethodRef 	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'ui testing' stamp: 'sr 6/11/2004 06:34'!existsEnabledCallIn: aMethodRef 	^ (self existsCompiledCallIn: aMethodRef)		and: [(aMethodRef compiledMethod literals first at: 4)				>= 0]! !!PrimCallControllerAbstract methodsFor: 'ui testing' stamp: 'sr 6/15/2004 20:46'!existsFailedCallIn: aMethodRef 	^ (self existsCompiledCallIn: aMethodRef)		and: [self blockSelectFailedCall value: aMethodRef]! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/10/2004 21:15'!extractCallModuleNames: aMethodRef	"Returns prim call and module name as call->module Association."	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:27'!methodsWithCall	"Returns all methods containing external prim calls."	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 02:15'!methodsWithCall: primName	^ self methodsWithCall: primName enabled: nil! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 02:12'!methodsWithCall: primName intoModule: moduleNameOrNil	^ self methodsWithCall: primName intoModule: moduleNameOrNil enabled: nil! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 19:20'!methodsWithCallIntoModule: moduleNameOrNil	^ self methodsWithCallIntoModule: moduleNameOrNil enabled: nil! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 19:30'!methodsWithCallIntoModule: moduleNameOrNil forClass: class 	^ self methodsWithCallIntoModule: moduleNameOrNil forClasses: {class}! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 19:30'!methodsWithCallIntoModule: moduleNameOrNil forClasses: classes 	^ self		methodsWithCallIntoModule: moduleNameOrNil		forClasses: classes		enabled: nil! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:36'!methodsWithCompiledCall	"Returns all methods containing compiled in external prim calls.  	If the by compilation subclass has disabled some, this method does *not*  	return all methods containing prim calls (use >>methodsWithCall in this 	case). "	^ (SystemNavigation new		allMethodsSelect: [:method | method primitive = 117])		reject: [:method | method actualClass == ProtoObject]! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:28'!methodsWithDisabledCall	"Returns all methods containing disabled external prim calls."	self subclassResponsibility! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:24'!methodsWithDisabledCall: primName	^ self methodsWithCall: primName enabled: false! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:25'!methodsWithDisabledCall: primName intoModule: moduleNameOrNil	^ self methodsWithCall: primName intoModule: moduleNameOrNil enabled: false! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:25'!methodsWithDisabledCallIntoModule: moduleNameOrNil	^ self methodsWithCallIntoModule: moduleNameOrNil enabled: false! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:24'!methodsWithDisabledCallIntoModule: moduleNameOrNil forClass: class 	^ self methodsWithDisabledCallIntoModule: moduleNameOrNil forClasses: {class}! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:20'!methodsWithDisabledCallIntoModule: moduleNameOrNil forClasses: classes 	^ self		methodsWithCallIntoModule: moduleNameOrNil		forClasses: classes		enabled: false! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/14/2004 21:28'!methodsWithEnabledCall	"Returns all methods containing enabled external prim calls."	^ self methodsWithCompiledCall		select: [:mRef | (mRef compiledMethod literals first at: 4)				>= 0]! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:15'!methodsWithEnabledCall: primName	^ self methodsWithCall: primName enabled: true! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:16'!methodsWithEnabledCall: primName intoModule: moduleNameOrNil	^ self methodsWithCall: primName intoModule: moduleNameOrNil enabled: true! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:11'!methodsWithEnabledCallIntoModule: moduleNameOrNil	^ self methodsWithCallIntoModule: moduleNameOrNil enabled: true! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 05:46'!methodsWithEnabledCallIntoModule: moduleNameOrNil forClass: class 	^ self methodsWithEnabledCallIntoModule: moduleNameOrNil forClasses: {class}! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/11/2004 06:07'!methodsWithEnabledCallIntoModule: moduleNameOrNil forClasses: classes 	^ self		methodsWithCallIntoModule: moduleNameOrNil		forClasses: classes		enabled: true! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 20:47'!methodsWithFailedCall	"Returns all methods containing failed external prim calls."	^ self methodsWithCompiledCall select: self blockSelectFailedCall! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 01:40'!methodsWithFailedCallForClass: class 	^ class selectors		collect: [:sel | MethodReference new setStandardClass: class methodSymbol: sel]		thenSelect: [:mRef | self existsFailedCallIn: mRef]! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 01:44'!methodsWithFailedCallForClasses: classes	| result |	result := OrderedCollection new.	classes		do: [:class | result				addAll: (self methodsWithFailedCallForClass: class)].	^ result! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 19:58'!methodsWithFailedCallIntoModule: moduleNameOrNil 	^ self methodsWithFailedCall		select: (self blockSelectModuleName: moduleNameOrNil)! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 02:19'!methodsWithFailedCallIntoModule: moduleNameOrNil forClass: class 	^ self methodsWithFailedCallIntoModule: moduleNameOrNil forClasses: {class}! !!PrimCallControllerAbstract methodsFor: 'ui querying' stamp: 'sr 6/15/2004 19:58'!methodsWithFailedCallIntoModule: moduleNameOrNil forClasses: classes	^ (self methodsWithFailedCallForClasses: classes)		select: (self blockSelectModuleName: moduleNameOrNil)! !!PrimCallControllerAbstract methodsFor: 'private' stamp: 'sr 6/10/2004 21:32'!extractCallModuleNamesFromLiterals: aMethodRef 	| firstLiteral |	firstLiteral := aMethodRef compiledMethod literals first.	^ (firstLiteral at: 2)		-> (firstLiteral at: 1)! !!PrimCallControllerAbstract methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/3/2006 22:39'!initialize	treatedMethods := Dictionary new."	logStream := Transcript."	changeStatusOfFailedCallsFlag := false! !!PrimCallControllerAbstract methodsFor: 'logging' stamp: 'sr 6/11/2004 05:12'!log: aString 	self logStream		ifNotNil: [self logStream cr; show: '[' , self className , '] ' , aString]! !!PrimCallControllerAbstract methodsFor: 'ui logging' stamp: 'sr 6/11/2004 04:17'!logStream: aStreamOrNil 	"If aStreamOrNil is notNil, there will be shown dis/en-abling prim call 	info; nil means no logging."	logStream := aStreamOrNil! !!PrimCallControllerAbstract commentStamp: 'sr 6/16/2004 09:42' prior: 0!A PrimCallController (PCC) serves for switching external prim calls (primitiveExternalCall) on and off: this is an abstract class, instantiate one of the subclasses PCCByLiterals and PCCByCompilation.External prim calls are used to access internal and external modules (plugins) as shown by	SmalltalkImage current listLoadedModules.	SmalltalkImage current listBuiltinModules.Note: not loaded external modules (since they have not been called so far) are not shown by these methods.Highlight: dis/en-abling prims by a PCC works for both internal and external modules!!To help you choosing the right subclass, some properties are listed in the following table:Functionality/Property							|	PCCByLiterals	PCCByCompilation------------------------------------------------------------------------------------------------------testing plugins									|		suited			not suitedpermanent disabling of external prim calls		|		no				yes------------------------------------------------------------------------------------------------------method changes visible in changeset				|		no				yesenabling survives snapshot/compilation			|		yes				yesdisabling survives snapshot/compilation			|		no				yesspeed disabling									|		fast				mediumspeed enabling									|		fast				slowCompiledMethod pointer valid after en/dis-abling	|		yes				no									Important: Be careful with mixing the use of different PCCs!! PCCByLiterals does not see prims disabled by PCCByCompilation and vice versa. For playing around you should start with PCCByLiterals; use PCCByCompilation only, if you know what you are doing!!In protocols 'ui controlling', 'ui logging' and 'ui querying' (please look into this class) are the most important user interface methods. Thereafter the methods in 'ui testing' could be of interest.Useful expressions:Controlling:	"Factorial example"	| pcc tDisabled tEnabled tEnabled2 |	pcc _ PCCByLiterals new logStream: Transcript. "logStream set here for more info"	pcc disableCallsIntoModule: 'LargeIntegers'.	tDisabled _ [1000 factorial] timeToRun.	pcc enableDisabled.	tEnabled _ [1000 factorial] timeToRun.	tEnabled2 _ [1000 factorial] timeToRun.	{tDisabled. tEnabled. tEnabled2}Note: You shouldn't switch off module 'LargeIntegers' for a longer time, since this slows down your system.Querying:	PCCByLiterals new methodsWithCall.								"all calls"	PCCByLiterals new methodsWithCall: 'prim1'.						"call in all modules or without module"	PCCByLiterals new methodsWithCallIntoModule: nil.				"all calls without module"	PCCByLiterals new methodsWithCallIntoModule: 'LargeIntegers'.	"all calls into module 'LargeIntegers'"	PCCByLiterals new		methodsWithCallIntoModule: 'LargeIntegers'		forClass: Integer.							"all calls into module 'LargeIntegers' in class Integer"	PCCByLiterals new		methodsWithCallIntoModule: 'LargeIntegers'		forClasses: Integer withAllSubclasses.		"all calls into module 'LargeIntegers' in class Integer withAllSubclasses"	| pcc | (pcc _ PCCByLiterals new) methodsWithCall			collect: [:mRef | {mRef. pcc extractCallModuleNames: mRef}].Structure: treatedMethods				Dictionary of MethodReferences->#disabled/#enabled								-- contains changed methods and how they are changed last logStream					WriteStream -- shows info about changed methods ifNotNil changeStatusOfFailedCalls	Boolean -- if status of failed calls should be changed, default is false!!PrimCallControllerAbstractTest methodsFor: 'helper' stamp: 'sr 6/14/2004 22:56'!avoidSlowTest	^ doNotMakeSlowTestsFlag and: [pcc class = PCCByCompilation]! !!PrimCallControllerAbstractTest methodsFor: 'helper' stamp: 'sr 6/7/2004 08:56'!disabledCallRefs	^ self disabledCallSelectors		collect: [:sel | MethodReference new setStandardClass: self class methodSymbol: sel]! !!PrimCallControllerAbstractTest methodsFor: 'helper' stamp: 'sr 6/7/2004 08:57'!enabledCallRefs	^ self enabledCallSelectors		collect: [:sel | MethodReference new setStandardClass: self class methodSymbol: sel]! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:46'!compiledMethodsToExampleModule	^ self methodSelectorsToExampleModule		collect: [:sel | self class >> sel]! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/14/2004 00:11'!failedCallRef	^ MethodReference new setStandardClass: self class methodSymbol: self failedCallSelector! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:46'!methodRefsToExampleModule	^ self methodSelectorsToExampleModule		collect: [:sym | MethodReference new setStandardClass: self class methodSymbol: sym]! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 13:58'!noExternalCallRef	^ MethodReference new setStandardClass: self class methodSymbol: self noExternalCallSelector! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:47'!numOfCallsExampleModule	^ self methodSelectorsToExampleModule size! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/14/2004 23:34'!singularCallRef	^ MethodReference new setStandardClass: self class methodSymbol: self singularCallSelector! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:49'!wrongCallRef	^ MethodReference new setStandardClass: self class methodSymbol: #nonExistingCall! !!PrimCallControllerAbstractTest methodsFor: 'constants' stamp: 'sr 6/7/2004 08:49'!wrongClassRef	^ MethodReference new setStandardClass: Integer methodSymbol: self methodSelectorsToExampleModule first! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'ar 7/13/2010 17:17'!setUp	super setUp.	Utilities authorInitialsPerSe = '' ifTrue:[Utilities setAuthorInitials: 'test'].	pcc := self classToBeTested new.	"set failed call"	(self class >> self failedCallSelector) literals first at: 4 put: -1.	"set it to false for some very slow tests..."	doNotMakeSlowTestsFlag := true.! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'ar 7/13/2010 17:10'!tearDown	Utilities authorInitialsPerSe = 'test' ifTrue:[Utilities setAuthorInitials: ''].! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:54'!testChangeFailedCallFailing	pcc preserveStatusOfFailedCalls.	self		should: [pcc enableCallIn: self failedCallRef]		raise: TestResult error.	self		should: [pcc disableCallIn: self failedCallRef]		raise: TestResult error! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 00:41'!testChangeFailedCallSucceedingDisable	pcc changeStatusOfFailedCalls.	pcc disableCallIn: self failedCallRef.	self		assert: (pcc existsDisabledCallIn: self failedCallRef).	"necessary for PCCByCompilation (to make it visible for initialization again)"	pcc enableCallIn: self failedCallRef! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 00:34'!testChangeFailedCallSucceedingEnable	pcc changeStatusOfFailedCalls.	pcc enableCallIn: self failedCallRef.	self		assert: (pcc existsEnabledCallIn: self failedCallRef)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 02:43'!testDisableCallsIntoModule	"wrong module"	self		should: [pcc disableCallsIntoModule: 'totallyRandom4711']		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"disabling"	pcc disableCallsIntoModule: self exampleModuleName.	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"not enabled!!"	self		should: [pcc disableCallsIntoModule: self exampleModuleName]		raise: TestResult error.	"enabling"	self methodRefsToExampleModule		do: [:ref | pcc enableCallIn: ref].	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not enabled!!"	self		should: [pcc disableCallsIntoModule: self failModuleName]		raise: TestResult error.	pcc changeStatusOfFailedCalls.	pcc disableCallsIntoModule: self failModuleName.	self assert: (pcc existsDisabledCallIn: self failedCallRef).	"postcondition"	pcc enableCallIn: self failedCallRef! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:24'!testDisableCallsIntoModuleForClasses	"wrong module"	self		should: [pcc disableCallsIntoModule: 'totallyRandom4711' forClasses: {self class}]		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"disabling"	pcc disableCallsIntoModule: self exampleModuleName forClasses: {self class}.	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"not enabled!!"	self		should: [pcc disableCallsIntoModule: self exampleModuleName forClasses: {self class}]		raise: TestResult error.	"enabling"	self methodRefsToExampleModule		do: [:ref | pcc enableCallIn: ref].	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not enabled!!"	self		should: [pcc disableCallsIntoModule: self failModuleName forClasses: {self class}]		raise: TestResult error.	pcc changeStatusOfFailedCalls.	pcc disableCallsIntoModule: self failModuleName forClasses: {self class}.	self assert: (pcc existsDisabledCallIn: self failedCallRef).	"postcondition"	pcc enableCallIn: self failedCallRef! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 02:43'!testEnableCallsIntoModule	self avoidSlowTest		ifTrue: [^ self].	"wrong module"	self		should: [pcc enableCallsIntoModule: 'totallyRandom4711']		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [pcc enableCallsIntoModule: self exampleModuleName]		raise: TestResult error.	"disabling"	self methodRefsToExampleModule		do: [:ref | pcc disableCallIn: ref].	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"enabling"	"now this should work"	pcc enableCallsIntoModule: self exampleModuleName.	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [pcc enableCallsIntoModule: self failModuleName]		raise: TestResult error.	pcc changeStatusOfFailedCalls.	pcc enableCallsIntoModule: self failModuleName.	self assert: (pcc existsEnabledCallIn: self failedCallRef)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:43'!testEnableCallsIntoModuleForClasses	"wrong module"	self		should: [pcc enableCallsIntoModule: 'totallyRandom4711' forClasses: {self class}]		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [pcc enableCallsIntoModule: self exampleModuleName forClasses: {self class}]		raise: TestResult error.	"disabling"	self methodRefsToExampleModule		do: [:ref | pcc disableCallIn: ref].	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"enabling"	"now this should work"	pcc enableCallsIntoModule: self exampleModuleName forClasses: {self class}.	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [pcc enableCallsIntoModule: self failModuleName forClasses: {self class}]		raise: TestResult error.	pcc changeStatusOfFailedCalls.	pcc enableCallsIntoModule: self failModuleName forClasses: {self class}.	self assert: (pcc existsEnabledCallIn: self failedCallRef)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:45'!testEnableDisableCallIn	| refs |	refs := self methodRefsToExampleModule.	"wrong call"	self		should: [pcc disableCallIn: self wrongCallRef]		raise: TestResult error.	"wrong class"	self		should: [pcc disableCallIn: self wrongClassRef]		raise: TestResult error.	"wrong call"	self		should: [pcc enableCallIn: self wrongCallRef]		raise: TestResult error.	"wrong class"	self		should: [pcc enableCallIn: self wrongClassRef]		raise: TestResult error.	"no external call"	self		should: [pcc enableCallIn: self noExternalCallRef]		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [refs				do: [:ref1 | pcc enableCallIn: ref1]]		raise: TestResult error.	"disabling"	refs		do: [:ref2 | pcc disableCallIn: ref2].	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"not enabled!!"	self		should: [refs				do: [:ref3 | pcc disableCallIn: ref3]]		raise: TestResult error.	"enabling"	"now this should work"	refs		do: [:ref4 | pcc enableCallIn: ref4].	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"try caches"	pcc disableEnabled.	"all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	pcc enableDisabled.	"all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 00:07'!testEnableDisableCallInCompiledMethod	"Note: >>compiledMethodsToExampleModule has to be called frequently,  	since the CMs are changing with a successful compile!!"	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [self compiledMethodsToExampleModule				do: [:cm1 | pcc enableCallInCompiledMethod: cm1]]		raise: TestResult error.	"disabling"	self compiledMethodsToExampleModule		do: [:cm2 | pcc disableCallInCompiledMethod: cm2].	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"not enabled!!"	self		should: [self compiledMethodsToExampleModule				do: [:cm3 | pcc disableCallInCompiledMethod: cm3]]		raise: TestResult error.	"enabling"	"now this should work"	self compiledMethodsToExampleModule		do: [:cm4 | pcc enableCallInCompiledMethod: cm4].	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"try caches"	pcc disableEnabled.	"all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	pcc enableDisabled.	"all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:57'!testEnableDisableCallInMethodClass	| sels |	sels := self methodSelectorsToExampleModule.	"wrong call"	self		should: [pcc disableCallInMethod: #nonExistingCall class: self class]		raise: TestResult error.	"wrong class"	self		should: [pcc disableCallInMethod: sels first class: Integer]		raise: TestResult error.	"wrong call"	self		should: [pcc enableCallInMethod: #nonExistingCall class: self class]		raise: TestResult error.	"wrong class"	self		should: [pcc enableCallInMethod: sels first class: Integer]		raise: TestResult error.	self		should: [pcc enableCallInMethod: self noExternalCallSelector class: self class]		raise: TestResult error.	"precondition: all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"not disabled!!"	self		should: [sels				do: [:sel1 | pcc enableCallInMethod: sel1 class: self class]]		raise: TestResult error.	"disabling"	sels		do: [:sel2 | pcc disableCallInMethod: sel2 class: self class].	"now all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	"not enabled!!"	self		should: [sels				do: [:sel3 | pcc disableCallInMethod: sel3 class: self class]]		raise: TestResult error.	"enabling"	"now this should work"	sels		do: [:sel4 | pcc enableCallInMethod: sel4 class: self class].	"all enabled now"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	"try caches"	pcc disableEnabled.	"all disabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	pcc enableDisabled.	"all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:46'!testExistsCallIn	self		deny: (pcc existsCallIn: self noExternalCallRef).	self enabledCallRefs , self disabledCallRefs , {self failedCallRef}		do: [:callRef | self				assert: (pcc existsCallIn: callRef)]! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:47'!testExistsDisabledCallIn	self		deny: (pcc existsDisabledCallIn: self noExternalCallRef).	self		deny: (pcc existsDisabledCallIn: self failedCallRef).	self enabledCallRefs		do: [:callRef | self				deny: (pcc existsDisabledCallIn: callRef)].	self disabledCallRefs		do: [:disabledRef | self				assert: (pcc existsDisabledCallIn: disabledRef)]! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:48'!testExistsEnabledCallIn	self		deny: (pcc existsEnabledCallIn: self noExternalCallRef).	self		deny: (pcc existsEnabledCallIn: self failedCallRef).	self enabledCallRefs		do: [:callRef | self				assert: (pcc existsEnabledCallIn: callRef)].	self disabledCallRefs		do: [:disabledRef | self				deny: (pcc existsEnabledCallIn: disabledRef)]! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:49'!testExistsFailedCallIn	self		deny: (pcc existsFailedCallIn: self noExternalCallRef).	self enabledCallRefs , self disabledCallRefs		do: [:callRef | self				deny: (pcc existsFailedCallIn: callRef)].	self		assert: (pcc existsFailedCallIn: self failedCallRef)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 23:25'!testMethodsWithCallAndMethodsWithDisabledCall	| methodRefs disabledMethodRefs enabledMethodRefs failedMethodRefs |	self avoidSlowTest		ifTrue: [^ self].	disabledMethodRefs := pcc methodsWithDisabledCall.	self assert: disabledMethodRefs size > 0.	enabledMethodRefs := pcc methodsWithEnabledCall.	self assert: enabledMethodRefs size > 0.	failedMethodRefs := pcc methodsWithFailedCall.	self assert: failedMethodRefs size > 0.	methodRefs := pcc methodsWithCall.	self assert: methodRefs size = (disabledMethodRefs size + enabledMethodRefs size + failedMethodRefs size)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 22:54'!testMethodsWithCallIntoModule	| methodRefs |	self avoidSlowTest ifTrue: [^ self].	"precondition: all enabled"	pcc disableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithCallIntoModule: self exampleModuleName.	self assert: methodRefs size = self numOfCallsExampleModule.	"postcondition"	pcc enableCallIn: self methodRefsToExampleModule first! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 22:32'!testMethodsWithCallIntoModuleForClass	"precondition: all enabled"	| methodRefs |	pcc disableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithCallIntoModule: self exampleModuleName forClass: self class.	self assert: methodRefs size = self numOfCallsExampleModule.	"postcondition"	pcc enableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithCallIntoModule: nil forClass: self class.	self		assert: (methodRefs size = 2				and: [| methodCoreStrings | 					methodCoreStrings := methodRefs								collect: [:mRef | mRef methodSymbol allButFirst asString].					(methodCoreStrings includes: 'ExternalCallWithoutModule')						and: [methodCoreStrings includes: 'DisabledExternalCallWithoutModule']])! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 22:31'!testMethodsWithCallIntoModuleForClasses	"precondition: all enabled"	| methodRefs |	pcc disableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithCallIntoModule: self exampleModuleName forClasses: {self class}.	self assert: methodRefs size = self numOfCallsExampleModule.	"postcondition"	pcc enableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithCallIntoModule: nil forClasses: {self class}.	self		assert: (methodRefs size = 2				and: [| methodCoreStrings | 					methodCoreStrings := methodRefs								collect: [:mRef | mRef methodSymbol allButFirst asString].					(methodCoreStrings includes: 'ExternalCallWithoutModule')						and: [methodCoreStrings includes: 'DisabledExternalCallWithoutModule']])! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:36'!testMethodsWithCallX	| methodRefs |	self avoidSlowTest		ifTrue: [^ self].	methodRefs := pcc methodsWithCall: self singularCallName.	self assert: methodRefs size = 1! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:34'!testMethodsWithCallXIntoModule	| methodRefs |	self avoidSlowTest		ifTrue: [^ self].	methodRefs := pcc methodsWithCall: self singularCallName intoModule: self moduleNameWithSingularCallName.	self assert: methodRefs size = 1.	methodRefs := pcc methodsWithCall: self singularCallName intoModule: self moduleNameNotWithSingularCallName.	self assert: methodRefs isEmpty! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 23:04'!testMethodsWithDisabledCallIntoModule	| methodRefs |	self avoidSlowTest ifTrue: [^ self].	"precondition: all enabled"	pcc disableCallIn: self methodRefsToExampleModule first.	methodRefs := pcc methodsWithDisabledCallIntoModule: self exampleModuleName.	self assert: methodRefs size = 1.	"postcondition"	pcc enableCallIn: self methodRefsToExampleModule first! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 22:37'!testMethodsWithDisabledCallIntoModuleForClass	"precondition: all enabled"	| methodRefs |	self methodRefsToExampleModule		do: [:ref | pcc disableCallIn: ref].	methodRefs := pcc methodsWithDisabledCallIntoModule: self exampleModuleName forClass: self class.	self assert: methodRefs size = self numOfCallsExampleModule.	"postcondition"	self methodRefsToExampleModule		do: [:ref | pcc enableCallIn: ref].	methodRefs := pcc methodsWithDisabledCallIntoModule: nil forClass: self class.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol allButFirst = 'DisabledExternalCallWithoutModule')! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:46'!testMethodsWithDisabledCallIntoModuleForClasses	"precondition: all enabled"	| methodRefs |	self methodRefsToExampleModule		do: [:ref | pcc disableCallIn: ref].	methodRefs := pcc methodsWithDisabledCallIntoModule: self exampleModuleName forClasses: {self class}.	self assert: methodRefs size = self numOfCallsExampleModule.	"postcondition"	self methodRefsToExampleModule		do: [:ref | pcc enableCallIn: ref].	methodRefs := pcc methodsWithDisabledCallIntoModule: nil forClasses: {self class}.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol allButFirst = 'DisabledExternalCallWithoutModule')! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 23:38'!testMethodsWithDisabledCallX	| methodRefs |	self avoidSlowTest		ifTrue: [^ self].	"precondition: all enabled"	pcc disableCallIn: self singularCallRef.	methodRefs := pcc methodsWithDisabledCall: self singularCallName.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol = self singularCallName).	"postcondition"	pcc enableCallIn: self singularCallRef! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 23:42'!testMethodsWithDisabledCallXIntoModule	"precondition: all enabled"	| methodRefs |	self avoidSlowTest		ifTrue: [^ self].	"precondition: all enabled"	pcc disableCallIn: self singularCallRef.	methodRefs := pcc methodsWithDisabledCall: self singularCallName intoModule: self moduleNameWithSingularCallName.	self assert: methodRefs size = 1.	methodRefs := pcc methodsWithDisabledCall: self singularCallName intoModule: self moduleNameNotWithSingularCallName.	self assert: methodRefs isEmpty.	"postcondition"	pcc enableCallIn: self singularCallRef! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 07:13'!testMethodsWithEnabledCall	| methodRefs |	methodRefs := pcc methodsWithEnabledCall.	self assert: methodRefs size > 0! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 07:17'!testMethodsWithEnabledCallIntoModule	| methodRefs |	methodRefs := pcc methodsWithEnabledCallIntoModule: self exampleModuleName.	self assert: methodRefs size = self numOfCallsExampleModule! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/14/2004 22:43'!testMethodsWithEnabledCallIntoModuleForClass	"precondition: all enabled"	| methodRefs |	methodRefs := pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class.	self assert: methodRefs size = self numOfCallsExampleModule.	methodRefs := pcc methodsWithEnabledCallIntoModule: nil forClass: self class.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol allButFirst = 'ExternalCallWithoutModule')! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 07:12'!testMethodsWithEnabledCallIntoModuleForClasses	"precondition: all enabled"	| methodRefs |	methodRefs := pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClasses: {self class}.	self assert: methodRefs size = self numOfCallsExampleModule.	methodRefs := pcc methodsWithEnabledCallIntoModule: nil forClasses: {self class}.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol allButFirst = 'ExternalCallWithoutModule')! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:16'!testMethodsWithEnabledCallX	| methodRefs |	methodRefs := pcc methodsWithEnabledCall: self singularCallName.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol = self singularCallName)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 07:17'!testMethodsWithEnabledCallXIntoModule	"precondition: all enabled"	| methodRefs |	methodRefs := pcc methodsWithEnabledCall: self singularCallName intoModule: self moduleNameWithSingularCallName.	self assert: methodRefs size = 1.	methodRefs := pcc methodsWithEnabledCall: self singularCallName intoModule: self moduleNameNotWithSingularCallName.	self assert: methodRefs isEmpty! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:07'!testMethodsWithFailedCall	| methodRefs |	methodRefs := pcc methodsWithFailedCall.	self assert: methodRefs size >= 1 & ((methodRefs				select: [:mRef | mRef methodSymbol = self failedCallSelector]) size = 1)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:11'!testMethodsWithFailedCallForClass	| methodRefs |	methodRefs := pcc methodsWithFailedCallForClass: self class.	self assert: methodRefs size = 1 & (methodRefs asArray first methodSymbol = self failedCallSelector)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 02:54'!testMethodsWithFailedCallIntoModule	| methodRefs |	methodRefs := pcc methodsWithFailedCallIntoModule: self failModuleName.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol = self failedCallSelector)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/15/2004 03:13'!testMethodsWithFailedCallIntoModuleForClass	| methodRefs |	methodRefs := pcc methodsWithFailedCallIntoModule: self failModuleName forClass: self class.	self assert: methodRefs size = 1 & (methodRefs first methodSymbol = self failedCallSelector)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:58'!testSwitchPrimCallOffOn	| res |	pcc disableCallInMethod: self realExternalCallOrPrimitiveFailedSelector class: self class.	self		should: [self perform: self realExternalCallOrPrimitiveFailedSelector]		raise: TestResult error.	pcc enableCallInMethod: self realExternalCallOrPrimitiveFailedSelector class: self class.	self		shouldnt: [res := self perform: self realExternalCallOrPrimitiveFailedSelector]		raise: TestResult error.	self assert: res isString! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:46'!testSwitchStored	| refs |	"all enabled, precondition"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	refs := self methodRefsToExampleModule.	"fill cache"	refs		do: [:ref | pcc disableCallIn: ref].	"enable one"	pcc enableCallIn: refs first.	self		assert: (pcc existsEnabledCallIn: refs first).	self		assert: (pcc existsDisabledCallIn: refs second).	"switching"	pcc switchStored.	"now the checks go vice versa"	self		assert: (pcc existsDisabledCallIn: refs first).	self		assert: (pcc existsEnabledCallIn: refs second).	pcc enableCallIn: refs first.	self		assert: (pcc existsEnabledCallIn: refs first)! !!PrimCallControllerAbstractTest methodsFor: 'tests' stamp: 'sr 6/11/2004 06:46'!testTryCaches	| refs |	"all enabled, precondition"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	refs := self methodRefsToExampleModule.	"fill cache"	refs		do: [:ref | pcc disableCallIn: ref].	"try caches"	pcc enableDisabled.	"all enabled"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule.	pcc disableEnabled.	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = 0.	pcc enableDisabled.	"all enabled, postcondition"	self assert: (pcc methodsWithEnabledCallIntoModule: self exampleModuleName forClass: self class) size = self numOfCallsExampleModule! !!PrimCallControllerAbstractTest commentStamp: 'sr 6/15/2004 19:20' prior: 0!PrimCallController tests.Tests are here, but this class isAbstract and won't be tested.Tests are done in the subclasses, which inherit the tests here.If you want to perform some more very slow tests, change doNotMakeSlowTestsFlag in >>setUp.!!PrimCallControllerAbstractTest class methodsFor: 'Testing' stamp: 'sr 6/7/2004 11:59'!isAbstract	^ true! !!Process methodsFor: 'accessing' stamp: 'eem 4/12/2010 10:57'!effectiveProcess	"effectiveProcess is a mechanism to allow process-faithful debugging.  The debugger executes code	 on behalf of processes, so unless some effort is made the identity of Processor activeProcess is not	 correctly maintained when debugging code.  The debugger uses evaluate:onBehalfOf: to assign the	 debugged process as the effectiveProcess of the process executing the code, preserving process	 identity."	^effectiveProcess ifNil: [self]! !!Process methodsFor: 'accessing' stamp: 'eem 4/28/2009 16:53'!isSuspended	"Provisional definition in anticipation of a VM that sets myList to self for an active process."	^(myList == nil or: [myList == self]) and: [self ~~ Processor activeProcess]! !!Process methodsFor: 'accessing' stamp: 'eem 4/9/2010 14:03'!isTerminated	self isActiveProcess ifTrue: [^ false].	^suspendedContext isNil	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.		   If so, and the pc is greater than the startpc, the block has already sent and returned		   from value and there is nothing more to do."		suspendedContext isBottomContext		and: [suspendedContext pc > suspendedContext startpc]]! !!Process methodsFor: 'accessing' stamp: 'ar 5/22/2005 13:36'!island	"Answer the receiver's island"	^island! !!Process methodsFor: 'accessing' stamp: 'ar 5/22/2005 13:36'!island: anIsland	"Indicate the receiver's island"	island := anIsland.! !!Process methodsFor: 'changing process state' stamp: 'eem 7/26/2010 12:18'!bindToThreadId: anIntegerOrNil	"Bind the receiver to a specific VM thread via the index of the thread,	 or unbind the receiver if anIntegerOrNil is 0 or nil."	<primitive: 229 error: errorCode>	^self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'eem 7/26/2010 12:23'!boundThreadId	"Answer the index of the thread the receiver is bound to, if any, otherwise answer nil."	"Processor activeProcess boundThreadId"	<primitive: 228 error: errorCode>	^self primitiveFailed! !!Process methodsFor: 'changing process state' stamp: 'ar 8/9/2010 17:26'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			(ctxt tempAt: 2) ifNil:[				ctxt tempAt: 2 put: nil.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		"Always suspend the process first so it doesn't accidentally get woken up"		oldList := self suspend.		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			"If we are terminating a process halfways through an unwind, try			to complete that unwind block first."			(suspendedContext findNextUnwindContextUpTo: nil) ifNotNil:[:outer|				(suspendedContext findContextSuchThat:[:c| c closure == (outer tempAt: 1)]) ifNotNil:[:inner|					"This is an unwind block currently under evaluation"					suspendedContext runUntilErrorOrReturnFrom: inner.				].			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:20'!complete: aContext 	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."		| ctxt pair error |	ctxt := suspendedContext.	suspendedContext := nil.  "disable this process while running its stack in active process below"	pair := Processor activeProcess				evaluate: [ctxt runUntilErrorOrReturnFrom: aContext]				onBehalfOf: self.	suspendedContext := pair first.	error := pair second.	error ifNotNil: [^ error signalerContext].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:50'!popTo: aContext 	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"	^Processor activeProcess		evaluate: [self return: callee value: callee receiver]		onBehalfOf: self! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:49'!popTo: aContext value: aValue	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ self].  "aContext is on top"	Processor activeProcess		evaluate: [self return: callee value: aValue]		onBehalfOf: self! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:19'!step	^Processor activeProcess		evaluate: [suspendedContext := suspendedContext step]		onBehalfOf: self! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:11'!step: aContext 	"Resume self until aContext is on top, or if already on top, do next step"	^Processor activeProcess		evaluate:			[self suspendedContext == aContext				ifTrue: [self step]				ifFalse: [self complete: (self calleeOf: aContext)]]		onBehalfOf: self! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:52'!stepToCallee	"Step until top context changes"	Processor activeProcess		evaluate:			[| ctxt |			ctxt := suspendedContext.			[ctxt == suspendedContext] whileTrue: [				suspendedContext := suspendedContext step]]		onBehalfOf: self.	^suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'eem 9/7/2009 11:10'!stepToSendOrReturn	^Processor activeProcess		evaluate: [suspendedContext := suspendedContext stepToSendOrReturn]		onBehalfOf: self! !!Process methodsFor: 'error handling' stamp: 'ar 12/6/2006 11:24'!handleError: anError	"Handle an otherwise unhandled error which occurred in the receiver. If an error handler is installed for the process, delegate the exception to the error handler. If not, delegate it to the default SystemErrorHandler."	^(errorHandler ifNil:[SystemErrorHandler default]) handleError: anError! !!Process methodsFor: 'private' stamp: 'eem 9/7/2009 11:10'!evaluate: aBlock onBehalfOf: aProcess	"Evaluate aBlock setting effectiveProcess to aProcess.  Used	 in the execution simulation machinery to ensure that	 Processor activeProcess evaluates correctly when debuggng."	| oldEffectiveProcess |	oldEffectiveProcess := effectiveProcess.	effectiveProcess := aProcess.	^aBlock ensure: [effectiveProcess := oldEffectiveProcess]! !!Process commentStamp: '<historical>' prior: 0!I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.(If anyone ever makes a subclass of Process, be sure to use allSubInstances in anyProcessesAbove:.)!!ProcessTerminateBug methodsFor: 'tests' stamp: 'm 7/28/2003 19:10'!testSchedulerTermination   | process sema gotHere sema2 |   gotHere := false.   sema := Semaphore new.   sema2 := Semaphore new.   process := [       sema signal.       sema2 wait.       "will be suspended here"       gotHere := true. "e.g., we must *never* get here"   ] forkAt: Processor activeProcess priority.   sema wait. "until process gets scheduled"   process terminate.   sema2 signal.   Processor yield. "will give process a chance to continue andhorribly screw up"   self assert: gotHere not.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 3/3/2010 21:39'!testTerminationDuringUnwind	"An illustration of the issue of process termination during unwind.	This uses a well-behaved unwind block that we should allow to complete	if at all possible."	| unwindStarted unwindFinished p |	unwindStarted := unwindFinished := false.	p := [[] ensure:[			unwindStarted := true.			Processor yield.			unwindFinished := true.		]] fork.	self deny: unwindStarted.	Processor yield.	self assert: unwindStarted.	self deny: unwindFinished.	p terminate.	self assert: unwindFinished.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:44'!testUnwindFromActiveProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert:(sema isSignaled).	process := [		sema critical:[			self deny: sema isSignaled.			Processor activeProcess terminate.		]	] forkAt: Processor userInterruptPriority.	self assert: sema isSignaled.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:49'!testUnwindFromForeignProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [		sema critical:[			self deny: sema isSignaled.			sema wait. "deadlock"		]	] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"This is for illustration only - the BlockCannotReturn cannot 	be handled here (it's truncated already)"	self shouldnt: [process terminate] raise: BlockCannotReturn.	self assert: sema isSignaled.	! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'eem 4/9/2010 14:43'!activePriority	"Answer the priority level of the currently running Process."	^activeProcess effectiveProcess priority! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'eem 9/7/2009 11:05'!activeProcess	"Answer the currently running Process."	^activeProcess effectiveProcess! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'eem 7/26/2010 12:21'!currentVMThreadId	"Answer the threadId of the VM's current thread."	"Processor currentVMThreadId"	<primitive: 227 error: errorCode>	^errorCode == nil		ifTrue: [1] "older VM without the primitive"		ifFalse: [self primitiveFailed]! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'eem 5/27/2009 10:16'!highestPriority: newHighestPriority	"Change the number of priority levels currently available for use."	| newProcessLists |	(quiescentProcessLists size > newHighestPriority		and: [self anyProcessesAbove: newHighestPriority])			ifTrue: [self error: 'There are processes with priority higher than '													,newHighestPriority printString].	newProcessLists := Array new: newHighestPriority.	1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do: 		[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].	(quiescentProcessLists size max: 1) to: newProcessLists size do: 		[:priority | newProcessLists at: priority put: LinkedList new].	quiescentProcessLists := newProcessLists! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'eem 3/3/2009 10:41'!highestPriorityRunnableProcess	[quiescentProcessLists reverseDo:		[:each| each isEmpty ifFalse: [^each first]]] valueUnpreemptively.	^nil	"| thisProcess interruptedProcess done |	thisProcess := Processor activeProcess.	done := false.	[(Delay forSeconds: 1) wait.	 interruptedProcess := Processor highestPriorityRunnableProcess.	 done := true] forkAt: Processor userInterruptPriority.	[done] whileFalse.	self assert: thisProcess == interruptedProcess"! !!ProcessorScheduler methodsFor: 'process state change' stamp: 'eem 4/9/2010 14:38'!terminateActive	"Terminate the process that is currently running."	activeProcess effectiveProcess terminate! !!ProcessorScheduler methodsFor: 'initialize-release' stamp: 'eem 5/27/2009 09:49'!initialize	quiescentProcessLists := Array new! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'eem 10/5/2009 11:39'!sweepHandIdleProcess	"A default background process which shows a sweeping circle of XOR-ed bits on the screen."	| sweepHand |	(sweepHand := Pen new)					defaultNib: 2;					combinationRule: (Display depth = 1 ifTrue: [6] ifFalse: [8]).	[sweepHand north.	 36 timesRepeat:		[sweepHand			place: Display boundingBox topRight + (-25@25);			go: 20;			turn: 10.		 self relinquishProcessorForMicroseconds: 10000].	 true] whileTrue! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'bgf 9/8/2007 21:40'!currentTweakProject	"If Tweak (the project extensions to Processor, and CProgressBar) is present,	 and the current execution is in a Tweak project, return the project."	(Smalltalk at: #CProgressBar ifAbsent: [ nil] ) ifNil: [ ^ nil ].	(Processor respondsTo: #activeProject) ifTrue: [		^ Processor perform: #activeProject	].	^ nil! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'ar 2/4/2010 14:40'!defaultMorphicAction	| result progress bar at |	"If we're in a Tweak project, use the Tweak progress bar."	self currentTweakProject ifNotNilDo: [ : project |		at := project world ifNotNilDo: [:w | w bounds center] ifNil: [20@20].		bar := (Smalltalk at: #CProgressBar) new.		[ result := bar displayProgress: progressTitle at: at from: minVal to: maxVal during: workBlock ]		ensure: [bar close].		self resume: result.			] ifNil: [		progress := SystemProgressMorph label: progressTitle min: minVal max: maxVal.		[				[result := workBlock value: progress] on: ProgressNotification do:[:ex|				ex extraParam isString ifTrue:[					SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam.				].				ex resume.			].		] ensure: [SystemProgressMorph close: progress].		self resume: result	]! !!ProjectController methodsFor: 'control activity' stamp: 'dtl 11/23/2009 23:38'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index := (UIManager default chooseFrom: #('enter' 'jump to project...') lines: #()).	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false revert: false saveForRevert: false].	index = 2 ifTrue: [Project current jumpToProject. ^ self].! !!ProjectLauncher methodsFor: 'running' stamp: 'ar 6/21/2010 18:51'!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (Smalltalk documentPath) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					"Allow for ../dir/scriptName arguments"					scriptName := (FileDirectory default uri 						resolveRelativeURI: scriptName) asString]].		]]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!ProjectLoading class methodsFor: 'loading' stamp: 'ar 6/21/2010 11:16'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!ProjectView methodsFor: 'displaying' stamp: 'tk 4/19/2000 17:15'!armsLengthCommand: aCommand	"Set up a save to be done after the subproject exits to here.  displayOn: checks it."	ArmsLengthCmd := aCommand.! !!ProjectView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ false! !!ProjectView methodsFor: 'displaying' stamp: 'tk 6/21/2000 16:22'!displayDeEmphasized	| cmd |	"Display this view with emphasis off.  Check for a command thatcould not be executed in my subproject.  Once it is done, remove thetrigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	ArmsLengthCmd first == model ifFalse: [^ self].	"not ours"	cmd := ArmsLengthCmd second.	ArmsLengthCmd := nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectView methodsFor: 'displaying' stamp: 'sw 1/11/2000 15:32'!displayView	super displayView.	self label = model name		ifFalse: [self setLabelTo: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !!ProjectView methodsFor: 'initialization'!defaultControllerClass	^ ProjectController! !!ProjectView methodsFor: 'initialization' stamp: 'ar 9/27/2005 20:10'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSet named: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'ar 9/27/2005 20:10'!relabel: newLabel	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSet named: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ self].	model projectChangeSet name: newLabel.	super relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 1/11/2000 15:30'!uncacheBits	super uncacheBits.	self label ~=  model name ifTrue: [self setLabelTo: model name]! !!ProjectView class methodsFor: 'as yet unclassified'!open: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView controller open! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 10:35'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on 	the display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject		enter: false		revert: false		saveForRevert: false! !!PromiseTest methodsFor: 'testing' stamp: 'jcg 4/5/2010 00:36'!testChainedResolvers	| promise1 promise2 result |	promise1 := Promise new.	promise2 := Promise new.	promise1 whenResolved: [:bool | promise2 resolveWith: bool not].	promise2 whenResolved: [:bool | result := bool].	promise1 resolveWith: false.	self should: [result].! !!PromiseTest methodsFor: 'testing' stamp: 'jcg 4/5/2010 00:31'!testMultipleResolvers	| promise sum |	sum := 0.	promise := Promise new.	5 timesRepeat: [		promise whenResolved: [:val | sum := sum + val].	].	promise resolveWith: 5.	self should: [sum = 25].	! !!PromiseTest methodsFor: 'testing' stamp: 'jcg 4/5/2010 00:30'!testSingleResolver	| promise sum |	sum := 0.	promise := Promise new.	promise whenResolved: [:val | sum := sum + val].	promise resolveWith: 5.	self should: [sum = 5].	! !!PromiseTest methodsFor: 'testing' stamp: 'jcg 4/6/2010 01:38'!testTimeout	| promise |	promise := Promise new.	self shouldnt: [promise waitTimeoutMSecs: 1].	self shouldnt: [promise isResolved].	promise resolveWith: 45.	self should: [promise waitTimeoutMSecs: 1].	self should: [promise isResolved].	! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1 with: arg2	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1 with: arg2 with: arg3	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'debugging' stamp: 'jdm 11/21/2007 10:14'!breakOnce	self doOnlyOnce: [ self break ].! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:05'!testFlag		self shouldnt: [ProtoObject new flag: #hallo] raise: Error.! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:40'!testIfNil		| object block |	object := ProtoObject new.	self shouldnt: [ object ifNil: [ self halt ]] raise: Halt.	self assert: (object ifNil: [ nil ]) == object.	"Now the same without inlining."	block := [ self halt ].	self shouldnt: [ object ifNil: block ] raise: Halt.	block := [ nil ].	self assert: (object ifNil: block) == object.	! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:49'!testIfNilIfNotNil	| object returnValue block |	object := ProtoObject new.	returnValue := Object new.	self should: [ object ifNil: [ self error ] ifNotNil: [ self halt ] ] raise: Halt.	self should: [ object ifNil: [ self error ] ifNotNil: [ :o | self halt ] ] raise: Halt.	self assert: (object ifNil: [ false ] ifNotNil: [ :o | o == object ]).	self assert: (object ifNil: [ nil ] ifNotNil: [ returnValue ]) == returnValue.	self assert: (object ifNil: [ nil ] ifNotNil: [ :o | returnValue ]) == returnValue.	"Now the same without inlining."	block := [ self halt ].	self should: [ object ifNil: [ self error ] ifNotNil: block ] raise: Halt.	block := [ :o | self halt ].	self should: [ object ifNil: [ self error ] ifNotNil: block ] raise: Halt.	block := [ :o | o == object ].	self assert: (object ifNil: [ false ] ifNotNil: block).	block := [ returnValue ].	self assert: (object ifNil: [ nil ] ifNotNil: block) = returnValue.	block := [ :o | returnValue ].	self assert: (object ifNil: [ nil ] ifNotNil: block) = returnValue! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:48'!testIfNotNil	| object returnValue block |	object := ProtoObject new.	returnValue := Object new.	self should: [ object ifNotNil: [ self halt ] ] raise: Halt.	self should: [ object ifNotNil: [ :o | self halt ] ] raise: Halt.	self assert: (object ifNotNil: [ :o | o == object ]).	self assert: (object ifNotNil: [ returnValue ]) == returnValue.	self assert: (object ifNotNil: [ :o | returnValue ]) == returnValue.		"Now the same without inlining."	block := [ self halt ].	self should: [ object ifNotNil: block ] raise: Halt.	block := [ :o | self halt ].	self should: [ object ifNotNil: block ] raise: Halt.	block := [ :o | o == object ].	self assert: (object ifNotNil: block).	block := [ returnValue ].	self assert: (object ifNotNil: block) = returnValue.	block := [ :o | returnValue ].	self assert: (object ifNotNil: block) = returnValue! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:48'!testIfNotNilIfNil	| object returnValue block |	object := ProtoObject new.	returnValue := Object new.	self should: [ object ifNotNil: [ self halt ] ifNil: [ self error ]  ] raise: Halt.	self should: [ object ifNotNil: [ :o | self halt ] ifNil: [ self error ] ] raise: Halt.	self assert: (object ifNotNil: [ :o | o == object ] ifNil: [ false ]).	self assert: (object ifNotNil: [ returnValue ] ifNil: [ false ]) == returnValue.	self assert: (object ifNotNil: [ :o | returnValue ] ifNil: [ false ]) == returnValue.	"Now the same without inlining."	block := [ self halt ].	self should: [ object ifNotNil: block ifNil: [ self error ]  ] raise: Halt.	block := [ :o | self halt ].	self should: [ object ifNotNil: block ifNil: [ self error ] ] raise: Halt.	block := [ :o | o == object ].	self assert: (object ifNotNil: block ifNil: [ false ]).	block := [ returnValue ].	self assert: (object ifNotNil: block ifNil: [ false ]) == returnValue.	block := [ :o | returnValue ].	self assert: (object ifNotNil: block ifNil: [ false ]) == returnValue! !!ProtoObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:48'!testIsNil	self deny: ProtoObject new isNil! !!ProtoObjectTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ProtoObject. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:56'!prototype	"Get a prototype"	^ prototype copy ! !!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/3/2006 22:39'!prototype: aPrototype 	"Set my prototype"	prototype := aPrototype copy ! !!PrototypeTester methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 18:57'!result	"Perform the test the default number of times"	^ self resultFor: self class defaultRuns ! !!PrototypeTester commentStamp: 'mjr 8/20/2003 13:09' prior: 0!I am a simple holder of a prototype object and hand out copies when requested.!!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!defaultRuns"the default number of times to test"	^ 50! !!PrototypeTester class methodsFor: 'as yet unclassified' stamp: 'mjr 8/20/2003 13:08'!with: aPrototype	^self new prototype:aPrototype! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:34'!interruptPassword	"The interrupt password to unseal the product"	^properties at: 'client.password' ifAbsent:['']! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 4/16/2011 18:50'!mcProductPrefix	"Product prefix for the different build entities"	^'OpenQwaq'! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 4/16/2011 18:51'!packageSpec	"Client packages for the build"	^{		self squeakCorePackages.		self squeakSupportPackages.		self squeakTestPackages.		self tweakCorePackages.		self hedgehogPackages.		self thirdPartyPackages.		self openqwaqClientPackages.		self pythonPackages.		self miramarPackages.		self stuffPackages.	}! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 7/1/2010 00:17'!prepareDevImage	"If necessary, prepare some things that should happen for the developer image"	^self prepareDevImage: true! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 4/16/2011 18:51'!unsealedImageName	"The name to use for the unsealed (developer) image"	^'OpenQwaq-', self version,'.image'! !!QClientImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:35'!version	"The version name for this build"	^properties at: 'client.version' ifAbsent:['anonymous build']! !!QClientImageBuilder commentStamp: 'ar 4/16/2011 18:50' prior: 0!Builds OpenQwaq Client images.!!QClientImageBuilder class methodsFor: 'LICENSE' stamp: 'osar 4/20/2011 10:25'!LICENSE	^'Project OpenQwaq	Copyright (c) 2005-20011, Teleplace, Inc., All Rights Reserved	Redistributions in source code form must reproduce the above	copyright and this condition.	The contents of this file are subject to the GNU General Public	License, Version 2 (the "License"); you may not use this file	except in compliance with the License. A copy of the License is	available at http://www.opensource.org/licenses/gpl-2.0.php.'! !!QImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:32'!build	"Build the new image"	| configList |	configList := self buildConfigurations.	self loadConfigurations: configList.	self storeConfigurations: configList.	configList := nil.	self generateChangeLog.	self checkForModifications.	self ensureBitstreamVeraSizes.	"self installLucidaGrande."	self initializeCommonParts.	self updateVersionInfo.	self prepareDevImage.! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/20/2010 11:57'!buildConfigurations	"Build a list of configurations from the package spec"	self log: 'Updating package list'.	^self packageSpec collect:[:spec| | config repo |		config := MCConfiguration new.		config name: spec first.		repo := MCHttpRepository 					location: spec first 					user: self username 					password: self password.		config repositories add: repo.		spec last do:[:pkgName|			config dependencies add:		           (MCConfiguration dependencyFromArray:		               { pkgName. pkgName,'-unknown.1'. UUID new asString})].		config versionBlock:[:verdep| self log: '	(adding) ',  verdep versionInfo name].		config updateFromRepositories.	].! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/20/2010 12:00'!checkForModifications	"Check all the package versions for modifications"	self log: 'Checking for modifications'.	(MCWorkingCopy allManagers 		sort:[:wcA :wcB| wcA packageName <= wcB packageName]) do:[:wc|		wc modified: (wc changesRelativeToRepository: 			wc repositoryGroup repositories second) isEmpty not.		self log: '	', (wc modified ifTrue:['(MODIFIED)'] ifFalse:['(ok)']),' ',				wc ancestors anyOne name.	] displayingProgress: 'Checking for modifications'.! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/23/2010 10:28'!ensureBitstreamVeraSizes	"Ensure the presence of all required BitStreamVeraSans sizes"	| style defaultFont sizes fonts ptSize font |	style := TextStyle named: 'BitstreamVeraSans'.	defaultFont := style defaultFont.	sizes := #(7 8 9 10 11 12 13 14 15 16 18 24 30 36 48).	fonts := Array new: sizes size.	1 to: fonts size do:[:i|		ptSize := sizes at: i.		font := style fontArray detect:[:each| each pointSize = ptSize] ifNone:[nil].		font ifNil:[			font := defaultFont class new.			font ttcDescription: defaultFont ttcDescription.			font pointSize: ptSize.		].		fonts at: i put: font.	].	style newFontArray: fonts.	style defaultFont: defaultFont.! !!QImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:31'!generateChangeLog	"Generate the changelog.txt file for the build"	| repository config target source updates stream |	self log: 'Generating change log'.	repository := MCHttpRepository		location: 'http://www.squeaksource.com/openqwaq'		user: self username		password: self password.	[repository readStreamForFileNamed: (self mcProductPrefix, '-', self priorVersion, '.mcm') do:[:s|		config := MCConfiguration fromArray: (MCScanner scan: s).	]] on: Error do:[:ex| Transcript cr; show: ex description].	config ifNil:[^self].	updates := OrderedCollection new.	config dependencies do:[:verdep|		source := verdep package workingCopy ancestors anyOne.		target := verdep versionInfo.		source = target ifFalse:[			{source}, (source allAncestorsOnPathTo: target) do:[:info| updates add: info].		].	].	stream := FileStream forceNewFileNamed: self mcProductPrefix, 'Changes.txt'.	[updates do: [:info| | msg |		msg := info message withBlanksTrimmed.		stream nextPutAll: info name;				     space; nextPutAll: (info timeStamp printString); cr;				     nextPutAll: msg; cr;				     nextPutAll: '................................................................'; cr	]] ensure:[stream close].! !!QImageBuilder methodsFor: 'building' stamp: 'eem 7/22/2010 17:31'!initializeCommonParts	"Initialize various common bits"	"Ensure splObjs up to date"	Smalltalk recreateSpecialObjectsArray.	"Ensure update url is cleared"	MCMcmUpdater defaultUpdateURL: ''.	"Ensure VM knows whether Process has threadId inst var or not."	Smalltalk processHasThreadIdInstVar: (Process instVarNames includes: 'threadId').	"Some day we might also want preemption not to yield."	"Smalltalk preemptionYields: false"! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/20/2010 10:40'!installLucidaGrande	"Download and install Lucida Grande"		| fontFile lucidaGrande |	self log: 'Installing Lucida Grande'.	fontFile := HTTPSocket 		httpGet: 'http://dev.qwaq.com/ss/Build/LucidaGrande.st.gz'		args: nil		user: self username		passwd: self password.	fontFile isString ifTrue:[^self error: 'Could not read font file'].	lucidaGrande := (RWBinaryOrTextStream with: fontFile contents unzipped) reset fileInObjectAndCode.	TextConstants at: #'Lucida Grande' put: lucidaGrande.	TextStyle setDefault: lucidaGrande.	Preferences setControlFontTo: lucidaGrande defaultFont.! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/21/2010 12:27'!launchApp	"Launch the app"	^self subclassResponsibility! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/20/2010 11:57'!loadConfigurations: configList	"Load the configurations"	self log: 'Loading updated packages'.	MCRepositoryGroup default initialize.	configList do:[:each|  | repoGroup |		each versionBlock:[:ver| self log: '	(loading) ',  ver info name].		each load.		repoGroup := MCRepositoryGroup new.		each repositories do:[:repo| 			repoGroup addRepository: repo.			MCRepositoryGroup default addRepository: repo.		].		each dependencies do:[:dep| 			dep package workingCopy repositoryGroup: repoGroup.		].	].! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/15/2010 17:15'!packageSpec	^self subclassResponsibility! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/1/2010 00:20'!prepareDevImage	"If necessary, prepare some things that should happen for the developer image"! !!QImageBuilder methodsFor: 'building' stamp: 'ar 7/20/2010 11:02'!prepareDevImage: isClient	"If necessary, prepare some things that should happen for the developer image"	Smalltalk windowSize: 1000@700.	Smalltalk at: #UsefulScripts ifPresent:[:aClass| aClass prepareDevImage: isClient].! !!QImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:31'!storeConfigurations: configList	"Store the build configuration in the release repository"	| config |	self username isEmptyOrNil ifTrue:[^self].	config := MCConfiguration new..	config name: self mcProductPrefix,'-',self version.	configList do:[:each|		"Copy the repositories from each piece to the release config"		each repositories do:[:repo|			(config repositories anySatisfy:[:r| r description = repo description])				ifFalse:[config repositories add: repo]].		"Do the same for the package versions"		config dependencies addAll: each dependencies.	].	"And save it"	(MCHttpRepository		location: 'http://www.squeaksource.com/openqwaq'		user: self username		password: self password) storeVersion: config.! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/21/2010 14:33'!storeImageUnsealed	"Store the unseald (developer) image after having loaded all packages"		self prepareDevImage.	"FIXME: #saveAs: does not return true/false depending on whether	the image was restarted or not. As a result we must save twice so	we can capture the actual result of the operation"	Smalltalk saveAs: self unsealedImageName.	"Remove properties since they contain user names, passwords etc"	properties removeAll.	"Second time will return true/false depending on resumption state"	^Smalltalk snapshot: true andQuit: false! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/15/2010 17:49'!unsealedImageName	"The name to use for the unsealed (developer) image"	^self subclassResponsibility! !!QImageBuilder methodsFor: 'building' stamp: 'ar 6/17/2010 14:57'!updateVersionInfo	Smalltalk at: #QwaqVersion ifPresent:[:aClass|		aClass newVersion: self versionString.	].! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!hedgehogPackages	"The Hedgehog packages"	^#('http://www.squeaksource.com/openqwaq'		('3DTransform' 'OpenGL' 'OpenAL' 'Croquet-SharedPools' 		'Croquet-Kernel' 'Croquet-Objects' 'Croquet-Router' 		'Croquet-Contacts' 'Croquet-Copier' 'Croquet-Demo' 		'Croquet-Embed' 'Croquet-Harness' 'Croquet-Import' 		'Croquet-Menus' 'Croquet-Misc' 'Croquet-Persist' 		'Croquet-Physics' 'Croquet-Streaming' 'Croquet-Window' 		'Croquet-Islands' 'VRML'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!miramarPackages	"Miramar packages"	^#('http://www.squeaksource.com/openqwaq'		('Miramar-Objects' 'Miramar-Streaming' 		'Miramar-Workspace'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!openqwaqClientPackages	"Main OpenQwaq client packages"	^#('http://www.squeaksource.com/openqwaq'		('QTest' 'Qwaq-SharedPools' 'Qwaq-Animation' 		'Qwaq-Benchmarks' 'Qwaq-Client' 'Qwaq-FFI' 		'Qwaq-Objects' 'Qwaq-Widgets' 'Qwaq-Streaming' 		'Qwaq-Service' 'Qwaq-Server' 'Qwaq-Stereo' 		'Qwaq-Video' 'Qwaq-VNC' 'Qwaq-Sound' 'Qwaq-Tools' 		'Qwaq-PShare' 'Qwaq-Test' 'Qwaq-Unix' 		'QwaqDemo-Client' 'QwaqDemo-Demo' 		'QwaqDemo-Forums' 'QwaqDemo-Test' 'Qwaq-SharePoint'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!openqwaqServerPackages	"SERVER only OpenQwaq packages"	^#('http://www.squeaksource.com/openqwaq'		('Qwaq-ODBC' 'Qwaq-EC2' 'Qwaq-Cloud'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!pythonPackages	"Python support packages"	^#('http://www.squeaksource.com/openqwaq'		('PyBridge'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:53'!squeakCorePackages	"The Squeak core packages, i.e., the packages already present in the base image"	^#('http://www.squeaksource.com/openqwaq'		('Balloon' 'Collections' 'Compiler' 'Compression' 		'Exceptions' 'Files' 'Graphics' 'Kernel' 'Monticello' 		'MonticelloConfigurations' 'Morphic' 'MorphicExtras' 		'Multilingual' 'Network' 'PackageInfo-Base' 'SUnit' 		'ShoutCore' 'Sound' 'Squeak-Version' 'System' 		'ToolBuilder-Kernel' 'ToolBuilder-Morphic' 		'ToolBuilder-SUnit' 'Tools' 'TrueType' 'Installer-Core'		"Tests and ST80 two shouldn't really be necessary but are		required by other packages (Tests by XML-Parser;		MVC by various other packages)"		'Tests'  'ST80' ))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!squeakSupportPackages	"The packages we need from Squeak but which are not in the base image"	^#('http://www.squeaksource.com/openqwaq'		('FFI-Pools' 'FFI-Kernel' 'FFI-Win32' 'FFI-Unix' 'FFI-MacOS' 		'XML-Parser' 'Movies' 'SUnitGUI' 'PreferenceBrowser' 'TweakMC'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!squeakTestPackages	"The Squeak unit test packages that we should load"	^#('http://www.squeaksource.com/openqwaq'		('CollectionsTests' 'GraphicsTests' 'KernelTests' 'MorphicTests'		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'FFI-Tests')	)! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:29'!stuffPackages	"Assorted packages"	^#('http://www.squeaksource.com/openqwaq' ('Brad'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:30'!thirdPartyPackages	"Some third party packages used by us"	^#('http://www.squeaksource.com/openqwaq'		('Alien' 'Crypto-RSA' 'MAPI-Client' 'RFB' 'TerrainBuilder' 			'WebClient-Core' 'WebClient-Tests'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:30'!thirdPartyServerPackages	"Third party packages for the SERVER only"		^#('http://www.squeaksource.com/openqwaq'		('ODBC' 'OSProcess' 'CommandShell'))! !!QImageBuilder methodsFor: 'packages' stamp: 'ar 5/23/2011 09:30'!tweakCorePackages	"The Tweak packages"	^#('http://www.squeaksource.com/openqwaq'		('Scripting-Preload' 'Scripting' 'Islands' 		'Tweak-Preload' 'Tweak-Hacks' 'Tweak-Compiler' 		'Tweak-Core-Proto' 'Tweak-Core-Object' 'Tweak-Costume'		 'Tweak-Basic' 'Tweak-Platforms' 'Tweak-Widgets' 		'Tweak-Morphic' 'Tweak-Projects' 'Tweak-ToolBuilder' 		'Tweak-Shout'))! !!QImageBuilder methodsFor: 'initialize' stamp: 'ar 5/23/2011 09:34'!initialize	properties := Dictionary new.! !!QImageBuilder methodsFor: 'initialize' stamp: 'ar 7/20/2010 10:35'!log: aString	"Log activity"	logFile ifNotNil:[logFile nextPutAll: aString; cr].! !!QImageBuilder methodsFor: 'initialize' stamp: 'ar 7/20/2010 10:35'!on: propsFileName	| data stream crlfSet delimSet line key value delim |	logFile := FileStream stdout.	propsFile := propsFileName.	data := (FileStream readOnlyFileNamed: propsFileName) contentsOfEntireFile.	properties := Dictionary new.	stream := data readStream.	crlfSet := String crlf asCharacterSet.	delimSet := '#=' asCharacterSet.	[stream atEnd] whileFalse:[		line := (stream upToAnyOf: crlfSet) withBlanksTrimmed readStream.		key := (line upToAnyOf: delimSet do:[:cc| delim := cc]) withBlanksTrimmed..		(key notEmpty and:[delim = $=]) ifTrue:[			line skipSeparators.			value := (line upTo: $#) withBlanksTrimmed.			properties at: key put: value.		].	].! !!QImageBuilder methodsFor: 'properties' stamp: 'ar 6/30/2010 23:55'!interruptPassword	"The interrupt password to unseal the product"	^self subclassResponsibility! !!QImageBuilder methodsFor: 'properties' stamp: 'ar 6/21/2010 11:53'!mcProductPrefix	"Product prefix for the different build entities"	^self subclassResponsibility! !!QImageBuilder methodsFor: 'properties' stamp: 'ar 6/21/2010 11:57'!priorVersion	"The name of the previous version"	^(self version copyUpToLast: $.), '.', ((self version copyAfterLast: $.) asNumber - 1)! !!QImageBuilder methodsFor: 'properties' stamp: 'ar 6/16/2010 10:42'!version	"The version name for this build"	^self subclassResponsibility! !!QImageBuilder methodsFor: 'properties' stamp: 'ar 6/21/2010 11:54'!versionString	^self mcProductPrefix, ' ', self version! !!QImageBuilder methodsFor: 'accessing' stamp: 'ar 7/20/2010 10:44'!logFile	"The log file for the build"	^logFile! !!QImageBuilder methodsFor: 'accessing' stamp: 'ar 7/20/2010 10:44'!logFile: aFileStream	"The log file for the build"	logFile := aFileStream! !!QImageBuilder methodsFor: 'accessing' stamp: 'ar 5/23/2011 09:33'!password	^properties at: 'mc.password' ifAbsent:['']! !!QImageBuilder methodsFor: 'accessing' stamp: 'ar 5/23/2011 09:33'!username	^properties at: 'mc.username' ifAbsent:['']! !!QImageBuilder commentStamp: 'ar 6/15/2010 17:03' prior: 0!Builds images from various package specs.!!QImageBuilder class methodsFor: 'LICENSE' stamp: 'osar 4/20/2011 10:25'!LICENSE	^'Project OpenQwaq	Copyright (c) 2005-20011, Teleplace, Inc., All Rights Reserved	Redistributions in source code form must reproduce the above	copyright and this condition.	The contents of this file are subject to the GNU General Public	License, Version 2 (the "License"); you may not use this file	except in compliance with the License. A copy of the License is	available at http://www.opensource.org/licenses/gpl-2.0.php.'! !!QImageBuilder class methodsFor: 'instance creation' stamp: 'ar 6/16/2010 12:22'!buildFrom: propsFileName	^(self on: propsFileName) build! !!QImageBuilder class methodsFor: 'instance creation' stamp: 'ar 6/16/2010 12:21'!on: propsFileName	^self new on: propsFileName! !!QImageBuilder class methodsFor: 'instance creation' stamp: 'ar 5/23/2011 10:54'!run	^self new build! !!QServerImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:35'!interruptPassword	"The interrupt password to unseal the product"	^properties at: 'server.password' ifAbsent:['']! !!QServerImageBuilder methodsFor: 'building' stamp: 'ar 6/21/2010 11:54'!mcProductPrefix	"Product prefix for the different build entities"	^'Server'! !!QServerImageBuilder methodsFor: 'building' stamp: 'ar 4/16/2011 18:54'!packageSpec	"Server packages for the build"	^{		self squeakCorePackages.		self squeakSupportPackages.		self squeakTestPackages.		self tweakCorePackages.		self hedgehogPackages.		self thirdPartyPackages.		self openqwaqClientPackages.		self openqwaqServerPackages.		self thirdPartyServerPackages.		self pythonPackages.		self miramarPackages.		self stuffPackages.	}! !!QServerImageBuilder methodsFor: 'building' stamp: 'ar 7/1/2010 00:17'!prepareDevImage	"If necessary, prepare some things that should happen for the developer image"	^self prepareDevImage: false! !!QServerImageBuilder methodsFor: 'building' stamp: 'ar 5/23/2011 09:35'!version	"The version name for this build"	^properties at: 'server.version' ifAbsent:['anonymous build']! !!QServerImageBuilder commentStamp: 'ar 4/16/2011 18:55' prior: 0!Builds OpenQwaq server images.!!QServerImageBuilder class methodsFor: 'LICENSE' stamp: 'osar 4/20/2011 10:25'!LICENSE	^'Project OpenQwaq	Copyright (c) 2005-20011, Teleplace, Inc., All Rights Reserved	Redistributions in source code form must reproduce the above	copyright and this condition.	The contents of this file are subject to the GNU General Public	License, Version 2 (the "License"); you may not use this file	except in compliance with the License. A copy of the License is	available at http://www.opensource.org/licenses/gpl-2.0.php.'! !!RWBinaryOrTextStreamTest methodsFor: 'tests' stamp: 'ar 9/1/2009 00:43'!testNextPutAll		| stream |	stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'hello'.	self assert: stream contents = 'hello'.	stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'hello' asArray.	self assert: stream contents = 'hello'.	stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'hello' asByteArray.	self assert: stream contents = 'hello'! !!RWBinaryOrTextStreamTest methodsFor: 'tests' stamp: 'ar 9/1/2009 00:45'!testUpTo	| stream |	stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'world'; reset.	self assert: (stream upTo: $r) = 'wo'.	self assert: stream next = $l.		stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'hello'; reset.	self assert: (stream upTo: $x) = 'hello'.	self assert: stream atEnd.		stream := RWBinaryOrTextStream on: String new.	stream binary.	stream nextPutAll: 'world'; reset.	self assert: (stream upTo: $r asciiValue) = 'wo' asByteArray.	self assert: stream next = $l asciiValue.		stream := RWBinaryOrTextStream on: String new.	stream binary.	stream nextPutAll: 'hello'; reset.	self assert: (stream upTo: $x asciiValue) = 'hello' asByteArray.	self assert: stream atEnd.! !!RWBinaryOrTextStreamTest methodsFor: 'tests' stamp: 'ar 9/1/2009 00:46'!testUpToEnd		| stream |	stream := RWBinaryOrTextStream on: String new.	stream nextPutAll: 'world'; reset.	self assert: stream upToEnd = 'world'.	self assert: stream atEnd.	self assert: stream upToEnd = ''.	self assert: stream atEnd.		stream reset.	stream upTo: $r.	self assert: stream upToEnd = 'ld'.	self assert: stream atEnd.		stream := RWBinaryOrTextStream on: String new.	stream binary.	stream nextPutAll: 'world'; reset.	self assert: stream upToEnd = 'world' asByteArray.	self assert: stream atEnd.	self assert: stream upToEnd = ByteArray new.	self assert: stream atEnd.		stream reset.	stream upTo: $r asciiValue.	self assert: stream upToEnd = 'ld' asByteArray.	self assert: stream atEnd! !!RandomTest methodsFor: 'setup' stamp: 'md 4/2/2003 12:32'!setUp	gen := Random seed: 112629.! !!RandomTest methodsFor: 'tests' stamp: 'md 4/2/2003 12:50'!testNext	10000 timesRepeat: [			| next | 			next := gen next.			self assert: (next >= 0).			self assert: (next < 1).	].! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:41'!accept 	"Overridden to allow accept of clean text"	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 14:02'!userHasEdited	"Ignore this -- I stay clean"! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:45'!zapSelectionWith: aText	view flash  "no edits allowed"! !!ReadStream methodsFor: 'accessing' stamp: 'bgf 5/23/2008 18:04'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	"<primitive: 65>  Doesn't pay its way."	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadStream methodsFor: 'accessing' stamp: 'ar 6/25/2007 14:33'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	n < 0 ifTrue:[^self error: 'Cannot read negative amounts'].	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!ReadStream methodsFor: 'accessing' stamp: 'bgf 12/1/2008 15:44'!nextFloat	"Read a floating point value from the receiver. This method is highly optimized for cases	where many floating point values need to be read subsequently. And if this needs to go	even faster, look at the inner loops fetching the characters - moving those into a plugin	would speed things up even more."	"Note that we use the incantation		((buffer at: index) asInteger)	instead of 'byteAt:' , in order to go through the at-cache in the primitive mechanism. "	| buffer count sign index cc value digit fraction exp startIndex anyDigit digitNeeded |	buffer := collection.	count := readLimit.	index := position+1.	"Skip separators"	index := ByteString findFirstInString: buffer inSet: String noSeparatorMap startingAt: index.	index = 0 ifTrue:[self setToEnd. ^nil].	"check for sign"	digitNeeded := false.	sign := 1. cc := ((buffer at: index) asInteger).	cc = 45 "$- asciiValue"		ifTrue:[sign := -1. index := index+1. digitNeeded := true]		ifFalse:[cc =  43 "$+ asciiValue" ifTrue:[index := index+1. digitNeeded := true]].	"Read integer part"	startIndex := index.	value := 0.	[index <= count and:[		digit :=((buffer at: index) asInteger)  - 48. "$0 asciiValue"		digit >= 0 and:[digit <= 9]]] whileTrue:[			value := value * 10 + digit.			index := index + 1.	].	anyDigit := index > startIndex.	index > count ifTrue:[		(digitNeeded and:[anyDigit not]) ifTrue:[^self error: 'At least one digit expected'].		self setToEnd. ^value asFloat * sign].	((buffer at: index) asInteger) = 46 "$. asciiValue" ifTrue:["<integer>.<fraction>"		index := index+1.		startIndex := index.		"NOTE: fraction and exp below can overflow into LargeInteger range. If they do, then things slow down horribly due to the relatively slow LargeInt -> Float conversion. This can be avoided by changing fraction and exp to use floats to begin with (0.0 and 1.0 respectively), however, this will give different results to Float>>readFrom: and it is not clear if that is acceptable here."		fraction := 0. exp := 1.		[index <= count and:[			digit := ((buffer at: index) asInteger)  - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				fraction := fraction * 10 + digit.				exp := exp * 10.				index := index + 1.		].		value := value + (fraction asFloat / exp asFloat).		anyDigit := anyDigit or:[index > startIndex].	].	value := value asFloat * sign.	"At this point we require at least one digit to avoid allowing:		- . ('0.0' without leading digits)		- e32 ('0e32' without leading digits) 		- .e32 ('0.0e32' without leading digits)	but these are currently allowed:		- .5 (0.5)		- 1. ('1.0')		- 1e32 ('1.0e32')		- 1.e32 ('1.0e32')		- .5e32 ('0.5e32')	"	anyDigit ifFalse:["Check for NaN/Infinity first"		(count - index >= 2 and:[(buffer copyFrom: index to: index+2) = 'NaN'])			ifTrue:[position := index+2. ^Float nan * sign].		(count - index >= 7 and:[(buffer copyFrom: index to: index+7) = 'Infinity'])			ifTrue:[position := index+7. ^Float infinity * sign].		^self error: 'At least one digit expected'	].	index > count ifTrue:[self setToEnd. ^value asFloat].	((buffer at: index) asInteger)  = 101 "$e asciiValue" ifTrue:["<number>e[+|-]<exponent>"		index := index+1. "skip e"		sign := 1. cc := ((buffer at: index) asInteger) .		cc = 45 "$- asciiValue"			ifTrue:[sign := -1. index := index+1]			ifFalse:[cc = 43 "$+ asciiValue" ifTrue:[index := index+1]].		startIndex := index.		exp := 0. anyDigit := false.		[index <= count and:[			digit := ((buffer at: index) asInteger)  - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				exp := exp * 10 + digit.				index := index + 1.		].		index> startIndex ifFalse:[^self error: 'Exponent expected'].		value := value * (10.0 raisedToInteger: exp * sign).	].	position := index-1.	^value! !!ReadStream methodsFor: 'accessing' stamp: 'jcg 7/31/2009 18:08'!peek: nBytes	| oldPosition result |	self class == ReadStream ifFalse: [		"Simply resetting the position after reading isn't enough		 for many subclasses, such as InflateStream."		self subclassResponsibility. 	].	oldPosition := self position.	result := self next: nBytes.	self position: oldPosition.	^result	! !!ReadStreamTest methodsFor: 'accessing' stamp: 'dc 3/7/2007 13:48'!classUnderTest	^ ReadStream! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!emptyStream	^ ReadStream on: String new.! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnArray	^ ReadStream on: (Array with: 1 with: #(a b c) with: false).! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnString	^ ReadStream on: 'abcde'.! !!ReadStreamTest methodsFor: 'failures' stamp: 'ar 7/27/2010 12:23'!expectedFailures	"testNextFloat broke due to rounding mode changes"	^#(testNextFloat)! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:55'!streamOn: aCollection	^ self classUnderTest on: aCollection! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:58'!streamOn: collection upToAll: subcollection	^ (self streamOn: collection) upToAll: subcollection! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 2/28/2007 14:14'!streamOn: collection upToAll: subcollection1 upToAll: subcollection2	^(self streamOn: collection)		upToAll: subcollection1;		upToAll: subcollection2! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:10'!testAtEnd	| stream |	self assert: self emptyStream atEnd.	stream := self streamOnArray.	self deny: stream atEnd.	stream next: 3.	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:58'!testIsEmpty	| stream |	self assert: self emptyStream isEmpty.		stream := self streamOnArray.	self deny: stream isEmpty.	stream skip: 3.	self deny: stream isEmpty.		stream := self streamOnString.	self deny: stream isEmpty.	stream next;next;next.	self deny: stream isEmpty.	stream setToEnd.	self deny: stream isEmpty.! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:30'!testNextMatchFor	| stream |	stream := self streamOnArray.	self assert: (stream nextMatchFor: 1).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).		stream := self streamOnArray.	self deny: (stream nextMatchFor: false).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:48'!testPeekFor	| stream |	stream := self streamOnArray.	self assert: (stream peekFor: 1).	self assert: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).	stream := self streamOnArray.	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).	self assert: (stream peekFor: 1).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: false).	self assert: (stream peekFor: #(a b c)).		self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).		self assert: (stream atEnd).	self deny: (stream peekFor: nil).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:54'!testPeekFor2	| stream negative number |	stream := self streamOn: '- 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.	stream := self streamOn: '-145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.		stream := self streamOn: ' 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.		stream := self streamOn: '145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:19'!testBack	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream back = $b.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testBackOnPosition1	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream back = $a.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:20'!testOldBack	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream oldBack = $a.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testOldBackOnPosition1	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream oldBack = nil.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:07'!testBackUpTo1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self assert: (stream backUpTo: 'ab').	self assert: stream peek = $g! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:11'!testBackUpToEmptyPattern1	"This test represents the current behavior which is not clearly defined and could be revised."	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self should: [stream backUpTo: ''] raise: Error.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:08'!testBackUpToPatternNotFound1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self deny: (stream backUpTo: 'zz').	self assert: stream position = 0! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:38'!testPosition	| stream |	self assert: self emptyStream position isZero.		stream := self streamOnArray.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 14:14'!testPositionOfSubCollection		self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'q' ) = 0.	self assert: ((self streamOn: 'xyz')  positionOfSubCollection: 'x' ) = 1.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'y' ) = 2.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'z' ) = 3.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:44'!testReset	| stream |	stream := self emptyStream.	stream reset.	self assert: stream position = 0.		stream := self streamOnArray.	stream reset.	self assert: stream position = 0.	self deny: stream atEnd.	stream position: 3.	self assert: stream atEnd.	stream reset.	self assert: stream position = 0.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:41'!testSetPosition	| stream |	stream := self emptyStream.	self should: [stream position: -2] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	stream := self streamOnArray.	self should: [stream position: -1] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	self shouldnt: [stream position: 1] raise: Error.	self shouldnt: [stream position: 2] raise: Error.	"According to ANSI Smalltalk Standard 1.9 Draft, the following should be tested too:	self should: [stream position: 3] raise: Error.		However, I don't see the point of raising an error when positioning at the end.		I prefer testing the absence of error:	"	self shouldnt: [stream position: 3] raise: Error.	self should: [stream position: 4] raise: Error.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:47'!testSetToEnd	| stream |	stream := self emptyStream.	stream setToEnd.	self assert: stream atEnd.		stream := self streamOnArray.	stream setToEnd.	self assert: stream atEnd.	stream position: 1.	self deny: stream atEnd.	stream setToEnd.	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:32'!testContents	| stream |	self assert: self emptyStream contents = ''.		stream := self streamOnArray.	self assert: stream contents = #(1 #(a b c) false).	stream position: 3.	self assert: stream contents = #(1 #(a b c) false).		stream := self streamOnString.	self assert: stream contents = 'abcde'.	stream setToEnd.	self assert: stream contents = 'abcde'.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/6/2007 18:26'!testContents2	"From ANSI Smalltalk Standard draft 1.9: 			it is unspecified whether or not the returned collection [using #contents] is the same object as the backing store collection. However, if the returned collection is not the same object as the stream backing store collection then the class of the returned collection is the same class as would be returned if the message #select: was sent to the backing store collection."			"In Squeak, there is #species to know what class should be used on copy, selection..."	| interval stream streamContents |	interval := 1 to: 32.	stream := self streamOn: interval.	streamContents := stream contents.		(streamContents == interval)		ifFalse: [self assert: streamContents class = Interval new species]! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:23'!testNext	|stream|	stream := self streamOnArray.	self assert: stream next = 1.	self assert: stream next = #(a b c).	self assert: stream next = false.		stream := self streamOnString.	self assert: stream next = $a.	self assert: stream next = $b.	self assert: stream next = $c.	self assert: stream next = $d.	self assert: stream next = $e.	! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'nice 12/7/2009 09:51'!testNextLine	| lines text stream |	lines := #('line 1' ' and line 2' '' 'fourth').	text := lines first , String cr , lines second , String crlf , lines third , String lf , lines fourth.	stream := text readStream.	lines do: [:e |		self assert: stream nextLine = e].	self assert: stream nextLine = nil! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:24'!testNexts	self assert: (self emptyStream next: 0) isEmpty.	self assert: (self streamOnArray next: 0) isEmpty.	self assert: (self streamOnArray next: 1) = #(1).	self assert: (self streamOnArray next: 2) = #(1 #(a b c)).	self assert: (self streamOnArray next: 3) = #(1 #(a b c) false).! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:40'!testNexts2	| stream |	stream := self streamOnArray.	self assert: (stream next: 2) = #(1 #(a b c)).	self assert: (stream next: 1) = #(false).! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:35'!testPeek	| stream |	stream := self streamOnArray.		self assert: stream peek = 1.	self deny: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self assert: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self deny: stream peek = #(a b c).	self assert: stream peek = false.		stream next.		"In ANSI Smalltalk Standard Draft, it is said that nil will return nil at the end when using #peek."	self assert: stream peek isNil.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:37'!testPeek2	| stream |	stream := self streamOn: #(nil nil nil).		self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.		"Yes, #peek answers nil when there is no more element to read."	self assert: stream peek isNil.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:41'!testUpTo	| returnValue stream |	returnValue := (self emptyStream upTo: nil).	self assert: returnValue isCollection.	self assert: returnValue isEmpty.		stream := self streamOnArray.	returnValue := stream upTo: #(a b c).	self assert: returnValue = #(1).	self assert: stream peek = false.		stream := self streamOnArray.	returnValue := stream upTo: true.	self assert: returnValue = #(1 #(a b c) false).	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:42'!testUpTo2	| returnValue stream |	stream := self streamOnString.	returnValue := stream upTo: $d.	self assert: returnValue = 'abc'.	self assert: stream peek = $e.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'nice 12/9/2009 13:05'!testUpTo3	| stream string |	string := 'XYZabcdUVW'.	stream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).	self assert: stream upToEnd = 'abcd'.	self assert: stream atEnd.	stream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).	self assert: (stream upTo: $c) = 'ab'.	self assert: stream next = $d.	stream := ReadStream on: string from: (string indexOf: $a) to: (string indexOf: $d).	self assert: (stream upTo: $e) = 'abcd'.	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 14:14'!testUpToAll	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd') = 'ab'.	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd' upToAll: 'gh') = 'ef'.	self assert: (self streamOn: '' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: 'a') = ''.	self assert: (self streamOn: 'a' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: '') = ''.	self assert: (self streamOn: 'ab' upToAll: 'a') = ''.	self assert: (self streamOn: 'ab' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'ab' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: '') = ''.	self assert: (self streamOn: 'abc' upToAll: 'a') = ''.	self assert: (self streamOn: 'abc' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'abc' upToAll: 'd') = 'abc'.	self assert: (self streamOn: 'abc' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: 'bc') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'cd') = 'abc'.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'nice 12/7/2009 19:48'!testUpToAll2	| string stream array |	string := 'aababcabcd'.	stream := self streamOn: string.	self assert: (stream upToAll: 'a') = ''.	self assert: (stream upToEnd) = 'ababcabcd'.	stream := self streamOn: string.	self assert: (stream upToAll: 'ab') = 'a'.	self assert: (stream upToEnd) = 'abcabcd'.	stream := self streamOn: string.	self assert: (stream upToAll: 'abc') = 'aab'.	self assert: (stream upToEnd) = 'abcd'.	stream := self streamOn: string.	self assert: (stream upToAll: 'abcd') = 'aababc'.	self assert: (stream upToEnd) = ''.	stream := self streamOn: string.	self assert: (stream upToAll: 'abe') = 'aababcabcd'.	self assert: (stream upToEnd) = ''.		array := #(1 1 2 1 2 3 nil 1 2 3 4).	stream := self streamOn: array.	self assert: (stream upToAll: #(1)) = #().	self assert: (stream upToEnd) = #(1 2 1 2 3 nil 1 2 3 4).	stream := self streamOn: array.	self assert: (stream upToAll: #(1 2)) = #(1).	self assert: (stream upToEnd) = #(1 2 3 nil 1 2 3 4).	stream := self streamOn: array.	self assert: (stream upToAll: #(1 2 3)) = #(1 1 2).	self assert: (stream upToEnd) = #(nil 1 2 3 4).	stream := self streamOn: array.	self assert: (stream upToAll: #(1 2 3 4)) = #(1 1 2 1 2 3 nil).	self assert: (stream upToEnd) = #().	stream := self streamOn: array.	self assert: (stream upToAll: #(1 2 5)) = array.	self assert: (stream upToEnd) = #().! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'nice 12/7/2009 09:57'!testUpToAnyOf	| stream |	stream := 'abcde' readStream.	self assert: (stream upToAnyOf: String crlf) = 'abcde'.	self assert: stream atEnd.		stream := 'abcde' readStream.	self assert: (stream upToAnyOf: 'dc') = 'ab'.	self assert: stream upToEnd = 'de'.		stream := #( 1 2 nil true false 10 ) readStream.	self assert: (stream upToAnyOf: #(100 1000)) = #( 1 2 nil true false 10 ).	self assert: stream atEnd.		stream := #( 1 2 nil true false 10 ) readStream.	self assert: (stream upToAnyOf: #( true false )) = #( 1 2 nil ).	self assert: stream upToEnd = #( false 10 ).! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'nice 12/7/2009 10:03'!testUpToAnyOfDo	| stream found |	found := false.	stream := 'abcde' readStream.	self assert: (stream upToAnyOf: String crlf do: [:char | found := true]) = 'abcde'.	self assert: stream atEnd.	self deny: found.		found := Object new.	stream := 'abcde' readStream.	self assert: (stream upToAnyOf: 'dc' do: [:char | found := char]) = 'ab'.	self assert: found = $c.	self assert: stream upToEnd = 'de'.		found := false.	stream := #( 1 2 nil true false 10 ) readStream.	self assert: (stream upToAnyOf: #(100 1000) do: [:anObject | found := true]) = #( 1 2 nil true false 10 ).	self deny: found.	self assert: stream atEnd.		found := Object new.	stream := #( 1 2 nil true false 10 ) readStream.	self assert: (stream upToAnyOf: #( true false ) do: [:anObject | found := anObject]) = #( 1 2 nil ).	self assert: found = true.	self assert: stream upToEnd = #( false 10 ).! !!ReadStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo	self emptyStream do: [:value | self fail]! !!ReadStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo2	| stream string |	stream := self streamOnArray.	string := String new.		stream do: [:value | string := string, ' ', value asString].		self assert: string = (' ', 1 asString, ' ', #(a b c) asString, ' ', false asString)! !!ReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 3/7/2007 13:50'!testNew	self should: [self classUnderTest new] raise: Error.! !!ReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/28/2007 15:39'!testOn	self shouldnt: [self streamOn: '  '] raise: Error.	self assert: (self streamOn: '  ') position isZero.! !!ReadStreamTest methodsFor: 'as yet unclassified' stamp: 'ar 3/18/2007 03:18'!testNextFloat	"Test nextFloat behavior"	self assert: ('' readStream nextFloat) = nil.	self assert: ('    ' readStream nextFloat) = nil.	self assert: ('1' readStream nextFloat) = 1.0.	self assert: ('1.' readStream nextFloat) = 1.0.	self assert: ('1.0' readStream nextFloat) = 1.0.	self assert: ('.1' readStream nextFloat) = 0.1.	self assert: ('1e5' readStream nextFloat) = 1.0e5.	self assert: ('1e-5' readStream nextFloat) = 1.0e-5.	self assert: ('0.1e5' readStream nextFloat) = 0.1e5.	self assert: ('0.1e-5' readStream nextFloat) = 0.1e-5.	self assert: ('.1e5' readStream nextFloat) = 0.1e5.	self assert: ('.1e-5' readStream nextFloat) = 0.1e-5.	self assert: ('-1' readStream nextFloat) = -1.0.	self assert: ('-1.' readStream nextFloat) = -1.0.	self assert: ('-1.0' readStream nextFloat) = -1.0.	self assert: ('-.1' readStream nextFloat) = -0.1.	self assert: ('-1e5' readStream nextFloat) = -1.0e5.	self assert: ('-1e-5' readStream nextFloat) = -1.0e-5.	self assert: ('-0.1e5' readStream nextFloat) = -0.1e5.	self assert: ('-0.1e-5' readStream nextFloat) = -0.1e-5.	self assert: ('-.1e5' readStream nextFloat) = -0.1e5.	self assert: ('-.1e-5' readStream nextFloat) = -0.1e-5.	self assert: ('NaN' readStream nextFloat) isNaN.	self assert: ('-NaN' readStream nextFloat) isNaN.	self assert: ('Infinity' readStream nextFloat) = Float infinity.	self assert: ('-Infinity' readStream nextFloat) = Float infinity negated.	self should:['-' readStream nextFloat] raise: Error.	self should:['-    ' readStream nextFloat] raise: Error.	self should:['+' readStream nextFloat] raise: Error.	self should:['+    ' readStream nextFloat] raise: Error.	self should:['.' readStream nextFloat] raise: Error.	self should:['a' readStream nextFloat] raise: Error.	self should:['e' readStream nextFloat] raise: Error.	self should:['.e5' readStream nextFloat] raise: Error.	self should:['.e-5' readStream nextFloat] raise: Error.	self should:['1e' readStream nextFloat] raise: Error.	self should:['1.e' readStream nextFloat] raise: Error.	self should:['1.0e' readStream nextFloat] raise: Error.	self should:['1e+' readStream nextFloat] raise: Error.	self should:['1.e+' readStream nextFloat] raise: Error.	self should:['1.0e+' readStream nextFloat] raise: Error.	self should:['1e-' readStream nextFloat] raise: Error.	self should:['1.e-' readStream nextFloat] raise: Error.	self should:['1.0e-' readStream nextFloat] raise: Error.	self should:['-.' readStream nextFloat] raise: Error.	self should:['-a' readStream nextFloat] raise: Error.	self should:['-e' readStream nextFloat] raise: Error.	self should:['-.e5' readStream nextFloat] raise: Error.	self should:['-.e-5' readStream nextFloat] raise: Error.	self should:['-1e' readStream nextFloat] raise: Error.	self should:['-1.e' readStream nextFloat] raise: Error.	self should:['-1.0e' readStream nextFloat] raise: Error.	self should:['-1e+' readStream nextFloat] raise: Error.	self should:['-1.e+' readStream nextFloat] raise: Error.	self should:['-1.0e+' readStream nextFloat] raise: Error.	self should:['-1e-' readStream nextFloat] raise: Error.	self should:['-1.e-' readStream nextFloat] raise: Error.	self should:['-1.0e-' readStream nextFloat] raise: Error.! !!ReadStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:17'!testSkipTo	| stream |	stream := self emptyStream.	self deny: (stream skipTo: nil).		stream := self streamOnArray.	self deny: stream atEnd.	self deny: (stream skipTo: nil).	self assert: stream atEnd.		stream := self streamOnArray.	self assert: stream peek = 1.	self assert: (stream skipTo: #(a b c)).	self assert: stream peek = false.	self assert: (stream skipTo: false).	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:18'!testSkipTo2	| stream |		stream := self streamOnString.	self assert: (stream skipTo: $b).	self assert: stream peek = $c.	self assert: (stream skipTo: $d).	self assert: stream peek = $e.	self assert: (stream skipTo: $e).	self assert: stream atEnd.! !!ReadStreamTest commentStamp: 'tlk 12/5/2004 14:36' prior: 0!I am an SUnit test for ReadStream.I have no test fixtures.!!ReadWriteStream methodsFor: 'accessing' stamp: 'bgf 5/23/2008 18:04'!next	"Primitive. Return the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	"<primitive: 65>  Doesn't pay its way."	"treat me as a FIFO"	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadWriteStream methodsFor: 'printing' stamp: 'jcg 4/24/2007 14:19'!printContentsOn: stream	"Do nothing; superclass implementation is borked."! !!ReadWriteStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:24'!testConstructionUsingWith	"Use the with: constructor."	| aStream |	aStream := ReadWriteStream with: #(1 2).	self assert: (aStream contents = #(1 2)) description: 'Ensure correct initialization.'! !!ReadWriteStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:24'!testNew	self should: [ReadWriteStream new] raise: Error.! !!ReadWriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:06'!testIsEmpty	| stream |	stream := ReadWriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.	stream next.	self deny: stream isEmpty.! !!ReadWriteStreamTest commentStamp: '<historical>' prior: 0!This is the unit test for the class ReadWriteStream.Unit tests are a good way to exercise thefunctionality of your system in a repeatable andautomatic manner. They are therefore recommended ifyou plan to release anything. For more information,see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!RealEstateAgent commentStamp: '<historical>' prior: 0!Responsible for real-estate management on the screen, which is to say, controlling where new windows appear, with what sizes, etc.  5/20/96 sw!!RealEstateAgent class methodsFor: 'framing' stamp: 'ar 7/7/2010 17:38'!initialFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the positioning preferences, the size needed, and other windows currently on the screen."	| allowedArea |	self placeWindowsAtPointer ifTrue:  [		allowedArea := self maximumUsableAreaInWorld: aWorld.			^ (				(aWorld cursorPoint 					- (50@10)				"puts use with the mouse ptr just to the right of the menu button"				) 				extent: initialExtent			)  translatedAndSquishedToBeWithin: allowedArea.	].	Preferences reverseWindowStagger ifTrue: [		^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent world: aWorld	].	^ self plausibleFrameFor: aView initialExtent: initialExtent world: aWorld! !!RealEstateAgent class methodsFor: 'framing' stamp: 'ar 7/7/2010 17:38'!plausibleFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView,	taking into account the size needed, and other windows currently on the screen.	This is the old default (not-reverse-staggered) window placement technique."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	allowedArea := self maximumUsableAreaInWorld: aWorld.	screenRight := allowedArea right.	screenBottom := allowedArea bottom.	otherFrames := Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins := otherFrames collect: [:f | f origin].	(self standardPositionsInWorld: aWorld) do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea]].	staggerOrigin := (self standardPositionsInWorld: aWorld) first.  "Fallback: try offsetting from top left"	putativeOrigin := staggerOrigin.	[putativeOrigin := putativeOrigin + StaggerOffset.	putativeFrame := putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea! !!RealEstateAgent class methodsFor: 'preferences' stamp: 'ar 7/7/2010 17:40'!placeWindowsAtPointer	"Value of the place-windows-at-pointer preference."	<preference: 'Place Windows At Pointer'		category: 'browsing'		description: 'When true, place new windows near the mouse pointer'		type: #Boolean>	^PlaceWindowsAtPointer ifNil:[true]! !!RealEstateAgent class methodsFor: 'preferences' stamp: 'ar 7/7/2010 17:36'!placeWindowsAtPointer: aBool	"Value of the place-windows-at-pointer preference."	PlaceWindowsAtPointer := aBool! !!RecentMessageSet methodsFor: 'update' stamp: 'ar 6/23/2010 16:24'!updateListsAndCodeIn: aWindow	| recentFromUtilities |	"RAA 20 june 2000 - a recent change to how messages were displayed in the list caused them not to match what was stored in Utilities. This caused the recent submissions to be continuously updated. The hack below fixed that problem.	BGF Oct 2008 - Ditto. I removed an extra space added to recentFromUtilities,	and made the thing use = instead of beginsWith.       Today these entries no longer have a { category } suffix, which was the case recently. "	self flag: #mref.	"in second pass, use simpler test"	self canDiscardEdits ifFalse: [^ self].	recentFromUtilities := Utilities mostRecentlySubmittedMessage, ' '.	(messageList first asStringOrText asString beginsWith: recentFromUtilities)		ifFalse:			[self reformulateList]		ifTrue:			[self updateCodePaneIfNeeded]! !!Rectangle methodsFor: 'transforming' stamp: 'das 4/25/2008 13:35'!positiveExtent" force a positive extent on the rectangle by switching left/right top/bottom as necessary"	| c o t |	c := corner.	o := origin.	c x < o x ifTrue:[ t := c x. c := o x@ c y. o := t @ o y.].	c y < o y ifTrue:[ t := c y. c := c x@ o y. o := o x @ t.].	^ o corner: c.! !!RectangleTest methodsFor: 'testing' stamp: 'BG 10/25/2005 06:48'!testAreasOutside1   "RectangleTest new testAreasOutside1"    | frame rects visibleArea  |    frame := 0@0 extent: 300@300.    rects := OrderedCollection new: 80.    0 to: 3 do: [:i |      0 to: 2 do: [:j |            rects add: (i@j * 20 extent: 10@10)    ]  ].     visibleArea := Array with: frame.   rects do: [:rect |  | remnants |      remnants := OrderedCollection new.      visibleArea do: [:a | remnants addAll: (a areasOutside: rect)].      visibleArea := remnants.  ].  visibleArea := visibleArea asArray.  self assert: (visibleArea allSatisfy: [:r | r area ~= 0]).   1 to: visibleArea size do: [:idx |     idx + 1 to: visibleArea size do: [:idx2 |        self deny: ((visibleArea at: idx) intersects: (visibleArea at: idx2)).  ]  ].  1 to: rects size do: [:idx |     1 to: visibleArea size do: [:idx2 |        self deny: ((rects at: idx) intersects: (visibleArea at: idx2)).  ]  ].! !!RectangleTest methodsFor: 'testing' stamp: 'BG 10/25/2005 18:58'!testAreasOutside2   "RectangleTest new testAreasOutside2"    | frame rects visibleArea  |    frame := 0@0 extent: 300@300.    rects := OrderedCollection new: 80.    rects add: (50@50 corner: 200 @ 200);          add: (100@100 corner: 250@250).     visibleArea := Array with: frame.   rects do: [:rect |  | remnants |      remnants := OrderedCollection new.      visibleArea do: [:a | remnants addAll: (a areasOutside: rect)].      visibleArea := remnants.  ].  visibleArea := visibleArea asArray.  self assert: (visibleArea allSatisfy: [:r | r area ~= 0]).   1 to: visibleArea size do: [:idx |     idx + 1 to: visibleArea size do: [:idx2 |        self deny: ((visibleArea at: idx) intersects: (visibleArea at: idx2)).  ]  ].  1 to: rects size do: [:idx |     1 to: visibleArea size do: [:idx2 |        self deny: ((rects at: idx) intersects: (visibleArea at: idx2)).  ]  ].! !!RectangleTest methodsFor: 'testing' stamp: 'BG 10/24/2005 20:24'!testCorner1   "RectangleTest new testCorner1"    | rect |   rect := 10@10 extent: 20@30.   self deny: (rect containsPoint: rect corner).! !!RectangleTest methodsFor: 'testing' stamp: 'BG 10/24/2005 20:28'!testIntersection1   "RectangleTest new testIntersection1"    | rect1 rect2 |   rect1 := 10@10 corner: 20@30.   rect2 := rect1 corner extent: 20@40.   self deny: (rect1 intersects: rect2).! !!RectangleTest methodsFor: 'testing' stamp: 'BG 10/25/2005 06:36'!testIntersection2   "RectangleTest new testIntersection2"    | rect1 rect2 |   rect1 := 0@0 corner: 40@40.   rect2 := 40@40 corner: 50@50.   self deny: (rect1 intersects: rect2);        deny: (rect2 intersects: rect1).! !!RectangleTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:16'!testMergingDisjointRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: -10 right: 0 top: -10 bottom: 0).	coll add: (Rectangle left: 0 right: 10 top: 0 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: -10 right: 10 top: -10 bottom: 10).! !!RectangleTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:17'!testMergingNestedRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 10 top: 1 bottom: 10).	coll add: (Rectangle left: 4 right: 5 top: 4 bottom: 5).	merge := Rectangle merging: coll.	self assert: merge = coll first.! !!RectangleTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:17'!testMergingOverlappingRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 5 right: 10 top: 0 bottom: 15).	coll add: (Rectangle left: 0 right: 15 top: 5 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: 0 right: 15 top: 0 bottom: 15).! !!RectangleTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:17'!testMergingTrivial	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 1 top: 1 bottom: 1).	merge := Rectangle merging: coll.	self assert: merge = coll first.! !!RectangleTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:17'!testMergingTwoRects	| coll merge |	coll := OrderedCollection new.	coll add: (Rectangle left: 1 right: 1 top: 1 bottom: 1).	coll add: (Rectangle left: 10 right: 10 top: 10 bottom: 10).	merge := Rectangle merging: coll.	self assert: merge = (Rectangle left: 1 right: 10 top: 1 bottom: 10).! !!RectangleTest methodsFor: 'tests' stamp: 'nice 11/1/2009 21:31'!testStoreOn	| assoc assoc2 |	assoc := (0@0 extent: 1@1) -> 0.	self shouldnt: [assoc2 := Compiler evaluate: assoc storeString] raise: Error.	self assert: assoc key = assoc2 key.	self assert: assoc value = assoc2 value.! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 4/7/2010 12:18'!emitLabelIfAnyFor: pc on: aStream	(labels at: pc) ~~ false ifTrue:		[aStream nextPutAll: (labels at: pc); nextPut: $:; cr]! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 4/7/2010 12:18'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	stream tab: self indent.	labelling		ifTrue: [stream print: oldPC - method initialPC; space]		ifFalse: [stream tab].	stream tab: (innerIndents at: oldPC).	self printCode ifTrue:		[stream nextPut: $<.		 oldPC to: scanner pc - 1 do: 			[:i | | code |			code := (method at: i) radix: 16.			stream				nextPut: (code size < 2 ifTrue: [$0] ifFalse: [code at: 1]);				nextPut: code last;				space].		 stream skip: -1; nextPut: $>; space].	stream nextPutAll: instruction; cr.	labelling ifFalse:		[self emitLabelIfAnyFor: scanner pc + 1 on: stream].	oldPC := scanner pc! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 4/7/2010 12:18'!printInstructionsOn: aStream	"Append to the stream, aStream, a description of each bytecode in the instruction stream."		| label |	labelling := true.	labels := Array new: method size + 1 withAll: false.	super printInstructionsOn: (String new: 1024) writeStream.	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	self emitLabelIfAnyFor: method initialPC + 1 on: aStream.	super printInstructionsOn: aStream! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 4/7/2010 12:19'!printInstructionsOn: aStream do: aBlock	"Append to the stream, aStream, a description of each bytecode in the instruction stream.	  Evaluate aBlock with the receiver, the scanner and the stream after each instruction."		| label |	labelling := true.	labels := Array new: method size withAll: false.	super printInstructionsOn: (String new: 1024) writeStream do: [:ig :no :re|].	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	self emitLabelIfAnyFor: method initialPC + 1 on: aStream.	super printInstructionsOn: aStream do: aBlock! !!ReleaseTest methodsFor: 'testing' stamp: 'wiz 5/30/2008 23:29'!testClassesSystemCategory"Find cases where classes have nil system categories.This test will tell you the classes.This is inspired by the proposed fix of a bug in release of 3.10.1 see Mantis #7070" | rejectClasses | rejectClasses :=  nil systemNavigation allClasses reject: [ :each |	each category notNil ] .self assert: rejectClasses isEmpty .! !!ReleaseTest methodsFor: 'testing' stamp: 'laza 10/7/2009 11:03'!testSuperSubclassReferences	"see mantis bug 7090 for more info on this"	"If the reason for this test to fail is above bug, the following might fix the system"	"(ProtoObject subclasses reject: [:each | each isMeta or: [each environment includes: each]]) do: [:each | ProtoObject removeSubclass: each]"		self assert: (ProtoObject allSubclasses reject: [:each | each isMeta or: [each environment includes: each]]) isEmpty! !!ReleaseTest methodsFor: 'testing' stamp: 'wiz 5/30/2008 23:30'!testSystemCategoryClasses"Find cases where system categories name absent classes.This test will tell you the classes.This is inspired by a bug in release of 3.10.1 see Mantis #7070" |  rejectCats rejectClasses | rejectCats := SystemOrganization categories reject: [ :catName |	(SystemOrganization listAtCategoryNamed: catName) 		allSatisfy: [ :className | 			( Smalltalk includesKey: className ) ] ] ."self assert: rejectCats isEmpty ."rejectCats isEmpty ifTrue: [ ^ true ] . rejectClasses :=rejectCats collect: [ :each |	each ->	( (SystemOrganization listAtCategoryNamed: each) 		reject: [ :eachOne | 			( Smalltalk includesKey: eachOne )  ] ) ] .self assert: rejectCats isEmpty .! !!ReleaseTest methodsFor: 'testing' stamp: 'md 2/12/2006 15:27'!testUndeclared	Smalltalk cleanOutUndeclared. 	self assert: Undeclared isEmpty	! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 19:09'!addRemoteTemp: aTempVariableNode encoder: encoder	remoteTemps isNil ifTrue:		[remoteTemps := OrderedCollection new].	(remoteTemps includes: aTempVariableNode) ifTrue:		[self halt].	remoteTemps addLast: aTempVariableNode.	aTempVariableNode referenceScopesAndIndicesDo:		[:scopeBlock "<BlockNode>" :location "<Integer>"|		 self addReadWithin: scopeBlock at: location].	encoder supportsClosureOpcodes ifFalse:		[encoder encodeLiteral: remoteTemps size.		 readNode := encoder encodeSelector: #at:.		 writeNode := encoder encodeSelector: #at:put:]! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/15/2008 22:44'!long"return time limit in milliseconds for tests"^4! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/14/2008 23:25'!shouldntTakeLong: aBlock"Check for infinite recursion. Test should finish in a reasonable time."^self should:  aBlock  		notTakeMoreThanMilliseconds: self long .! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:36'!testForward"If the bug exist there will be an infinte recursion.""self new testForward""self run: #testForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [self assert: ( t forwardDirection = 0.0 ) ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:34'!testHeading"If the bug exist there will be an infinte recursion.""self new testHeading""self run: #testHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ [self assert: ( t heading = 0.0 ) ] 				ensure: [ t delete ] ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetForward"If the bug exist there will be an infinte reccursion.""self new testSetForward""self run: #testSetForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self 	shouldntTakeLong: [ t forwardDirection: 180.0 . 					self assert: ( t forwardDirection = 0.0 )  ]  ."and without a rendee it should not change things."^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetHeading"If the bug exist there will be an infinte recursion.""self new testSetHeading""self run: #testSetHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ t heading:  180 .					 self assert: ( t heading = 0.0 ) .]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:33'!testTestTime"This is a control case. Should always pass. If it does not something external to the tests are slowing things down past the 1 millisecond mark.""self new testTestTime""self run: #testTestTime"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ self assert: ( true )  ]  .^true  ! !!RenderBugz commentStamp: 'wiz 5/15/2008 22:58' prior: 0!A RenderBugz is an infinite recursion bug test for TransformationMorphs.In 3.9 (7067) and before, when TransformationMorph has no rendee there are several methods that will infinitely recurse until manually stopped or the image runs out of memory.So far the ones I've caught are the getters and setters for heading and forwardDirection.So there  are tests for them here.Ideally there would be a way to run a test against a stopwatch to catch endless recursion.Found it. Now incorperated. And the tests should be both save to run and cleanup after themselves even when they fail. So far we have not tested the normal cases of rendering working. I will leave that as a separate task for another time. So this is an automatic test when the bugs are fixed and interactive (crash) tests when the bugs are present.Instance VariablesRevision notes. wiz 5/15/2008 22:58When running tests from the TestRunner browser the test would sporadically fail.When they failed a transfomation morph would be left on the screen and not removed by the ensureBlock. So I changed things to fall under MorphicUIBugTests because that had a cleanup mechansizm for left over morphs.I also added one routine to test for time and one parameter to determine the time limit.To my surprise doubling or tripling the time limit still produced sporadic errors when the test is run repeatedly enough ( I am using a 400mz iMac. )  So now the parameter is set to 4. Things will probably fail there if tried long enough. At that point try 5 etc. I am reluctant to make the number larger than necessary. The tighter the test the more you know what is working.I also added a dummy test to check specifically for the timing bug. It fails on the same sporadic basis as the other test went the time parameter is short enough. This lends confidence to the theory that the timing difficulty is coming from outside the test. The sunit runner puts up a progress morph for each test. So the morphic display stuff is busy and probably also the GC.!!RepeatingSound methodsFor: 'initialization' stamp: 'jcg 2/14/2007 15:56'!loudness: aNumber	sound ifNotNil: [sound loudness: aNumber]! !!RepeatingSound methodsFor: 'playing' stamp: 'jcg 2/12/2007 17:50'!stopAfterMSecs: mSecs	"Terminate this sound after the given number of milliseconds."	iteration := 0.	sound stopAfterMSecs: mSecs! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitReturnNode: self! !!ReverbSound methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:55'!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #tapDelays declareC: 'int *tapDelays'>	<var: #tapGains declareC: 'int *tapGains'>	<var: #leftBuffer declareC: 'short int *leftBuffer'>	<var: #rightBuffer declareC: 'short int *rightBuffer'>	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft := delayedRight := 0.		1 to: tapCount do: [:tapIndex |			i := bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i := i + bufferSize].  "wrap"			tapGain := tapGains at: tapIndex.			delayedLeft := delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight := delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j := (2 * sliceIndex) - 1.		out := (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j := j + 1.		out := (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex := (bufferIndex \\ bufferSize) + 1].! !!RightGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:39'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!RightGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultWidth	^ 5! !!RightGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (self defaultWidth negated @ self defaultHeight negated corner: 0@ 0)! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!ptName	^#right! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!resizeCursor	^ Cursor resizeForEdge: #right! !!RunArray methodsFor: 'accessing' stamp: 'ar 10/16/2001 18:56'!runLengthAt: index 	"Answer the length remaining in run beginning at index."	self at: index 		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:25'!testAt	"self debug: #testAt"	| array |	array := RunArray new: 5 withAll: 2.	self assert: (array at: 3) = 2.		array at: 3 put: 5.	self assert: (array at: 3) = 5! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:26'!testAtPut	"self debug: #testAtPut"	| array |	array := RunArray new: 5 withAll: 2.		array at: 3 put: 5.	self assert: array = #(2 2 5 2 2).		array at: 1 put: 1.	self assert: array = #(1 2 5 2 2).! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:29'!testAtPut2	"self debug: #testAtPut2"	| array |	array := RunArray new: 5 withAll: 2.		self should: [array at: 0 put: 5] raise: Error.	self should: [array at: 6 put: 5] raise: Error.	self should: [array at: $b put: 5] raise: Error.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testFirst	"self debug: #testFirst"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array first = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array first = $a.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testLast	"self debug: #testLast"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array last = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array last = $d.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:58'!testRunLengthAt	"self debug: #testRunLengthAt"	| array |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	self assert: (array runLengthAt: 1) = 1.	self assert: (array runLengthAt: 2) = 2.	self assert: (array runLengthAt: 3) = 1.	self assert: (array runLengthAt: 4) = 3.	self assert: (array runLengthAt: 5) = 2.	self assert: (array runLengthAt: 6) = 1.	self assert: (array runLengthAt: 7) = 2.	self assert: (array runLengthAt: 8) = 1.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 10:12'!testWithStartStopAndValueDo	"self debug: #testWithStartStopAndValueDo"	| array elements startStops |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	elements := OrderedCollection new.	startStops := OrderedCollection new.	array withStartStopAndValueDo: [:start :stop :value | elements add: value. startStops add: start->stop].		self assert: elements asArray = #($a $b  $c  $d).	self assert: startStops asArray = {1->1 . 2->3 . 4->6 . 7->8}! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:22'!testNew	"self debug: #testNew"	| array |	array := RunArray new.	self assert: array size = 0.! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:24'!testNewFrom	"self debug: #testNewFrom"	| array |	array := RunArray newFrom: #($a $b $b $b $b $c $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:15'!testNewWithAll	"self debug: #testNewWithAll"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array size = 5.	self assert: array = #(2 2 2 2 2)! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := RunArray new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:30'!testRunsValues	"self debug: #testRunsValues"	| array |	array := RunArray runs: #(1 4 2 1) values: #($a $b $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 09:13'!testScanFromANSICompatibility	"self run: #testScanFromANSICompatibility"	RunArray scanFrom: (ReadStream on: '()f1dNumber new;;').	RunArray scanFrom: (ReadStream on: '()a1death;;').	RunArray scanFrom: (ReadStream on: '()F1death;;').! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'ar 2/24/2010 18:05'!testScanFromTrailer	"This test documents an ancient bug in RunArray class>>scanFrom:."	self assert: (RunArray scanFrom: '(8 4 5),b,!!' readStream) = 		(RunArray runs: #(8 4 5) values: { {}. {TextEmphasis bold}. {} }).! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/16/2002 00:33'!handleCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 18:26'!handleComment: aString	self saxHandler		checkEOD; 		comment: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:38'!handleEndDocument	self saxHandler endDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:55'!handlePCData: aString	self languageEnvironment		ifNotNil: [aString applyLanguageInfomation: self languageEnvironment].	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePI: piTarget data: piData	self saxHandler		checkEOD; 		processingInstruction: piTarget data: piData! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:29'!handleStartDocument	self saxHandler startDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:49'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	(attributeList includesKey: 'xml:lang')		ifTrue: [languageEnvironment := LanguageEnvironment localeID: (LocaleID isoString: (attributeList at: 'xml:lang'))].	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/18/2003 01:00'!handleWhitespace: aString	self saxHandler		checkEOD; 		ignorableWhitespace: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:39'!handleXMLDecl: attributes namespaces: namespaces	self saxHandler		checkEOD; 		documentAttributes: attributes.	self usesNamespaces		ifTrue: [			namespaces keysAndValuesDo: [:ns :uri |				self scope declareNamespace: ns uri: uri]]! !!SAXDriver methodsFor: 'initialization' stamp: 'mir 6/5/2003 16:29'!initialize	super initialize.	useNamespaces := false.	validateAttributes := false! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 7/14/2006 11:48'!languageEnvironment	^languageEnvironment! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:51'!saxHandler	^saxHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler := aHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:51'!useNamespaces: aBoolean	useNamespaces := aBoolean! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/24/2003 13:40'!scope	scope ifNil: [scope := XMLNamespaceScope new].	^scope! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i := aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 16:30'!usesNamespaces	^useNamespaces! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 17:06'!validatesAttributes	^validateAttributes! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:27'!characters: aString	"This call corresponds to the Java SAX call	characters(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:24'!checkEOD	"Check if the document shouldn't be ended already"	self eod		ifTrue: [self driver errorExpected: 'No more data expected,']! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/17/2002 13:12'!documentAttributes: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod := true! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 19:05'!endElement: elementName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName	"This call corresponds to the Java SAX call	endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName).	By default this call is mapped to the following more convenient call:"	self endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!endPrefixMapping: prefix	"This call corresonds to the Java SAX call	endPrefixMapping(java.lang.String prefix)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!ignorableWhitespace: aString	"This call corresonds to the Java SAX call	ignorableWhitespace(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:26'!processingInstruction: piName data: dataString	"This call corresonds to the Java SAX call	processingInstruction(java.lang.String target, java.lang.String data)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!skippedEntity: aString	"This call corresonds to the Java SAX call	skippedEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!startDocument	"This call corresonds to the Java SAX call	startDocument()."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!startElement: elementName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 16:50'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	"This call corresonds to the Java SAX call	startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts).	By default this call is mapped to the following more convenient call:"	self startElement: localName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:47'!startPrefixMapping: prefix uri: uri	"This call corresonds to the Java SAX call	startPrefixMapping(java.lang.String prefix, java.lang.String uri)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:52'!comment: commentString	"This call corresponds to the Java SAX ext call	comment(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!endEntity: entityName	"This call corresponds to the Java SAX ext call	endEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!startCData	"This call corresponds to the Java SAX ext call	startCData()."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startDTD: declName publicID: publicID systemID: systemID	"This call corresponds to the Java SAX ext call	startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startEntity: entityName	"This call corresponds to the Java SAX ext call	startEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document	^document! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document := aDocument! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver	^driver! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver := aDriver.	driver saxHandler: self! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:18'!eod	^eod! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:28'!useNamespaces: aBoolean	self driver useNamespaces: aBoolean! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod := false! !!SAXHandler methodsFor: 'parsing' stamp: 'mir 1/8/2002 18:18'!parseDocument	[self driver nextEntity isNil or: [self eod]] whileFalse! !!SAXHandler methodsFor: 'entity' stamp: 'mir 8/11/2000 17:33'!resolveEntity: publicID systemID: systemID	"This call corresonds to the Java SAX call	resolveEntity(java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	parser := self new driver: driver.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser := self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:24'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:26'!parseDocumentFrom: aStream useNamespaces: aBoolean	|  parser |	parser := self on: aStream.	parser useNamespaces: aBoolean.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName	^self parseDocumentFromFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'nice 2/8/2010 09:09'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	xmlDoc := [self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:15'!parserOnFileNamed: fileName	^self parserOnFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	^self on: stream! !!SHParserST80 methodsFor: 'parse' stamp: 'eem 7/14/2010 16:32'!parseExternalCall	[self scanNext.	((Smalltalk at: #ExternalFunction) callingConventionModifierFor: currentToken) notNil]		whileTrue.	self scanPast: #externalCallType.	currentToken = '*' 		ifTrue: [self scanPast: #externalCallTypePointerIndicator].	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: 	[			self failUnless: currentTokenFirst == $'.			self parseString].	self failUnless: currentTokenFirst == $(.	self scanPast: #leftParenthesis.	[currentTokenFirst ~= $)] 		whileTrue: [			self scanPast: #externalCallType.			currentToken = '*' 				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].	self scanPast: #rightParenthesis.	currentToken = 'module:' 		ifTrue: [			self scanPast: #module.			self failUnless: currentTokenFirst == $'.			self parseString].	currentToken = 'error:' 		ifTrue: [			self scanPast: #module.			currentTokenFirst == $'				ifTrue: [self parseString]				ifFalse: [self scanPast: #patternTempVar]].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'eem 12/1/2008 15:18'!parsePrimitive	| numericPrim yetToSeeErrorCode |	yetToSeeErrorCode := true.	self scanNext.	(numericPrim := currentTokenFirst isDigit)		ifTrue: [self scanPast: #integer]		ifFalse: [			self failUnless: currentTokenFirst == $'.			self parseString].	currentToken = 'error:' ifTrue:		[yetToSeeErrorCode := false.		 self scanPast: #primitive.		 self isName			ifTrue: [self scanPast: #patternTempVar]			ifFalse:				[self failUnless: currentTokenFirst == $'.				 self parseString]].	numericPrim ifFalse:		[currentToken = 'module:' ifTrue:			[self scanPast: #module.			 self failUnless: currentTokenFirst == $'.			 self parseString]].	(yetToSeeErrorCode	 and: [currentToken = 'error:']) ifTrue:		[self scanPast: #primitive.		 self isName			ifTrue: [self scanPast: #patternTempVar]			ifFalse:				[self failUnless: currentTokenFirst == $'.				 self parseString]].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'eem 7/14/2010 16:33'!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $:]).	start := sourcePosition.		[c := self nextChar.	 c isAlphaNumeric or: [c == $:]] 		whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	ranges notEmpty ifTrue:		[ranges removeLast].	self scanPast: #symbol start: start - 1 end: end.	^c! !!SMTPClientTest methodsFor: 'running' stamp: 'fbs 3/22/2004 13:11'!setUp	socket := MockSocketStream on: ''.	smtp := SMTPClient new.	smtp stream: socket.! !!SMTPClientTest methodsFor: 'testing' stamp: 'fbs 3/23/2004 17:15'!testMailFrom	smtp mailFrom: 'frank@angband.za.org'.	self assert: socket outStream contents = ('MAIL FROM: <frank@angband.za.org>', String crlf).		socket resetOutStream.	smtp mailFrom: '<frank@angband.za.org>'.	self assert: socket outStream contents = ('MAIL FROM: <frank@angband.za.org>', String crlf).		socket resetOutStream.	smtp mailFrom: 'Frank <frank@angband.za.org>'.	self assert: socket outStream contents = ('MAIL FROM: <frank@angband.za.org>', String crlf).! !!ST80MenusTest methodsFor: 'testing' stamp: 'tlk 5/2/2006 22:46'!testSupplyAnswerOfFillInTheBlank	self should: ['blue' = ([UIManager default request: 'Should not see this message or this test failed?'] 		valueSupplyingAnswer: #('Should not see this message or this test failed?' 'blue'))]! !!ST80MenusTest methodsFor: 'tests' stamp: 'tlk 5/2/2006 22:42'!testSupplySpecificAnswerToQuestion	self should: [false = ([self confirm: 'Should not see this message or this test failed?'] 		valueSupplyingAnswer: #('Should not see this message or this test failed?' false))]! !!ST80MenusTest methodsFor: 'tests' stamp: 'tlk 5/2/2006 22:28'!testSuppressInform	self should: [[nil inform: 'Should not see this message or this test failed!!'] valueSuppressingAllMessages isNil]! !!ST80MenusTest commentStamp: 'tlk 5/2/2006 22:41' prior: 0!I am an SUnit Test of PopUpMenu and FillInTheBlank.  The original motivation for my creation was the regression of functionality associated with allowing the non-interactive testing of these menus.  My fixtures are: NoneNOTES ABOUT AUTOMATING USER INPUTS (See MethodContextTest also for a discussion of this functionality.)When executing non-interactive programs you will inevitably run into programs  that require user input during their execution and these sort of problems shoot the whole non-interactiveness of your enclosing program. This is particularly true in doing Sunit tests.PopUpMenu and FillInTheBlankMorph were modified to first signal a ProvideAnswerNotification and if someone handles that (e.g. the enclosing block) then the user interaction will be avoided and a answer provided by an array will be used instead. PopUpMenu and FillInTheBlankMorph take advantage of BlockContext helper methods have been made available and tests of these helpers are provided in this class to demonstrate that it can intercept  requests for user interaction.  Of course, The basic syntax looks like:	[self confirm: 'Install spyware?'] valueSupplyingAnswer: #('Install spyware?' false)There a few variants on this theme making it easy to provide a literal list of answers for the block so that you can handle a bunch of questions in a block with appropriate answers.Additionally, it is possible to suppress Object>>inform: modal dialog boxes as these get in the way of automating anything.  After applying this changeset you should be able to tryout the following code snippets to see the variants on this theme that are available.Examples:So you don't need any introduction here -- this one works like usual.[self inform: 'hello'. #done] value.Now let's suppress all inform: messages.[self inform: 'hello'; inform: 'there'. #done] valueSuppressingAllMessages.Here we can just suppress a single inform: message.[self inform: 'hi'; inform: 'there'. #done] valueSuppressingMessages: #('there')Here you see how you can suppress a list of messages.[self inform: 'hi'; inform: 'there'; inform: 'bill'. #done] valueSuppressingMessages: #('hi' 'there')Enough about inform:, let's look at confirm:. As you see this one works as expected.[self confirm: 'You like Squeak?'] valueLet's supply answers to one of the questions -- check out the return value.[{self confirm: 'You like Smalltalk?'. self confirm: 'You like Squeak?'}]	valueSupplyingAnswer: #('You like Smalltalk?' true)Here we supply answers using only substrings of the questions (for simplicity).[{self confirm: 'You like Squeak?'. self confirm: 'You like MVC?'}]	valueSupplyingAnswers: #( ('Squeak' true) ('MVC' false) )This time let's answer all questions exactly the same way.[{self confirm: 'You like Squeak?'. self confirm: 'You like Morphic?'}]	valueSupplyingAnswer: true	And, of course, we can answer FillInTheBlank questions in the same manner.[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswer: 'the first day of the rest of your life'	We can also return whatever the initialAnswer of the FillInTheBlank was by using the #default answer.[FillInTheBlank request: 'What day is it?' initialAnswer: DateAndTime now dayOfWeekName]	valueSupplyingAnswer: #default	Finally, you can also do regex matches on any of the question text (or inform text) (should you have VB-Regex enhancements in your image).[FillInTheBlank request: 'What day is it?']	valueSupplyingAnswers: { {'What day.*\?'. DateAndTime now dayOfWeekName} }!!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:43'!testTestTimeoutLoop	<timeout: 1>	self should:[[true] whileTrue.] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!SampledSound methodsFor: 'playing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #samples declareC: 'short int *samples'>	lastIndex := (startIndex + n) - 1.	outIndex := startIndex.    "index of next stereo output sample pair"	sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample := ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i := (2 * outIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * outIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].		scaledIndex := scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow := scaledIndex >> IncrementFractionBits.			indexHighBits := indexHighBits + overflow.			scaledIndex := scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex := outIndex + 1].	count := count - n.! !!SampledSound methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:37'!* scaleFactor	^self class samples: (samples * scaleFactor) samplingRate: originalSamplingRate! !!SampledSound methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:09'!- aSampledSound	originalSamplingRate = aSampledSound originalSamplingRate ifFalse: [self error: 'no resampling yet'].	^self class samples: (samples - aSampledSound samples) samplingRate: originalSamplingRate! !!SampledSound methodsFor: 'utilities' stamp: 'crl 3/15/2010 10:11'!sampleIndexOfPositivePeak: peakNumber startingAt: startingSampleIndex	^samples sampleIndexOfPositivePeak: peakNumber startingAt: startingSampleIndex! !!SampledSound methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:06'!withoutFirst: numberOfSamples	^self class samples: (samples withoutFirst: numberOfSamples) samplingRate: originalSamplingRate! !!SampledSound class methodsFor: 'instance creation' stamp: 'ar 12/4/2007 17:32'!fromWaveFileNamed: fileName	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"	"| snd fd |	fd := FileDirectory on:'c:\windows\media\'.	fd fileNames do: [:n |		(n asLowercase endsWith: '.wav')			ifTrue: [				snd := SampledSound fromWaveFileNamed: (fd pathName,n).				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	^self fromWaveStream: (FileStream readOnlyFileNamed: fileName)! !!SampledSound class methodsFor: 'utilities' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:14'!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	<var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'>	n := aByteArray size.	1 to: n do: [:i |		s := aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:14'!addNewWindow	self addWindow: prototype clone! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 19:01'!addWindow: aModel	aModel multiWindowState: self.	self assert: models size = modelStates size.	models := models					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: aModel).	modelStates := modelStates					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: self emptyEditState).	self assert: models size = modelStates size.	self selectWindowIndex: (currentModelIndex = 0 ifTrue: [currentModelIndex := 1] ifFalse: [currentModelIndex + 1]).	self assert: models size = modelStates size.	1 to: models size do:		[:idx|		self assert: (idx = currentModelIndex					or: [(modelStates at: idx) isArray and: [(modelStates at: idx) size = 2]])]! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:10'!copyWindow	self addWindow: (models at: currentModelIndex) copy breakDependents! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 21:15'!removeCurrentWindow	"Remove the current pane."	| deletedIndex |	self assert: models size > 1.	self assert: models size = modelStates size.	(models at: currentModelIndex) okToChange ifFalse:		[^self].	deletedIndex := currentModelIndex.	self selectWindowIndex: (currentModelIndex = 1								ifTrue: [currentModelIndex + 1]								ifFalse: [currentModelIndex - 1]).	models := models copyWithoutIndex: deletedIndex.	modelStates :=  modelStates copyWithoutIndex: deletedIndex.	currentModelIndex > deletedIndex ifTrue:		[currentModelIndex := currentModelIndex - 1].	(models at: currentModelIndex) changed: #relabel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 8/11/2010 13:27'!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | modelLabel |		modelLabel := index = currentModelIndex							ifTrue: [model multiWindowName]							ifFalse: [model multiWindowNameForState: (modelStates at: index) first].		models size > 1 ifTrue:			[modelLabel := index printString, '. ', modelLabel].		menu			add: (index = currentModelIndex					ifTrue: [Text string: modelLabel attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: modelLabel attribute: TextColor red]							ifFalse: [modelLabel]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 15:01'!currentModelIndex	^currentModelIndex! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 21:07'!emptyEditState	^#(nil ())! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 19:03'!models	^models! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 7/1/2010 10:40'!prototype	^prototype! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!editState	| textState |	textState := WeakIdentityKeyDictionary new.	modelDependents do:		[:dep|		dep canHaveUnacceptedEdits ifTrue:			[textState at: dep put: dep unacceptedEditState]].	^textState! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!restoreEditState: aWeakDictionary	aWeakDictionary keysAndValuesDo:		[:depOrNil :unacceptedEditState|		depOrNil ifNotNil:			[depOrNil unacceptedEditState: unacceptedEditState]]! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 21:09'!selectWindowIndex: index	| currentModel newModel newModelState |	index = currentModelIndex ifTrue: [^self].	currentModel := models at: currentModelIndex.	newModel := models at: index.	modelDependents addAll: currentModel dependents.	modelStates at: currentModelIndex put: { currentModel saveMultiWindowState. self editState }.	"the become makes things confusing.  currentModel will end up being newModel and vice verce"	models swap: currentModelIndex with: index.	currentModel become: newModel.	currentModel := models at: currentModelIndex.	newModel := models at: index.	newModel myDependents: (DependentsArray withAll: modelDependents asArray).	currentModel myDependents: nil.	"Change currentModelIndex before restoreMultiWIndowState: so label index is shown correctly"	currentModelIndex := index.	newModelState := modelStates at: index.	newModelState first ifNotNil: "emptyState has nil for savedModelState.  Don;t restore state for a new window"		[:savedModelState| newModel restoreMultiWindowState: savedModelState].	self restoreEditState: newModelState last.	modelStates at: index put: nil.	newModel changed: #relabel! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 15:12'!initialize	models := OrderedCollection new.	modelStates := OrderedCollection new.	modelDependents := IdentitySet new.	currentModelIndex := 0! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 18:42'!on: aModel	prototype := aModel clone.	self addWindow: aModel! !!SavedMultiWindowState methodsFor: 'testing' stamp: 'eem 6/30/2010 22:11'!okToClose	"Answer if the unaccepted edit states are void.  If they are not then	 offer to select a window with non-empty unaccepted edit state."	modelStates withIndexDo:		[:savedState :index|		savedState ifNotNil:			[(savedState last anySatisfy: [:editState| editState notNil]) ifTrue:				[(PopUpMenu					confirm: 'One or more windows have unsaved changes.'					trueChoice: 'Close Anyway'					falseChoice: 'Select Unsaved') ifTrue: [^true].				 self selectWindowIndex: index.				 ^false]]].	^true! !!SavedMultiWindowState commentStamp: 'eem 6/30/2010 15:45' prior: 0!A SavedMultiWindowState is a collection of states of inactive windows for a multi-window tool ui where one can select between multiple copies of a tool sharing a single system window, each tol having its own state.  It manages switching between windows, swapping unaccepted edit state (e.g. in text views) as it does so.Instance Variables	currentModelIndex:		<Integer>	modelDependents:		<IdentitySet>	modelStates:			<OrderedCollection of: (Array													with: modelState <Object>													with: unacceptedEditStates <WeakIdentityKeyDictionary>) >	models:					<OrderedCollection of: Model>currentModelIndex	- index into models and modelStates of current window selectionmodelDependents	- set of all dependentsmodelStates	- the pairs of model-specific selection state and widget-specfic unaccepted edit state for each unselected/inactive windowmodels	- the models for each window!!SavedMultiWindowState class methodsFor: 'instance creation' stamp: 'eem 6/30/2010 13:46'!on: aModel	^self new on: aModel! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:22'!testAsNumber	"Ensure no loss of precision"	| sd |	sd := '1.40s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '1.40s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberNegatedWithoutDecimalPoint	| sd |	sd := '-123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 0.	self assert: '-123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberNegatedWithoutDecimalPoint2	| sd |	sd := '-123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '-123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:21'!testAsNumberWithExtendedScale	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:28'!testAsNumberWithRadix	| sd |	sd := '10r-22.2s5' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 5.	self assert: '-22.20000s5' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:20'!testAsNumberWithSuperfluousDecimalPoint	| sd |	sd := '123.s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:49'!testAsNumberWithoutDecimalPoint	| sd |	sd := '123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 0.	self assert: '123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberWithoutDecimalPoint2	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 5/16/2009 23:48'!testCoercion	#( #* #+ #- #/) do: [:op |		self assert: (1.0s1 perform: op with: 2) class = ScaledDecimal.		self assert: (1.0s1 perform: op with: 1/2) class = ScaledDecimal.		self deny: (1.0s1 perform: op with: 1.0) class = ScaledDecimal.				self assert: (1 perform: op with: 2.0s1) class = ScaledDecimal.		self assert: (1/2 perform: op with: 2.0s1) class = ScaledDecimal.		self deny: (1.0 perform: op with: 1.0s1) class = ScaledDecimal]! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:04'!testConvertFromFloat	| aFloat sd f2 diff |	aFloat := 11/13 asFloat.	sd := aFloat asScaledDecimal: 2.	self assert: 2 == sd scale.	self assert: '0.84s2' = sd printString.	f2 := sd asFloat.	diff := f2 - aFloat.	self assert: diff < 1.0e-9. "actually, f = f2, but this is not a requirement"! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 2/13/2010 23:21'!testConvertFromFraction	"Converting a Fractionwith asScaledDecimal use strictly necessary number of decimal places when possible."		| defaultNumberOfDecimals |	0 to: 11 do: [:pow2 |		0 to: 11 do: [:pow5 |			| fraction sd sd2 |			fraction := 13 / (2 raisedTo: pow2) / (5 raisedTo: pow5).			sd := fraction asScaledDecimal.			self assert: sd scale = (pow2 max: pow5).			sd2 := ScaledDecimal readFrom: sd printString.			self assert: sd = sd2]].		defaultNumberOfDecimals := (1/3) asScaledDecimal scale.	#(6 7 9 11 12 13 14 17 18 19 21 22 23 24) do: [:den |		| sd sd2 |		sd := (1/den) asScaledDecimal.		self assert: sd scale = defaultNumberOfDecimals.		sd2 := ScaledDecimal readFrom: sd printString.		self deny: sd = sd2		] ! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 2/13/2010 23:14'!testConvertFromFractionWithScale	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ScaledDecimal == sd class.	self assert: ('1.181818s6' = sd printString).	self assert: 6 == sd scale! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 2/13/2010 23:12'!testConvertFromInteger	"Converting an Integer with asScaledDecimal use strictly necessary number of decimal places: 0."	| sd |	sd := 13 asScaledDecimal.	self assert: 0 = sd scale.	self assert: ('13s0' = sd printString).	sd := -13 asScaledDecimal.	self assert: 0 = sd scale.	self assert: ('-13s0' = sd printString).	sd := 130000000013 asScaledDecimal.	self assert: 0 = sd scale.	self assert: ('130000000013s0' = sd printString).	sd := -130000000013 asScaledDecimal.	self assert: 0 = sd scale.	self assert: ('-130000000013s0' = sd printString)! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 2/13/2010 23:13'!testConvertFromIntegerWithScale	"Converting an Integer with asScaledDecimal: does now honour the scale passed as message argument."	| sd |	sd := 13 asScaledDecimal: 6.	self assert: 6 = sd scale.	self assert: ('13.000000s6' = sd printString).	sd := -13 asScaledDecimal: 4.	self assert: 4 = sd scale.	self assert: ('-13.0000s4' = sd printString).	sd := 130000000013 asScaledDecimal: 3.	self assert: 3 = sd scale.	self assert: ('130000000013.000s3' = sd printString).	sd := -130000000013 asScaledDecimal: 1.	self assert: 1 = sd scale.	self assert: ('-130000000013.0s1' = sd printString)! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 12/3/2007 20:35'!testIsLiteral	"This test is related to http://bugs.squeak.org/view.php?id=6796"		self assert: 1.00s2 isLiteral description: 'every literal obviously isLiteral'.		"Note that (1 / 3.00s2) is not a well behaved literal,	because it does not re-evaluate to self...	Every literal should be evaluated as self (see isSelfEvaluating).	There is currently no way to print it as a literal.	So i propose it shall not answer true."	self deny: (1/3.00s2) isLiteral description: 'this number cannot represent itself as a literal'.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 13:38'!testLiteral	| sd |	sd := 1.40s2.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '1.40s2' = sd printString! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 5/17/2009 00:38'!testOneRaisedToInteger	"One might be handled specially"		self assert: (1.0s1 raisedToInteger: -1) scale = 1.	self assert: (1.0s1 raisedToInteger: -1) = 1.	self assert: (1.0s1 raisedToInteger: 0) scale = 1.	self assert: (1.0s1 raisedToInteger: 0) = 1.	self assert: (1.0s1 raisedToInteger: 1) scale = 1.	self assert: (1.0s1 raisedToInteger: 1) = 1.	self assert: (1.0s1 raisedToInteger: 2) scale = 1.	self assert: (1.0s1 raisedToInteger: 2) = 1.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 11:51'!testPrintString	"The printed representation of a ScaledDecimal is truncated, not rounded.	Not sure if this is right, so this test describes the current Squeak implementation.	If someone knows a reason that rounding would be preferable, then update	this test."	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ('1.181818s6' = sd printString).	sd := (13 / 11) asScaledDecimal: 5.	self deny: ('1.18182s5' = sd printString).	sd := (13 / 11) asScaledDecimal: 5.	self assert: ('1.18181s5' = sd printString)! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 5/17/2009 00:35'!testRaisedToInteger	"Raising to integer should preserve class and scale"		self assert: (3.0s1 raisedToInteger: -1) scale = 1.	self assert: (3.0s1 raisedToInteger: -1) = (1/3).	self assert: (3.0s1 raisedToInteger: 0) scale = 1.	self assert: (3.0s1 raisedToInteger: 0) = 1.	self assert: (3.0s1 raisedToInteger: 1) scale = 1.	self assert: (3.0s1 raisedToInteger: 1) = 3.	self assert: (3.0s1 raisedToInteger: 2) scale = 1.	self assert: (3.0s1 raisedToInteger: 2) = 9.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 11/22/2007 22:42'!testReadFrom	"This is related to http://bugs.squeak.org/view.php?id=6779"		self should: [(ScaledDecimal readFrom: '5.3') isKindOf: ScaledDecimal]		description: 'Reading a ScaledDecimal should answer a ScaledDecimal'.	self should: [((ScaledDecimal readFrom: '5.3') asScaledDecimal: 1) = (53/10 asScaledDecimal: 1)]		description: 'ScaledDecimal readFrom: should not use Float intermediate because it would introduce round off errors'.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 5/17/2009 00:31'!testScaleExtension	"The scale is extended to the larger one in case of arithmetic operation"		#( #* #+ #- #/) do: [:op |		self assert: (2.5s1 perform: op with: 1.000s3) scale = 3.		self assert: (3.5000s4 perform: op with: 1.0s1) scale = 4.]! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 12/3/2007 21:43'!testStoreOn	"this is http://bugs.squeak.org/view.php?id=4378"		"Both results should be 1.	ScaledDecimal representations are exact	(though only scale digits or fractional part are printed)"	self assert:    		(Compiler evaluate: (0.5s1 squared storeString)) * 4		= (0.5s1 squared * 4).				"However, exact literals should store literaly	If not, they would break Decompiler."		"BUG: i cannot write the test like this:	self assert:    		0.5s2 squared storeString = '0.25s2'	BECAUSE compiler would consider 0.5s2 as = 0.5s1 and would reuse same slot..."		self assert:    		0.25s2 storeString = '0.25s2'! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 5/17/2009 00:40'!testZeroRaisedToInteger	"Zero might be handle specially"		self should: [0.0s1 raisedToInteger: -1] raise: Error.	self assert: (0.0s1 raisedToInteger: 0) = 1.	self assert: (0.0s1 raisedToInteger: 0) scale = 1.	self assert: (0.0s1 raisedToInteger: 1) = 0.	self assert: (0.0s1 raisedToInteger: 1) scale = 1.	self assert: (0.0s1 raisedToInteger: 2) = 0.	self assert: (0.0s1 raisedToInteger: 2) scale = 1.! !!ScaledDecimalTest commentStamp: '<historical>' prior: 0!I provide a test suite for ScaledDecimal values. Examine my tests to see how SmallIntegers should behave, and see how to use them.!!Scanner methodsFor: 'expression types' stamp: 'eem 7/2/2010 10:07'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !!Scanner methodsFor: 'public access' stamp: 'eem 8/20/2008 20:55'!scanTokens: textOrString 	"Answer an Array that has been tokenized as though the input text, 	textOrString, had appeared between the array delimitors #( and ) in a 	Smalltalk literal expression."	self initScannerForTokenization.	self scan: (ReadStream on: textOrString asString).	self scanLitVec.	^token	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !!Scanner methodsFor: 'public access' stamp: 'eem 8/30/2010 13:16'!typedScan: textOrString do: aBinaryBlock	"Evaluate aBinaryBlock with the token and its type for the first token in input,	 mapping literals to type #literal and anything else to type #word."	| theTokensType theToken |	self initScannerForTokenization.	self scan: (ReadStream on: textOrString asString).	theTokensType := tokenType.	theToken := self nextLiteral.	[tokenType = #keyword and: [theToken last = $:]] whileTrue:		[theToken := theToken, self nextLiteral].	theToken isNumber ifTrue: [theTokensType := #number].	^aBinaryBlock		value: theToken		value: ((#(number string literal) includes: theTokensType)				ifTrue: [#literal]				ifFalse: [#word])! !!Scanner class methodsFor: 'class initialization' stamp: 'ar 4/5/2006 01:31'!initialize	| newTable |	newTable := Array new: 256 withAll: #xIllegal. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #xUnderscore.	newTable at: $| asciiValue put: #verticalBar.	TypeTable := newTable "bon voyage!!"	"Scanner initialize"! !!ScannerTest methodsFor: 'testing' stamp: 'jmv 2/24/2010 10:03'!testLiteralSymbols	self assert: ('*+-/\~=<>&@%,|' allSatisfy: [:char | Scanner isLiteralSymbol: (String with: char) asSymbol])		description: 'single letter binary symbols can be printed without string quotes'.			self assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | Scanner isLiteralSymbol: str asSymbol])		description: 'valid ascii selector symbols can be printed without string quotes'.			((32 to: 126) collect: [:ascii | Character value: ascii]) ,	#(':x:yourself' '::' 'x:yourself' '123' 'x0:1:2:' 'x.y.z' '1abc' 'a1b0c2' ' x' 'x ' '+x-y' '||' '--' '++' '+-' '+/-' '-/+' '<|>' '#x' '()' '[]' '{}' '')		do: [:str |			self assert: (Compiler evaluate: str asSymbol printString) = str asSymbol				description: 'in all case, a Symbol must be printed in an interpretable fashion']! !!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!classToBeTested	^ Schedule! !!ScheduleTest methodsFor: 'Coverage' stamp: 'brp 9/25/2003 16:03'!selectorsToBeIgnored	| private | 	private := #( #printOn: ).	^ super selectorsToBeIgnored, private! !!ScheduleTest methodsFor: 'running' stamp: 'brp 9/26/2004 19:30'!setUp 	 "Schedule is a type of Timespan representing repeated occurences of the same event. 	The beginning of the schedule is the first occurrence of the event.	A schedule maintains an array of Durations. 	Each durations specify the offset to the next scheduled each. 	The duration of each occurence of the event is not specified. 	Nor are any other attributes such as name"	restoredTimeZone := DateAndTime localTimeZone.	DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz | tz abbreviation = 'GMT']).	"Create aSchedule with an event scheduled for 8:30pm every Saturday 	and Sunday for the year 2003. "	"Create the first event occurring on the first Saturday at 8:30 pm: 1/4/03"	firstEvent :=  DateAndTime year: 2003 month: 1 day: 4 hour: 20 minute: 30. 		"Create a schedule for one year starting with the first event" 	aSchedule := Schedule starting: firstEvent duration: 52 weeks.	"Schedule the recurring events by scheduling the time in between each one.  	One day for Sat-Sun. 6 days for Sun-Sat" 	aSchedule schedule: { Duration days: 1. Duration days: 6 }.! !!ScheduleTest methodsFor: 'running' stamp: 'brp 9/26/2004 19:30'!tearDown	DateAndTime localTimeZone: restoredTimeZone.! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoDisjointWithSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2004				month: 4				day: 1)		and: (DateAndTime				year: 2004				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 0! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoIncludedInSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2003				month: 4				day: 1)		and: (DateAndTime				year: 2003				month: 4				day: 30)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testBetweenAndDoOverlappingSchedule	| count |	count := 0.	aSchedule		between: (DateAndTime				year: 2002				month: 12				day: 1)		and: (DateAndTime				year: 2003				month: 1				day: 31)		do: [:each | count := count + 1].	self assert: count = 8! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testDateAndTimes	| answer |	self assert: aSchedule dateAndTimes size  = 104.	self assert: aSchedule dateAndTimes first = firstEvent.	answer := true.	aSchedule dateAndTimes do: [:each | (each dayOfWeekName = 'Saturday'		or: [each dayOfWeekName = 'Sunday']) ifFalse: [^false]].	self assert: answer! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testExampleFromSwikiPage	"It is often neccessary to schedule repeated events, like airline flight schedules, TV programmes, and file backups.	 Schedule is a Timespan which maintains an array of Durations.	 The durations specify the offset to the next scheduled DateAndTime. "	"Consider a TV programme scheduled for 8:30pm every Saturday and Sunday for the current year. "	"Find the first Saturday and set its time to 20h30"	| sat shows |	sat := Year current asMonth dates detect: [ :d | d dayOfWeekName = #Saturday ].	sat := sat start + (Duration hours: 20.5).	"Create a schedule" 	shows := Schedule starting: sat ending: Year current end.	shows schedule: { Duration days: 1. Duration days: 6 }.	"To inspect:"	shows dateAndTimes.	shows dateAndTimes collect: [ :dt | dt dayOfWeekName ].! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testIncludes	self assert: (aSchedule includes: (DateAndTime year: 2003 month: 6 day: 15 hour: 20 minute: 30 second: 0 offset: 0 hours))	! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testSchedule	self assert: aSchedule schedule size = 2.	self assert: aSchedule schedule first = 1 days.		self assert: aSchedule schedule second = 6 days.! !!ScheduleTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 16:08'!testFromDateAndTime	| oc1 oc2 |	oc1 := OrderedCollection new.	DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [ :dt | oc1 add: dt ].	oc2 := { DateAndTime today. 			(DateAndTime today + 10 hours). 				(DateAndTime today + 20 hours) }.	self assert: (oc1 asArray = oc2)! !!ScheduleTest methodsFor: 'Tests' stamp: 'nk 3/30/2004 10:34'!testMonotonicity	| t1 t2 t3 t4 |	t1 := DateAndTime now.	t2 := DateAndTime now.	t3 := DateAndTime now.	t4 := DateAndTime now.	self 		assert: (	t1 <= t2);		assert: (	t2 <= t3);		assert: (	t3 <= t4).! !!ScreenController methodsFor: 'menu messages' stamp: 'nk 7/29/2004 10:12'!aboutThisSystem 	SmalltalkImage current aboutThisSystem! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/13/1998 16:03'!absorbUpdatesFromServer 	Utilities updateFromServer! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:25'!bitCachingString	^ StandardSystemView cachingBits		ifTrue: ['don''t save bits (compact)']		ifFalse: ['save bits (fast)']! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:17'!browseChangedMessages	ChangeSet  browseChangedMessages! !!ScreenController methodsFor: 'menu messages'!browseRecentSubmissions	"Open a method-list browser on recently-submitted methods.  5/16/96 sw"	Utilities browseRecentSubmissions! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:50'!changeWindowPolicy	Preferences toggleWindowPolicy! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!chooseDirtyWindow	"Put up a list of windows with unaccepted edits and let the user chose one to activate."	"ScheduledControllers screenController chooseDirtyWindow"	ScheduledControllers findWindowSatisfying:		[:c | c model canDiscardEdits not].! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!closeUnchangedWindows	"Close any window that doesn't have unaccepted input."	| clean |	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	clean := ScheduledControllers scheduledControllers select:		[:c | c model canDiscardEdits and: [(c isKindOf: ScreenController) not]].	clean do: [:c | c closeAndUnscheduleNoTerminate].	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages'!collapseAll	"Collapses all open windows"	ScheduledControllers scheduledControllers do:		[:controller | controller == self ifFalse:			[controller view isCollapsed ifFalse:					[controller collapse.					controller view deEmphasize]]]! !!ScreenController methodsFor: 'menu messages'!commonRequests 	"Put up a popup of common requests, and perform whatever the user request.  2/1/96 sw"	Utilities offerCommonRequests! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 12/10/1999 11:29'!configureFonts	Preferences presentMvcFontConfigurationMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 8/9/2009 14:44'!editPreferences	"Open up a Preferences inspector.  2/7/96 sw"	self inform: 'The preference browser is currently not available in MVC'! !!ScreenController methodsFor: 'menu messages'!emergencyCollapse	"Emergency collapse of a selected window"	| controller |	(controller := ScheduledControllers windowFromUser) notNil		ifTrue:			[controller collapse.			controller view deEmphasize]! !!ScreenController methodsFor: 'menu messages' stamp: 'dao 10/1/2004 13:14'!exitProject 	"Leave the current Project and enter the Project in which the receiver's 	view is scheduled."	Project current exit! !!ScreenController methodsFor: 'menu messages'!expandAll	"Reopens all collapsed windows"	ScheduledControllers scheduledControllers reverseDo:		[:controller | controller == self ifFalse:			[controller view isCollapsed				ifTrue:  [controller view expand]				ifFalse: [controller view displayDeEmphasized]]]! !!ScreenController methodsFor: 'menu messages'!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 2/3/2000 16:23'!fileForRecentLog	Smalltalk writeRecentToFile! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 1/16/2004 21:32'!fileOutChanges	ChangeSet current verboseFileOut.! !!ScreenController methodsFor: 'menu messages'!findWindow	"Put up a menu of all windows on the screen, and let the user select one.	 1/18/96 sw: the real work devolved to ControlManager>>findWindowSatisfying:"	ScheduledControllers findWindowSatisfying: [:c | true]! !!ScreenController methodsFor: 'menu messages' stamp: 'nk 6/17/2003 14:39'!fontSizeSummary	TextStyle fontSizeSummary! !!ScreenController methodsFor: 'menu messages' stamp: 'dtl 2/10/2010 10:23'!fullScreenOff	Project current fullScreenOff! !!ScreenController methodsFor: 'menu messages' stamp: 'dtl 2/10/2010 10:24'!fullScreenOn	Project current fullScreenOn! !!ScreenController methodsFor: 'menu messages' stamp: 'nk 2/15/2004 09:37'!garbageCollect	"Do a garbage collection, and report results to the user."	Utilities garbageCollectAndReport! !!ScreenController methodsFor: 'menu messages' stamp: 'dtl 11/23/2009 23:38'!jumpToProject	Project current jumpToProject.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/23/2003 14:41'!lookForSlips	ChangeSet current lookForSlips! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 9/27/2005 20:11'!newChangeSet	ChangeSet newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 9/27/2005 20:33'!openBrowser 	"Create and schedule a Browser view for browsing code."	ToolSet browse: nil selector: nil! !!ScreenController methodsFor: 'menu messages'!openCommandKeyHelp	"1/18/96 sw Open a window that explains command-keys"	Utilities openCommandKeyHelp! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 9/18/2009 20:08'!openMorphicProject	"Open a morphic project from within a MVC project"	Smalltalk at: #MorphicProject ifPresent:[:mp| ProjectView open: mp new].! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 9/18/2009 21:36'!openProject 	"Create and schedule a Project."	ProjectView open: MVCProject new.! !!ScreenController methodsFor: 'menu messages'!openStandardWorkspace	"Open a standard, throwaway window chock full of useful expressions.  1/17/96 sw"	Utilities openStandardWorkspace! !!ScreenController methodsFor: 'menu messages' stamp: 'di 5/8/1998 12:49'!openTranscript 	"Create and schedule the System Transcript."	Transcript open! !!ScreenController methodsFor: 'menu messages' stamp: 'ar 9/27/2005 20:46'!openWorkspace 	"Create and schedule workspace."	UIManager default edit:'' label: 'Workspace'! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!quit	SmalltalkImage current		snapshot:			(self confirm: 'Save changes before quitting?' translated				orCancel: [^ self])		andQuit: true! !!ScreenController methodsFor: 'menu messages' stamp: 'dtl 12/28/2009 16:16'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Project current restoreDisplay! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/22/1998 06:45'!returnToPreviousProject	Project returnToPreviousProject.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 13:17'!saveAs	^ SmalltalkImage current saveAs! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/10/96'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	Utilities setAuthorInitials! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/26/96'!setDesktopColor	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   "	Preferences desktopColor: Color fromUser.	ScheduledControllers updateGray; restore! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 9/18/1999 20:01'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result := (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result]! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!snapshot	SmalltalkImage current snapshot: true andQuit: false! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 11/16/2003 14:17'!snapshotAndQuit	"Snapshot and quit without bother the user further.  2/4/96 sw"	SmalltalkImage current		snapshot: true		andQuit: true! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:01'!soundEnablingString	^ Preferences soundEnablingString! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 3/16/2000 18:26'!soundOnOrOff	Preferences setPreference: #soundsEnabled		toValue: Preferences soundsEnabled not! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:23'!staggerPolicyString	^ Preferences staggerPolicyString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/29/2000 00:26'!standardGraphicsLibrary	"Open a standard, throwaway window chock full of useful expressions.  1/17/96 sw"	ScriptingSystem inspectFormDictionary! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 5/11/2003 22:04'!viewImageImports	"Open an inspector on forms imported from Image files."	Imports default viewImages! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 9/30/2003 13:53'!vmStatistics	"Open a string view on a report of vm statistics"	(StringHolder new contents: SmalltalkImage current  vmStatisticsReportString)		openLabel: 'VM Statistics'! !!ScreenController methodsFor: 'nested menus' stamp: 'ar 8/15/2009 14:56'!appearanceMenu 	"Answer the appearance menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(			'system fonts...'			'full screen on'			'full screen off'			'set display depth...'			'set desktop color...' ) 		lines: #(2 4)		selections: #(configureFontsfullScreenOn fullScreenOff setDisplayDepth setDesktopColor)"ScreenController new appearanceMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'ar 11/12/2009 01:07'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(			'simple change sorter'			'dual change sorter'			'file out current change set'			'create new change set...'			'browse changed methods'			'check change set for slips'			'browse recent submissions'			'recently logged changes...'			'recent log file...'			)		lines: #(1 3 7)		selections: #(openSimpleChangeSorter openChangeManagerfileOutChanges newChangeSet browseChangedMessages lookForSlipsbrowseRecentSubmissions browseRecentLog fileForRecentLog)"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'ar 8/15/2009 15:01'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(			'about this system...'			'update code from server'			'preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view graphical imports'			'standard graphics library'),			(Array with: (Preferences soundsEnabled							ifFalse: ['turn sound on']							ifTrue: ['turn sound off'])) ,		#(	'set author initials...'			'vm statistics'			'space left')		lines: #(1 4 6 11)		selections: #( aboutThisSystem absorbUpdatesFromServereditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsstandardGraphicsLibrary soundOnOrOff setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'dtl 10/31/2009 19:27'!openMenu	"Smalltalk hasMorphic ifTrue: [^self openMenuWithMorphicOptions]."	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'package browser'			'method finder'			'workspace'			'file list'			'file...'			'transcript'			'simple change sorter'			'dual change sorter'			'new project'			)		lines: #(1 8 10)		selections: #(durableOpenMenuopenBrowser openPackageBrowser openSelectorBrowser openWorkspace openFileList openFile openTranscriptopenSimpleChangeSorter openChangeManageropenProject   )"ScreenController  new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'dtl 10/31/2009 19:32'!openMenuWithMorphicOptions	"Include 'morphic world' and 'morphic project' selections"	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'package browser'			'method finder'			'workspace'			'file list'			'file...'			'transcript'			'morphic world'			'simple change sorter'			'dual change sorter'			'mvc project'			'morphic project'			)		lines: #(1 9 11)		selections: #(durableOpenMenuopenBrowser openPackageBrowser openSelectorBrowser openWorkspace openFileList openFile openTranscript openMorphicWorldopenSimpleChangeSorter openChangeManageropenProject  openMorphicProject  )"ScreenController  new openMenuWithMorphicOptions startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sma 3/11/2000 12:23'!popUpMenuFor: aSymbol	(self perform: aSymbol) invokeOn: self! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/13/1999 18:07'!presentAppearanceMenu	self popUpMenuFor: #appearanceMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'ar 8/15/2009 14:59'!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(			'previous project'			'jump to project...'			'restore display'			'open...'			'windows...'			'changes...'			'help...'			'appearance...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 10)		selections: #(returnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu presentAppearanceMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'ar 8/15/2009 15:00'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(			'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows' ) , 			(Array				with: self bitCachingString				with: self staggerPolicyString)		lines: #(1 4 7)		selections: #(findWindow chooseDirtyBrowser chooseDirtyWindowcollapseAll expandAll closeUnchangedWindowsfastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"! !!ScreenController methodsFor: 'cursor'!centerCursorInView	"Override so this doesn't happen when taking control"! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:21'!controlActivity	"Any button opens the screen's menu.	If the shift key is down, do find window."	sensor leftShiftDown ifTrue: [^ self findWindow].	(self projectScreenMenu invokeOn: self) ifNil: [super controlActivity]! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:06'!isControlActive	^ self isControlWanted! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:05'!isControlWanted	^ self viewHasCursor and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:47'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp := DiskProxy global: #ScheduledControllers selector: #screenController args: #().	refStrm replace: self with: dp.	^ dp! !!ScreenController methodsFor: '*Tools' stamp: 'ab 8/22/2003 18:39'!browseRecentLog	"Open a changelist browser on changes submitted since the last snapshot.  1/17/96 sw"	ChangeList browseRecentLog! !!ScreenController methodsFor: '*Tools' stamp: 'tk 4/13/1998 23:12'!chooseDirtyBrowser	"Put up a list of browsers with unsubmitted edits and activate the one selected by the user, if any."	"ScheduledControllers screenController chooseDirtyBrowser"	ScheduledControllers findWindowSatisfying:		[:c | (c model isKindOf: Browser) and: [c model canDiscardEdits not]]. ! !!ScreenController methodsFor: '*Tools'!openChangeManager	"Open a dual change sorter.  For looking at two change sets at once."	DualChangeSorter new open! !!ScreenController methodsFor: '*Tools' stamp: 'sw 6/9/1999 12:30'!openFile	FileList openFileDirectly! !!ScreenController methodsFor: '*Tools'!openFileList	"Create and schedule a FileList view for specifying files to access."	FileList open! !!ScreenController methodsFor: '*Tools' stamp: 'ar 1/31/2001 17:06'!openPackageBrowser 	"Create and schedule a Browser view for browsing code."	PackagePaneBrowser openBrowser! !!ScreenController methodsFor: '*Tools' stamp: 'tk 8/31/1998 16:18'!openSelectorBrowser	"Create and schedule a selector fragment window."	SelectorBrowser new open! !!ScreenController methodsFor: '*Tools' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController commentStamp: '<historical>' prior: 0!I am the controller for the parts of the display screen that have no view on them. I only provide a standard yellow button menu. I view (a FormView of) an infinite gray form.  (ScheduledControllers screenController) is the way to find me.!!ScrollController methodsFor: 'scrolling'!anyButtonActivity	"deal with red button down in scrollBar beyond yellowLine"	self yellowButtonActivity! !!ScrollController methodsFor: 'scrolling'!downLine	"if cursor before downLine, display down cursor and scroll down on button down"	^scrollBar left + 6 ! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor := sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling'!scrollAmount	"Answer the number of bits of y-coordinate should be scrolled. This is a 	default determination based on the view's preset display transformation."	^((view inverseDisplayTransform: sensor cursorPoint)		- (view inverseDisplayTransform: scrollBar inside topCenter)) y! !!ScrollController methodsFor: 'scrolling' stamp: 'th 12/11/1999 16:57'!scrollByKeyboard	| keyEvent |	keyEvent := sensor keyboardPeek.	keyEvent ifNil: [^ false].	(sensor controlKeyPressed or:[sensor commandKeyPressed]) ifFalse: [^ false].	keyEvent asciiValue = 30		ifTrue: 			[sensor keyboard.			self scrollViewDown ifTrue: [self moveMarker].			^ true].	keyEvent asciiValue = 31		ifTrue: 			[sensor keyboard.			self scrollViewUp ifTrue: [self moveMarker].			^ true].	^ false! !!ScrollController methodsFor: 'scrolling'!scrollView	"The scroll bar jump method was used so that the view should be 	updated to correspond to the location of the scroll bar gray area.	Return true only if scrolling took place."	^ self scrollView: self viewDelta! !!ScrollController methodsFor: 'scrolling'!scrollView: anInteger 	"Tell the reciever's view to scroll by anInteger amount.	Return true only if scrolling actually resulted."	(view scrollBy: 0 @ 				((anInteger min: view window top - view boundingBox top)						max: view window top - view boundingBox bottom))		ifTrue: [view clearInside; display.  ^ true]		ifFalse: [^ false]! !!ScrollController methodsFor: 'scrolling'!scrollViewDown	"Scroll the receiver's view down the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount! !!ScrollController methodsFor: 'scrolling'!scrollViewUp	"Scroll the receiver's view up the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount negated! !!ScrollController methodsFor: 'scrolling'!upDownLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!upLine	"if cursor beyond upLine, display up cursor and scroll up on button down"	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!viewDelta	"Answer an integer that indicates how much the view should be scrolled. 	The scroll bar has been moved and now the view must be so the amount 	to scroll is computed as a ratio of the current scroll bar position."	^view window top - view boundingBox top -		((marker top - scrollBar inside top) asFloat /			scrollBar inside height asFloat *				view boundingBox height asFloat) rounded! !!ScrollController methodsFor: 'scrolling'!yellowLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 16! !!ScrollController methodsFor: 'cursor'!changeCursor: aCursor 	"The current cursor should be set to be aCursor."	sensor currentCursor ~~ aCursor ifTrue: [aCursor show]! !!ScrollController methodsFor: 'cursor'!markerContainsCursor	"Answer whether the gray area inside the scroll bar area contains the 	cursor."	^marker inside containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'cursor'!menuBarContainsCursor	"Answer whether the cursor is anywhere within the menu bar area."	^ menuBar notNil and:			[menuBar containsPoint: sensor cursorPoint]! !!ScrollController methodsFor: 'cursor'!scrollBarContainsCursor	"Answer whether the cursor is anywhere within the scroll bar area."	^scrollBar containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'marker adjustment'!computeMarkerRegion	"Answer the rectangular area in which the gray area of the scroll bar 	should be displayed."	^0@0 extent: Preferences scrollBarWidth @			((view window height asFloat /						view boundingBox height *							scrollBar inside height)				 rounded min: scrollBar inside height)! !!ScrollController methodsFor: 'marker adjustment'!markerDelta	^ marker top 		- scrollBar inside top  		- ((view window top - view boundingBox top) asFloat 			/ view boundingBox height asFloat *				scrollBar inside height asFloat) rounded! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker := marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !!ScrollController methodsFor: 'marker adjustment'!moveMarker	"The view window has changed. Update the marker."	self moveMarker: self markerDelta negated anchorMarker: nil! !!ScrollController methodsFor: 'marker adjustment'!moveMarker: anInteger anchorMarker: anchorMarker	"Update the marker so that is is translated by an amount corresponding to 	a distance of anInteger, constrained within the boundaries of the scroll 	bar.  If anchorMarker ~= nil, display the border around the area where the	marker first went down."	Display fill: marker fillColor: scrollBar insideColor.	anchorMarker = nil		ifFalse: [Display border: anchorMarker width: 1 fillColor: Color gray].	marker := marker translateBy: 0 @				((anInteger min: scrollBar inside bottom - marker bottom) max:					scrollBar inside top - marker top).	marker displayOn: Display! !!ScrollController methodsFor: 'marker adjustment'!moveMarkerTo: aRectangle 	"Same as markerRegion: aRectangle; moveMarker, except a no-op if the marker	 would not move."	(aRectangle height = marker height and: [self viewDelta = 0]) ifFalse:		[self markerRegion: aRectangle.		self moveMarker]! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:17'!controlActivity	self scrollByKeyboard ifTrue: [^ self].	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self normalActivity]! !!ScrollController methodsFor: 'control defaults' stamp: 'ar 3/24/2000 00:45'!isControlActive 	super isControlActive ifTrue: [^ true].	sensor blueButtonPressed ifTrue: [^ false].	^ (scrollBar inside merge: view insetDisplayBox) containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:31'!isControlWanted	^ self viewHasCursor! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:16'!normalActivity	super controlActivity! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar := scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker := marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea := Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar := Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'basic control sequence'!controlTerminate	super controlTerminate.	savedArea notNil 			ifTrue: 			[savedArea displayOn: Display at: scrollBar topLeft.			savedArea := nil].! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar := Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker := Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar := Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'private'!scrollAbsolute	| markerOutline oldY markerForm |	self changeCursor: Cursor rightArrow.	oldY := -1.	sensor anyButtonPressed ifTrue: 	  [markerOutline := marker deepCopy.	  markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  Display border: markerOutline width: 1 fillColor: Color gray.	  markerForm 		follow: 			[oldY ~= sensor cursorPoint y				ifTrue: 					[oldY := sensor cursorPoint y.					marker := marker translateBy: 					  0 @ ((oldY - marker center y 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).					self scrollView].				marker origin] 		while: [sensor anyButtonPressed].	  Display fill: markerOutline fillColor: scrollBar insideColor.	  self moveMarker]! !!ScrollController methodsFor: 'private'!scrollDown	| markerForm firstTime |	self changeCursor: Cursor down.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewDown ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController methodsFor: 'private'!scrollUp	| markerForm firstTime |	self changeCursor: Cursor up.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewUp ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController commentStamp: '<historical>' prior: 0!I represent control for scrolling using a scrollBar. I am a MouseMenuController that creates a scrollBar, rather than menus. My subclasses add the button menus. I keep control as long as the cursor is inside the view or the scrollBar area.	A scrollBar is a rectangular area representing the length of the information being viewed. It contains an inner rectangle whose top y-coordinate represents the relative position of the information visible on the screen with respect to all of the information, and whose size represents the relative amount of that information visible on the screen. The user controls which part of the information is visible by pressing the red button. If the cursor is to the right of the inner rectangle, the window onto the visible information moves upward, if the cursor is to the left, the window moves downward, and if the cursor is inside, the inner rectangle is grabbed and moved to a desired position.!!SecureHashAlgorithm methodsFor: 'public' stamp: 'ar 4/6/2010 17:35'!hashStream: aPositionableStream	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength finished |	self initializeTotals.	"A previous implementation used multiple sends of #atEnd.  This is slow when directly processing a FileStream.  Also, using #nextInto: instead of #next: reduces the number of ByteArray allocations."	finished := false.	buf := ByteArray new: 64.	startPosition := aPositionableStream position.	[finished] whileFalse: [		buf := aPositionableStream nextInto: buf.		finished := buf size < 64.		finished 			ifFalse: [self processBuffer: buf]			ifTrue: [				bitLength := (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength].	].	^ self finalHash! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'ar 2/25/2010 23:40'!testEmptyInput	self assert: ((SecureHashAlgorithm new hashMessage: '') radix: 16)			= 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709'! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample1	"This is the first example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage: 'abc'.	self assert: (hash = 16rA9993E364706816ABA3E25717850C26C9CD0D89D).		! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample2	"This is the second example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage:		'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'.	self assert: (hash = 16r84983E441C3BD26EBAAE4AA1F95129E5E54670F1).! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:25'!testExample3	"This is the third example from the specification document (FIPS PUB 180-1). 	This example may take several minutes."	hash := SecureHashAlgorithm new hashMessage: (String new: 1000000 withAll: $a).	self assert: (hash = 16r34AA973CD4C4DAA4F61EEB2BDBAD27316534016F).! !!SecureHashAlgorithmTest commentStamp: '<historical>' prior: 0!This is the unit test for the class SecureHashAlgorithm. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!SecurityManager methodsFor: 'accessing' stamp: 'ar 12/31/2007 10:52'!untrustedUserDirectory	"SecurityManager default untrustedUserDirectory"	| dir |	dir := self primUntrustedUserDirectory.	^ dir		ifNil: [FileDirectory default pathName]		ifNotNil: [dir utf8ToSqueak]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:47'!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:15'!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitSelectorNode: self! !!Semaphore methodsFor: 'communication'!wait	"Primitive. The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 86>	self primitiveFailed	"excessSignals>0  		ifTrue: [excessSignals := excessSignals-1]  		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !!Semaphore methodsFor: 'accessing' stamp: 'ar 9/10/2007 18:52'!signalCount	"Answer the number of outstanding signals on this semaphore."	^excessSignals! !!SemaphoreTest methodsFor: 'private' stamp: 'tlk 5/5/2006 13:26'!criticalError	Processor activeProcess terminate! !!SemaphoreTest methodsFor: 'testing' stamp: 'tlk 5/5/2006 13:27'!testCritical	| lock |	lock := Semaphore forMutualExclusion.	[lock critical: [self criticalError]] forkAt: Processor userInterruptPriority.	self assert: lock isSignaled! !!SemaphoreTest methodsFor: 'testing' stamp: 'tlk 5/5/2006 13:28'!testCriticalIfError	| lock |	lock := Semaphore forMutualExclusion.	[lock critical: [self criticalError ifError:[]]] forkAt: Processor userInterruptPriority.	self assert: lock isSignaled! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/6/2007 11:04'!testSemaAfterCriticalWait	"self run: #testSemaAfterCriticalWait"	"This tests whether a semaphore that has just left the wait in Semaphore>>critical:	leaves it with signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] forkAt: Processor activePriority-1.	"wait until p entered the critical section"	[p suspendingList == s] whileFalse:[(Delay forMilliseconds: 10) wait].	"Now that p entered it, signal the semaphore. p now 'owns' the semaphore	but since we are running at higher priority than p it will not get to do	anything."	s signal.	p terminate.	self assert: ((s instVarNamed: #excessSignals) = 1)! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 10/6/2007 11:05'!testSemaInCriticalWait	"self run: #testSemaInCriticalWait"	"This tests whether a semaphore that has entered the wait in Semaphore>>critical:	leaves it without signaling the associated semaphore."	| s p |	s := Semaphore new.	p := [s critical:[]] fork.	Processor yield.	self assert:(p suspendingList == s).	p terminate.	self assert:((s instVarNamed: #excessSignals) = 0)! !!SemaphoreTest methodsFor: 'testing' stamp: 'jf 12/2/2003 19:31'!testWaitAndWaitTimeoutTogether	| semaphore value waitProcess waitTimeoutProcess |	semaphore := Semaphore new.		waitProcess := [semaphore wait. value := #wait] fork.	waitTimeoutProcess := [semaphore waitTimeoutMSecs: 50. value := #waitTimeout] fork.	"Wait for the timeout to happen"	(Delay forMilliseconds: 100) wait.	"The waitTimeoutProcess should already have timed out.  This should release the waitProcess"	semaphore signal.	[waitProcess isTerminated and: [waitTimeoutProcess isTerminated]]		whileFalse: [(Delay forMilliseconds: 100) wait].	self assert: value = #wait.	! !!SemaphoreTest methodsFor: 'testing' stamp: 'ar 3/23/2009 17:01'!testWaitTimeoutMSecs	"Ensure that waitTimeoutMSecs behaves properly"	"Ensure that a timed out waitTimeoutMSecs: returns true from the wait"	self assert: (Semaphore new waitTimeoutMSecs: 50) == true.	"Ensure that a signaled waitTimeoutMSecs: returns false from the wait"	self assert: (Semaphore new signal waitTimeoutMSecs: 50) == false.! !!SemaphoreTest commentStamp: 'tlk 5/5/2006 13:32' prior: 0!A SemaphoreTest is sunit test for simple and multiEx semaphoresInstance Variables none; does not have common test fixture accross all tests (because its testing differenct sorts of semaphores (could refactor into muliple testcases if there were more test conditions.!!SequenceableCollection methodsFor: 'copying' stamp: 'eem 2/10/2009 11:44'!copyUpThrough: anElement 	"Answer all elements up to and including anObject. If there	is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jcg 1/27/2009 18:32'!findNearbyBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, answer the closest index we could find."	| index low high test |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^index! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'bgf 8/11/2008 14:22'!withIndexDetect: aBlock ifNone: exceptionBlock 	"Just like detect:ifNone:, except that the block recieves the item index as second argument."	self doWithIndex: [: each : i | (aBlock value: (self at: i) value: i) ifTrue: [^ each]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'bgf 8/2/2008 20:49'!withIndexSelect: aBlock 	"Just like select:, except the block receives a second argument, the index of the element"	| aStream |	aStream := WriteStream on: (self species new: self size).	1 to: self size do: 		[:index |		(aBlock value: (self at: index) value: index)			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'testing' stamp: 'bgf 3/1/2008 22:23'!isFloatArray	^ false! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'sd 6/5/2005 09:21'!testAfterIfAbsent	| col |	col := #(2 3 4).	self assert: ((col after: 4 ifAbsent: ['block']) = 'block').	self assert: ((col after: 5 ifAbsent: ['block']) = 'block').	self assert: ((col after: 2 ifAbsent: ['block']) = 3).! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'sd 6/5/2005 09:22'!testBeforeIfAbsent	| col |	col := #(2 3 4).		self assert: ((col before: 2 ifAbsent: ['block']) = 'block').	self assert: ((col before: 5 ifAbsent: ['block']) = 'block').	self assert: ((col before: 3 ifAbsent: ['block']) = 2).! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'sd 6/5/2005 09:22'!testBeginsWith	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la prefix oc |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 1; add: 2; add: 3.	self assert: (la beginsWith: #(1)).	self assert: (la beginsWith: #(1 2)).	self assert: (la beginsWith: #(1 2 3)).	self assert: (la beginsWith: oc).	self deny: (la beginsWith: #()).	self deny: (la beginsWith: '').	self deny: (la beginsWith: OrderedCollection new).		self assert: (oc beginsWith: #(1 2)).		prefix := OrderedCollection new.	self deny: (oc beginsWith: prefix).	prefix add: 1.	self assert: (oc beginsWith: prefix).	prefix add: 2.	self assert: (oc beginsWith: prefix).	prefix add: 3.	self assert: (oc beginsWith: prefix).	prefix add: 4.	self deny: (oc beginsWith: prefix).! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'ar 2/1/2010 19:14'!testBeginsWithAnyOf	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 1; add: 2; add: 3.	self assert: (la beginsWithAnyOf: #((17) (1) (42))).	self assert: (la beginsWithAnyOf: #((17) (1 2) (42))).	self assert: (la beginsWithAnyOf: #((17) (1 2 3) (42))).	self deny: (la beginsWithAnyOf: #()).	self deny: (la beginsWithAnyOf: #(())).	self deny: (la beginsWithAnyOf: #((42))).! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'sd 6/5/2005 09:22'!testEndsWith	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc suffix |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 4; add: 5; add: 6.		self assert: (la endsWith: #(6)).	self assert: (la endsWith: #(5 6)).	self assert: (la endsWith: #(4 5 6)).	self assert: (la endsWith: oc).	self deny: (la endsWith: #()).	self deny: (la endsWith: '').		suffix := OrderedCollection new.	suffix add: 6.	self assert: (oc endsWith: suffix).	suffix addFirst: 5.	self assert: (oc endsWith: suffix).	suffix addFirst: 4.	self assert: (oc endsWith: suffix).	suffix addFirst: 3.	self deny: (oc endsWith: suffix).! !!SequenceableCollectionTest methodsFor: 'testing - testing' stamp: 'ar 2/1/2010 19:13'!testEndsWithAnyOf	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc |	la := #(6 5 4 3 2 1).	oc := OrderedCollection new.	oc add: 3; add: 2; add: 1.	self assert: (la endsWithAnyOf: #((17) (1) (42))).	self assert: (la endsWithAnyOf: #((17) (2 1) (42))).	self assert: (la endsWithAnyOf: #((17) (3 2 1) (42))).	self deny: (la endsWithAnyOf: #()).	self deny: (la endsWithAnyOf: #(())).	self deny: (la endsWithAnyOf: #((42))).! !!SequenceableCollectionTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:12'!testAtAllPut	|table|.	table := Array new: 5.	table atAllPut: $a.	self assert: (table allSatisfy: [:elem | elem = $a])! !!SequenceableCollectionTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:13'!testCopyWith	| table |	table := Array new: 4 withAll: 3.	self assert: table = #(3 3 3 3).	table := table copyWith: 4.	self assert: table = #(3 3 3 3 4).! !!SequenceableCollectionTest methodsFor: 'tests - converting' stamp: 'dc 3/3/2007 17:16'!testEvalStrings	| table |	table := #('String new' 'Array with: 3 with: $a' '15+4').	table := table evalStrings.	self assert: table first isString.	self assert: table first isEmpty.		self assert: table second isArray.	self assert: table second first = 3.	self assert: table second second = $a.		self assert: table third = 19.! !!SequenceableCollectionTest methodsFor: 'tests - converting' stamp: 'ar 2/27/2010 22:25'!testSplitBy	"Tests for  splitBy: and splitBy:do:"	self assert: ('a/b' splitBy: '/') = #('a' 'b').	self assert: ('a/b/' splitBy: '/') = #('a' 'b' '').	self assert: ('/a/b/' splitBy: '/') = #('' 'a' 'b' '').	self assert: ('///' splitBy: '/') = #('' '' '' '').	self assert: ('/' splitBy: '/') = #('' '').	self assert: ('a' splitBy: '/') = #('a').	self assert: ('' splitBy: '/') = #('').	self assert: ('a//b' splitBy: '//') = #('a' 'b').	self assert: ('///' splitBy: '//') = #('' '/').	self assert: ('Hello<p>World<p>' splitBy: '<p>') = #('Hello' 'World' '').! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:19'!testPreMultiplyByArray	| array|.	array := #(3).	self assert:(array preMultiplyByArray: 2)=6.		array := Array new: 4.	self should:[array preMultiplyByArray: 2] raise:Error.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:26'!testPreMultiplyByMatrix	| array matrix result|.	array := #(1 2 3 4 5).		"( 1  2  3  4  5	  10 20 30 40 50)"	matrix := Matrix				rows:2 columns:5 tabulate: [:row :column | row = 1 											ifTrue: column											ifFalse: column * 10].	result := array preMultiplyByMatrix: matrix.	self assert: result isArray.	self assert: result size = 2.	self assert: result first = 55.	self assert: result second = 550.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:28'!testPreMultiplyByMatrix2	| array matrix|.		array := #(1 2 3 4 5).	matrix := Matrix rows:1 columns:4 tabulate: [:row :column | column].		"Not compatible size"	self should:[array preMultiplyByMatrix: matrix] raise: Error.! !!SequenceableCollectionTest methodsFor: 'testing' stamp: 'dc 3/5/2007 15:57'!testReplaceFromToWithStartingAt	| string |	string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'lmnd'.		string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 2.	self assert: string = 'mnod'.		string := 'abcd' copy.	string replaceFrom: 2 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'almd'.! !!SequentialSound methodsFor: 'accessing' stamp: 'jcg 8/18/2008 13:41'!asSampledSound	"Try to avoid resampling... if all of our sounds have the same sampling rate (which they typically do), just concatenate the samples. "	| rates stream |	rates := (sounds collect: [:s | s originalSamplingRate]) asSet.	rates size > 1 ifTrue: [^super asSampledSound "sampling rates don't match"].	stream := WriteStream on: (SoundBuffer newMonoSampleCount: 										(sounds collect: [:s | s samples size]) sum).	sounds do: [:s | stream nextPutAll: s samples].	^SampledSound samples: stream contents samplingRate: rates anyOne	! !!ServerDirectory methodsFor: 'server groups' stamp: 'ar 3/27/2004 21:50'!serversInGroup	^group		ifNil: [Array with: self]		ifNotNil: [self class serversInGroupNamed: self groupName]! !!SetTest methodsFor: 'running' stamp: 'GL 2/27/2006 21:30'!setUp	empty := Set new.	full := Set with: 5 with: #abc! !!SetTest methodsFor: 'running' stamp: 'md 4/16/2003 15:03'!tearDown	"I am called whenever your test ends. I am the place where you release the ressources"! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 2/28/2006 08:26'!testAdd	empty add: 5.	self assert: (empty includes: 5).! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 2/28/2006 08:27'!testGrow	empty addAll: (1 to: 100).	self assert: (empty size = 100).			! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 2/28/2006 08:23'!testIllegal	self 		should: [empty at: 5] raise: TestResult error.	self 		should: [empty at: 5 put: #abc] raise: TestResult error.			! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 2/27/2006 21:42'!testIncludes	self assert: (full includes: 5).	self assert: (full includes: #abc).	self deny: (full includes: 3).			! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 2/28/2006 08:27'!testOccurrences	self assert: ((empty occurrencesOf: 0) = 0).	self assert: ((full occurrencesOf: 5) = 1).	full add: 5.	self assert: ((full occurrencesOf: 5) = 1).! !!SetTest methodsFor: 'Sunit original tests' stamp: 'GL 3/8/2006 08:20'!testRemove	full remove: 5.	self assert: (full includes: #abc).	self deny: (full includes: 5).! !!SetTest methodsFor: 'tests' stamp: 'GL 3/16/2006 10:36'!testAddWithOccurences	empty add: 2 withOccurrences: 3.	self assert: (empty includes: 2).	self assert: ((empty occurrencesOf: 2) = 1).! !!SetTest methodsFor: 'tests' stamp: 'GL 3/16/2006 10:37'!testAsSet	"could be moved in Array or Collection"	| newFull |	newFull := #(#abc 5) asSet.	newFull add: 5.	self assert: (newFull = full).! !!SetTest methodsFor: 'tests' stamp: 'GL 2/28/2006 09:25'!testAtRandom	| rand |	rand := Random new.	full add: 3.	full add: 2.	full add: 4.	full add: 1.	self assert: (full includes: (full atRandom: rand)).	! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 09:09'!testCollect	| newFull result |	newFull := Set withAll: (1 to: 10).	result := newFull collect: [:each | each >= 1 ifTrue: [each] ifFalse: ['no']].	self assert: (result = newFull).	result := newFull collect: [:each | each >= 5 ifTrue: [each] ifFalse: ['no']].	self assert: (result = ((Set withAll: (5 to: 10)) add: 'no'; yourself)).! !!SetTest methodsFor: 'tests' stamp: 'GL 2/28/2006 09:46'!testCopy	| newFull |	full add: 3.	full add: 2.	newFull := full copy.	self assert: (full size = newFull size).	self assert: ((full select: [:each | (newFull includes: each) not]) isEmpty).	self assert: ((newFull select: [:each | (full includes: each) not]) isEmpty).! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 00:06'!testCopyWithout	| newFull |	full add: 3.	full add: 2.	newFull := full copyWithout: 3.	self assert: (newFull size = (full size - 1)).	self deny: (newFull includes: 3).	self assert: ((newFull select: [:each | (full includes: each) not]) isEmpty).	self assert: ((full select: [:each | (newFull includes: each) not]) = (Set with: 3)).	! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 09:23'!testDo	| newFull result |	newFull := Set withAll: (1 to: 5).	result := 0.	newFull do: [:each | result := (result + each)].	self assert: (result = 15).! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 09:55'!testIntersection	| newFull col |	full add: 3; add: 2.	col := full intersection: full.	self assert: (full = col).	newFull := Set with: 8 with: 9 with: #z.	col := newFull intersection: full.	self assert: (col isEmpty).		newFull add: 5; add: #abc; add: 7.	col := newFull intersection: full.	self assert: ((full select: [:each | (newFull includes: each)]) = col).			! !!SetTest methodsFor: 'tests' stamp: 'GL 2/28/2006 09:07'!testLike	self assert: ((full like: 5) = 5).	self assert: ((full like: 8) isNil).! !!SetTest methodsFor: 'tests' stamp: 'nice 9/14/2009 21:08'!testRemoveAll	"Allows one to remove all elements of a collection" 		| c1 c2 s2 |	c1 := full.	c2 := c1 copy.	s2 := c2 size.		c1 removeAll.		self assert: c1 size = 0.	self assert: c2 size = s2 description: 'the copy has not been modified'.! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 08:27'!testRemoveIfAbsent	| result1 result2  |	result1 := true.	result2 := true.	full remove: 8 ifAbsent: [ result1 := false ].	self assert: (result1 = false).	full remove: 5 ifAbsent: [ result2 := false ].	self assert: (result2 = true).			! !!SetTest methodsFor: 'tests' stamp: 'GL 2/28/2006 09:51'!testSize	self assert: (empty size = 0).	self assert: (full size = 2).	empty add: 2.	empty add: 1.	full add: 2.	self assert: (empty size = 2).	self assert: (full size = 3).	empty remove: 2.	self assert: (empty size = 1).! !!SetTest methodsFor: 'tests' stamp: 'GL 3/8/2006 00:50'!testUnion	| newFull col newCol |	full add: 3.	full add: 2.	col := full union: full.	self assert: (full = col).	newFull := Set with: 8 with: 9 with: #z.	col := newFull union: full.	self assert: (col size = (full size + newFull size)).	self assert: ((col select: [:each | (full includes: each) not]) = newFull).	self assert: ((col select: [:each | (newFull includes: each) not]) = full).	full add: 9.	col := newFull union: full.	newCol := newFull copy.	newCol remove: 9.	self assert: (col size = (full size + newFull size - 1)).	self assert: ((col select: [:each | (full includes: each) not]) = newCol).	newCol := full copy.	newCol remove: 9.	self assert: ((col select: [:each | (newFull includes: each) not]) = newCol).			! !!SetTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Set. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:43'!runSetWithNilTestOf: newSet	"Run the common tests for the given set class"	self shouldnt:[newSet value add: nil] raise: Error.	self shouldnt:[newSet value addAll: #(nil nil nil)] raise: Error.	self assert: (newSet value add: nil; yourself) size = 1.	self assert: (newSet value addAll: #(nil nil nil); yourself) size = 1.	self assert: ((newSet value add: nil; yourself) includes: nil).	self assert: ((newSet value addAll: #(nil nil nil); yourself) includes: nil).	self assert: (newSet value add: nil; yourself) anyOne = nil.	self assert: ((newSet value add: nil; yourself) remove: nil) == nil.	self assert: ((newSet value add: nil; yourself) remove: nil; yourself) isEmpty.	self assert: (newSet value addAll: #(1 nil foo); yourself) size = 3.	self assert: ((newSet value addAll: #(1 nil foo); yourself) remove: nil; yourself) size = 2.	self assert: ((newSet value add: nil; yourself) collect:[:x| x]) = (newSet value add: nil; yourself).	self assert: ((newSet value add: nil; yourself) collect:[:x| x] as: Array) = #(nil).	self deny: ((newSet value) includes: nil).	self deny: ((newSet value add: 3; yourself) includes: nil).	self deny: ((newSet value add: 3; remove: 3; yourself) includes: nil).! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testIdentitySetWithNil	self runSetWithNilTestOf: [IdentitySet new]! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:28'!testKeyedIdentitySetWithNil	| set |	self runSetWithNilTestOf: [KeyedIdentitySet keyBlock:[:o| o]].	set := KeyedIdentitySet keyBlock:[:o| o].	set add: nil.	self assert: (set at: nil) == nil.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ul 2/19/2010 15:59'!testKeyedSetWithNil	| set |	self runSetWithNilTestOf: [KeyedSet keyBlock:[:o| o]].	set := KeyedSet keyBlock:[:o| o].	set add: nil.	self assert: (set at: nil) == nil.	self assert: (set includes: nil)! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testPluggableSetWithNil	self runSetWithNilTestOf: [PluggableSet new]! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testSetWithNil	self runSetWithNilTestOf: [Set new]! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:40'!testWeakSetWithNil	| set |	self runSetWithNilTestOf: [WeakSet new].	"Ensure that GCed entries don't count"	set := WeakSet with: Object new.	Smalltalk garbageCollect.	set do:[:x| self assert: false]. 	"test for de facto emptyness"	self deny: (set includes: nil).	set add: nil.	self assert: (set includes: nil).	set remove: nil.	self deny: (set includes: nil).! !!SharedQueue methodsFor: 'accessing' stamp: 'ar 5/28/2007 13:39'!detect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	| value |	accessProtect critical: [		readPosition to: writePosition-1 do:[:i|			value := contentsArray at: i.			(aBlock value: value) ifTrue:[^value].		].	].	^exceptionBlock value! !!SharedQueue methodsFor: 'accessing' stamp: 'bgf 3/22/2007 14:37'!includes:anObject	"True if the shared queue contains the given object	 (i.e. it has been put and not consumed.)"	| |	accessProtect		critical: [			readPosition to: writePosition-1 do: [:i|				(contentsArray at: i) = anObject ifTrue: [^true].			].		].	^false! !!SharedQueue methodsFor: 'accessing' stamp: 'bgf 7/31/2009 16:54'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value retry |	retry := false.	readSynch wait.	accessProtect		critical: [readPosition = writePosition					ifTrue: 						["Flush or next-or-nil stole my entry." retry := true]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1]].	^ retry ifTrue: [ self next ] ifFalse: [ value ]! !!SharedQueue methodsFor: 'accessing' stamp: 'bgf 3/25/2009 13:23'!nextPut: value beforeFirst: testBlock	"Send value through the receiver, positioned in the queue before the first	 entry for which testBlock offers true.  At end if no such entry.	 If a Process has been suspended 	waiting to receive a value through the receiver, allow it to proceed.	Not implemented for high performance."	accessProtect		critical: [			| inserted |			writePosition > contentsArray size					ifTrue: [self makeRoomAtEnd].			inserted := false.			readPosition to: writePosition-1 do: [ : i |				"No early loop escapes, so just do it the clumsy way."				inserted ifFalse: [					(testBlock value: (contentsArray at: i)) ifTrue: [						(writePosition-1) to: i by: -1 do: [ : j | 							contentsArray at: j+1 put: (contentsArray at: j) ].					contentsArray at: i put: value.					inserted := true.				]]].				inserted ifFalse: [				contentsArray at: writePosition put: value.			].			writePosition := writePosition + 1].	readSynch signal.	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'jcg 5/5/2010 12:11'!nextTimeoutMSecs: msecs	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is, or until the timeout interval passes.	 If the timeout interval is exceeded before an object has been sent, return nil.	 The deadline may be exceeded by unpredictable amounts of time	 if the queue is flushed or peeked into while the wait is ongoing."	| value retry |	retry := false.	msecs <= 0 ifTrue: [^self nextOrNil "less risk than changing Semaphore"].	(readSynch waitTimeoutMSecs: msecs) ifTrue: [ ^ nil ].	accessProtect		critical: [readPosition = writePosition					ifTrue: 						["Flush or next-or-nil stole my entry." retry := true]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1]].	^ retry ifTrue: [ self nextTimeoutMSecs: msecs ] ifFalse: [ value ]! !!SharedQueue methodsFor: 'accessing' stamp: 'bgf 9/2/2009 11:59'!nextTimeoutSeconds: secs	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is, or until the timeout interval passes.	 If the timeout interval passes, return nil.	 The deadline may be exceeded by unpredictable amounts of time	 if the queue is flushed or peeked into while the wait is ongoing." 	^ self nextTimeoutMSecs: (secs *1000)! !!SharedQueue methodsFor: 'accessing' stamp: 'bgf 3/25/2009 13:19'!sort: block	"Reorder the queue using the comparison block."	accessProtect critical: [		readPosition < (writePosition - 1) ifTrue: [			contentsArray mergeSortFrom: readPosition to: writePosition-1 by: block		]].! !!SharedQueue methodsFor: 'private' stamp: 'ar 3/26/2008 11:22'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray := contentsArray , (Array new: (contentsArray size // 10 max: 100))]		ifFalse: 			[contentsSize := writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			"fix: clear the old upper range so we don't hoard references."			contentsArray				from: contentsSize+1 "new end of content"				to: writePosition-1 "old write position"				put: nil.			readPosition := 1.			writePosition := contentsSize + 1]! !!SharedQueue methodsFor: 'private' stamp: 'ar 10/4/2006 12:43'!printOn: aStream	super printOn: aStream.	"Print a guesstimate of the size of the queue without aquiring the lock properly"	aStream nextPut: $(.	aStream print: writePosition - readPosition.	aStream nextPut: $).! !!SharedQueue2Test methodsFor: 'testing' stamp: 'ls 6/25/2005 13:49'!testBasics	| q |	q := SharedQueue2 new.	self should: [ q nextOrNil = nil ].	q nextPut: 5.	self should: [ q nextOrNil = 5 ].	self should: [ q nextOrNil = nil ].! !!SharedQueue2Test methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:10'!testContention1	"here is a test case that breaks the standard SharedQueue from Squeak 3.8"	| q r1 r2 |	q := SharedQueue2 new.	q nextPut: 5.	q nextPut: 10.	self should: [ q nextOrNil = 5 ].	[ r1 := q next ] fork.	[ r2 := q next ] fork.	Processor  yield.   "let the above two threads block"		q nextPut: 10.	Processor yield.	self should: [ r1 = 10 ].	self should: [ r2 = 10 ].	self should: [ q nextOrNil = nil ].! !!SharedQueue2Test methodsFor: 'testing' stamp: 'ls 6/25/2005 14:15'!testNextOrNilSuchThat	| q item |	q := SharedQueue2 new.	q nextPut: 5.	q nextPut: 6.	item := q nextOrNilSuchThat: [ :x | x even ].	self should: [ item = 6 ].	self should: [ q nextOrNil = 5 ].	self should: [ q nextOrNil = nil ].! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'bgf 1/2/2009 17:45'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil: [		| rect |		rect := 	(((scroller transformFrom: self) invertBoundsRect: selectedMorph bounds)						intersect: scroller bounds).		rect extent y > 0 ifTrue: [			aCanvas fillRectangle: rect				 	fillStyle: (Morph selectionBackgroundFillForBounds: rect)].		].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas.	].! !!SimpleSwitchMorphTest methodsFor: 'as yet unclassified' stamp: 'apb 5/3/2006 16:05'!classToBeTested	^ SimpleSwitchMorph ! !!SimpleSwitchMorphTest methodsFor: 'as yet unclassified' stamp: 'apb 5/3/2006 16:08'!setUp	super setUp.	testSwitch := SimpleSwitchMorph new! !!SimpleSwitchMorphTest methodsFor: 'as yet unclassified' stamp: 'apb 5/3/2006 16:17'!testName	self assert: testSwitch externalName = 'SimpleSwitch'! !!SimpleSwitchMorphTest methodsFor: 'as yet unclassified' stamp: 'apb 5/3/2006 16:11'!testState	self assert: testSwitch isOff.	self deny: testSwitch isOn.	testSwitch toggleState.	self assert: testSwitch isOn.	self deny: testSwitch isOff! !!SimpleSwitchMorphTest methodsFor: 'as yet unclassified' stamp: 'apb 5/3/2006 16:14'!testSwitching	testSwitch setSwitchState: false.	self assert: testSwitch isOff.	self assert: testSwitch color = testSwitch offColor.	testSwitch setSwitchState: true.	self assert: testSwitch isOn.	self assert: testSwitch color = testSwitch onColor.! !!SimpleSwitchMorphTest commentStamp: '<historical>' prior: 0!I test the behavior of SimpleSwitchMorph!!SmallInteger methodsFor: 'bit manipulation' stamp: 'jjl 8/18/2008 17:28'!bitAnd: arg 	"Primitive. Answer an Integer whose bits are the logical AND of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 14>	self >= 0 ifTrue: [^ arg bitAnd: self].	^ (self bitInvert bitOr: arg bitInvert) bitInvert! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!deepCopy! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!shallowCopy! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'sd 6/5/2005 08:59'!testBasicNew	self should: [SmallInteger basicNew] raise: TestResult error. ! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'sd 6/5/2005 08:59'!testMaxVal	self assert: (SmallInteger maxVal = 16r3FFFFFFF).! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'sd 6/5/2005 08:59'!testMinVal	self assert: (SmallInteger minVal = -16r40000000).! !!SmallIntegerTest methodsFor: 'testing - Class Methods' stamp: 'sd 6/5/2005 08:59'!testNew	self should: [SmallInteger new] raise: TestResult error. ! !!SmallIntegerTest methodsFor: 'testing - arithmetic' stamp: 'sd 6/5/2005 08:59'!testDivide	self assert: 2 / 1 = 2.	self assert: (3 / 2) isFraction.	self assert: 4 / 2 = 2.	self should: [ 1 / 0 ] raise: ZeroDivide.! !!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'p4s 7/12/2009 01:33'!testEven		self assert: (SmallInteger minVal even).	self deny: (SmallInteger maxVal even).		self deny: ((SmallInteger minVal + 1) even).	self assert: ((SmallInteger maxVal - 1) even).		self deny: (1 even).	self deny: (-1 even).		self assert: (2 even).	self assert: (-2 even).		self assert: (0 even).! !!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'p4s 7/12/2009 01:35'!testOdd		self deny: (SmallInteger minVal odd).	self assert: (SmallInteger maxVal odd).		self assert: ((SmallInteger minVal + 1) odd).	self deny: ((SmallInteger maxVal - 1) odd).		self assert: (1 odd).	self assert: (-1 odd).		self deny: (2 odd).	self deny: (-2 odd).		self deny: (0 odd).! !!SmallIntegerTest methodsFor: 'testing - printing' stamp: 'fbs 12/8/2005 12:58'!testPrintPaddedWithself assert: (123 printPaddedWith: $0 to: 10 base: 2)  = '0001111011'.self assert: (123 printPaddedWith: $0 to: 10 base: 8)  = '0000000173'.self assert: (123 printPaddedWith: $0 to: 10 base: 10) = '0000000123'.self assert: (123 printPaddedWith: $0 to: 10 base: 16) = '000000007B'.! !!SmallIntegerTest methodsFor: 'testing - printing' stamp: 'al 7/21/2008 21:48'!testPrintString	self assert: 1 printString  = '1'.	self assert: -1 printString  = '-1'.	self assert: SmallInteger minVal printString  = '-1073741824'.	self assert: SmallInteger maxVal printString  = '1073741823'.	self assert: 12345 printString  = '12345'.	self assert: -54321 printString  = '-54321'.	self assert: 0 decimalDigitLength = 1.	self assert: 4 decimalDigitLength = 1.	self assert: 12 decimalDigitLength = 2.	self assert: 123 decimalDigitLength = 3.	self assert: 1234 decimalDigitLength = 4.	self assert: 56789 decimalDigitLength = 5.	self assert: 657483 decimalDigitLength = 6.	self assert: 6571483 decimalDigitLength = 7.	self assert: 65174383 decimalDigitLength = 8.	self assert: 625744831 decimalDigitLength = 9.	self assert: 1000001111 decimalDigitLength = 10.	self assert: SmallInteger maxVal decimalDigitLength = 10.! !!SmallIntegerTest commentStamp: 'fbs 3/8/2004 22:13' prior: 0!I provide a test suite for SmallInteger values. Examine my tests to see how SmallIntegers should behave, and see how to use them.!!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jcg 6/21/2010 19:03'!initialize	"SmalltalkEditor initialize"	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeYellowButtonMenu.	self initializeShiftedYellowButtonMenu.! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jcg 6/21/2010 19:03'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"SmalltalkEditor initialize"	| cmds |	super initializeCmdKeyShortcuts.	cmds := #($b #browseIt: $d #doIt: $i #inspectIt: $j #doAgainOnce: $l #cancel: $m #implementorsOfIt: $n #sendersOfIt: $o #spawnIt: $p #printIt: $q #querySymbol: $/ #querySymbol: $s #save: ).	1 to: cmds size		by: 2		do: [ : i | cmdActions at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].	"Set up type-method argument hot keys, 1-4.."	'1234' do:		[ : eachKeyboardChar |		cmdActions 			at: eachKeyboardChar asciiValue + 1			put: #typeMethodArgument: ]! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'eem 8/31/2010 10:38'!processShutDownList: quitting	"Send #shutDown to each class that needs to wrap up before a snapshot.	 Also void the endianness chace;  this can't safely be done on start-up because	 Smalltalk is too late in the start-up sequence."	EndianCache := nil.	self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'ar 6/23/2010 11:11'!quitPrimitive	"Quit with exit code zero"	^self quitPrimitive: 0! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'ar 6/23/2010 14:37'!quitPrimitive: exitCode	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 113>	self primitiveFailed.! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 6/16/2010 14:47'!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'	) do:[:pkgName| (MCPackage named: pkgName) unload].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 4/16/2011 19:00'!unloadOpenQwaqPackages	"Unloads packages for OpenQwaq images. Keeps MVC and Tests."	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'SUnitGUI'	) do:[:pkgName| (MCPackage named: pkgName) unload].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill:  (Color r: 0.42 g: 0.45 b: 0.51).	World color:  (Color r: 0.42 g: 0.45 b: 0.51).! !!SmalltalkImage methodsFor: 'memory space' stamp: 'ar 6/15/2010 16:13'!installLowSpaceWatcher: aBlock	"Start a process to watch for low-space conditions."	"Smalltalk installLowSpaceWatcher"	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"	LowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].	LowSpaceProcess := aBlock newProcess.	LowSpaceProcess priority: Processor lowIOPriority.	LowSpaceProcess resume.! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/27/2010 14:24'!flagInterpretedMethods	"Answer if the Coggit VM is currently flagging only-interpreted methods"	^(self vmParameterAt: 48) anyMask: 2! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:44'!flagInterpretedMethods: aBoolean	"The Cog VM can be instructed to set the flag bit of CompiledMethods that	 it executes but will only interpret.  This can be used e.g. to profile startup.	 See CompiledMethod>>#flag & CompiledMethod>>#clearFlag.  	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 2) + (aBoolean ifTrue: [2] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 5/17/2007 12:49'!gcBiasToGrow: aBool	"Tell the VM to grow after tenures instead of running in a tight loop where it does IGCs over and over. For some weird reason the primitive takes an integer not a bool but oh well..."	self primitiveGCBiasToGrow: (aBool ifTrue:[1] ifFalse:[0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 5/17/2007 13:29'!gcBiasToGrowLimit: memAmt	"Tell the VM after which amount of growth we're tired of just growing further and will cause a fullGC regardless"	<primitive: 'primitiveSetGCBiasToGrowGCLimit'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 6/4/2009 14:06'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000...-1 - command line arguments that specify VM options 	0 - the full path name for currently executing VM 	(or, on some platforms, just the path name of the VM's directory) 	1 - full path name of this image 	2 - a Squeak document to open, if any 	3...1000 - command line arguments for Squeak programs 	1001 - this platform's operating system 	1002 - operating system version 	1003 - this platform's processor type (or at least the type the VM was compiled for)	1004 - vm version	1005 - this platform's windowing system's name	1006 - a string identifying the VM build	1007 - a strnig identifying the interpreter build (or nil if not a Cog Stack VM)	1008 - a string identifying the cogit build (or nil if not a Cogit VM)"	<primitive: 149>	^ nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 4/28/2009 17:51'!isMainWindowObscured	"Do not use the primitive on Windows Vista since it always returns true"	((Smalltalk platformName = 'Win32') and:[Smalltalk osVersion >= '6.0']) ifTrue:[^false].	^self primIsMainWindowObscured! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:43'!isRunningCog	"Returns true if we're running on a Cog VM (JIT or StackInterpreter)	 (vmParameterAt: 42 is the number of stack pages)"	^[(self vmParameterAt: 42) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:41'!isRunningCogit	"Returns true if we're running on the Cog JIT	 (vmParameterAt: 46 is the size of the machine code zone)"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 4/28/2009 17:41'!primIsMainWindowObscured	<primitive: 'primitiveIsWindowObscured'>	^ nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 5/17/2007 12:50'!primitiveGCBiasToGrow: arg	"Tell the VM to grow after tenures instead of running in a tight loop where it does IGCs over and over. For some weird reason the primitive takes an integer not a bool but oh well..."	<primitive: 'primitiveSetGCBiasToGrow'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 2/27/2008 11:21'!primitiveGetWindowSize	"Answer the window label for the main Squeak window"	<primitive: 'primitiveGetWindowSize'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 10/12/2007 15:10'!primitiveLogDirectory	"Answer the current log directory for VM information"	<primitive: 'primitiveGetLogDirectory'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 10/12/2007 15:10'!primitiveLogDirectory: aString	"Set the log directory for VM-level logging"	<primitive: 'primitiveSetLogDirectory'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 2/27/2008 11:21'!primitiveSetWindowSizeX: xVal y: yVal	"Primitive. Sets the window label for the main Squeak window."	<primitive: 'primitiveSetWindowSize'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 6/3/2007 19:55'!primitiveWindowLabel	"Answer the window label for the main Squeak window"	<primitive: 'primitiveGetWindowLabel'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 6/3/2007 19:54'!primitiveWindowLabel: aString	"Set the window label for the main Squeak window"	<primitive: 'primitiveSetWindowLabel'>	^nil! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:23'!processHasThreadIdInstVar: aBoolean	"The threaded VM needs to know if the 4th inst var of Process	 is threadId which it uses to control process-to-thread binding.	 This flag persists across snapshots, stored in the image header."	aBoolean ifTrue: [self assert: (Process instVarNames at: 4) ='threadId'].	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 1) + (aBoolean ifTrue: [1] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:29'!processPreemptionYields	"Answer whether the VM causes a process to yield on process preemption,	 i.e. to put a preempted process at the back of its run queue.  If bit 2 (4) is	 0 preemption yields."	^((self vmParameterAt: 48) allMask: 4) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:26'!processPreemptionYields: aBoolean	"The Cog VM can be instructed not to yield on process preemption,	 i.e. not to put a preempted process at the back of its run queue.  By	 default preempting a process causes it to yield (Blue Book semantics)	 which can have unfortunate effects.	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 4) + (aBoolean ifTrue: [0] ifFalse: [4])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'jcg 5/4/2007 19:04'!setPlatformPreferences	"Set some platform specific preferences on system startup"	| platform specs |	Preferences automaticPlatformSettings ifFalse:[^self].	platform := self platformName.	specs := 	#(						(soundStopWhenDone false)					(soundQuickStart false)					(usePrimitiveClipboard true)			).	platform = 'Win32' ifTrue:[		specs := #(						(soundStopWhenDone true)					(soundQuickStart false)					(usePrimitiveClipboard true)				)].	platform = 'Mac OS' ifTrue:[		specs := #(						(soundStopWhenDone false)					(soundQuickStart true)					(usePrimitiveClipboard true)				)].	platform = 'unix' ifTrue:[		specs := #(						(usePrimitiveClipboard false)  "would otherwise cause VM crash"				)].	specs do:[:tuple|		Preferences setPreference: tuple first toValue: (tuple last == true).	].! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/27/2010 14:22'!threadingFromGUIThread	"Answer whether the VM allows threading from the GUI thread.	 If bit 3 (8) is 0 threading from the GUi thread is allowed."	^((self vmParameterAt: 48) allMask: 8) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/27/2010 14:14'!threadingFromGUIThread: aBoolean	"The threaded VM can be told not to thread (disown) the VM when in the GUI thread.	 This allows one to know that the GUI threwad is always available, e.g. to receive GUI events."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 8) + (aBoolean ifTrue: [0] ifFalse: [8])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 10/12/2007 15:10'!vmLogDirectory	"Answer the VMs log directory"	^self primitiveLogDirectory utf8ToSqueak! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 10/12/2007 15:11'!vmLogDirectory: aString	"Answer the VMs log directory"	^self primitiveLogDirectory: aString squeakToUtf8! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 1/20/2010 17:38'!vmParameterAt: parameterIndex	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Answer with the current value of that register.	Fail if parameterIndex has no corresponding register.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only; nil in Cog VMs)		5	allocations between GCs (read-write; nil in Cog VMs)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)		12-20 specific to the translating VM		21	root table size (read-only)		22	root table overflows since startup (read-only)		23	bytes of extra memory to reserve for VM buffers, plugins, etc.		24	memory threshold above whichto shrink object memory (read-write)		25	memory headroom when growing object memory (read-write)		26  interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking		28	number of times sweep loop iterated  for current IGC/FGC (read-only)		29	number of times make forward loop iterated for current IGC/FGC (read-only)		30	number of times compact move loop iterated for current IGC/FGC (read-only)		31	number of grow memory requests (read-only)		32	number of shrink memory requests (read-only)		33	number of root table entries used for current IGC/FGC (read-only)		34	number of allocations done before current IGC/FGC (read-only)		35	number of survivor objects after current IGC/FGC (read-only)		36  millisecond clock when current IGC/FGC completed (read-only)		37  number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)		38  milliseconds taken by current IGC  (read-only)		39  Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)		40  BytesPerWord for this image		41  imageFormatVersion for the VM		42	number of stack pages in use (Cog Stack VM only, otherwise nil)		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)		44	size of eden, in bytes (Cog VMs only, otherwise nil)		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)		46	size of machine code zone, in bytes (stored in image file header; Cog JIT VM only, otherwise nil)		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)		48	various properties of the Cog VM as an integer encoding an array of bit flags.			 Bit 0: implies the image's Process class has threadId as its 3rd inst var (zero relative)		49-55 reserved for VM parameters that persist in the image (such as eden above)		56	number of process switches since startup (read-only)		57	number of ioProcessEvents calls since startup (read-only)		58	number of ForceInterruptCheck (Cog VMs) or quickCheckInterruptCalls (non-Cog VMs) calls since startup (read-only)		59	number of check event calls since startup (read-only)		60	number of stack page overflows since startup (read-only; Cog VMs only)		61	number of stack page divorces since startup (read-only; Cog VMs only)"	<primitive: 254>	self primitiveFailed! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 1/20/2010 17:38'!vmParameterAt: parameterIndex put: newValue	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Store newValue (a positive integer) into that	register and answer with the previous value that was stored there.	Fail if newValue is out of range, if parameterIndex has no corresponding	register, or if the corresponding register is read-only.	Writable VM parameters are numbered as follows:		5	allocations between GCs (read-write; nil in Cog VMs)		6	survivor count tenuring threshold (read-write)		24	memory threshold above whichto shrink object memory (read-write)		25	memory headroom when growing object memory (read-write)		26  interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)		43	desired number of stack pages (applies at startup only, stored in image file header, max 65535; Cog VMs only)		45	desired size of eden, in bytes (applies at startup only, stored in image file header; Cog VMs only)		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)		48	various properties of the Cog VM as an integer encoding an array of bit flags.			 Bit 0: implies the image's Process class has threadId as its 3rd inst var (zero relative)"	<primitive: 254>	self primitiveFailed! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 6/3/2007 19:55'!windowLabel	"Answer the window label for the main Squeak window"	^self primitiveWindowLabel utf8ToSqueak! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 6/3/2007 19:55'!windowLabel: aString	"Set the window label for the main Squeak window"	^self primitiveWindowLabel: (aString ifNil:[''] ifNotNil:[aString squeakToUtf8])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 2/27/2008 11:21'!windowSize	"Answer the window label for the main Squeak window"	^self primitiveGetWindowSize! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'ar 2/27/2008 11:21'!windowSize: aPoint	"Answer the window label for the main Squeak window"	^self primitiveSetWindowSizeX: aPoint x y: aPoint y! !!SmalltalkImage methodsFor: 'special objects' stamp: 'eem 7/23/2010 14:47'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: Mutex.	"a tag for the processes running external code list; was TranslatedMethod"	newArray at: 41 put: ((self specialObjectsArray at: 41) class == LinkedList							ifTrue: [self specialObjectsArray at: 41]							ifFalse: [LinkedList new]).	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move' #'resource limit exceeded').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/14/2008 17:33'!clearVMProfile	"Clear the VM profile histograms."	<primitive: 250>! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 12/22/2009 19:34'!primitiveCrashVM: crashInThisThread	<primitive: 'primitiveCrashVM'>	^self primitiveFailed	"Smalltalk primitiveCrashVM: true"	"Smalltalk primitiveCrashVM: false"! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/21/2008 11:37'!profile: aBlock	"Make a virtual machine profile of the given block."	"Note: Profiling support is provided so that VM implementors	 can better understand and improve the efficiency of the virtual	 machine."	| info virtualMachineHistogram entireAddressSpaceHistogram |	self statusOfVMProfileInfoInto: (info := Array new: 4).	virtualMachineHistogram := Array new: info third.	entireAddressSpaceHistogram := Array new: info fourth.	self clearVMProfile.	self startVMProfiling.	aBlock value.	self stopVMProfilingVMInto: virtualMachineHistogram EASInto: entireAddressSpaceHistogram.	^{ virtualMachineHistogram. entireAddressSpaceHistogram }! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/14/2008 18:33'!startVMProfiling	"Start profiling the virtual machine."	<primitive: 251>! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/21/2008 11:36'!statusOfVMProfileInfoInto: anArrayOrNil	"Answer whether VM profiling is running or not.	 If anArrayOrNil is an Array of at least 4 elements then fill it with the following information:		1. the addresses of the first element of the VM histogram (the first address in the executable)		2. the address following the last element (the last address in the executable, excluding dynamically linked libraries)		3. the size of the VM histogram in bins (each bin is a 4 byte unsigned long)		4. the size of the VM histogram in bins (each bin is a 4 byte unsigned long)"	<primitive: 253>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/21/2008 11:36'!stopVMProfilingVMInto: virtualMachineHistogramOrNil EASInto: entireAddressSpaceHistogramOrNil	"Stop profiling the virtual machine and if the arguments are	 Arrays of the right size, copy the profile data into them."	<primitive: 252>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/19/2008 16:37'!vmProfileExtent	"Answer an Array of the addresses of the first element	of the VM histogram and the address following the last element."	<primitive: 253>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'eem 8/28/2009 14:52'!voidCogVMState	"Void any internal caches the VM maintains other than the method lookup caches.	 These comprise		- the stack zone, where method activations are stored, and		- the machine code zone, where the machine code form of CompiledMethods is held."	<primitive: 214>	^self primitiveFailed	"Time millisecondsToRun: [Smalltalk voidCogVMState]"	"(1 to: 10) collect: [:ign| Time millisecondsToRun: [Smalltalk voidCogVMState]]"! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:25'!highResClock	"Smalltalk highResClock"	"Primitive. Answer the value of the high resolution clock if this computer has one.	Usually, this should be the highest resolution value available, for example on Intel	it will be the value of the time stamp counter register."	<primitive: 'primitiveHighResClock'>	^0! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:24'!interruptChecksPerMSec	"Primitive. Answer the number of interrupt checks per milliseconds that we execute	on this machine. This can be used to adjust the sub-msecs profiler to check (roughly) 	n times per millisecond."	<primitive: 'primitiveInterruptChecksPerMSec'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'eem 8/28/2009 13:47'!longRunningPrimitive	"Primitive. Answer an Array of the current long-running primitive method identified by the	 heartbeat, and the number of heartbeats it ran for, or nil if none.  To use this, first install a	 semaphore to wait upon via SystemDictionary>>longRunningPrimitiveSemaphore:"	<primitive: 'primitiveLongRunningPrimitive'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'eem 9/28/2009 14:41'!longRunningPrimitiveSemaphore: aSemaphoreOrNil	"Primitive. Install the semaphore to be used for collecting long-running primitives, 	 or nil if no semaphore should be used.  The semaphore will be signalled once the	 heartbeat detects a long-running primitive until the result is collected via	 primitiveLongRunningPrimitive (see SystemDictionary>>longRunningPrimitive)"	<primitive: 'primitiveLongRunningPrimitiveSemaphore'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:24'!profilePrimitive	"Primitive. Answer the primitive sample by the profiler, or nil if the profiler isn't active.	See also primitiveProfileStart."	<primitive: 'primitiveProfilePrimitive'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:24'!profileSample	"Primitive. Answer the last sample taken by the profiler, or nil if the profiler isn't active.	See also primitiveProfileStart."	<primitive: 'primitiveProfileSample'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:24'!profileSemaphore: aSemaphore	"Primitive. Install the semaphore to be used for profiling, 	or nil if no semaphore should be used.	See also primitiveProfileStart."	<primitive: 'primitiveProfileSemaphore'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'profiling' stamp: 'ar 6/22/2007 15:24'!profileStart: counter	"Primitive. Begin profiling execution every by using the interrupt check-counter instead of a time-based process (which is limited to timing resolution and triggers off the same signal that many of the processes being profiled trigger off leading to consistently wrong results).	The argument is the number of interrupt checks (method activations) to let go by before taking a sample. The sample is being stored in the profileSample iVar which can be retrieved by executing primitiveProfileSample. When a sample is taken, it signals the semaphore specified in primitiveProfileSemaphore.	If the argument is less or equal to zero, it disables profiling."	<primitive: 'primitiveProfileStart'>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'benchmarks' stamp: 'ar 6/21/2010 17:28'!macroBenchmark1    "Smalltalk macroBenchmark1"	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |	classes := Smalltalk allClasses select: [:c | c name < 'B3'].	badOnes := OrderedCollection new.	'Decompiling and recompiling...' displayProgressAt: Sensor cursorPoint		from: 0 to: (classes detectSum: [:c | c selectors size])		during: [:bar | n := 0.			classes do:[:cls | 				cls selectors do:[:selector | 					bar value: (n := n+1).					oldMethod := cls compiledMethodAt: selector.					oldCodeString := (cls decompilerClass new								decompile: selector in: cls method: oldMethod)								decompileString.					methodNode := cls compilerClass new								compile: oldCodeString								in: cls notifying: nil ifFail: [].					newMethod := methodNode generate.					oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)								decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].	].	^ badOnes size! !!SmalltalkImage methodsFor: 'benchmarks' stamp: 'ar 7/7/2007 15:49'!macroBenchmark2  "Smalltalk macroBenchmark2"	"Copied from Interpreter class>>translate:doInlining:forBrowserPlugin:"	^Smalltalk at: #Interpreter ifPresent:[:aClass| aClass macroBenchmark]! !!SmalltalkImage methodsFor: 'benchmarks' stamp: 'ar 6/7/2007 00:32'!macroBenchmark3   "Smalltalk macroBenchmark3"	| testBlock tallies prev receiver |	"Runs the stepping simulator with the messageTally tree (like tallySends)."	testBlock :=[		'Running the context step simulator' displayProgressAt: Sensor cursorPoint			from: 0 to: 200 during:[:bar |				1 to: 200 do:[:x | 					bar value: x.					Float pi printString.					15 factorial printString]]].	tallies := MessageTally new class: testBlock receiver class							method: testBlock method.	receiver := nil.	prev := testBlock.	thisContext sender		runSimulated: testBlock		contextAtEachStep:[:current |			current == prev ifFalse:["call or return"				prev sender == nil ifFalse:["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev := current]].! !!SmalltalkImage methodsFor: 'benchmarks' stamp: 'ar 6/21/2010 17:29'!macroBenchmarks	"Smalltalk macroBenchmarks"	| time saveMorphs freeCell report fullReport benchStart |	fullReport := String streamContents: [:strm | 		Smalltalk timeStamp: strm.		benchStart := Time millisecondClockValue.		"1:	Decompile, pretty-print, and compile a bunch of  			methods. Does not install in classes, so does not 			flush  cache."		strm cr; cr; nextPutAll: 'Benchmark #1: '; 			print: (time := self standardTime:[self macroBenchmark1]); 			nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 			nextPutAll: self vmStatisticsShortString.		"2:	Build morphic tiles for all methods over 800 bytes  			(;-). Does no display."		Smalltalk at: #SyntaxMorph ifPresent:[:aClass|			strm cr; nextPutAll: 'Benchmark #2: '; 				print: (time := self standardTime:[aClass testAllMethodsOver: 800]); 				nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 				nextPutAll: self vmStatisticsShortString.		].		"3:	Translate the interpreter with inlining.  			Does not include any plugins."			strm cr; nextPutAll: 'Benchmark #3: '; 				print: (time := self standardTime:[self macroBenchmark2]); 				nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 				nextPutAll: self vmStatisticsShortString.false ifTrue:[		"4:	Run the context step simulator.  			200 iterations printing pi and 15 factorial."			strm cr; nextPutAll: 'Benchmark #4: '; 				print: (time := self standardTime:[self macroBenchmark3]); 				nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 				nextPutAll: self vmStatisticsShortString.].		"5:	Open 10 browsers and close them.  			Includes browsing to a specific method."			strm cr; nextPutAll: 'Benchmark #5: ';			print: ([saveMorphs := World submorphs.				World removeAllMorphs."heh, heh"				time := self standardTime:[1 to: 10 do: [:i | 					Browser fullOnClass: SystemDictionary selector: #macroBenchmarks].					World submorphs do: [:m | m delete. self currentWorld doOneCycle].				]] ensure:[World addAllMorphs: saveMorphs]); 				nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 				nextPutAll: self vmStatisticsShortString.		"6:	Play a game of FreeCell with display, while running the MessageTally.  			Thanks to Bob Arning for the clever part of this one."			Smalltalk at: #FreeCell ifPresent:[:fcc|			strm cr; nextPutAll: 'Benchmark #6: ';				print: ([(freeCell := fcc new) openInWorld.						time := self standardTime:[freeCell board pickGame: 1].						(((report := World firstSubmorph) isKindOf: SystemWindow)							and: [World firstSubmorph label = 'Spy Results'])								ifTrue: [report delete].						time					] ensure:[freeCell delete]); 				nextPutAll: 'ms'; cr; nextPutAll: '---------------------'; cr; 				nextPutAll: self vmStatisticsShortString.			].		strm cr; nextPutAll: '---------------------'; cr; 			nextPutAll: 'Total time = '; print: Time millisecondClockValue - benchStart; 			nextPutAll: ' milliseconds.'; cr	].	StringHolder new textContents: fullReport;		 openLabel: 'Macro Benchmark Results'.! !!SmalltalkImage methodsFor: 'benchmarks' stamp: 'ar 6/7/2007 00:33'!standardTime: aBlock	"Times the execution of aBlock in milliseconds"	Utilities vmStatisticsReportString.  "To reset statistics"	Smalltalk garbageCollectMost.  "To clear that garbage"	^Time millisecondsToRun: aBlock! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'eem 8/31/2010 10:37'!startUp	SystemChangeNotifier uniqueInstance notify: Smalltalk ofAllSystemChangesUsing: #event:! !!SmalltalkImageTest methodsFor: 'testing' stamp: 'nice 5/11/2009 23:47'!testImageName	"Non regression test for http://bugs.squeak.org/view.php?id=7351"	| shortImgName fullImgName fullChgName |	shortImgName := 'Squeak3.10.2-7179-basic'.	fullImgName := SmalltalkImage current fullNameForImageNamed: shortImgName.	fullChgName := SmalltalkImage current fullNameForChangesNamed: shortImgName.	FileDirectory splitName: fullImgName to: [:path :name |		self assert: path = SmalltalkImage current imagePath.		self assert: name = 'Squeak3.10.2-7179-basic.image'.].	FileDirectory splitName: fullChgName to: [:path :name |		self assert: path = SmalltalkImage current imagePath.		self assert: name = 'Squeak3.10.2-7179-basic.changes'.].! !!Socket methodsFor: 'accessing' stamp: 'bgf 10/26/2007 21:17'!totalBytesReceived	"Bytes read from the network since creation."	^ totalBytesReceived! !!Socket methodsFor: 'accessing' stamp: 'bgf 10/26/2007 21:17'!totalBytesSent	"Bytes delivered to the network since creation."	^ totalBytesSent! !!Socket methodsFor: 'connection open/close' stamp: 'jcg 11/2/2009 12:00'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^self class acceptFrom: self.! !!Socket methodsFor: 'connection open/close' stamp: 'ar 3/26/2006 21:39'!bindTo: addr port: aPort	self primSocket: socketHandle bindTo: addr port: aPort! !!Socket methodsFor: 'connection open/close' stamp: 'ar 9/23/2009 15:17'!listenOn: port	"Listen for a connection on the given port."	^self listenOn: port backlogSize: 4.! !!Socket methodsFor: 'connection open/close' stamp: 'jcg 10/6/2009 14:06'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.	(portNumber between: 1 and: 1023) ifTrue: [		"OS X (Snow Leopard, anyway) has a weird behavior where if you don't have root privileges, then instead of failing, it instead listens on a random-ish high-number port (actually, they seem to be sequentially assigned).  This is nonsense, so detect it and raise an error."		self localPort = portNumber ifFalse: [			self destroy.			InvalidPort signal: 'unable to listen on port ', portNumber		].	].! !!Socket methodsFor: 'datagrams' stamp: 'ar 1/5/2009 18:13'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	| received |	received := self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size.	totalBytesReceived := totalBytesReceived + (received at: 1).	^ received! !!Socket methodsFor: 'datagrams' stamp: 'bgf 10/26/2007 21:19'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		totalBytesSent := totalBytesSent + count.		bytesSent := bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'initialize-destroy' stamp: 'bgf 10/27/2007 13:10'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	totalBytesSent := 0.	totalBytesReceived := 0.	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'bgf 10/26/2007 21:17'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	totalBytesSent := 0.	totalBytesReceived := 0.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 1/5/2009 19:13'!initializeRAW: protocolID	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	totalBytesSent := 0.	totalBytesReceived := 0.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateRAW: 0			protocol: protocolID			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 1/7/2009 16:52'!resetTotalBytesReceived	"Reset the total bytes received. Answer the number of bytes previously sent."	| result |	result := totalBytesReceived.	totalBytesReceived := 0.	^result! !!Socket methodsFor: 'initialize-destroy' stamp: 'ar 1/7/2009 16:52'!resetTotalBytesSent	"Reset the total bytes sent. Answer the number of bytes previously sent."	| result |	result := totalBytesSent.	totalBytesSent := 0.	^result! !!Socket methodsFor: 'initialize-destroy' stamp: 'bgf 10/26/2007 21:37'!resetTotals	"Reset the total bytes sent/received."	totalBytesSent := 0.	totalBytesReceived := 0.! !!Socket methodsFor: 'primitives' stamp: 'ar 3/26/2006 21:40'!primSocket: aHandle bindTo: addr port: aPort	<primitive: 'primitiveSocketBindToPort' module: 'SocketPlugin'>	^self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 1/5/2009 19:13'!primSocketCreateRAW: netType protocol: protocolID receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The protocol parameter specifies:		1 - ICMP	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 'primitiveSocketCreateRAW' module: 'SocketPlugin'>	^ nil  "socket creation failed"! !!Socket methodsFor: 'receiving' stamp: 'ar 6/22/2010 15:47'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf := String new: 10000.	totalBytesDiscarded := 0.	[self isConnected and:[self dataAvailable]] whileTrue: [		totalBytesDiscarded :=			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!Socket methodsFor: 'receiving' stamp: 'ar 2/13/2009 15:05'!receiveDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.  The answer may be zero (indicating that no data was 	available before the socket closed)."	| bytesRead closed |	bytesRead := 0.	closed := false.	[closed not and: [bytesRead == 0]]		whileTrue: [			self waitForDataIfClosed: [closed := true].			bytesRead := self primSocket: socketHandle							receiveDataInto: aStringOrByteArray							startingAt: aNumber							count: aStringOrByteArray size-aNumber+1.			totalBytesReceived := totalBytesReceived + bytesRead].	closed ifTrue:[ConnectionClosed signal].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'bgf 10/26/2007 21:28'!receiveDataSignallingClosedInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data until something is read or the socket is closed, upon which	we signal."	| bytesRead |	bytesRead := 0.	[bytesRead == 0]		whileTrue: [			self waitForData.			bytesRead := self primSocket: socketHandle							receiveDataInto: aStringOrByteArray							startingAt: aNumber							count: aStringOrByteArray size-aNumber+1.			totalBytesReceived := totalBytesReceived + bytesRead.		].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'ar 7/23/2010 17:19'!receiveDataSignallingTimeout: timeout into: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Wait for data once for the specified nr of seconds.  This method will	throw exceptions on timeout or the socket closing."	| bytesReceived |	self waitForDataFor: timeout		ifClosed: []		ifTimedOut: [ConnectionTimedOut signal: 'Data receive timed out.'].	bytesReceived := self primSocket: socketHandle						receiveDataInto: aStringOrByteArray						startingAt: aNumber						count: aStringOrByteArray size-aNumber+1.	totalBytesReceived := totalBytesReceived + bytesReceived.	^ bytesReceived! !!Socket methodsFor: 'receiving' stamp: 'bgf 10/26/2007 21:28'!receiveDataTimeout: timeout into: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Wait for data once for the specified nr of seconds.  The answer may be 	zero (indicating that there was no data available within the given timeout)."	| bytesReceived |	self waitForDataFor: timeout ifClosed: [] ifTimedOut: [].	bytesReceived := self primSocket: socketHandle						receiveDataInto: aStringOrByteArray						startingAt: aNumber						count: aStringOrByteArray size-aNumber+1.	totalBytesReceived := totalBytesReceived + bytesReceived.	^ bytesReceived! !!Socket methodsFor: 'receiving' stamp: 'bgf 10/26/2007 21:27'!receiveSomeDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	| bytesReceived |	bytesReceived := self primSocket: socketHandle						receiveDataInto: aStringOrByteArray						startingAt: aNumber						count: aStringOrByteArray size-aNumber+1.	totalBytesReceived := totalBytesReceived + bytesReceived.	^ bytesReceived! !!Socket methodsFor: 'sending' stamp: 'bgf 10/26/2007 21:20'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 60)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		totalBytesSent := totalBytesSent + count.		bytesSent := bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'sending' stamp: 'bgf 10/26/2007 21:21'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneFor: 20)		ifTrue: [			bytesSent := self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count.			totalBytesSent := totalBytesSent + bytesSent ]		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'waiting' stamp: 'ar 4/27/2009 12:21'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| startTime msecsDelta status deadline |	startTime := Time coarseClockValue.	msecsDelta := timeout * 1000.	deadline := startTime + msecsDelta.	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [(Time coarseMillisecondsSince: startTime) < msecsDelta]]		whileTrue: [			"Soft busy-loop waiting to avoid msecs rollover issues"			semaphore waitTimeoutMSecs: 				(deadline - Time coarseClockValue min: 500 max: 0).			status := self primSocketConnectionStatus: socketHandle].	status = Connected ifFalse: [^timeoutBlock value]! !!Socket methodsFor: 'waiting' stamp: 'ar 4/27/2009 12:24'!waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock	"Wait for the given nr of seconds for data to arrive."	| startTime msecsDelta deadline |	startTime := Time coarseClockValue.	msecsDelta := timeout * 1000.	deadline := startTime + msecsDelta.	[(Time coarseMillisecondsSince: startTime) < msecsDelta] whileTrue: [			(self primSocketReceiveDataAvailable: socketHandle)				ifTrue: [^self].			self isConnected				ifFalse: [^closedBlock value].			"Soft busy-loop waiting to avoid msecs rollover issues"			self readSemaphore waitTimeoutMSecs: 				 ((deadline - Time coarseClockValue) min:500 max:0)			].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [^timedOutBlock value]				ifFalse: [^closedBlock value]]! !!Socket methodsFor: 'waiting' stamp: 'ar 1/12/2009 12:09'!waitForDataIfClosed: closedBlock	"Wait indefinitely for data to arrive.  This method will block until	data is available or the socket is closed."	[true]		whileTrue: [			(self primSocketReceiveDataAvailable: socketHandle)				ifTrue: [^self].			self isConnected				ifFalse: [^closedBlock value].			"Soft 500ms busy loop - to protect against AIO probs;			occasionally, VM-level AIO fails to trip the semaphore"			self readSemaphore waitTimeoutMSecs: 500].! !!Socket methodsFor: 'waiting' stamp: 'ar 4/27/2009 12:23'!waitForDisconnectionFor: timeout	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| startTime msecsDelta extraBytes status deadline |	startTime := Time coarseClockValue.	msecsDelta := timeout * 1000.	deadline := startTime + msecsDelta.	extraBytes := 0.	status := self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [(Time coarseMillisecondsSince: startTime) < msecsDelta]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes := extraBytes + self discardReceivedData].		"Soft busy-loop waiting to avoid msecs rollover issues"		semaphore waitTimeoutMSecs: 			(deadline - Time coarseClockValue min: 500 max: 0).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'ar 4/27/2009 12:23'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone startTime msecsDelta deadline |	startTime := Time coarseClockValue.	msecsDelta := timeout * 1000.	deadline := startTime + msecsDelta.	[self isConnected & (sendDone := self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [(Time coarseMillisecondsSince: startTime) < msecsDelta]] whileTrue: [			"Soft busy-loop waiting to avoid msecs rollover issues"			self writeSemaphore waitTimeoutMSecs:				(deadline - Time coarseClockValue min: 500 max: 0)].	^ sendDone! !!Socket commentStamp: '<historical>' prior: 0!A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocolsSubclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.JMM June 2nd 2000 Macintosh UDP support was added if you run open transport.!!Socket class methodsFor: 'instance creation' stamp: 'ar 1/5/2009 19:13'!newRAW: protocolID	"Create a socket and initialise it for RAW sockets"	self initializeNetwork.	^[ super new initializeRAW: protocolID ]		repeatWithGCIf: [ :socket | socket isValid not ]! !!Socket class methodsFor: 'utilities' stamp: 'ar 3/4/2009 12:06'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	^ Time coarseClockValue + (secs * 1000) truncated! !!SocketStream methodsFor: 'configuration' stamp: 'ar 4/2/2009 14:38'!recvCypher	"The cypher used to decrypt received data"	^recvCypher! !!SocketStream methodsFor: 'configuration' stamp: 'ar 4/2/2009 14:38'!recvCypher: aCypher	"The cypher used to decrypt received data"	recvCypher := aCypher! !!SocketStream methodsFor: 'configuration' stamp: 'ar 4/2/2009 14:39'!sendCypher	"The cypher used to encrypt sent data"	^sendCypher! !!SocketStream methodsFor: 'configuration' stamp: 'ar 4/2/2009 14:39'!sendCypher: aCypher	"The cypher used to encrypt sent data"	sendCypher := aCypher! !!SocketStream methodsFor: 'control' stamp: 'ar 8/2/2010 18:52'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	((outNextToWrite > 1) and: [socket isOtherEndClosed not])		ifTrue: [			[self sendData: outBuffer count: outNextToWrite - 1]				on: ConnectionTimedOut				do: [:ex | shouldSignal ifFalse: ["swallow"]].			outNextToWrite := 1]! !!SocketStream methodsFor: 'control' stamp: 'ar 8/5/2010 12:09'!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self isConnected and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'initialize-release' stamp: 'ar 8/2/2010 18:52'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'stream in' stamp: 'jcg 9/30/2009 11:56'!nextAvailable	"Answer all the data currently available,	in buffer or in socket."	self isInBufferEmpty ifFalse: [^self nextAllInBuffer].	self receiveDataIfAvailable.	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If  anObject is not in the collection, answer the entire rest of the receiver."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upTo: aCharacterOrByte limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| index result searchedSoFar |	"Look in the current inBuffer first"	index := inBuffer indexOf: aCharacterOrByte startingAt: lastRead + 1.	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: aCharacterOrByte						startingAt: (lastRead + searchedSoFar + 1).		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48'!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar |	sz := aStringOrByteArray size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/5/2010 12:07'!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself.		NOTE: Does not honour timeouts if shouldSignal is false!!"	[[self isConnected] whileTrue: [self receiveData]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream out' stamp: 'ar 8/2/2010 18:52'!nextPutAllFlush: aCollection	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self flush. "first flush pending stuff, then directly send"	sendCypher ifNotNil:[self error: 'Cannot do this with cypher'].	socket isOtherEndClosed ifFalse: [		[self sendData: toPut count: toPut size]			on: ConnectionTimedOut			do: [:ex | shouldSignal ifFalse: ["swallow"]]]! !!SocketStream methodsFor: 'stream out' stamp: 'ar 4/2/2009 14:34'!nextPut: char	"Put a single Character or byte onto the stream."	| toPut |	toPut := binary ifTrue: [char asInteger] ifFalse: [char asCharacter].	self adjustOutBuffer: 1.	outBuffer at: outNextToWrite put: toPut.	sendCypher ifNotNil:["Encrypt if necessary"		sendCypher process: outBuffer from: outNextToWrite to: outNextToWrite.	].	outNextToWrite := outNextToWrite + 1.	self checkFlush.	"return the argument - added by kwl"	^ char! !!SocketStream methodsFor: 'stream out' stamp: 'ar 4/2/2009 14:34'!nextPutAll: aCollection	"Put a String or a ByteArray onto the stream.	Currently a large collection will allocate a large buffer."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self adjustOutBuffer: toPut size.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + toPut size - 1 with: toPut startingAt: 1.	sendCypher ifNotNil:["Encrypt if necessary"		sendCypher process: outBuffer from: outNextToWrite to: outNextToWrite + toPut size - 1.	].	outNextToWrite := outNextToWrite + toPut size.	self checkFlush! !!SocketStream methodsFor: 'testing' stamp: 'ar 8/2/2010 18:52'!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we check the socket for data. If it claims to have data available to read, we try to read some once and recursively call this method again. If something really was available it is now in the inBuffer. This is because there has been spurious dataAvailable when there really is no data to get.	Note: Some subclasses (such as SecureSocketStream) rely on the behavior here since even though data may be available in the underlying socket, it may not result in any output (yet)." 	self isInBufferEmpty ifFalse: [^true].	^socket dataAvailable		ifFalse: [false]		ifTrue: [self receiveAvailableData; isDataAvailable]! !!SocketStream methodsFor: 'private' stamp: 'ar 4/2/2009 14:37'!adjustInBuffer: bytesRead	"Adjust markers and possibly grow inBuffer or move data down.	Currently grows through doubling when less than 1024 bytes are left.	Never shrinks. Returns the position in the buffer where any new	data can be found."	| old |	bytesRead = 0 ifTrue: [^inNextToWrite].	old := inNextToWrite.	inNextToWrite := inNextToWrite + bytesRead.	recvCypher ifNotNil:[recvCypher process: inBuffer from: old to: inNextToWrite-1].	(inBuffer size - inNextToWrite) < 1024 ifTrue: [		"Hit the roof, move data down (if enough has been read) or do we grow?"		(lastRead > 512)			ifTrue: [^old - self moveInBufferDown]			ifFalse: [self growInBuffer]].	^old! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 8/2/2010 17:40'!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 8/2/2010 17:40'!receiveData	"Receive data. Signal exceptions and timeouts depending on #shouldSignal and #shouldTimeout. Return the position in the buffer where the new data starts, regardless if anything was read."	socket		waitForDataFor: self timeout		ifClosed: [self shouldSignal 			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]		ifTimedOut: [self shouldTimeout			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 8/2/2010 17:40'!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 8/2/2010 17:40'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 8/2/2010 18:53'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SocketStream methodsFor: 'accessing' stamp: 'jcg 12/8/2009 20:00'!remoteAddress	^socket ifNotNilDo: [:s | s remoteAddress]! !!SocketStream methodsFor: 'accessing' stamp: 'jcg 12/8/2009 20:00'!remotePort	^socket ifNotNilDo: [:s | s remotePort]! !!SocketStream commentStamp: 'md 7/14/2006 16:32' prior: 0!SocketStream is a wrapper for class Socket making it easy to write networking code by giving the programmer a stream-like protocol. A Socket is a two way communication link with two logically separate channels - input and output. The Socket class is the lowest level in Squeak for network communication and using it directly can be difficult and bug prone.A SocketStream can be in binary or ascii mode, ascii is the default which means you are transmitting and receiving Strings. Most Internet protocols are in clear text ascii, like for example HTTP. Another setting is what timeout you want to use - default is the standardTimeout from Socket. More settings can be found in the method category 'configuration'.Simplest example of connecting, sending/receiving and closing:| stream result |stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.[[stream nextPutAll: 'GET / HTTP/1.0'; crlf; crlf; flush.result := stream upToEnd. "Give us all data until the socket is closed."Transcript show: result; cr.]	ensure: [stream close]]		on: ConnectionTimedOut		do: [:ex | Transcript show: ex asString;cr. ex resume]There are two important things to note above:	- The methods in category "stream in" can signal two exceptions (unless turned off with #shouldSignal:):		ConnectionClosed and ConnectionTimedOut	- We close the stream using #ensure:, that is to make sure it isn't left opened.	- We use #on:do: to catch any signal. In this case we do not need to catch ConnectionClosed since #upToEnd does that for us intrinsically.----------------SocketStream (below called SS) is a reimplementation of 'Old'-SocketStream (below called OSS) - the class that originates from the original Comanche implementation but now is included in standard Squeak. SS has the same protocol as OSS and is meant to replace it. SS is faster, more flexible, is better documented and adds a few features:1. #shouldSignal:, which decides if SS should signal low level Socket exceptions (true) or if it should swallow them like original OSS did. Default is true. The only reason I added this is for backwards compatibility - not signalling causes problems - see bug 4 below.2. #nextAllInBuffer, #nextInBuffer:, #skip:, #receiveData:, #nextPutAllFlush: and #recentlyRead are new additions to the public protocol.It also fixes various bugs:1. #isDataAvailable could theoretically answer false, when there actually is some in the buffer in OSS. If #receiveDataIfAvailable reads the last byte then the following "socket dataAvailable" would answer false. So the last byte would be sitting in the inStream missed.2. #upToAll: in OSS has several problems, for example - #positionOfSubCollection:ifAbsent: which was introduced answers one position too low. This was compensated in upToAll:, but only in the pushBack: call, not the actual result being returned which was cut short 1 byte. Amusingly this makes KomHttpServer not use "Keep-Alive" since the last $e in 'Alive' was cut short. :)3. SS doesn't inherit from PositionableStream since that just breaks various inherited messages, like for example #skip:. OSS should IMHO be changed to inherit from Object - or of course, replaced in full with SS. :)4. Since SocketStream by default signals closes and timeouts the SocketStreamTest now passes. The reason for SocketStream to fail is that while it does timeout on a low level (#SocketStream>>receiveData doesn't hang forever) - the callers of #receiveData sometimes loop - like in #next:, and thus eliminates the timeout. SS warns about some methods (in their method comments) not honouring timeouts if shouldSignal is false, I really don't know what they should do in that case:	#next:, #upTo:, #upToAll: and #upToEnd (and #receiveData:)The primary reason for the SS implementation is optimal performance. The main differences in implementation with the old OSS are:1. SS uses two buffers directly (inBuffer and outBuffer) with pointers marking start and stop within the buffer. OSS instead uses two regular streams, a ReadStream and a WriteStream. Using internal buffers makes it possible to avoid copying and reallocation in various ways, it also makes SS be able to have specialized growing/buffer moving behaviour.2. #upTo:, #upToAll: and #peekForAll: uses selectged String messages that in turn uses fast primitives for searching. OSS used other messages that fell back on byte per byte reading.3. #receiveData in OSS creates a temporary buffer stream for each call!! During a long read operation, like say #upToAll: (which for example is used when uploading files using HTTP POST forms), this is devastating - especially since the default size is only 2000 bytes - and leads to a very high number of low level read operations on the Socket, typically 100 times more calls than with OSS. The buffer in OSS is held in an instvar (not recreated for each call), is larger from the start and above all - grows dynamically by doubling. OSS can also avoid a grow/reallocation by doing a "move down" if data has been read from the SS as it comes in and through that making room in the lower part of the inBuffer. The net result is that upToAll: for large files is about 10 times faster.4. The implementation of upTo: and upToAll: tries to avoid doing unnecessary find operations in the buffer and is greedy by default, which means it favors reading more data - if available - before searching for the stop sequence. If we had #findString:startingAt:stoppingAt: this wouldn't have to be greedy and we wouldn't be needlessly scanning dead buffer area. VM hackers? Also, while you are at it - make it work for ByteArrays too. :)SS can not be run unbuffered, since that seems unneeded. The option to autoFlush is still available, with it set to true SocketStream (just like OSS) will flush on its own on each nextPut:/nextPutAll:, otherwise flushing it will have to be done manually but is done on close.The first performance tests shows that, as noted above, receiving large amounts of data using #upToAll: is greatly improved - factor of 10. Serving HTTP with small payloads seemed at first not be faster at all - but this is due to the high overhead of Socket connect/close and other things. Increasing payloads show a difference and especially with keep alive on - where the new SS roughly doubles the throughput!!!!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 18:08'!port	^4421! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 18:10'!setUp	| listener clientSocket serverSocket |	listener := Socket newTCP.	[listener listenOn: 0 backlogSize: 4.	clientSocket := Socket newTCP.	clientSocket connectTo: #[127 0 0 1] port: listener localPort.	clientSocket waitForConnectionFor: 1.	self assert: clientSocket isConnected.	serverSocket := listener waitForAcceptFor: 1.	self assert: serverSocket isConnected.	] ensure:[listener destroy].	clientStream := SocketStream on: clientSocket.	serverStream := SocketStream on: serverSocket.! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 17:59'!tearDown	clientStream ifNotNil:[clientStream destroy].	serverStream ifNotNil:[serverStream destroy].! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoClose	"Ensure that #next:into: will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoCloseNonSignaling	"Ensure that #next:into: will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpTo	"Tests correct behavior of #upTo:"	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: Character cr) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String cr; flush] fork.	self assert: (serverStream upTo: Character cr) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upTo: Character cr] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upTo: Character cr] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:29'!testUpToAll	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: String crlf) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String crlf; flush] fork.	self assert: (serverStream upToAll: String crlf) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:02'!testUpToAllAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upToAll: String crlf] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:26'!testUpToAllAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upToAll: String crlf] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:48'!testUpToAllLimit	"Tests correct behavior of #upToAll:limit:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upToAll: String crlf limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:11'!testUpToAllTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upToAll: String crlf] raise: ConnectionTimedOut.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:16'!testUpToEndClose	"Ensure that #upToEnd will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:16'!testUpToEndCloseNonSignaling	"Ensure that #upToEnd will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:49'!testUpToMax	"Tests correct behavior of #upToAll:max:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upTo: Character cr limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upTo: Character cr] raise: ConnectionTimedOut.! !!SortedCollection methodsFor: 'accessing' stamp: 'eem 12/14/2008 16:48'!sortBlock: aBlock 	"Make the argument, aBlock, be the criterion for ordering elements of the receiver."	sortBlock := aBlock.	self size > 0 ifTrue: [self reSort]! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:27'!testAdd	"self run: #testAdd"	"self debug: #testAdd"		| collection |	collection := #(10 9 8 7 5 4 4 2) asSortedCollection.	self assert: collection first = 2.	self assert: collection last = 10.	self assert: (collection size = 8).	collection add:1.	self assert: (collection size = 9).	collection add: 6.	self assert: ((collection at: 5) = 5).	self assert: (collection size = 10).	collection add: 3.	! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:30'!testAddAll	"self run: #testAddAll"	"self debug: #testAddAll"		| sorted2 sorted|	sorted2 := SortedCollection new.	sorted2 add: 'brochet'; add:'truitelle'.	sorted := SortedCollection new.	sorted addAll: sorted2.	self assert: (sorted hasEqualElements: sorted2).	 ! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:32'!testAddAll2	"self run: #testAddAll2"	"self debug: #testAddAll2"		| sorted2 sorted|	sorted2 := SortedCollection new.	sorted2 add: 'brochet'; add:'truitelle'.	sorted := SortedCollection new.	sorted add: 'perche'.	sorted addAll: sorted2.	self assert: (sorted size = (sorted2 size + 1)).	sorted2 do: 			[ :each | self assert: (sorted includes: each)]	 ! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:33'!testCollect	"self run: #testCollect"		|result aSortedCollection|	aSortedCollection := SortedCollection new.	result := OrderedCollection new.	result add:true ; add: true ; add: true ;add: false ; add: false.	aSortedCollection := (1 to: 5) asSortedCollection.	self assert: (result = (aSortedCollection collect: [:each | each < 4])).	! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:39'!testCopy	"self run: #testCopy"	"self debug: #testCopy"		|aSortedCollection copySorted|	aSortedCollection := SortedCollection new.	aSortedCollection sortBlock: [:a :b | a < b].	aSortedCollection add: 'truite' ; add: 'brochet'.	self assert: aSortedCollection first = 'brochet'.		copySorted := aSortedCollection copy.		self assert: (copySorted  hasEqualElements: aSortedCollection).	self assert: (copySorted  species = aSortedCollection species).	self assert: (copySorted  sortBlock = aSortedCollection sortBlock).	self assert: copySorted first = 'brochet'.! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:30'!testCreation	"self run: #testCreation"	"self debug: #testCreation"		| collection |	collection := #(10 9 3 6 1 8 7 5 4 2) asSortedCollection.	self assert: collection = (1 to: 10) asSortedCollection.	! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:42'!testEquals	"self run: #testEquals"	"self debug: #testEquals"		|aSortedCollection|	aSortedCollection := SortedCollection new.	aSortedCollection add:'truite' ; add: 'brochet'.	self assert: aSortedCollection copy = aSortedCollection.! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:43'!testMedian	"self run: #testMedian"	"self debug: #testMedian"		|aSortedCollection|	aSortedCollection := (1 to: 10) asSortedCollection.	self assert: aSortedCollection median=5.		aSortedCollection := SortedCollection new.	aSortedCollection add:'truite' ; add:'porcinet' ; add:'carpe'.	self assert: (aSortedCollection median = 'porcinet').	! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 9/14/2009 21:02'!testRemoveAll	"Allows one to remove all elements of a collection" 		| c1 c2 s2 |	c1 := #(10 9 8 7 5 4 4 2) asSortedCollection: [:a :b | a >= b].	c2 := c1 copy.	s2 := c2 size.		c1 removeAll.		self assert: c1 size = 0.	self assert: c2 size = s2 description: 'the copy has not been modified'.		c1 add: 13; add: 14.	self assert: (c1 first = 14 and: [c1 second = 13])  description: 'the sortBlock has been preserved'.! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 2/26/2008 22:52'!testReversed		| sc1 sc2 sc3 |	sc1 := #(1 2 3 4) asSortedCollection.	self assert: sc1 reversed asArray = sc1 asArray reversed.		self		assert: sc1 reversed class = SortedCollection		description: 'reversing a SortedCollection should answer a SortedCollection'.		sc1 removeFirst; removeLast.	sc2 := sc1 reversed.	self assert: sc2 reversed asArray = sc1 asArray.		sc2 add: 3/2; add: 1/2; add: 7/2.	self assert: sc2 asArray = {7/2. 3. 2. 3/2. 1/2}.			sc3 := #(1 2 3 3.0 4) asSortedCollection.	self assert: sc3 reversed asArray = #(4 3.0 3 2 1).	self assert: (sc3 reversed at: 2) class = Float.	! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:46'!testShouldPrecede	"self run: #testShouldPrecede"		|aSortedCollection|	aSortedCollection := SortedCollection new.	self assert: (aSortedCollection should: 'za' precede: 'zb').	self assert: (aSortedCollection isEmpty).	self assert: (aSortedCollection should: 1 precede: 2).		aSortedCollection sortBlock: [:a :b | a > b].	aSortedCollection reSort.	self assert: (aSortedCollection should: 'zb' precede: 'za').	self assert: (aSortedCollection isEmpty).	self assert: (aSortedCollection should: 2 precede: 1).		! !!SortedCollectionTest methodsFor: 'basic' stamp: 'DM 3/16/2006 11:38'!testSortBlock	"self run: #testSortBlock"	"self debug: #testSortBlock"		|aSortedCollection|	aSortedCollection := SortedCollection new.	aSortedCollection sortBlock: [:a :b | a < b].	aSortedCollection add: 'truite' ; add: 'brochet' ; add: 'tortue'.	self assert: aSortedCollection first = 'brochet'.		aSortedCollection := SortedCollection new.	aSortedCollection sortBlock: [:a :b | a >b].	aSortedCollection add: 'truite' ; add: 'brochet' ; add: 'tortue'.	self assert: aSortedCollection first = 'truite'.			! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 5/22/2008 09:59'!testSpeciesLooseSortBlock	"This is a non regression test for http://bugs.squeak.org/view.php?id=6535"	| numbers reverseOrder firstThree |	numbers := #(1 2 3 4 5).	reverseOrder := SortedCollection sortBlock: [:x :y | x > y].	reverseOrder addAll: numbers.	"The elements are inverted"	self assert: [reverseOrder asArray = #(5 4 3 2 1)].	"Copy the first 3 elements"	firstThree := reverseOrder copyFrom: 1 to: 3.	"It appears to work"	self assert: [firstThree asArray = #(5 4 3)].	"but we have lost the sort block"	firstThree add: 1.	" firstThree is now #(1 5 4 3)!! "	self assert: [firstThree asArray = #(5 4 3 1)] "fails"! !!SortedCollectionTest methodsFor: 'tests - sorting' stamp: 'ul 12/23/2009 12:20'!testSort	| s |	s := SortedCollection withAll: #(3 2 1).	self assert: s asArray = #(1 2 3).	s sort: #>=. "This should change the sortBlock too"	self assert: s asArray = #(3 2 1).	s add: 4.	self assert: s asArray = #(4 3 2 1).	s := SortedCollection new 		sortBlock: #>=;		addAll: #(1 2 3);		yourself.	self assert: s asArray = #(3 2 1).	s sort.	self assert: s asArray = #(1 2 3).	s add: 0.	self assert: s asArray = #(0 1 2 3)! !!SoundBuffer methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:39'!* scaleFactor	| me result |	me := self readStream.	result := (self class newMonoSampleCount: self monoSampleCount) writeStream.	[me atEnd] whileFalse: [result nextPut: (me next * scaleFactor) floor].	^result contents! !!SoundBuffer methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:17'!- aSoundBuffer	| us them result |	us := self readStream.	them := aSoundBuffer readStream.	result := (self class newMonoSampleCount: self monoSampleCount) writeStream.	[us atEnd or: [them atEnd]] whileFalse: [result nextPut: us next - them next].	^result contents! !!SoundBuffer methodsFor: 'utilities' stamp: 'crl 3/15/2010 10:18'!sampleIndexOfPositivePeak: peakIndex startingAt: startingSampleIndex	| stream currentSample nextSample peaksSeen peakPosition |	stream := self readStream.	stream position: startingSampleIndex.	nextSample := stream next.	peaksSeen := 0.	[peaksSeen < peakIndex] whileTrue: [		"Find the next positive peak."		[			stream atEnd ifTrue: [^nil].			currentSample := nextSample.			nextSample := stream next.			currentSample > 0 and: [nextSample > 0 and: [nextSample < currentSample]]		]			whileFalse.		peaksSeen := peaksSeen + 1.		peakPosition := stream position - 1.		"Skip the next negative peak."		[			stream atEnd ifTrue: [^nil].			currentSample := nextSample.			nextSample := stream next.			nextSample < currentSample		]			whileTrue].	^peakPosition! !!SoundBuffer methodsFor: 'utilities' stamp: 'crl 3/12/2010 15:04'!withoutFirst: numberOfSamples	| stream |	stream := self readStream.	stream next: numberOfSamples.	^stream upToEnd! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'crl 3/11/2010 17:15'!fromLSBByteArray: aByteArray	"Convert the given ByteArray (stored with the least significant byte first) into 16-bit sample buffer."	| n buf src w |	n := aByteArray size // 2.	buf := SoundBuffer newMonoSampleCount: n.	src := 1.	1 to: n do: [:i |		w := ((aByteArray at: src + 1) bitShift: 8) + (aByteArray at: src).		w > 32767 ifTrue: [w := w - 65536].		buf at: i put: w.		src := src + 2].	^ buf! !!SoundCodec methodsFor: 'private' stamp: 'jcg 5/7/2008 15:05'!encodeSoundBuffer: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	self reset.	^self encodeSoundBufferNoReset: aSoundBuffer! !!SoundCodec methodsFor: 'private' stamp: 'pbm 3/15/2006 15:37'!encodeSoundBufferNoReset: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i lastIncs |	frameSize := self samplesPerFrame.	fullFrameCount := aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples := aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	codeFrameSize := self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue:		["Allow room for 1 byte per sample for variable-length compression"		codeFrameSize := frameSize].	lastFrameSamples > 0		ifTrue: [result := ByteArray new: (fullFrameCount + 1) * codeFrameSize]		ifFalse: [result := ByteArray new: fullFrameCount * codeFrameSize]."	self reset."	increments := self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame := SoundBuffer newMonoSampleCount: frameSize.		i := fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i := i + 1))].		lastIncs := self encodeFrames: 1 from: finalFrame at: 1 into: result at: 1 + increments second.		increments := Array with: increments first + lastIncs first							with: increments second + lastIncs second].	increments second < result size		ifTrue: [^ result copyFrom: 1 to: increments second]		ifFalse: [^ result]! !!SoundPlayer class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 14:39'!defaultPlayer	"Answer the deviceName of the default device to be used as the next player (output) device to be opened."	PlayerListMutex critical: [		^ self primDefaultPlayer	].! !!SoundPlayer class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 18:07'!defaultPlayer: deviceName	PlayerListMutex critical: [		^ self primDefaultPlayer: deviceName	].! !!SoundPlayer class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 14:40'!playerDevices	"Answer a sortable collection of available values for use with #defaultPlayer:."	| devices n |	PlayerListMutex critical: [		n := self numberOfPlayerDevices.		devices := Array new: n.		1 to: n do: [:index |			devices at: index put: (self playerDeviceNameOfIndex: index).			].		^devices	].! !!SoundPlayer class methodsFor: 'initialization' stamp: 'bgf 10/17/2009 14:37'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate := 22050.	BufferMSecs := 120.	Stereo := true.	UseReverb ifNil: [UseReverb := true].	PlayerListMutex := Mutex new.! !!SoundPlayer class methodsFor: 'player process' stamp: 'bgf 2/16/2008 23:56'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	aSound		ifNil:[ActiveSounds := OrderedCollection new]		ifNotNil:[ActiveSounds := OrderedCollection with: aSound].	Buffer := SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	LastBuffer ifNotNil:[LastBuffer := SoundBuffer basicNew: Buffer basicSize].	PlayerSemaphore := Semaphore forMutualExclusion.	SamplingRate := samplesPerSecond.	Stereo := stereoFlag.	ReadyForBuffer := Semaphore new.	SoundSupported := true. "Assume so"	UseReadySemaphore := true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess := [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess := [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor highIOPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'private' stamp: 'hrs 10/24/2008 13:27'!numberOfPlayerDevices	"Answer the number of player (output) devices. See #playerDeviceNameOf:."	<primitive: 'primitiveGetNumberOfSoundPlayerDevices' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'hrs 10/24/2008 13:28'!playerDeviceNameOfIndex: deviceNumber	"Answer the name of the nth player (output) device, or nil.	The device number must range from 0 to less than the the #numberOfPlayerDevices."	<primitive: 'primitiveGetSoundPlayerDeviceName' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'bgf 10/17/2009 14:38'!primDefaultPlayer	"Answer the deviceName of the default device to be used as the next player (output) device to be opened."	<primitive: 'primitiveGetDefaultSoundPlayer' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'bgf 10/17/2009 14:37'!primDefaultPlayer: deviceName	"Set deviceName as the default device to be used as the next player (output) device to be opened."	<primitive: 'primitiveSetDefaultSoundPlayer' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundRecorder methodsFor: 'accessing' stamp: 'hrs 10/24/2008 14:45'!recordLevel	"Get the recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Before there was a primitive, this used to refer to an instance variable set by #recordLevel:."	^self primGetRecordLevel / 1000.0! !!SoundRecorder methodsFor: 'accessing' stamp: 'hrs 10/24/2008 13:21'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely."  	| recordLevel |	recordLevel := (level asFloat min: 1.0) max: 0.0.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.! !!SoundRecorder methodsFor: 'initialization' stamp: 'hrs 10/24/2008 11:12'!initialize	"SoundRecorder new"	stereo := false.	samplingRate := 11025.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'primitives' stamp: 'jcg 3/24/2010 17:10'!primEnableEchoCancellation: zeroOrOne	"Turn AEC on or off.  Zero means off, and one means on.  Primitive will fail if you try to turn AEC on, but it is not supported by the platform."	<primitive: 'primitiveSoundEnableAEC' module: 'SoundPlugin'>	self primitiveFailed ! !!SoundRecorder methodsFor: 'primitives' stamp: 'hrs 10/24/2008 11:04'!primGetRecordLevel	"Get the  recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	<primitive: 'primitiveSoundGetRecordLevel' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jcg 3/24/2010 12:33'!disableEchoCancellation	"Turn AEC on."	self enableEchoCancellation: false! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jcg 3/24/2010 12:33'!enableEchoCancellation	"Turn AEC on."	self enableEchoCancellation: true! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jcg 3/24/2010 12:33'!enableEchoCancellation: trueOrFalse	"Turn AEC on or off.  Primitive will fail if you try to turn AEC on, but it is not supported by the platform."	self primEnableEchoCancellation: (trueOrFalse ifTrue: [1] ifFalse: [0]).! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jcg 3/28/2010 13:06'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex actualSamplingRate |	Preferences canRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused := true.	meteringBuffer := SoundBuffer newMonoSampleCount: 1024.	meterLevel := 0.	self allocateBuffer.	bufferAvailableSema := Semaphore new.	semaIndex := Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	RecorderActive := true.	actualSamplingRate := self primGetActualRecordingSampleRate.	actualSamplingRate > 0 ifTrue: [		"Sometimes the primitive (at least on Win32) returns zero,		 which is always bogus and therefore never sensible to 		 remember."		samplingRate := actualSamplingRate	].	recordProcess := [self recordLoop] newProcess.	recordProcess priority: Processor highIOPriority.	recordProcess resume.! !!SoundRecorder commentStamp: '<historical>' prior: 0!It is absolutely stupid how difficult it is to use this class.  Here's a quick way to get a positive result (execute in two parts in a workspace)."Create recorder and start recording"recorder := SoundRecorder new samplingRate: 22050.recorder clearRecordedSound. 		"Otherwise it will explode, 'natch"recorder startRecording.				"Not really, start in paused state"recorder resumeRecording.			"Really begin recording.  Really.""When you're done, stop recording and play the sound."recorder stopRecording.recorder recordedSound play.!!SoundRecorder class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 14:45'!defaultRecorder	"Get deviceName of the default device to be used as the next recorder (input) device to be opened."	RecorderListMutex critical: [		^ self primDefaultRecorder	].! !!SoundRecorder class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 18:07'!defaultRecorder: deviceName	"Set deviceName as the default device to be used as the next recorder (input) device to be opened.	 The initial listing setup  (self recorderDevices) should be called prior to doing this;	 if it returns NULL, then no devices are to be considered."	RecorderListMutex critical: [		^ self primDefaultRecorder: deviceName	]! !!SoundRecorder class methodsFor: 'accessing' stamp: 'bgf 10/17/2009 14:44'!recorderDevices	"Answer a sortable collection of available values for use with #defaultRecorder:."	| devices n |	RecorderListMutex critical: [		n := self numberOfRecorderDevices.		devices := Array new: n.		1 to: n do: [:index |			devices at: index put: (self recorderDeviceNameOfIndex: index).			].		^devices	]! !!SoundRecorder class methodsFor: 'accessing' stamp: 'jcg 3/24/2010 17:40'!supportsEchoCancellation	"Answer true if this SoundPlugin/OS/hardware supports echo-cancellation, and false otherwise."	<primitive: 'primitiveSoundSupportsAEC' module: 'SoundPlugin'>	^false! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'bgf 10/17/2009 14:43'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying := #ignoredNowInPreferences.	RecorderListMutex := Mutex new.! !!SoundRecorder class methodsFor: 'private' stamp: 'hrs 10/24/2008 13:28'!numberOfRecorderDevices	"Answer the number of recorder (input) devices. See #recorderDeviceNameOf:."	<primitive: 'primitiveGetNumberOfSoundRecorderDevices' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundRecorder class methodsFor: 'private' stamp: 'bgf 10/17/2009 14:43'!primDefaultRecorder	"Get deviceName of the default device to be used as the next recorder (input) device to be opened."	<primitive: 'primitiveGetDefaultSoundRecorder' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundRecorder class methodsFor: 'private' stamp: 'bgf 10/17/2009 14:43'!primDefaultRecorder: deviceName	"Set deviceName as the default device to be used as the next recorder (input) device to be opened."	<primitive: 'primitiveSetDefaultSoundRecorder' module: 'SoundPlugin'>	^self primitiveFailed! !!SoundRecorder class methodsFor: 'private' stamp: 'hrs 10/24/2008 13:29'!recorderDeviceNameOfIndex: deviceNumber	"Answer the name of the nth recorder (input) device, or nil.	The device number must range from 0 to less than the the #numberOfRecorderDevices."	<primitive: 'primitiveGetSoundRecorderDeviceName' module: 'SoundPlugin'>	^self primitiveFailed! !!SparseLargeArray methodsFor: 'private' stamp: 'eem 11/5/2008 10:36'!analyzeSpaceSaving	| elems tablesTotal nonNilTables lastPage lastChunkSize |	elems := 0.	tablesTotal := self basicSize.	nonNilTables := 0.	lastPage := self basicAt: self basicSize.	(lastChunkSize := size \\ chunkSize) = 0 ifTrue:		[lastChunkSize := chunkSize].	1 to: self basicSize do:		[:i | | page |		(page := self basicAt: i) ifNotNil:			[nonNilTables := nonNilTables + 1.			 1 to: (page == lastPage ifTrue: [lastChunkSize] ifFalse: [chunkSize]) do:				[:j|				(page at: j) ~= defaultValue ifTrue:					[elems := elems + 1]]]].	^String streamContents:		[:strm |		strm nextPutAll: 'total: '; print: size.		strm nextPutAll: ' elements: '; print: elems.		strm nextPutAll: ' tables: '; print: tablesTotal.		strm nextPutAll: ' non-nil: '; print: nonNilTables]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 14:00'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	1 to: self basicSize do:		[:i|		self basicAt: i put: nil].	defaultValue := anObject! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 12:53'!noCheckAt: index	^(self basicAt: index - base // chunkSize + 1)		ifNil: [defaultValue]		ifNotNil: [:chunk| chunk at: index - base \\ chunkSize + 1]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/2/2008 11:57'!noCheckAt: index put: value	| chunkIndex chunk lastChunkSize |	chunkIndex := index - base // chunkSize + 1.	(chunk := self basicAt: chunkIndex) ifNil:		[value = defaultValue ifTrue:			[^value].		chunk := arrayClass					new: ((chunkIndex == self basicSize						   and: [(lastChunkSize := size \\ chunkSize) > 0])							ifTrue: [lastChunkSize]							ifFalse: [chunkSize])					withAll: defaultValue.		self basicAt: chunkIndex put: chunk].	^chunk at: index - base \\ chunkSize + 1 put: value! !!SparseLargeArray methodsFor: 'initialization' stamp: 'eem 11/1/2008 12:16'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	chunkSize := aChunkSize.	size := aSize.	base := b.	defaultValue := d.	arrayClass := aClass! !!SparseLargeArray commentStamp: '<historical>' prior: 0!A version of SparseLargeTable that does not populate its bins until a value other than the default is stored.!!Spline methodsFor: 'accessing'!coefficients	"Answer an eight-element Array of Arrays each of which is the length 	of the receiver. The first four arrays are the values, first, second and 	third derivatives, respectively, for the parametric spline in x. The last 	four elements are for y."	^coefficients! !!Spline methodsFor: 'displaying'!computeCurve	"Compute an array for the coefficients."	| length extras |	length := self size.	extras := 0.	coefficients := Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(self at: i) x asFloat]						ifFalse: [(self at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver, a spline curve, approximated by straight line	segments."	| n line t x y x1 x2 x3 y1 y2 y3 |	collectionOfPoints size < 1 ifTrue: [self error: 'a spline must have at least one point'].	line := Line new.	line form: self form.	line beginPoint: 		(x := (coefficients at: 1) at: 1) rounded @ (y := (coefficients at: 5) at: 1) rounded.	1 to: (coefficients at: 1) size - 1 do: 		[:i | 		"taylor series coefficients"		x1 := (coefficients at: 2) at: i.		y1 := (coefficients at: 6) at: i.		x2 := ((coefficients at: 3) at: i) / 2.0.		y2 := ((coefficients at: 7) at: i) / 2.0.		x3 := ((coefficients at: 4) at: i) / 6.0.		y3 := ((coefficients at: 8) at: i) / 6.0.		"guess n"		n := 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3)							at: i + 1) abs + ((coefficients at: 7)							at: i + 1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t := j asFloat / n.			line endPoint: 				(x3 * t + x2 * t + x1 * t + x) rounded 							@ (y3 * t + y2 * t + y1 * t + y) rounded.			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			line beginPoint: line endPoint].		line beginPoint: 				(x := (coefficients at: 1) at: i + 1) rounded 					@ (y := (coefficients at: 5) at: i + 1) rounded.		line			displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Get the scaled and translated path of newKnots."	| newKnots newSpline |	newKnots := aTransformation applyTo: self.	newSpline := Spline new.	newKnots do: [:knot | newSpline add: knot].	newSpline form: self form.	newSpline		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Spline methodsFor: 'private'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| l v anArray |	l := a size.	l < 2 ifTrue: [^self].	l > 2	  ifTrue:		[v := Array new: l.		 v  at:  1 put: 4.0.		 anArray := Array new: l.		 anArray  at:  1 put: (6.0 * ((a  at:  1) - ((a  at:  2) * 2.0) + (a  at:  3))).		 2 to: l - 2 do:			[:i | 			v  at:  i put: (4.0 - (1.0 / (v  at:  (i - 1)))).			anArray				at:  i 				put: (6.0 * ((a  at:  i) - ((a  at:  (i + 1)) * 2.0) + (a  at:  (i + 2)))						- ((anArray  at:  (i - 1)) / (v  at:  (i - 1))))].		 point2  at: (l - 1) put: ((anArray  at:  (l - 2)) / (v  at:  (l - 2))).		 l - 2 to: 2 by: 0-1 do: 			[:i | 			point2 				at: i 				put: ((anArray  at:  (i - 1)) - (point2  at:  (i + 1)) / (v  at:  (i - 1)))]].	point2 at: 1 put: (point2  at:  l put: 0.0).	1 to: l - 1 do:		[:i | point1 				at: i 				put: ((a at: (i + 1)) - (a  at:  i) - 						((point2  at:  i) * 2.0 + (point2  at:  (i + 1)) / 6.0)).		      point3 at: i put: ((point2  at:  (i + 1)) - (point2  at:  i))]! !!Spline commentStamp: '<historical>' prior: 0!I represent a collection of Points through which a cubic spline curve is fitted.!!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm := Form extent: 2@2.	aForm  fillBlack.	splineCurve := Spline new.	splineCurve form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag:=false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !!SqNumberParserTest methodsFor: 'utility' stamp: 'nice 3/14/2010 23:02'!areLowercaseDigitsAllowed	"Answer true if lowercase letter are allowed digits."		^(SqNumberParser parse: '16re' onError: [-1]) = 16rE! !!SqNumberParserTest methodsFor: 'tests - fail' stamp: 'NikoSchwarz 10/23/2009 12:39'!testFail	"Verify that the value of a failblock is returned."	self assert: (SqNumberParser parse: 'blablabla' onError: [42]) equals: 42! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 5/7/2006 17:46'!testFloatFromStreamAsNumber	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '10r-12.3456' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -12.3456 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2e2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -1234.56 = aFloat.	self assert: rs upToEnd = 'e2'.	rs := '10r-12.3456d2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456q2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '-12.3456q2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456q2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456z2' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 12.3456 = aFloat.	self assert: rs upToEnd = 'z2'.! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 5/7/2006 17:46'!testFloatFromStreamWithExponent	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '1.0e-14' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs atEnd.	rs := '1.0e-14 1' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = ' 1'.	rs := '1.0e-14eee' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = 'eee'.	rs := '1.0e14e10' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1.0e14 = aFloat.	self assert: rs upToEnd = 'e10'.	rs := '1.0e+14e' readStream. "Plus sign is not parseable"	aFloat := SqNumberParser parse: rs.	self assert: 1.0 = aFloat.	self assert: rs upToEnd = 'e+14e'.	rs := '1.0e' readStream.	aFloat := SqNumberParser parse: rs.	self assert: 1.0 = aFloat.	self assert: rs upToEnd = 'e'.! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 3/14/2010 23:03'!testFloatGradualUnderflow	"Gradual underflow are tricky.	This is a non regression test for http://bugs.squeak.org/view.php?id=6976"	| float trueFraction str |		"as a preamble, use a base 16 representation to avoid round off error and check that number parsing is correct"	trueFraction := 16r2D2593D58B4FC4 / (16 raisedTo: 256+13).	"Parse the number in base 16 if possible - it is impossible if lowercase letter are allowed digits due to exponent letter ambiguity."	float := self areLowercaseDigitsAllowed		ifNil: [SqNumberParser parse: '16r2.D2593D58B4FC4e-256']		ifNotNil: [trueFraction asFloat]..	self assert: float asTrueFraction = trueFraction.	self assert: float = trueFraction asFloat.	"now print in base 10"	str := (String new: 32) writeStream.	float absPrintExactlyOn: str base: 10.		"verify if SqNumberParser can read it back"	self assert: (SqNumberParser parse: str contents) = float. ! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 3/14/2010 23:04'!testFloatPrintString	"self debug: #testFloatPrintString"		| f r bases |	f := Float basicNew: 2.	r := Random new seed: 1234567.	"printing a Float in base other than 10 is broken if lowercase digits are allowed"	bases := self areLowercaseDigitsAllowed		ifTrue: [#(10)]		ifFalse: [#(2 8 10 16)].	100		timesRepeat: [f basicAt: 1 put: (r nextInt: 16r100000000)- 1.			f basicAt: 2 put: (r nextInt: 16r100000000) - 1.			bases				do: [:base | | str |						str := (String new: 64) writeStream.						f negative ifTrue: [str nextPut: $-].						str print: base; nextPut: $r.						f absPrintExactlyOn: str base: base.						self assert: (SqNumberParser parse: str contents) = f]].	"test big num near infinity"	10		timesRepeat: [f basicAt: 1 put: 16r7FE00000 + ((r nextInt: 16r100000) - 1).			f basicAt: 2 put: (r nextInt: 16r100000000) - 1.			bases				do: [:base | | str |						str := (String new: 64) writeStream.						f negative ifTrue: [str nextPut: $-].						str print: base; nextPut: $r.						f absPrintExactlyOn: str base: base.						self assert: (SqNumberParser parse: str contents) = f]].	"test infinitesimal (gradual underflow)"	10		timesRepeat: [f basicAt: 1 put: 0 + ((r nextInt: 16r100000) - 1).			f basicAt: 2 put: (r nextInt: 16r100000000) - 1.			bases				do: [:base | | str |						str := (String new: 64) writeStream.						f negative ifTrue: [str nextPut: $-].						str print: base; nextPut: $r.						f absPrintExactlyOn: str base: base.						self assert: (SqNumberParser parse: str contents) = f]].! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 5/1/2006 00:40'!testFloatReadError	"This covers parsing in Number>>readFrom:"	| rs num |	rs := '1e' readStream.	num := SqNumberParser parse: rs.	self assert: 1 = num.	self assert: rs upToEnd = 'e'.		rs := '1s' readStream.	num := SqNumberParser parse: rs.	self assert: 1 = num.	self assert: rs upToEnd = 's'.	rs := '1.' readStream.	num := SqNumberParser parse: rs.	self assert: 1 = num.	self assert: num isInteger.	self assert: rs upToEnd = '.'.		rs := '' readStream.	self should: [SqNumberParser parse: rs] raise: Error.		rs := 'foo' readStream.	self should: [SqNumberParser parse: rs] raise: Error.	rs := 'radix' readStream.	self should: [SqNumberParser parse: rs] raise: Error.		rs := '.e0' readStream.	self should: [SqNumberParser parse: rs] raise: Error.		rs := '-.e0' readStream.	self should: [SqNumberParser parse: rs] raise: Error.		rs := '--1' readStream.	self should: [SqNumberParser parse: rs] raise: Error.! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'nice 5/7/2006 17:46'!testFloatReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1.0101e9' asNumber.	self assert: 672.0 = aNumber.	self assert: (SqNumberParser parse: '2r1.0101e9') = (1.3125 * (2 raisedTo: 9)).	rs := ReadStream on: '2r1.0101e9e9'.	self assert: (SqNumberParser parse: rs) = 672.0.	self assert: rs upToEnd = 'e9'! !!SqNumberParserTest methodsFor: 'tests - Integer' stamp: 'nice 5/7/2006 17:46'!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: '.s could be confused with a ScaledDecimal' = s! !!SqNumberParserTest methodsFor: 'tests - Integer' stamp: 'nice 5/7/2006 17:46'!testIntegerReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1e26' asNumber.	self assert: 67108864 = aNumber.	self assert: (SqNumberParser parse: '2r1e26') = (2 raisedTo: 26).	rs := '2r1e26eee' readStream.	self assert: (SqNumberParser parse: rs) = 67108864.	self assert: rs upToEnd = 'eee'! !!SqNumberParserTest methodsFor: 'tests - ScaledDecimal' stamp: 'nice 8/29/2008 22:03'!testScaledDecimalWithTrailingZeroes	"This is a non regression tests for http://bugs.squeak.org/view.php?id=7169"		self assert: (SqNumberParser parse: '0.50s2') = (1/2).	self assert: (SqNumberParser parse: '0.500s3') = (1/2).	self assert: (SqNumberParser parse: '0.050s3') = (1/20).! !!SqNumberParserTest commentStamp: 'nice 5/7/2006 17:54' prior: 0!Provide tests for new clas aimed at parsing numbers.It duplicates NumberParsingTest, with few more tests.!!StackTest methodsFor: 'test' stamp: 'dc 6/21/2006 10:55'!testEmptyError	| aStack |	aStack := Stack new.	self should: [ aStack top ] raise: Error.	self should: [ aStack pop] raise: Error.		aStack push: 'element'.		self shouldnt: [ aStack top ] raise: Error.	self shouldnt: [ aStack pop] raise: Error.			"The stack is empty again due to previous pop"	self should: [ aStack top ] raise: Error.	self should: [ aStack pop] raise: Error.! !!StackTest methodsFor: 'test' stamp: 'sd 3/21/2006 22:13'!testPop	| aStack res elem |	elem := 'anElement'.		aStack := Stack new.	self assert: aStack isEmpty.		aStack push: 'a'.	aStack push: elem.	res := aStack pop.		self assert: res = elem.	self assert: res == elem.		self assert: aStack size = 1.	aStack pop.	self assert: aStack isEmpty.! !!StackTest methodsFor: 'test' stamp: 'sd 3/21/2006 22:13'!testPush		| aStack |	aStack := Stack new.	aStack push: 'a'.	self assert: aStack size = 1.		aStack push: 'b'.	self assert: aStack size = 2.	! !!StackTest methodsFor: 'test' stamp: 'sd 3/21/2006 22:13'!testSize		| aStack |	aStack := Stack new.	self assert: aStack size = 0.	aStack push: 'a'.	self assert: aStack size = 1.	aStack push: 'b'.	self assert: aStack size = 2.	aStack pop.	self assert: aStack size = 1.	aStack pop.	self assert: aStack size = 0. 	! !!StackTest methodsFor: 'test' stamp: 'sd 3/21/2006 22:13'!testTop	| aStack |	aStack := Stack new.	self assert: aStack isEmpty.	aStack push: 'a'.	aStack push: 'b'.	self assert: aStack top = 'b'.	self assert: aStack top = 'b'.	self assert: aStack size = 2.! !!StandardFileMenu methodsFor: '*ST80-Support' stamp: 'acg 4/15/1999 20:50'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: (MenuStyle leftFlush)! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'ar 12/9/2008 16:17'!requestDropName: dropIndex	"Request the name for some file that was dropped onto Squeak"	| rawName |	rawName := self primDropRequestFileName: dropIndex.	^rawName utf8ToSqueak! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'ar 12/31/2007 10:53'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto Squeak."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name :=  rawName utf8ToSqueak.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil ifTrue:[^nil].	self register.	rwmode := false.	buffer1 := String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'ar 7/20/2010 10:23'!handle: fileHandle name: fileName forWrite: writeMode	"Initialize the receiver with an explicit file handle and name.	Does *not* register the receiver for finalization since this method	is used for the stdio handles that should not be closed."	fileID := fileHandle.	name := fileName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering.! !!StandardFileStream class methodsFor: 'registry' stamp: 'bgf 12/7/2008 20:08'!retryWithGC: execBlock until: testBlock forFileNamed: fullName	"Re-implemented to only force GC if a file with the given name exists"	| blockValue foundIt |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	"See if we have a file with the given name"	foundIt := Registry keys "hold on strongly for now" anySatisfy:[:file|		"Under some circumstances in highly concurrent situations		'file name' can be nil in the test below. This is likely because we only		obtain the lock for the duration of retrieving the keys and another process		may be able to change the registry. There is two choices: Either change the		lock to be a proper mutex instead of a semaphore and keep the lock, 		or make the code here a little more defensively. The latter is easier for now."		| fname |		(fname := file name) ifNotNil:[fname sameAs: fullName] ifNil: [ false ].	].	foundIt ifFalse:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'eem 5/22/2008 14:59'!at: index put: aFile	files at: index put: aFile.	"This effectively closes the read-only copies on image exit as a side-effect of setting the changes to nil."	self closeReadOnlyCopies! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'eem 5/22/2008 14:57'!closeReadOnlyCopies	readOnlyCopies notNil ifTrue:		[readOnlyCopies do: [:roc| roc notNil ifTrue: [roc close]].		 readOnlyCopies atAllPut: nil]! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'eem 5/22/2008 15:02'!readOnlyCopyAt: index	| copy file |	readOnlyCopies isNil ifTrue:		[readOnlyCopies := Array new: files size].	(copy := readOnlyCopies at: index) notNil ifTrue:		[^copy].	^(file := self at: index) notNil ifTrue:		[readOnlyCopies at: index put: file readOnlyCopy]! !!StandardSourceFileArray commentStamp: '<historical>' prior: 0!This class implements the source file management behavior of traditional Squeak, with a sources file and a changes file. File positions are mapped such that those files can be up to 32MBytes in size.Structure: files		Array -- storing the actual source files!!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAddressRange	"Test source pointer to file position address translation across the full address range"		| sf |	sf := StandardSourceFileArray new.	(16r1000000 to: 16r4FFFFFF by: 811) do: [:e | | i a p |		i := sf fileIndexFromSourcePointer: e.		p := sf filePositionFromSourcePointer: e.		a := sf sourcePointerFromFileIndex: i andPosition: p.		self assert: a = e]! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 i p |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)]! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:05'!testFileIndexFromSourcePointer	"Test derivation of file index for sources or changes file from source pointers"	| sf |	sf := StandardSourceFileArray new.	"sources file mapping"	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3FFFFFF).	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	"changes file mapping"	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4FFFFFF).	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000000).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000013).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0FFFFFF)! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:10'!testFilePositionFromSourcePointer	"Test derivation of file position for sources or changes file from source pointers"	| sf |	sf := StandardSourceFileArray new.	"sources file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r1000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r1000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r1FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r3000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r3000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r3FFFFFF).	"changes file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r2000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r2000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r2FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r4000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r4000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r4FFFFFF).	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf filePositionFromSourcePointer: 16r0000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r0000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r0FFFFFF)! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:09'!testSourcePointerFromFileIndexAndPosition	"Test valid input ranges"	| sf |	sf := StandardSourceFileArray new.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 2 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 3] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: -1] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: 16r2000000] raise: Error.	self should: [sf sourcePointerFromFileIndex: 3 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 4 andPosition: 0] raise: Error.		self assert: 16r1000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 0).	self assert: 16r1000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r13).	self assert: 16r1FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16rFFFFFF).	self assert: 16r2000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 0).	self assert: 16r2000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r13).	self assert: 16r2FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16rFFFFFF).	self assert: 16r3000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000000).	self assert: 16r3000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000013).	self assert: 16r3FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF).	self assert: 16r4000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000000).	self assert: 16r4000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000013).	self assert: 16r4FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1FFFFFF)! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 p i |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)]! !!StandardSourceFileArrayTest commentStamp: 'dtl 12/13/2009 23:42' prior: 0!This test documents the source pointer address conversion methods for StandardSourceFileArray.The available address space for source pointers in CompiledMethod is 16r1000000 through 16r4FFFFFF. StandardSourceFileArray maps positions in the sources file to address range 16r1000000 through 16r1FFFFFF and 16r3000000 through 16r3FFFFFF, and positions in the changes file to address range 16r2000000 through 16r2FFFFFF and 16r4000000 through 16r4FFFFFF. This permits a maximum file size of 16r2000000 (32MB) for both the sources file and the changes file. !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame := view displayBox.	side := #none.	VBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect := sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect := sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect := sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect := sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:22'!adjustWindowBorders 	| side noClickYet |	noClickYet := true.	VBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #left) | (side = #right)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]].	HBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #top) | (side = #bottom)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'nice 12/26/2009 22:01'!adjustWindowCorners 	| box clicked |	box := view windowBox.	clicked := false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			| cornerBox |			cornerBox := ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (sensor cursorPoint))						and: [(clicked := sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | | p f2 |						p := sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 := p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 := (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 := f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 := (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:30'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp := sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	view subViews size <= 1 ifTrue: [^ self].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp := sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i := view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box := view windowBox]		ifFalse: [box := (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'borders'!fullScreen	"Make the receiver's window occupy jes' about the full screen.  6/10/96 sw"	view fullScreen! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:01'!blueButtonActivity	ScheduledBlueButtonMenu ifNil: [^ super controlActivity].	ScheduledBlueButtonMenu invokeOn: self! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:20'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'control defaults'!isControlActive	status == #active ifFalse: [^ false].	sensor anyButtonPressed ifFalse: [^ true].	self viewHasCursor		ifTrue: [^ true]		ifFalse: [ScheduledControllers noteNewTop.				^ false]! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/15/2000 22:19'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p := sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box := view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box := view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	(((box := view labelTextRegion expandBy: 1) containsPoint: p)			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'menu messages'!chooseColor	"Allow the user to specify a new background color for the receiver's window.  5/6/96 sw.	 7/31/96 sw: use Color fromUser"	view backgroundColor: Color fromUser; uncacheBits; display! !!StandardSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	model okToChange ifFalse: [^self].	status := #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint! !!StandardSystemController methodsFor: 'menu messages'!expand	"The receiver's view was collapsed; open it again and ask the user to 	designate its rectangular area."	view expand; emphasize! !!StandardSystemController methodsFor: 'menu messages' stamp: 'rbb 3/1/2005 11:14'!label	| newLabel |	newLabel := UIManager default		request: 'Edit the label, then type RETURN'		initialAnswer: view label.	newLabel isEmpty ifFalse: [view relabel: newLabel].! !!StandardSystemController methodsFor: 'menu messages'!move	"Ask the user to designate a new origin position for the receiver's view.	6/10/96 sw: tell the view that it has moved"	| oldBox | 	oldBox := view windowBox.	view uncacheBits.	view align: view windowBox topLeft		with: view chooseMoveRectangle topLeft.	view displayEmphasized.	view moved.  "In case its model wishes to take note."	(oldBox areasOutside: view windowBox) do:		[:rect | ScheduledControllers restore: rect]! !!StandardSystemController methodsFor: 'menu messages'!reframe	^ view reframeTo: view getFrame! !!StandardSystemController methodsFor: 'menu messages'!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view become: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view become: (view as: StandardSystemView)].! !!StandardSystemController methodsFor: 'menu messages'!under	"Deactive the receiver's scheduled view and pass control to any view that 	might be positioned directly underneath it and the cursor."	status := #inactive! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnscheduleNoErase	"Remove the scheduled view from the collection of scheduled views. Set 	its status to closed but do not erase."	status := #closed.	view release.	ScheduledControllers unschedule: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 3/18/98 19:21'!closeAndUnscheduleNoTerminate	"Erase the receiver's view and remove it from the collection of scheduled views, but do not terminate the current process."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self.! !!StandardSystemController methodsFor: 'scheduling'!open	"Create an area on the screen in which the receiver's scheduled view can 	be displayed. Make it the active view."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling'!openDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view."	view align: view viewport center with: aPoint.	view translateBy:		(view displayBox amountToTranslateWithin: Display boundingBox).	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!openNoTerminateDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view. Do not terminate the 	currently active process."	view resizeMinimumCenteredAt: aPoint.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!status: aSymbol	status := aSymbol! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status := #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 5/11/1999 22:05'!controlTerminate	status == #closed		ifTrue: 			[view ~~ nil ifTrue: [view release].			ScheduledControllers unschedule: self.			^self].	view deEmphasize; cacheBits.	view isCollapsed ifFalse: [model modelSleep].! !!StandardSystemController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:12'!getPluggableYellowButtonMenu: shiftKeyState	^ nil! !!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status := #inactive! !!StandardSystemController methodsFor: 'cursor'!labelHasCursor	"Answer true if the cursor is within the window's label"	^view labelContainsPoint: sensor cursorPoint! !!StandardSystemController commentStamp: '<historical>' prior: 0!I am a controller for StandardSystemViews, that is, those views that are at the top level of a project in the system user interface. I am a kind of MouseMenuController that creates a blue button menu for moving, framing, collapsing, and closing ScheduledViews, and for selecting views under the view of my instance.!!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu := SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemFontsTest methodsFor: 'utilities' stamp: 'bp 8/9/2009 19:57'!assert: selector familyName: aString pointSize: anInteger	| font |	font := Preferences perform: selector.	self assert: aString equals: font familyName.	self assert: anInteger equals: font pointSize! !!StandardSystemFontsTest methodsFor: 'testing' stamp: 'ar 7/13/2010 15:12'!testRestoreDefaultFonts	Preferences restoreFontsAfter: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardBalloonHelpFont familyName: 'Accujen' pointSize: 9.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'BitstreamVeraSansMono' pointSize: 9]! !!StandardSystemView methodsFor: 'displaying'!cacheBits	| oldLabelState |	CacheBits ifFalse: [^ self uncacheBits].	(oldLabelState := isLabelComplemented) ifTrue: [ self deEmphasize ].	self cacheBitsAsIs.	(isLabelComplemented := oldLabelState) ifTrue: [ self emphasize ].! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits := (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid := true.! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ true! !!StandardSystemView methodsFor: 'displaying'!deEmphasizeForDebugger	"Carefully de-emphasis this window because a debugger is being opened. Care must be taken to avoid invoking potentially buggy window display code that could cause a recursive chain of errors eventually resulting in a virtual machine crash. In particular, do not de-emphasize the subviews."	self deEmphasizeView.  "de-emphasize this top-level view"	self uncacheBits.	Smalltalk garbageCollectMost > 1000000 ifTrue: [		"if there is enough space, cache current window screen bits"		self cacheBitsAsIs].! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: false.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying'!display	isLabelComplemented		ifTrue: [self displayEmphasized]		ifFalse: [self displayDeEmphasized]! !!StandardSystemView methodsFor: 'displaying' stamp: 'hmm 7/21/1999 07:37'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	(bitsValid and: [controller ~~ ScheduledControllers activeController])		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [Display deferUpdates: true.				super display.				Display deferUpdates: false; forceToScreen: self windowBox.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self displayDeEmphasized; emphasize.	isLabelComplemented := true! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 5/15/1998 21:55'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 := self labelDisplayBox insetBy: 2.	r2 := r1 insetBy: 0@2.	r3 := r2 insetBy: 0@3.	c3 := self labelColor.	c2 := c3 dansDarker.	c1 := c2 dansDarker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes := Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelBoxes	"closeBox, growBox."	| aRect smallRect backColor |	aRect := self closeBoxFrame.	backColor := self labelColor.	Display fill: (aRect insetBy: -2) fillColor: backColor.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	aRect := self growBoxFrame.	smallRect := aRect origin extent: 7@7.	Display fill: (aRect insetBy: -2) fillColor: backColor.	aRect := aRect insetOriginBy: 2@2 cornerBy: 0@0.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	Display fillBlack: smallRect.	Display fill: (smallRect insetBy: 1) fillColor: backColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect := self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/29/97 18:57'!displayOn: aPort	bitsValid ifFalse:		[^ Display clippingTo: aPort clipRect do: [super display]].	windowBits displayOnPort: aPort at: self windowOrigin! !!StandardSystemView methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:40'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox := self labelDisplayBox.	top := labelDisplayBox top + 3.	bottom := labelDisplayBox bottom - 3.	stripes := Bitmap with: (Display pixelWordFor: self labelColor)			with: (Display pixelWordFor: Color black).	top even ifFalse: [stripes swap: 1 with: 2].	left := labelDisplayBox left + 3.	box := self closeBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self labelTextRegion.	right := box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self growBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	right := labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:14'!displayView	"Refer to the comment in View|displayView. "	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: true.	self displayLabelBoxes.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid := bitsValid.			bitsValid := false.			ScheduledControllers restore: self windowBox without: self.			bitsValid := oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 6/14/2000 17:27'!makeMeVisible        | newLoc portRect |        ((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))                containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].        "window not on screen (probably due to reframe) -- move it now"        newLoc := self isCollapsed                ifTrue: [RealEstateAgent assignCollapsePointFor: self]                ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].        portRect := newLoc + self labelOffset                                extent: self windowBox extent - self labelOffset.        self resizeTo: portRect.        self setLabelRegion.! !!StandardSystemView methodsFor: 'displaying'!uncacheBits	windowBits := nil.	bitsValid := false.! !!StandardSystemView methodsFor: 'displaying'!windowBits	^ windowBits! !!StandardSystemView methodsFor: 'framing' stamp: 'sr 3/26/2000 03:47'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm := Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown := Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset := self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt := (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown := true]							ifFalse: [beenDown not]].		^ pt].	^ (RealEstateAgent assignCollapseFrameFor: self) origin.! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm := bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid := false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f := self getFrame.			bitsValid := false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing' stamp: 'nice 12/26/2009 22:02'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset |	offset := Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | | p |					p := Sensor cursorPoint + offset.					p := (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | | p |					p := Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'ar 8/15/2009 14:57'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[model modelSleep.			expandedViewport := self viewport.			savedSubViews := subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid := false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport := self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame := self chooseFrame expandBy: borderWidth.			collapsedViewport := self viewport.			subViews := savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews := nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'framing'!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 8/15/97 17:18'!fullScreen	"Expand the receiver to fill the screen.  Let the model decide how big is full -- allows for flop-out scrollbar on left if desired"	self isCollapsed ifFalse:		[self reframeTo: model fullScreenSize]! !!StandardSystemView methodsFor: 'framing'!getFrame	"Ask the user to designate a rectangular area in which	the receiver should be displayed."	| minFrame |	minFrame := Cursor origin showWhile: 		[(Sensor cursorPoint extent: self minimumSize) newRectFrom:			[:f | Sensor cursorPoint extent: self minimumSize]].	self maximumSize <= self minimumSize ifTrue: [^ minFrame].	^ Cursor corner showWhile:		[minFrame newRectFrom:			[:f | self constrainFrame: (f origin corner: Sensor cursorPoint)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 1/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ model initialExtent min: maximumSize max: minimumSize! !!StandardSystemView methodsFor: 'framing' stamp: 'RAA 6/14/2000 17:27'!initialFrame        "Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"        ^ RealEstateAgent initialFrameFor: self world: nil! !!StandardSystemView methodsFor: 'framing'!moved	"The user has moved the receiver; after a new view rectangle is chosen, this method is called to allow certain views to take note of the change.  6/10/96 sw" ! !!StandardSystemView methodsFor: 'framing'!newFrame: frameChangeBlock	self reframeTo: (self windowBox newRectFrom:		[:f | self constrainFrame: (frameChangeBlock value: f)])! !!StandardSystemView methodsFor: 'framing' stamp: 'nice 12/26/2009 22:03'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| delta newRect minDim theMin |	newRect := aDisplayBox.	theMin := 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim := ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta := minDim - theMin.		newRect := newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[| newBox |			newBox := sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport := nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'BG 12/4/2003 13:14'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox := self windowBox.	portRect := newFrame topLeft + self labelOffset				corner: newFrame corner.	self setWindow: nil.	self resizeTo: portRect.	self setLabelRegion.	newBox := self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f := self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing'!resizeInitially	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	self resizeTo: self initialFrame! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!resizeMinimumCenteredAt: aPoint 	"Determine the rectangular area for the receiver, adjusted so that it is 	centered a position, aPoint."	| aRectangle |	aRectangle := 0 @ 0 extent: self minimumSize.	aRectangle := aRectangle align: aRectangle center with: aPoint.	self resizeTo: aRectangle! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:29'!resizeTo: aRectangle	"Resize this view to aRectangle"	"First get scaling right inside borders"	self window: (self window insetBy: borderWidth)		viewport: (aRectangle insetBy: borderWidth).	"Then ensure window maps to aRectangle"	window := transformation applyInverseTo: aRectangle! !!StandardSystemView methodsFor: 'framing'!standardWindowOffset	^ Preferences standardWindowOffset! !!StandardSystemView methodsFor: 'framing'!windowBox	^ self displayBox merge: self labelDisplayBox! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/3/97 14:19'!windowOrigin	^ (self isCollapsed or: [labelFrame height = 0  "no label"])		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'clipping box access'!clippingBox	"Answer the rectangular area in which the receiver can show its label."	^self isTopView		ifTrue: [self labelDisplayBox]		ifFalse: [super insetDisplayBox]! !!StandardSystemView methodsFor: 'clipping box access' stamp: 'BG 12/5/2003 11:13'!constrainFrame: aRectangle	"Constrain aRectangle, to the minimum and maximum size	for this window"   | adjustmentForLabel |   adjustmentForLabel := 0 @ (labelFrame height  - labelFrame borderWidth).	^ aRectangle origin extent:		((aRectangle extent max: minimumSize + adjustmentForLabel)		      min: maximumSize + adjustmentForLabel).! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:30'!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:29'!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access'!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]! !!StandardSystemView methodsFor: 'label access' stamp: 'jmv 8/6/2009 08:55'!label: aString 	"Set aString to be the receiver's label."	labelText := Paragraph			withText: (Text fromString: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString]))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access'!labelColor	"Answer the color to use as the background for the receiver's label.  By default, this is the same as the background color of the window, but need not be.  7/16/96 sw"	^ self backgroundColor! !!StandardSystemView methodsFor: 'label access'!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin! !!StandardSystemView methodsFor: 'label access'!labelFrame	^labelFrame! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:47'!labelHeight	^ ((LabelStyle fontAt: 1) height + 4) max: 20! !!StandardSystemView methodsFor: 'label access'!labelOffset	^ 0 @ (self labelHeight-2)! !!StandardSystemView methodsFor: 'label access' stamp: 'sr 3/26/2000 04:26'!labelText	^labelText! !!StandardSystemView methodsFor: 'label access'!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 14:20'!noLabel	"A label of zero height indicates no label"	labelFrame height > 0		ifTrue: [labelFrame region: (labelFrame bottomLeft + (0@1) extent: labelFrame width@0).				labelFrame borderWidth: 0.				self uncacheBits]! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 1/19/2001 20:13'!setLabel: aLabel	"For compatibility with morphic"	self relabel: aLabel! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 13:35'!setLabelRegion	"Always follows view width"	labelFrame region: (0 @ 0 extent: self displayBox width @ self labelHeight).	labelFrame borderWidth: 2! !!StandardSystemView methodsFor: 'label access' stamp: 'sumim 2/8/2002 14:36'!setLabelTo: aString 	"Force aString to be the new label of the receiver, bypassing any logic about whether it is acceptable and about propagating information about the change."	| oldRegion oldWidth |	self label: aString.	self controller isControlActive ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized]! !!StandardSystemView methodsFor: 'testing'!containsPoint: aPoint 	"Refer to the comment in View|containsPoint:."	^(super containsPoint: aPoint) | (self labelContainsPoint: aPoint)! !!StandardSystemView methodsFor: 'testing'!isCollapsed	"Answer whether the receiver is collapsed (true) or expanded (false)."	^savedSubViews ~~ nil! !!StandardSystemView methodsFor: 'testing' stamp: 'ar 8/15/2009 15:05'!isWindowForModel: aModel	"Return true if the receiver acts as the window for the given model"	^aModel == self model! !!StandardSystemView methodsFor: 'testing'!labelContainsPoint: aPoint 	"Answer TRUE if aPoint is in the label box."	^self labelDisplayBox containsPoint: aPoint! !!StandardSystemView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		updatablePanes ifNil: [updatablePanes := #()].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented := false]! !!StandardSystemView methodsFor: 'deEmphasizing'!emphasizeView 	"Refer to the comment in View|emphasizeView."	self emphasizeLabel! !!StandardSystemView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StandardSystemController! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'sw 10/29/1999 12:58'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame := Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented := false.	minimumSize := 50 @ 50.	maximumSize := Display extent.	collapsedViewport := nil.	expandedViewport := nil.	bitsValid := false.	updatablePanes := #()! !!StandardSystemView methodsFor: 'initialize-release'!model: aModel	"Set the receiver's model.  For a Standard System View, we also at this time get the default background color set up.  7/30/96 sw"	super model: aModel.	self setDefaultBackgroundColor! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'size'!maximumSize	"Answer a point representing the maximum width and height of the 	receiver."	^maximumSize! !!StandardSystemView methodsFor: 'size'!maximumSize: aPoint 	"Set the argument, aPoint, to be the maximum width and height of the 	receiver."	maximumSize := aPoint! !!StandardSystemView methodsFor: 'size'!minimumSize	"Answer a point representing the minimum width and height of the 	receiver."	^minimumSize! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the 	receiver."	minimumSize := aPoint! !!StandardSystemView methodsFor: 'private'!setTransformation: aTransformation 	"Override to support label size changes "	super setTransformation: aTransformation.	self label: self label! !!StandardSystemView methodsFor: 'private' stamp: 'nice 12/26/2009 22:04'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen |	theLen := 0.	subViews do:		[:sub |		| box |		box := sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub := sub.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView methodsFor: 'updating' stamp: 'nice 12/26/2009 22:04'!setUpdatablePanesFrom: getSelectors	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	| aList |	aList := OrderedCollection new.	getSelectors do:		[:sel | 			| aPane |			aPane := self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes := aList asArray! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:20'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message upon window activation or expansion."	^ updatablePanes ifNil: [updatablePanes := #()]! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 1/11/2000 15:30'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self setLabelTo: model labelString].	^ super update: aSymbol! !!StandardSystemView commentStamp: '<historical>' prior: 0!I represent a view that has a label above its top left corner. The text in the label identifies the kind of view. In addition to a label, I add control over the maximum and minimum size of the display box of my instance. My default controller is StandardSystemController. The elements of ScheduledControllers, the sole instance of ControlManager, are usually controllers for instances of me.!!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'dtl 2/14/2010 13:08'!doCacheBits	"StandardSystemView doCacheBits - Enable fast window repaint feature"	CacheBits := true.	ScheduledControllers ifNotNilDo: [:sc | sc unCacheWindows; restore]! !!StandardSystemView class methodsFor: 'class initialization'!dontCacheBits	"StandardSystemView dontCacheBits - Disable fast window repaint feature.	Return true iff bits were cached, ie if space was been recovered"	CacheBits ifFalse: [^ false].	CacheBits := false.	ScheduledControllers unCacheWindows.	^ true! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 23:42'!initialize		"StandardSystemView initialize"	self doCacheBits.	self setLabelStyle! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:26'!setLabelStyle	| aFont |	"StandardSystemView setLabelStyle"	aFont := Preferences windowTitleFont.	LabelStyle := TextStyle fontArray: { aFont }.	LabelStyle gridForFont: 1 withLead: 0! !!StickynessBugz methodsFor: 'as yet unclassified' stamp: 'wiz 7/28/2007 18:54'!testForTiltedStickyness"self new testForTiltedStickyness""self run: #testForTiltedStickyness"| m |m := RectangleMorph new openCenteredInWorld .cases := Array with: m . "save for tear down."self assert: ( m topRendererOrSelf isSticky not ) .m beSticky .self assert: ( m topRendererOrSelf isSticky ) .m addFlexShell .cases := Array with: m topRendererOrSelf .m topRendererOrSelf rotationDegrees: 45.0 .self assert: ( m topRendererOrSelf isSticky ) .m beUnsticky .self assert: ( m topRendererOrSelf isSticky not ) .m topRendererOrSelf delete.^true ! !!StickynessBugz commentStamp: 'wiz 11/24/2006 00:24' prior: 0!A StickynessBugz is for mantis #5500 rectangles and ellipses don't act sticky when rotated even when they are..Instance Variables!!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 22:49'!classToBeTested	^ Stopwatch! !!StopwatchTest methodsFor: 'Coverage' stamp: 'brp 9/24/2003 23:01'!selectorsToBeIgnored	| private | 	private := #( #printOn: #state: ).	^ super selectorsToBeIgnored, private! !!StopwatchTest methodsFor: 'running' stamp: 'brp 1/21/2004 18:49'!setUp	aStopwatch := Stopwatch new.	aDelay := Delay forMilliseconds: 1.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:45'!testActive	| sw |	sw := Stopwatch new.	sw activate.		1 seconds asDelay wait.	self 		assert: (sw duration >= 1 seconds).	2 seconds asDelay wait.	self 		assert: (sw duration >= 3 seconds).	sw suspend.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/24/2003 22:56'!testNew	| sw |	sw := Stopwatch new.		self 		assert: (sw isSuspended);		assert: (sw state = #suspended);		deny: (sw isActive);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 12:02'!testReActivate	| sw |	sw := Stopwatch new.	sw 		activate;		suspend;		reActivate.		self 		assert: (sw isActive).! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:56'!testReset	| sw |	sw := Stopwatch new.	sw activate.		sw reset.	self 		assert: (sw isSuspended);		assert: (sw timespans isEmpty)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/26/2004 19:36'!testStartStop	| sw t1 t2 t3 t4 |	sw := Stopwatch new.	t1 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw activate; activate.	(Delay forMilliseconds: 10) wait.	t2 := DateAndTime now.		self 		deny: (sw isSuspended);		assert: (sw isActive);		assert: (sw timespans size = 1);		assert: (t1 <= sw start);		assert: (sw start <= t2).	(Delay forMilliseconds: 10) wait.	t3 := DateAndTime now.	(Delay forMilliseconds: 10) wait.	sw suspend; suspend.	(Delay forMilliseconds: 10) wait.	t4 := DateAndTime now.	self 		assert: (sw isSuspended);		deny: (sw isActive);		assert: (sw timespans size = 1);		assert: (sw end between: t3 and: t4);		assert: (t3 <= sw end);		assert: (sw end <= t4).! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testChangingStatus	aStopwatch activate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 1.	aStopwatch suspend.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 1.	aStopwatch activate.	aStopwatch reActivate.	self assert: aStopwatch isActive.	self assert: aStopwatch timespans size = 3.	aStopwatch reset.	self assert: aStopwatch isSuspended.	self assert: aStopwatch timespans size = 0.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testInitialStatus	self assert: aStopwatch isSuspended.	self deny: aStopwatch isActive.	self assert: aStopwatch duration = 0 seconds! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:32'!testMultipleTimings	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 2. 	self assert: aStopwatch timespans first asDateAndTime <= 					aStopwatch timespans last asDateAndTime.! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:49'!testPrintOn	| cs rw |	cs := ReadStream on: 'a Stopwatch(suspended:0:00:00:00)'.	rw := ReadWriteStream on: ''.	aStopwatch printOn: rw.	self assert: rw contents = cs contents! !!StopwatchTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:32'!testSingleTiming	| timeBefore |	timeBefore := DateAndTime now.	aStopwatch activate.	aDelay wait.	aStopwatch suspend.	self assert: aStopwatch timespans size = 1. 	self assert: aStopwatch timespans first asDateAndTime >= timeBefore. 	self assert: aStopwatch timespans first asDateAndTime <= aStopwatch end.! !!Stream methodsFor: 'accessing' stamp: 'nk 2/24/2001 17:31'!contents	"Answer all of the contents of the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:07'!next	"Answer the next object accessible by the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing' stamp: 'jcg 4/24/2007 14:13'!printContentsOn: stream	stream space.	self contents printOn: stream.! !!Stream methodsFor: 'accessing' stamp: 'jcg 4/24/2007 14:12'!printOn: stream	super printOn: stream.	self printContentsOn: stream.! !!Stream methodsFor: 'testing' stamp: 'bgf 10/10/2008 23:56'!name	"Avoid Object printString: , which is a silly way to label a stream.	 Since the ZipArchive unpacker (for example) uses  stream name	 to get a filename or filename substitute when run on a data stream,	 avoiding the self-print can help performance.	 (N.b. FileStream overrides this to provide the fileName)."	^ 'a stream'! !!StreamBugz methodsFor: 'as yet unclassified' stamp: 'ar 8/5/2003 02:25'!testReadWriteStreamNextNBug	| aStream |	aStream := ReadWriteStream on: String new.	aStream nextPutAll: 'Hello World'.	self shouldnt:[aStream next: 5] raise: Error.! !!StreamingMP3Sound methodsFor: 'file ops' stamp: 'jm 11/25/2001 14:11'!closeFile	"Close the MP3 or MPEG file."	self pause.	mpegFile ifNil: [^ self].	mpegFile closeFile.	mpegFile := nil.	mixer := nil.! !!StreamingMP3Sound methodsFor: 'file ops' stamp: 'jm 11/16/2001 15:58'!mpegFileIsOpen	"Answer true if I have an open, valid MPEG file handle. If the handle is not valid, try to re-open the file."	mpegFile ifNil: [^ false].	mpegFile fileHandle ifNil: [		"try to reopen the file, which may have been saved in a snapshot"		mpegFile openFile: mpegFile fileName.		mpegFile fileHandle ifNil: [mpegFile := nil]].	^ mpegFile notNil! !!StreamingMP3Sound methodsFor: 'private' stamp: 'jm 11/16/2001 15:59'!createMixer	"Create a mixed sound consisting of sampled sounds with one sound buffer's worth of samples. The sound has the same sampling rate and number of channels as the MPEG or MP3 file."	| channels pan snd |	mpegFile ifNil: [^ self error: 'No MPEG or MP3 file'].	channels := mpegFile audioChannels: mpegStreamIndex.	streamSamplingRate := mpegFile audioSampleRate: mpegStreamIndex.	mixer := MixedSound new.	1 to: channels do: [:c |		channels = 1			ifTrue: [pan := 0.5]			ifFalse: [pan := (c - 1) asFloat / (channels - 1)].		snd := SampledSound			samples: (SoundBuffer newMonoSampleCount: 2)  "buffer size will be adjusted dynamically"			samplingRate: streamSamplingRate.		mixer add: snd pan: pan volume: volume].! !!StreamingMP3Sound methodsFor: 'private' stamp: 'crl 1/23/2003 14:26'!loadBuffersForSampleCount: count        "Load the sound buffers for all tracks with the next countsamples from the MPEGfile sound track."        | snd buf |        1 to: mixer sounds size do: [:i |                snd := mixer sounds at: i.                buf := snd samples.                buf monoSampleCount = count ifFalse: [                        buf := SoundBuffer newMonoSampleCount: count.                        snd setSamples: buf samplingRate:streamSamplingRate].                i = 1 ifTrue: [  "first channel"                                mpegFile                                        audioReadBuffer: buf                                        stream: mpegStreamIndex                                        channel: 0]                        ifFalse: [  "all other channels"                                mpegFile                                        audioReReadBuffer: buf                                        stream: mpegStreamIndex                                        channel: 1]].        mixer reset.! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:16'!duration	"Answer the duration of this sound in seconds."	^ totalSamples asFloat / streamSamplingRate! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 6/3/2001 15:43'!repeat	"Answer the repeat flag."	repeat ifNil: [repeat := false].	^ repeat! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 6/3/2001 18:39'!repeat: aBoolean	"Set the repeat flag. If true, this sound will loop back to the beginning when it gets to the end."	repeat := aBoolean.! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:18'!soundPosition	"Answer the relative position of sound playback as a number between 0.0 and 1.0."	self mpegFileIsOpen ifFalse: [^ 0.0].	mpegFile hasAudio ifFalse: [^ 0.0].	^ (mpegFile audioGetSample: 0) asFloat / totalSamples! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:19'!soundPosition: fraction	"Jump to the position the given fraction through the sound file. The argument is a number between 0.0 and 1.0."	| sampleIndex |	self mpegFileIsOpen ifFalse: [^ self].	mpegFile hasAudio ifTrue: [		sampleIndex := ((totalSamples * fraction) truncated max: 0) min: totalSamples.		mpegFile audioSetSample: 0 stream: 0.  "work around for library bug: first seek to zero"		mpegFile audioSetSample: sampleIndex stream: 0].! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 15:34'!streamSamplingRate	"Answer the sampling rate of the MP3 stream."	^ streamSamplingRate! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 9/26/2000 07:49'!volume	"Answer my volume."	^ volume! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 5/30/2001 16:53'!volume: aNumber	"Set my volume to the given number between 0.0 and 1.0."	volume := aNumber.	self createMixer.! !!StreamingMP3Sound methodsFor: 'initialization' stamp: 'jm 11/27/2001 10:06'!initMPEGFile: anMPEGFile streamIndex: anInteger	"Initialize for playing the given stream of the given MPEG or MP3 file."	volume := 0.3.	repeat := false.	mpegFile := anMPEGFile.	mpegStreamIndex := anInteger.	totalSamples := mpegFile audioSamples: mpegStreamIndex.	self reset.! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:16'!millisecondsSinceStart	"Answer the number of milliseconds since this sound started playing."	| i mSecs |	mpegFile ifNil: [^ 0].	mpegFile fileHandle ifNil: [^ 0].  "mpeg file not open"	i := mpegFile audioGetSample: mpegStreamIndex.	i < 0 ifTrue: [^ 0].  "movie file has no audio"	mSecs := i * 1000 // streamSamplingRate.	(self isPlaying and: [lastBufferMSecs > 0]) ifTrue: [		"adjust mSecs by the milliseconds since the last buffer"		mutex critical: [			mSecs := i * 1000 // streamSamplingRate.			mSecs := mSecs + ((Time millisecondClockValue - lastBufferMSecs) max: 0)]].	^ mSecs + 350 - (2 * SoundPlayer bufferMSecs)! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:09'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index"	| current |	self repeat ifTrue: [  "loop if necessary"		current := mpegFile audioGetSample: mpegStreamIndex.		(totalSamples - current) < n ifTrue: [			mpegFile audioSetSample: 0 stream: mpegStreamIndex]].	mutex critical: [		lastBufferMSecs := Time millisecondClockValue.		self loadBuffersForSampleCount: (n * streamSamplingRate) // SoundPlayer samplingRate.		mixer playSampleCount: n into: aSoundBuffer startingAt: startIndex].! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:06'!reset	super reset.	self createMixer.	mpegFile audioSetSample: 0 stream: mpegStreamIndex.	lastBufferMSecs := 0.	mutex := Semaphore forMutualExclusion.! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/16/2001 15:59'!samplesRemaining	| samplesPlayed |	mpegFile ifNil: [^ 0].	self repeat ifTrue: [^ 1000000].	samplesPlayed := mpegFile audioGetSample: mpegStreamIndex.	samplesPlayed > totalSamples ifTrue: [^ 0].	^ totalSamples - samplesPlayed! !!StreamingMP3Sound methodsFor: 'converting' stamp: 'jm 12/13/2001 20:32'!saveAsFileNamed: newFileName compressionType: compressionTypeString	"Store this MP3 sound in a SunAudio file with the given name using the given compression type."	| outFile |	outFile := (FileStream newFileNamed: newFileName) binary.	self storeSunAudioOn: outFile compressionType: compressionTypeString.	outFile close.! !!StreamingMP3Sound methodsFor: 'converting' stamp: 'jm 12/14/2001 12:39'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame codec inBuf compressed outSamplingRate audioWriter samplesRemaining outBuf counts byteCount |	self pause; reset.  "stop playing and return to beginning"	fmt := SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize := 64000.	samplesPerFrame := 1.	codec := SunAudioFileWriter codecForFormatCode: fmt.	codec ifNotNil: [		samplesPerFrame := codec samplesPerFrame.		inBufSize := inBufSize roundUpTo: (2 * samplesPerFrame).		compressed := ByteArray new:			(inBufSize // samplesPerFrame) * codec bytesPerEncodedFrame].	inBuf := SoundBuffer newMonoSampleCount: inBufSize.	outSamplingRate := streamSamplingRate.	streamSamplingRate > 22050 ifTrue: [		streamSamplingRate = 44100 ifFalse: [self error: 'unexpected MP3 sampling rate'].		outSamplingRate := 22050].	"write audio header"	audioWriter := SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: totalSamples during: [:bar |			samplesRemaining := totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				samplesRemaining < inBuf monoSampleCount ifTrue: [					inBuf := SoundBuffer newMonoSampleCount:						(samplesRemaining roundUpTo: 2 * samplesPerFrame)].				mpegFile audioReadBuffer: inBuf stream: 0 channel: 0.				outSamplingRate < streamSamplingRate					ifTrue: [outBuf := inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf := inBuf].				codec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts := codec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount := counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining := samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!StreamingMP3Sound commentStamp: '<historical>' prior: 0!I implement a streaming player for MPEG or MP3 files.Example of use:	(StreamingMP3Sound onFileNamed: 'song.mp3') play.!!StreamingMP3Sound class methodsFor: 'instance creation' stamp: 'jm 11/20/2001 16:35'!onFileNamed: fileName	"Answer an instance of me for playing the sound track of the MPEG or MP3 file with the given name. Answer nil the file is not a valid MPEG or MP3 file."	| mpegFile |	(MPEGFile isFileValidMPEG: fileName) ifFalse: [^ nil].	mpegFile := MPEGFile openFile: fileName.	^ self new initMPEGFile: mpegFile streamIndex: 0  "assume sound track is in stream 0"! !!StrikeFont methodsFor: 'accessing' stamp: 'bf 2/26/2007 12:39'!derivativeFonts	derivativeFonts ifNil: [^#()].	^derivativeFonts copyWithout: nil! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 9/2/2010 09:54'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| leftX rightX glyphInfo char destY form gfont destX destPt |	destX := aPoint x.	charIndex := startIndex.	glyphInfo := Array new: 5.	startIndex to: stopIndex do:[:charIndex|		char := aString at: charIndex.		(self hasGlyphOf: char) ifTrue: [			self glyphInfoOf: char into: glyphInfo.			form := glyphInfo at: 1.			leftX := glyphInfo at: 2.			rightX := glyphInfo at: 3.			destY := glyphInfo at: 4.			gfont := glyphInfo at: 5.			(gfont == aBitBlt lastFont) ifFalse: [gfont installOn: aBitBlt].			destY := baselineY - destY. 			aBitBlt displayGlyph: form at: destX @ destY left: leftX right: rightX font: self.			destX := destX + (rightX - leftX + kernDelta).		] ifFalse:[			destPt := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: charIndex at: destX @ aPoint y kern: kernDelta baselineY: baselineY.			destPt x = destX ifTrue:[				"In some situations BitBlt doesn't return the advance width from the primitive.				Work around the situation"				destX := destX + (self widthOfString: aString from: charIndex to: charIndex) + kernDelta.			] ifFalse:[destX := destPt x].		].	].	^destX @ aPoint y! !!StrikeFont methodsFor: 'displaying' stamp: 'dvd 4/15/2009 14:55'!postAdjustFor: aCharacter	"Return the amount of advance for aCharacter."	^self widthOf: aCharacter! !!StrikeFont methodsFor: 'displaying' stamp: 'dvd 4/15/2009 14:50'!preAdjustFor: aCharacter	"Return the amount of underhang for aCharacter. StrikeFont glyphs have none."	^0! !!StrikeFont class methodsFor: 'font creation' stamp: 'ar 5/21/2011 12:08'!installDejaVu	"Warning: Uses the methods in 'dejaVu font data' category, that will be removed soon (or are already removed) to save space.""StrikeFont installDejaVu"	(TextConstants includesKey: 'Bitmap DejaVu Sans') ifTrue:[^self].	TextConstants at: 'Bitmap DejaVu Sans' put: (TextStyle fontArray: 		(Array			with: (self createDejaVu: 7)			with: (self createDejaVu: 9)			with: (self createDejaVu: 12))).	Preferences restoreDefaultFonts.	StrikeFont limitTo16Bits.	StrikeFont useUnderscoreIfOver1bpp.! !!String methodsFor: 'comparing' stamp: 'eem 5/22/2008 13:54'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString isString ifFalse:		[aString isText ifTrue: [^self = aString string].		 ^false].	^self hasEqualElements: aString! !!String methodsFor: 'converting' stamp: 'jcg 3/26/2010 16:22'!asBoolean	self = 'true' ifTrue: [^true].	self = 'false' ifTrue: [^false].	"Better than a regular #error, dontcha think?"	NonBooleanReceiver new 		object: self;		signal: 'String does not represent a Boolean'! !!String methodsFor: 'converting' stamp: 'ar 12/31/2007 10:53'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	^FileDirectory checkName: self fixErrors: true.! !!String methodsFor: 'converting' stamp: 'ar 4/7/2009 16:25'!asOctetString	"Attempt to normalize the receiver as an octet (byte) string.	Will return a ByteString only if the receiver can be represented as such."	| string |	string := ByteString new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!String methodsFor: 'converting' stamp: 'ar 12/31/2007 10:57'!asVmPathName	"Convert the receiver from Squeak to the VM encoding used for files"	^self squeakToUtf8! !!String methodsFor: 'converting' stamp: 'jjl 12/23/2008 12:06'!unquoted	"If the receiver starts with ' or "" and ends with matching ' or "", strip them"	| curr |	curr := self.	((curr first = $') and: [curr last = $']) ifTrue:[		curr := curr copyFrom: 2 to: (curr size - 1)	] ifFalse:[		((curr first = $") and: [curr last = $"]) ifTrue:[			curr := curr copyFrom: 2 to: (curr size - 1)		].	].	^ curr		! !!String methodsFor: 'converting' stamp: 'ar 7/15/2010 17:18'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineStop lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				lineStop := (lineStart + aNumber - 1) min: endWithoutDelimiters.				[spacePosition <= lineStop] whileTrue:[					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [endWithoutDelimiters+1].					spacePosition <= (lineStop+1) ifTrue:[lineEnd := spacePosition].				].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !!String methodsFor: 'converting' stamp: 'bgf 7/10/2009 23:25'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| i |	i := self size.	[i > 0] whileTrue: [ 		((self at: i) isDigit or: [ (self at: i) = $ ]) ifFalse: [			^ self copyFrom: 1 to: i		].		i := i - 1.	].	^ ''	"'Whoopie234' withoutTrailingDigits'Lucida Grande 15' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'copying' stamp: 'bgf 3/7/2009 17:08'!copy	"Clone, done directly"	<primitive: 148>	self primitiveFailed! !!String methodsFor: 'internet' stamp: 'ar 6/22/2010 12:08'!unescapeHtmlEntities	"Unescape HTML entities of the form &euro; or &#34;"	| entityEnd entityStart entity |	entityEnd := 0.	entityStart := self indexOf: $& startingAt: 1 ifAbsent:[^self].	^String new: self size streamContents:[:s|		["Copy last chunk between (previoues) entityEnd and (next) entityStart"		s nextPutAll: (self copyFrom: entityEnd+1 to: entityStart-1).		entityEnd := self indexOf: $; startingAt: entityStart ifAbsent:[			"Malformed input. Copy all the remaining contents."			s nextPutAll: (self copyFrom: entityStart to: self size).			self size+1.		].		entity := self copyFrom: entityStart+1 to: entityEnd-1.		entity first = $# 			ifTrue:[entity := Character value: entity allButFirst asNumber]			ifFalse:[entity := HtmlEntities at: entity ifAbsent:['?']].		s nextPut: entity.		entityStart := self indexOf: $& startingAt: entityEnd.		entityStart = 0] whileFalse.		s nextPutAll: (self copyFrom: entityEnd+1 to: self size).	].! !!String methodsFor: 'private' stamp: 'bgf 12/10/2009 20:39'!compValue: char from: matchTable	"Private to String findSubstring.	 Return the value to use for comparing the given character in a substring-match.	 Safe for widestrings where a single 'asciivalue' may often be > 255."	| v |	char leadingChar = 0 ifFalse: [ ^ char asciiValue + 1 ].	v := char asciiValue + 1.	^ v > (matchTable size) ifTrue: [ v ] ifFalse: [ matchTable at: v ]! !!String methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment		| leadingChar |	leadingChar := languageEnvironment leadingChar.	self withIndexDo: [:each :idx |		each asciiValue > 255			ifTrue: [self at: idx put: (Character leadingChar: leadingChar code: each asUnicode)]]! !!String methodsFor: '*ST80-Support' stamp: 'yo 11/3/2004 19:24'!asParagraph	"Answer a Paragraph whose text string is the receiver."	^Paragraph withText: self asText! !!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!!String class methodsFor: 'as yet unclassified' stamp: 'bgf 3/7/2009 17:52'!howToPassAsArgument	"Strings are cloneable.	 We inherit passByCopy, and its tricks already get us to the same behavior,	 but I'm leaving this here so someone later doesn't wonder about it."	^ #passByClone:! !!StringHolder methodsFor: '*Tools' stamp: 'eem 11/9/2009 09:47'!browseLocalSenders	self selectedClass ifNotNil:		[:cls| | token |		token := UIManager default request: 'browse for selector or literal'.		token isEmpty ifTrue: [^self].		Scanner new			typedScan: token			do: [:scannedToken :tokenType|				token := tokenType = #word							ifTrue:								[(Symbol findInterned: scannedToken)									ifNil: [^UIManager default  inform: 'no such selector: ', scannedToken]									ifNotNil: [:symbol| symbol]]							ifFalse:								[scannedToken].				self systemNavigation browseAllCallsOn: token localTo: cls]]! !!StringHolder methodsFor: '*Tools' stamp: 'rr 3/15/2004 09:17'!codeTextMorph	^ self dependents		detect: [:dep | (dep isKindOf: PluggableTextMorph)				and: [dep getTextSelector == #contents]]		ifNone: []! !!StringHolder methodsFor: '*Tools' stamp: 'eem 12/15/2008 12:05'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| litGetter selector method messages |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^aBlock value: selector])				compiledMethodAt: selector				ifAbsent: [].	method isNil ifTrue: [^aBlock value: selector].	messages := Preferences thoroughSenders					ifTrue:						[litGetter := [:set :l|										(l isSymbol and: [l size > 0 and: [l first isLowercase]]) ifTrue:											[set add: l].										l isArray ifTrue:											[l inject: set into: litGetter copy].										set].						method allLiterals						, (method pragmas collect: [:pragma| pragma keyword])							inject: method messages into: litGetter copy]					ifFalse: [method messages].	messages isEmpty ifTrue: [^aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	self systemNavigation 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53'!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:53'!accept 	"Refer to the comment in ParagraphEditor|accept."	super accept.	model contents: paragraph string.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:54'!cancel 	"Refer to the comment in ParagraphEditor|cancel."	super cancel.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:14'!performMenuMessage: aSelector	"Intercept #again so the model does not get locked by keying the search text."	| hadEdits |	hadEdits := view canDiscardEdits not.	super performMenuMessage: aSelector.	(hadEdits not and:	 [aSelector == #again and:	 [(UndoMessage sends: #undoAgain:andReselect:typedKey:) and:	 [UndoMessage arguments at: 3]]])		ifTrue: [self userHasNotEdited].! !!StringHolderController methodsFor: 'compiler access'!bindingOf: aString	^model bindingOf: aString! !!StringHolderController methodsFor: 'accessing' stamp: 'di 6/21/2001 10:32'!changeText: aText	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self selectAndScroll.	self deselect! !!StringHolderController methodsFor: 'accessing'!model: aModel	super model: aModel.	view displayContents == nil		ifFalse: [self changeParagraph: view displayContents]! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:43'!closeTypeIn	"Note edit if something actually was typed."	beginTypeInBlock ~~ nil ifTrue: [self userHasEdited].	super closeTypeIn.! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:45'!zapSelectionWith: aText	"Note edit except during typeIn, which notes edits at close."	super zapSelectionWith: aText.	beginTypeInBlock == nil ifTrue: [self userHasEdited].! !!StringHolderController methodsFor: 'edit flag' stamp: 'di 10/9/1998 15:41'!hasUnacceptedEdits: aBoolean	^ view hasUnacceptedEdits: aBoolean! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:09'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:08'!userHasNotEdited	"Note that my text is free of user edits."	model clearUserEditFlag! !!StringHolderController commentStamp: '<historical>' prior: 0!I represent a ParagraphEditor for a single paragraph of text, omitting alignment commands. I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.	doIt	evaluate the text selection as an expression	printIt	same as doIt but insert a description of the result after the selection	accept	store the contents of the StringHolder into the model	cancel	store the contents of the model into the StringHolder!!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 14:38'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 17:49'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 17:17'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	hasUnacceptedEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'dgd 9/21/2003 17:42'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated) ifTrue: [model clearUserEditFlag].		^ self].	stripes := (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel := self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView methodsFor: 'updating' stamp: 'di 4/21/1998 11:30'!update: aSymbol	"Refer to the comment in View|update:."	aSymbol == #wantToChange ifTrue: [^ self promptForCancel].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #flash ifTrue: [^ controller flash].	self updateDisplayContents! !!StringHolderView methodsFor: 'updating'!updateDisplayContents	"Make the text that is displayed be the contents of the receiver's model."	self editString: model contents.	self displayView! !!StringHolderView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	(self controller isKindOf: ParagraphEditor)	 	ifTrue: [controller deselect]! !!StringHolderView methodsFor: 'controller access'!defaultController 	"Refer to the comment in View|defaultController."	^self defaultControllerClass newParagraph: displayContents! !!StringHolderView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StringHolderController! !!StringHolderView methodsFor: 'controller access'!displayContents	^displayContents! !!StringHolderView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super display! !!StringHolderView methodsFor: 'displaying' stamp: 'hmm 6/18/2000 19:24'!displayView 	"Refer to the comment in View|displayView."	Display deferUpdatesIn: self displayBox while: [		self clearInside.		(self controller isKindOf: ParagraphEditor)			ifTrue: [controller display]			ifFalse: [displayContents display]]! !!StringHolderView methodsFor: 'displaying'!lock	"Refer to the comment in view|lock.  Must do at least what display would do to lock the view."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super lock! !!StringHolderView methodsFor: 'displaying'!positionDisplayContents	"Presumably the text being displayed changed so that the wrapping box 	and clipping box should be reset."	displayContents 		wrappingBox: (self insetDisplayBox insetBy: 6 @ 0)		clippingBox: self insetDisplayBox! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents := Paragraph withText: aString asText		style: TextStyle default copy		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)		clippingRectangle: self insetDisplayBox		foreColor: self foregroundColor backColor: self backgroundColor.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!StringHolderView methodsFor: 'model access' stamp: 'sma 5/28/2000 23:25'!getMenu: shiftKeyState	^ nil! !!StringHolderView methodsFor: 'model access'!model: aLockedModel 	"Refer to the comment in View|model:." 	super model: aLockedModel.	self editString: model contents! !!StringHolderView methodsFor: 'initialize-release' stamp: 'jm 3/24/98 14:39'!initialize 	"Refer to the comment in View|initialize."	super initialize.	displayContents := '' asParagraph.	hasUnacceptedEdits := false.	askBeforeDiscardingEdits := true.! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:53'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [displayContents text]! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:55'!unacceptedEditState: stateOrNil	(hasUnacceptedEdits := stateOrNil notNil) ifTrue:		[self editString: stateOrNil]! !!StringHolderView commentStamp: '<historical>' prior: 0!I am a View of a String that is an aspect of a more structured object. This String should not be changed by any editing unless the user issues the accept command. Thus my instances provide a working copy of the String. This copy is edited. When the user issues the accept command, the String is copied from the working version; or if the user issues the cancel command, the working version is restored from the String. StringHolderController is my default controller. It is initialized specially by passing the string viewed which is then converted to a Paragraph for editing.!!StringHolderView class methodsFor: 'instance creation'!container	"Answer an instance of me with a new instance of StringHolder as the 	model."	^self container: StringHolder new! !!StringHolderView class methodsFor: 'instance creation'!container: aContainer 	"Answer an instance of me whose model is aContainer. Give it a 2-dot 	border."	| aCodeView |	aCodeView := self new model: aContainer.	aCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^aCodeView! !!StringHolderView class methodsFor: 'instance creation' stamp: 'ar 9/27/2005 20:48'!open	"Create a standard system view of a workspace on the screen."	self open: StringHolder new label: 'Workspace'! !!StringHolderView class methodsFor: 'instance creation'!open: aStringHolder 	"Create a standard system view of the argument, aStringHolder, as viewed 	by an instance of me. The view has label 'StringHolder'."	self open: aStringHolder label: 'StringHolder'! !!StringHolderView class methodsFor: 'instance creation' stamp: 'ar 8/7/2009 22:43'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	aStringHolderView := self container: aStringHolder.	topView := StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !!StringTest methodsFor: 'initialize-release' stamp: 'md 4/18/2003 10:00'!setUp	string := 'Hi, I am a String'! !!StringTest methodsFor: 'tests - converting' stamp: 'ar 8/27/2009 20:43'!testAsDecomposedUnicode	"Test the behavior of #asDecomposedUnicode"	| composed decomposed |	"Tests single character"	composed := String with: (Character value: 353).	decomposed := String with: (Character value: 115) with: (Character value: 780).	self assert: composed asDecomposedUnicode = decomposed.	"Test character at end of text"	composed := 'Hello', (String with: (Character value: 353)).	decomposed := 'Hello', (String with: (Character value: 115) with: (Character value: 780)).	self assert: composed asDecomposedUnicode = decomposed.	"Test character in the midst of text"	composed := 'Hello', (String with: (Character value: 353)), 'World'.	decomposed := 'Hello', (String with: (Character value: 115) with: (Character value: 780)), 'World'.	self assert: composed asDecomposedUnicode = decomposed.	"Test character in the end of text"	composed := (String with: (Character value: 353)), 'World'.	decomposed := (String with: (Character value: 115) with: (Character value: 780)), 'World'.	self assert: composed asDecomposedUnicode = decomposed.	"Test string full of characters"	"Test character in the end of text"	composed := (String with: (Character value: 353)).	decomposed := (String with: (Character value: 115) with: (Character value: 780)).	self assert: (composed, composed, composed) asDecomposedUnicode = (decomposed, decomposed, decomposed).! !!StringTest methodsFor: 'tests - converting' stamp: 'sd 6/5/2005 09:26'!testAsInteger	self assert: '1796exportFixes-tkMX' asInteger = 1796.	self assert: 'donald' asInteger isNil.	self assert: 'abc234def567' asInteger = 234.	self assert: '-94' asInteger = -94.	self assert: 'foo-bar-92' asInteger = -92! !!StringTest methodsFor: 'tests - converting' stamp: 'ar 8/27/2009 20:36'!testAsPrecomposedUnicode	"Test the behavior of #asPrecomposedUnicode"	| composed decomposed |	"Tests single character"	composed := String with: (Character value: 353).	decomposed := String with: (Character value: 115) with: (Character value: 780).	self assert: decomposed asPrecomposedUnicode = composed.	"Test character at end of text"	composed := 'Hello', (String with: (Character value: 353)).	decomposed := 'Hello', (String with: (Character value: 115) with: (Character value: 780)).	self assert: decomposed asPrecomposedUnicode = composed.	"Test character in the midst of text"	composed := 'Hello', (String with: (Character value: 353)), 'World'.	decomposed := 'Hello', (String with: (Character value: 115) with: (Character value: 780)), 'World'.	self assert: decomposed asPrecomposedUnicode = composed.	"Test character in the end of text"	composed := (String with: (Character value: 353)), 'World'.	decomposed := (String with: (Character value: 115) with: (Character value: 780)), 'World'.	self assert: decomposed asPrecomposedUnicode = composed.	"Test string full of characters"	"Test character in the end of text"	composed := (String with: (Character value: 353)).	decomposed := (String with: (Character value: 115) with: (Character value: 780)).	self assert: (decomposed, decomposed, decomposed) asPrecomposedUnicode = (composed, composed, composed).! !!StringTest methodsFor: 'tests - converting' stamp: 'sd 6/5/2005 09:27'!testAsSmalltalkComment	| exampleStrings  |	exampleStrings := #(		''		' '		'"'		'""'		'"""'		'abc"abc'		'abc""abc'		'abc"hello"abc'		'abc"'		'"abc' ).	"check that the result of scanning the comment is empty"	exampleStrings do: [ :s |		| tokens  |		tokens :=  Scanner new scanTokens: s asSmalltalkComment.		self assert: (tokens isEmpty) ].	"check that the result has the same non-quote characters as the original"	exampleStrings do: [ :s |		self assert: ( (s copyWithout: $") = (s asSmalltalkComment copyWithout: $"))].	"finnaly, test for some common kinds of inputs"	self assert: ( 'abc' asSmalltalkComment = '"abc"').	self assert: ( 'abc"abc' asSmalltalkComment = '"abc""abc"').	self assert: ('abc""abc' asSmalltalkComment = '"abc""abc"' ).		! !!StringTest methodsFor: 'tests - converting' stamp: 'ar 7/22/2009 22:02'!testBase64	self assert: 'SGVsbG8gV29ybGQ=' base64Decoded = 'Hello World'.	self assert: 'Hello World' base64Encoded = 'SGVsbG8gV29ybGQ='.! !!StringTest methodsFor: 'tests - converting' stamp: 'sd 6/5/2005 09:27'!testCapitalized	| uc lc empty |			uc := 'MElViN'.	lc := 'mElViN'.	empty := ' '.	self assert:  lc capitalized = uc.	self assert: uc capitalized = uc.	"the string gets copied"	self deny: uc capitalized == uc.	self deny: empty capitalized == empty.! !!StringTest methodsFor: 'tests - converting' stamp: 'ky 7/8/2006 15:28'!testUnescapePercents	self assert: '' unescapePercents = ''.	self assert: 'x' unescapePercents = 'x'.	self assert: '+' unescapePercents = ' '.	self assert: 'x+' unescapePercents = 'x '.	self assert: '+x' unescapePercents = ' x'.	self assert: 'x+x' unescapePercents = 'x x'.	self assert: '%' unescapePercents = '%'.	self assert: '%3' unescapePercents = '%3'.	self assert: '%3C' unescapePercents = '<'.		self assert: '%3Cx%3E4%3C%2Fx%3E' unescapePercents = '<x>4</x>'.		self assert: '!!@#$%25%5E&*()%7B%7D%5B%5D=:/;?+''%22' unescapePercents  = '!!@#$%^&*(){}[]=:/;? ''"'.	self assert: '!!%40%23%24%25%5E%26*()%7B%7D%5B%5D%3D%3A%2F%3B%3F%2B''%22' unescapePercents  = '!!@#$%^&*(){}[]=:/;?+''"'.	self assert: '%21@%23%24%25%5E%26*%28%29%7B%7D%5B%5D%3D%3A/%3B%3F+%27%22' unescapePercents = '!!@#$%^&*(){}[]=:/;? ''"'! !!StringTest methodsFor: 'tests - converting' stamp: 'ky 7/8/2006 18:01'!testUnescapePercentsWithTextEncoding	| leading kataTe kataSu kataTo |	leading := JapaneseEnvironment leadingChar.	"Katakana letter Te"	kataTe := (Character leadingChar: leading code: 12486) asString.	"Katakana letter Su"	kataSu := (Character leadingChar: leading code: 12473) asString.	"Katakana letter To"	kataTo := (Character leadingChar: leading code: 12488) asString.	self assert: ('%83e%83X%83g' unescapePercentsWithTextEncoding: 'shift_jis')			= (kataTe , kataSu , kataTo).	self assert: ('%83e%83X%83g%20and%20%83e%83X%83g' unescapePercentsWithTextEncoding: 'shift_jis')			= (kataTe , kataSu , kataTo , ' and ' , kataTe , kataSu , kataTo)! !!StringTest methodsFor: 'tests - converting' stamp: 'dc 4/10/2007 09:35'!testUpTo	"self debug: #testUpTo"	self assert: #up:to: keywords = #(up: to:).	self assert: #copy:from:to: keywords = #(copy: from: to:).	self assert: #up keywords = #(up).	self assert: #at: keywords = #(at:).	! !!StringTest methodsFor: 'tests - converting' stamp: 'ul 1/29/2010 02:12'!testUtf8ToSqueakByteOrderMark	"Ensure that utf8ToSqueak ignores Byte order mark (BOM) just like UTF8TextConverter does"	{		#('' '').		#('abc' 'abc').		"Make sure that we remove inner BOMs for maximal compatibility with UTF8TextConverter"		#('abc' 'abc').		{ 'abc'. 'abc', (Unicode value: 1234) asString }	} do: [ :each |		self assert: each first utf8ToSqueak = each second ]! !!StringTest methodsFor: 'tests - converting' stamp: 'nice 1/18/2010 18:10'!testUtf8ToSqueakLeadingChar	"Ensure utf8ToSqueak inserts the leading char just like UTF8TextConverter does"	| data |	data := #[ 227 129 130 227 129 132 227 129 134 227 129 136 227 129 138 ] asString "aiueo in Japanese".	self assert: data utf8ToSqueak = (data convertFromEncoding: #utf8)! !!StringTest methodsFor: 'tests - converting' stamp: 'sd 6/5/2005 09:27'!testWithFirstCharacterDownshifted	| uc lc empty |			uc := 'MElViN'.	lc := 'mElViN'.	empty := ' '.	self assert:  uc withFirstCharacterDownshifted = lc.	self assert: lc withFirstCharacterDownshifted = lc.	"the string gets copied"	self deny: lc withFirstCharacterDownshifted == lc.	self deny: empty withFirstCharacterDownshifted == empty.! !!StringTest methodsFor: 'tests - converting' stamp: 'ar 1/11/2010 20:00'!testWithNoLineLongerThan	"self run: #testWithNoLineLongerThan"	self assert: ('Hello World' withNoLineLongerThan: 5) = ('Hello', String cr, 'World').	self shouldnt:[('Hello', String cr, String cr,'World') withNoLineLongerThan: 5] raise: Error.! !!StringTest methodsFor: 'tests - converting' stamp: 'md 2/5/2007 15:21'!testZipped	| compressed |		compressed := 'hello' zipped.	self assert: (compressed unzipped = 'hello').! !!StringTest methodsFor: 'tests - accessing' stamp: 'sd 6/5/2005 09:27'!testAt	self assert: (string at: 1) = $H.! !!StringTest methodsFor: 'tests - finding' stamp: 'dtl 11/21/2009 15:57'!testBeginsWith	self assert: ('Elvis' beginsWith: 'Elv').	self assert: ('Elvis' beginsWith: 'Elvis').	self assert: ('Elvis' beginsWith: 'E').	self deny: ('Elvis' beginsWith: 'e').	self deny: ('Elvis' beginsWith: 'Elvis ').	self deny: ('' beginsWith: '').	self deny: ('abc' beginsWith: '')! !!StringTest methodsFor: 'tests - finding' stamp: 'dtl 11/21/2009 15:55'!testEndsWith	self assert: ('Elvis' endsWith: 'vis').	self assert: ('Elvis' endsWith: 'Elvis').	self assert: ('Elvis' endsWith: 's').	self deny: ('Elvis' endsWith: 'S').	self deny: ('Elvis' endsWith: ' Elvis').	self deny: ('' endsWith: '').	self deny: ('abc' endsWith: '')! !!StringTest methodsFor: 'tests - finding' stamp: 'ul 9/14/2009 03:16'!testFindStringStartingAt	"Run the tests with both String's and ByteString's method"	{		"text pattern startIndex expectedResult"		#('Smalltalk' 'al' 2 3).		{ (Character value: 12345) asString, 'foo'. 'foo'. 1. 2 }.		{ (Character value: 12345) asString, 'foo'. (Character value: 12345) asString, 'foo'. 1. 1 }.		{ 'foo', (Character value: 12345) asString. (Character value: 12345) asString. 1. 4 }.		#('ababab' 'ab' 2 3).		#('abc' 'a' 2 0) } do: [ :input |			#(				(yourself yourself)				"the (yourself asWideString) pair would sometimes result 0 				(like here: 'Smalltalk' findString: 'al' asWideString startingAt: 1)				if the text is a ByteString, because of the optimized version,				but normally ByteStrings never ''contain'' WideStrings"				(asWideString yourself)				(asWideString asWideString)) do: [ :modifiers |					| text pattern startIndex expectedResult result |					text := input first perform: modifiers first.					pattern := input second perform: modifiers second.					startIndex := input third.					expectedResult := input fourth.					self assert: (result := text findString: pattern startingAt: startIndex) = expectedResult ] ]! !!StringTest methodsFor: 'test-comparing' stamp: 'lr 7/7/2006 11:32'!testComparing	self assert: 'foo' < 'foo:'.	self assert: 'foo' < 'fooBar'.	self assert: 'foo' <= 'foo:'.	self assert: 'foo' <= 'fooBar'.	self assert: 'foo:' > 'foo'.	self assert: 'fooBar' > 'foo'.	self assert: 'foo:' >= 'foo'.	self assert: 'fooBar' >= 'foo'! !!StringTest methodsFor: 'testing - converting' stamp: 'nice 11/17/2009 11:16'!testEncodeForHTTP	self assert: 'aa aa  aa aa' encodeForHTTP = 'aa%20aa%20%C3%A9%C3%A9%20aa%20aa'! !!StringTest methodsFor: 'testing - converting' stamp: 'ar 6/25/2007 16:08'!testFindFirstInByteString	"Tests that ByteString>>findFirstInString: works as advertised"	| map index |	string := 'Hello World'.	map := (ByteArray new: 256) at: $H asciiValue+1 put: 1; yourself.	index := ByteString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 1.	map := (ByteArray new: 256) at: $W asciiValue+1 put: 1; yourself.	index := ByteString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 7.	map := (ByteArray new: 256) at: $d asciiValue+1 put: 1; yourself.	index := ByteString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 11.	map := (ByteArray new: 256) at: $q asciiValue+1 put: 1; yourself.	index := ByteString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 0.! !!StringTest methodsFor: 'testing - converting' stamp: 'ar 6/25/2007 16:07'!testFindFirstInString	"Tests that String>>findFirstInString: works as advertised"	| map index |	string := 'Hello World'.	map := (ByteArray new: 256) at: $H asciiValue+1 put: 1; yourself.	index := String findFirstInString: string inSet: map startingAt: 1.	self assert: index = 1.	map := (ByteArray new: 256) at: $W asciiValue+1 put: 1; yourself.	index := String findFirstInString: string inSet: map startingAt: 1.	self assert: index = 7.	map := (ByteArray new: 256) at: $d asciiValue+1 put: 1; yourself.	index := String findFirstInString: string inSet: map startingAt: 1.	self assert: index = 11.	map := (ByteArray new: 256) at: $q asciiValue+1 put: 1; yourself.	index := String findFirstInString: string inSet: map startingAt: 1.	self assert: index = 0.! !!StringTest methodsFor: 'testing - converting' stamp: 'ar 6/25/2007 16:11'!testFindFirstInWideString	"Tests that WideString>>findFirstInString: works as advertised"	| map index |	string := 'Hello World' asWideString.	map := (ByteArray new: 256) at: $H asciiValue+1 put: 1; yourself.	index := WideString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 1.	map := (ByteArray new: 256) at: $W asciiValue+1 put: 1; yourself.	index := WideString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 7.	map := (ByteArray new: 256) at: $d asciiValue+1 put: 1; yourself.	index := WideString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 11.	map := (ByteArray new: 256) at: $q asciiValue+1 put: 1; yourself.	index := WideString findFirstInString: string inSet: map startingAt: 1.	self assert: index = 0.! !!StringTest methodsFor: 'testing - converting' stamp: 'KR 06/24/2005 11:21'!testPercentEncodingJa	| leading hiraA hiraO hiraAO encodedHiraA encodedHiraO encodedHiraAO |    "Make Japanese String from unicode. see http://www.unicode.org/charts/PDF/U3040.pdf"     leading := JapaneseEnvironment leadingChar.	hiraA := (Character leadingChar: leading code: 16r3042) asString.  "HIRAGANA LETTER A"	hiraO := (Character leadingChar: leading code: 16r304A) asString.  "HIRAGANA LETTER O"	hiraAO := hiraA, hiraO.	"Percent Encoded Japanese String"	encodedHiraA := hiraA encodeForHTTP.	self assert: encodedHiraA = '%E3%81%82'.	encodedHiraO := hiraO encodeForHTTP.	self assert: encodedHiraO = '%E3%81%8A'.	encodedHiraAO := hiraAO encodeForHTTP.	self assert: encodedHiraAO =  '%E3%81%82%E3%81%8A'.     "without percent encoded string"	self assert: '' unescapePercents = ''.	self assert: 'abc' unescapePercents = 'abc'.	"latin1 character"	self assert: hiraAO unescapePercents = hiraAO.  "multibyte character"	"encoded latin1 string"	self assert: '%61' unescapePercents = 'a'.	self assert: '%61%62%63' unescapePercents = 'abc'.	"encoded multibyte string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: encodedHiraA unescapePercents = hiraA.		self assert: encodedHiraAO unescapePercents = hiraAO].	"mixed string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraAO,'a') unescapePercents = (hiraAO, 'a').		self assert: ('a', encodedHiraA) unescapePercents = ('a', hiraA).		self assert: ('a', encodedHiraA, 'b')  unescapePercents = ('a', hiraA, 'b').		self assert: ('a', encodedHiraA, 'b', encodedHiraO) unescapePercents = ('a', hiraA, 'b', hiraO).		self assert: (encodedHiraA, encodedHiraO, 'b', encodedHiraA) unescapePercents = (hiraA, hiraO, 'b', hiraA)].	"for Seaside"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraA, '+', encodedHiraO) unescapePercents = (hiraA, ' ', hiraO)].! !!StringTest methodsFor: 'testing - converting' stamp: 'ul 10/13/2009 00:55'!testWithBlanksTrimmed	| s |	self assert: ' abc  d   ' withBlanksTrimmed = 'abc  d'.	self assert: 'abc  d   ' withBlanksTrimmed = 'abc  d'.	self assert: ' abc  d' withBlanksTrimmed = 'abc  d'.	self assert: (((0 to: 255) collect: [ :each | each asCharacter ] thenSelect: [ :each | each isSeparator ]) as: String) withBlanksTrimmed = ''.	s := 'abcd'.	self assert: s withBlanksTrimmed = s.	self assert: s withBlanksTrimmed ~~ s.! !!StringTest methodsFor: 'as yet unclassified' stamp: 'nice 1/18/2010 14:54'!testEquality	self assert: 'abc' = 'abc' asWideString.	self assert: 'abc' asWideString = 'abc'.	self assert: (#[ 97 0 0 0 ] asString ~= 'a000' asWideString).	self assert: ('a000' asWideString ~= #[ 97 0 0 0 ] asString).	self assert: ('abc' sameAs: 'aBc' asWideString).	self assert: ('aBc' asWideString sameAs: 'abc').	self assert: (#[ 97 0 0 0 ] asString 						sameAs: 'Abcd' asWideString) not.	self assert: ('a000' asWideString sameAs: 					#[ 97 0 0 0 ] asString) not.! !!StringTest methodsFor: 'testing' stamp: 'nice 10/5/2009 03:44'!testFindLastOccurenceOfStringStartingAt	self assert: ('Smalltalk' findLastOccurrenceOfString: 'al' startingAt: 2) = 7.	self assert: ('aaa' findLastOccurrenceOfString: 'aa' startingAt: 1) = 2.	self assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' startingAt: 2) = 7.	self assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' asWideString startingAt: 2) = 7.	self assert: (('Smalltalk' copyWith: 835 asCharacter) findLastOccurrenceOfString: 'al' asWideString startingAt: 2) = 7.! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy01	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size == 3! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:20'!testFindTokensEscapedBy02	| tokens |	string := ''.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens isEmpty! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy03	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size == 4! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy04	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size == 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy05	| tokens |	string := 'this, /is, a"," test/'.	tokens := string findTokens: ',#' escapedBy: '"/'.	self assert: tokens size = 2.	self assert: tokens first = 'this'.	self assert: tokens second = ' is, a"," test'.! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy06	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size == 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy07	| tokens |	string := 'a:b::c'.	tokens := string findTokens: ':' escapedBy: '"'.	self assert: tokens size == 4.	self assert: tokens first = 'a'.	self assert: tokens second = 'b'.	self assert: tokens third = ''.	self assert: tokens fourth = 'c'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy08	| tokens |	string := 'this, is, ##a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size == 4.	self assert: tokens third = ' a'.	self assert: tokens fourth = ' test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy09	| tokens |	string := 'this, is, ###a, test#'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size == 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy10	| tokens |	string := 'this, is, ###a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size == 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy11	| tokens |	string := 'this, is, """a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size == 3.	self assert: tokens third = ' "a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy12	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: '"'.	self assert: tokens size == 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy13	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: nil.	self assert: tokens size == 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy14	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: ',#;.' escapedBy: '"&'.	self assert: tokens size == 3.	self assert: tokens second = ' two# three'.	self assert: tokens third = ' four. five'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy15	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: nil escapedBy: '"&'.	self assert: tokens size = 1.	self assert: tokens first = 'one, two# three; four. five'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy16	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: nil escapedBy: nil.	self assert: tokens size = 1.	self assert: tokens first = string! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy21	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size == 3! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy22	| tokens |	string := ''.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 0! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy23	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size == 4! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy24	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size == 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy25	| tokens |	string := 'this, /is, a"," test/'.	tokens := string findTokens: $, escapedBy: $/.	self assert: tokens size = 2.	self assert: tokens first = 'this'.	self assert: tokens second = ' is, a"," test'.! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'stephaneducasse 2/4/2006 20:10'!testFindTokensEscapedBy26	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size == 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - formatting' stamp: 'ul 10/13/2009 01:23'!testFormat	{ 		[ '\{ \} \\ foo {1} bar {2}' format: { 12. 'string' } ] -> '{ } \ foo 12 bar string'.		[ '\{ \} \\ foo {2} bar {1}' format: { 'string'. 12 } ] -> '{ } \ foo 12 bar string'.		[ '\{1}' format: {} ] -> '{1}'.		[ '\{1}{1}' format: { $a } ] -> '{1}a'.	} do: [ :each |		self assert: each key value = each value ]! !!StringTest methodsFor: 'tests - indexOf' stamp: 'nice 3/15/2007 21:11'!testIndexOf		"test for http://bugs.impara.de/view.php?id=3574"	self assert: ('abc-' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 4.	self assert: ('ab7' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 3.	self assert: ('a2c' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 2.	self assert: ('3bc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 1.	self assert: ('abc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 0.		"extension to wide characters"	self assert: ((String with: 803 asCharacter with: 811 asCharacter) indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 2.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 0.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: $c))) = 3.		"make sure start index is used in wide string algorithm"	self assert: ('ab bcd abc' copyWith: 811 asCharacter) substrings = {'ab'. 'bcd'. 'abc' copyWith: 811 asCharacter}.! !!StringTest methodsFor: 'testing - lines' stamp: 'nice 11/16/2009 13:22'!testLineCorrespondingToIndex	| sampleCRString sampleLFString sampleCRLFString anIndex |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		anIndex := sampleCRString indexOf: $h.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'the'.	anIndex := sampleLFString indexOf: $h.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'the'.	anIndex := sampleCRLFString indexOf: $h.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'the'.		anIndex := sampleCRString indexOf: $B.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'Bear'.	anIndex := sampleLFString indexOf: $B.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'Bear'.	anIndex := sampleCRLFString indexOf: $B.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'Bear'.		anIndex := sampleCRString indexOf: $d.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'Fred'.	anIndex := sampleLFString indexOf: $d.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'Fred'.	anIndex := sampleCRLFString indexOf: $d.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'Fred'.! !!StringTest methodsFor: 'testing - lines' stamp: 'nice 11/16/2009 13:13'!testLineCount	| sampleCRString sampleLFString sampleCRLFString |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		self assert: sampleCRString lineCount = 3.	self assert: sampleLFString lineCount = 3.	self assert: sampleCRLFString lineCount = 3.! !!StringTest methodsFor: 'testing - lines' stamp: 'nice 11/16/2009 13:14'!testLineNumber	| sampleCRString sampleLFString sampleCRLFString |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		self assert: (sampleCRString lineNumber: 2) = 'the'.	self assert: (sampleLFString lineNumber: 2) = 'the'.	self assert: (sampleCRLFString lineNumber: 2) = 'the'.! !!StringTest methodsFor: 'testing - lines' stamp: 'nice 11/16/2009 13:19'!testLinesDo	| sampleCRString sampleLFString sampleCRLFString lines |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		lines := OrderedCollection new.	sampleCRString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').		lines := OrderedCollection new.	sampleLFString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').	lines := OrderedCollection new.	sampleCRLFString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').! !!StringTest methodsFor: 'testing - lines' stamp: 'nice 11/16/2009 22:26'!testWthNoLineLongerThan	| phrases |	phrases := {		'Fred the bear went down to the brook to read his book in silence'.		'Fred the bear went down' , String cr , ' to the brook to ' , String cr , 'read his book in silence'.		'Fred the bear went down' , String lf , '  to the brook to ' , String lf , 'read his book in silence'.		'Fred the bear went down' , String crlf , '  to the brook to ' , String crlf , 'read his book in silence'.		}.	#(5 7 9) do: [:length |		phrases do: [:phrase |			| split |			split := phrase withNoLineLongerThan: length.			self				assert: (split copyWithoutAll: CharacterSet separators) = (phrase copyWithoutAll: CharacterSet separators)				description: 'no information should be lost'.			split linesDo: [:line |				self assert: line size <= length description: 'lines should not be longer than prescribed'].			phrase lineCount = 1 ifTrue: [| lastLineSize |				lastLineSize := length.				split linesDo: [:line |					line isEmpty ifFalse: [| firstWordSize |						firstWordSize := line indexOfAnyOf: CharacterSet separators startingAt: 1 ifAbsent: [line size + 1].						self assert: (lastLineSize + firstWordSize) > length description: 'split was too short'.						lastLineSize := line size]]]]]! !!StringTest methodsFor: 'testing - instance creation' stamp: 'dc 3/21/2007 11:22'!testSpace	"self debug: #testSpace"		string := String new.	self assert: string size = 0. "instead of #isEmpty to be consistent with the following test"		string := String space.	self assert: string size = 1.	self assert: string = ' '! !!StringTest methodsFor: 'testing - internet' stamp: 'ul 11/23/2009 14:39'!testWithInternetLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String crlf).		'abc', String lf -> ('abc', String crlf).		'abc', String crlf -> ('abc', String crlf).		String cr, 'abc' -> (String crlf, 'abc').		String lf, 'abc' -> (String crlf, 'abc').		String crlf, 'abc' -> (String crlf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).	} do: [ :each |		self assert: each key withInternetLineEndings = each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'nice 1/18/2010 23:33'!testWithSqueakLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String cr).		'abc', String lf -> ('abc', String cr).		'abc', String crlf -> ('abc', String cr).		String cr, 'abc' -> (String cr, 'abc').		String lf, 'abc' -> (String cr, 'abc').		String crlf, 'abc' -> (String cr, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String cr, String cr, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String cr, 'abc', String cr, String cr, 'abc', String cr).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String cr, 'abc', String cr, String cr, 'abc', String cr).	} do: [ :each |		self assert: each key withSqueakLineEndings = each value ]! !!StringTest methodsFor: 'testing - internet' stamp: 'nice 1/18/2010 23:35'!testWithUnixLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String lf).		'abc', String lf -> ('abc', String lf).		'abc', String crlf -> ('abc', String lf).		String cr, 'abc' -> (String lf, 'abc').		String lf, 'abc' -> (String lf, 'abc').		String crlf, 'abc' -> (String lf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String lf, String lf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String lf, 'abc', String lf, String lf, 'abc', String lf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String lf, 'abc', String lf, String lf, 'abc', String lf).	} do: [ :each |		self assert: each key withUnixLineEndings = each value ]! !!StringTest commentStamp: '<historical>' prior: 0!This is the unit test for the class String. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Switch methodsFor: 'state'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on := false.			self changed]! !!Switch methodsFor: 'state'!isOff	"Answer whether the receiver is set off or not."	^on not! !!Switch methodsFor: 'state'!isOn	"Answer whether the receiver is set on or not."	^on! !!Switch methodsFor: 'state'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on := true.			self changed]! !!Switch methodsFor: 'state'!switch	"Change the state of the receiver from 'on' to 'off' or from 'off' to 'on' (see 	Switch|turnOn, Switch|turnOff)."	self isOn		ifTrue: [self turnOff]		ifFalse: [self turnOn]! !!Switch methodsFor: 'state'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on := false.			self changed.			self doAction: offAction]! !!Switch methodsFor: 'state'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on := true.			self changed.			self doAction: onAction]! !!Switch methodsFor: 'action'!doAction: anAction 	"Execute anAction if it is non-nil."	anAction == nil ifFalse: [anAction value]! !!Switch methodsFor: 'action' stamp: 'nice 1/11/2010 20:57'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction := anAction! !!Switch methodsFor: 'action' stamp: 'nice 1/11/2010 20:57'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction := anAction! !!Switch methodsFor: 'private'!initializeOff	on := false. 	onAction := nil.	offAction := nil! !!Switch methodsFor: 'private'!initializeOn	on := true. 	onAction := nil.	offAction := nil! !!Switch methodsFor: 'converting' stamp: 'md 9/18/2004 19:51'!printOn: aStream	self isOn		ifTrue: [aStream nextPutAll: 'ON-Switch']		ifFalse: [aStream nextPutAll: 'OFF-Switch']! !!Switch commentStamp: '<historical>' prior: 0!I represent a selection setting and actions to take depending on a change in the setting. An instance has three attributes: state, which is either on or off; on action; and off action. The on and off actions are blocks of code that execute whenever the instance changes state. I am typically used as a menu item in conjunction with a SwitchView and a SwitchController.1/24/96 sw: made this a subclass of Model, for faster dependents handling!!Switch class methodsFor: 'instance creation'!new	"Answer an instance of me such that the on and off actions are set to nil	('no action'), and the state is set to 'off'."	^self newOff! !!Switch class methodsFor: 'instance creation'!newOff	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'off'."	^super new initializeOff! !!Switch class methodsFor: 'instance creation'!newOn	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'on'."	^super new initializeOn! !!Symbol methodsFor: 'comparing' stamp: 'eem 5/22/2008 13:42'!= aSymbol	"Compare the receiver and aSymbol." 	self == aSymbol ifTrue: [^ true].	self class == aSymbol class ifTrue: [^ false].	"Use a potentally primitive comparison otherwise"	^self hasEqualElements: aSymbol! !!Symbol class methodsFor: 'access' stamp: 'ar 6/4/2008 11:54'!allSymbols	"Answer all interned symbols"	^AccessProtect critical:[Array streamContents:[:s|		s nextPutAll: NewSymbols.		s nextPutAll: OneCharacterSymbols.		s nextPutAll: SymbolTable.	]].! !!Symbol class methodsFor: 'access' stamp: 'eem 12/21/2008 12:18'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !!Symbol class methodsFor: 'class initialization' stamp: 'ar 6/4/2008 11:52'!allSymbolTablesDo: aBlock	AccessProtect critical:[		NewSymbols do: aBlock.		SymbolTable do: aBlock.	].! !!Symbol class methodsFor: 'class initialization' stamp: 'ar 6/4/2008 11:52'!allSymbolTablesDo: aBlock after: aSymbol	AccessProtect critical:[		NewSymbols do: aBlock after: aSymbol.		SymbolTable do: aBlock after: aSymbol.	].! !!Symbol class methodsFor: 'class initialization' stamp: 'ar 6/4/2008 11:55'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)"	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable array size.	AccessProtect critical:[		SymbolTable growTo: SymbolTable size * 4 // 3 + 100.	].	^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'! !!Symbol class methodsFor: 'class initialization' stamp: 'eem 6/11/2008 18:14'!compareTiming	" 	Symbol compareTiming	"	| answer t selectorList implementorLists flattenedList md |	answer := WriteStream on: String new.	SmalltalkImage current timeStamp: answer.	answer cr; cr.	answer nextPutAll: MethodDictionary instanceCount printString , ' method dictionaries';		 cr;		 cr.	answer nextPutAll: (MethodDictionary allInstances			inject: 0			into: [:sum :each | sum + each size]) printString , ' method dictionary entries';		 cr;		 cr.	md := MethodDictionary allInstances.	t := [100				timesRepeat: [md						do: [:each | each includesKey: #majorShrink]]] timeToRun.	answer nextPutAll: t printString , ' ms to check all method dictionaries for #majorShrink 1000 times';		 cr;		 cr.	selectorList := Symbol selectorsContaining: 'help'.	t := [3				timesRepeat: [selectorList						collect: [:each | self systemNavigation allImplementorsOf: each]]] timeToRun.	answer nextPutAll: t printString , ' ms to do #allImplementorsOf: for ' , selectorList size printString , ' selectors like *help* 3 times';		 cr;		 cr.	t := [3				timesRepeat: [selectorList						do: [:eachSel | md								do: [:eachMd | eachMd includesKey: eachSel]]]] timeToRun.	answer nextPutAll: t printString , ' ms to do #includesKey: for ' , md size printString , ' methodDicts for ' , selectorList size printString , ' selectors like *help* 3 times';		 cr;		 cr.	#('help' 'majorShrink' )		do: [:substr | 			answer nextPutAll: (Symbol selectorsContaining: substr) size printString , ' selectors containing "' , substr , '"';				 cr.			t := [3						timesRepeat: [selectorList := Symbol selectorsContaining: substr]] timeToRun.			answer nextPutAll: t printString , ' ms to find Symbols containing *' , substr , '* 3 times';				 cr.			t := [3						timesRepeat: [selectorList := Symbol selectorsContaining: substr.							implementorLists := selectorList										collect: [:each | self systemNavigation allImplementorsOf: each].							flattenedList := SortedCollection new.							implementorLists								do: [:each | flattenedList addAll: each]]] timeToRun.			answer nextPutAll: t printString , ' ms to find implementors of *' , substr , '* 3 times';				 cr;				 cr].	StringHolder new contents: answer contents;		 openLabel: 'timing'! !!Symbol class methodsFor: 'class initialization' stamp: 'ar 6/4/2008 11:50'!initialize	"Symbol initialize"	AccessProtect := Mutex new.	Symbol rehash.	OneCharacterSymbols := nil.	OneCharacterSymbols := (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].	Smalltalk addToShutDownList: self.! !!Symbol class methodsFor: 'instance creation' stamp: 'eem 7/21/2010 17:18'!intern: aStringOrSymbol 	^(self lookup: aStringOrSymbol) ifNil:[		| aClass aSymbol |		aStringOrSymbol isSymbol ifTrue:[			aSymbol := aStringOrSymbol.		] ifFalse:[			aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].			aSymbol := aClass new: aStringOrSymbol size.			self primitiveSetIdentityHashOf: aSymbol to: aStringOrSymbol stringhash.			aSymbol string: aStringOrSymbol.		].		AccessProtect critical:[NewSymbols add: aSymbol].		aSymbol].! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 6/4/2008 11:53'!lookup: aStringOrSymbol	^AccessProtect critical:[		(SymbolTable like: aStringOrSymbol) ifNil: [NewSymbols like: aStringOrSymbol].	].! !!Symbol class methodsFor: 'private' stamp: 'ar 7/22/2010 10:44'!primitiveSetIdentityHashOf: aSymbol to: anInteger	"Set aSymbol's identity hash to anInteger, answering aSymbol's previous hash value.	 DO NOT USE THIS IN NORMAL CODE!!  It is only indended to give new symbols a	 deterministic hash."	<primitive: 161>! !!Symbol class methodsFor: 'private' stamp: 'ar 6/4/2008 11:52'!rehash		"Symbol rehash"	"Rebuild the hash table, reclaiming unreferenced Symbols."	AccessProtect critical:[		SymbolTable := WeakSet withAll: self allSubInstances.		NewSymbols := WeakSet new.	].! !!Symbol class methodsFor: 'private' stamp: 'ar 6/4/2008 11:53'!shutDown: aboutToQuit	AccessProtect critical:[		SymbolTable addAll: NewSymbols.		NewSymbols := WeakSet new.	].! !!SymbolTest methodsFor: 'tests' stamp: 'md 9/6/2005 20:02'!testAsMutator	self assert: #x asMutator = #x:.	self assert: #x asMutator isSymbol! !!SymbolTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:29'!testCapitalized	| uc lc |			uc := #MElViN.	lc := #mElViN.	self assert:  lc capitalized = uc.	self assert: uc capitalized = uc.! !!SymbolTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:29'!testWithFirstCharacterDownshifted	| uc lc empty |			uc := #MElViN.	lc := #mElViN.	empty := #' '.	self assert:  uc withFirstCharacterDownshifted = lc.	self assert: lc withFirstCharacterDownshifted = lc.	! !!SymbolTest methodsFor: 'as yet unclassified' stamp: 'md 2/16/2006 17:17'!testNumArgs2    "TODO: need to be extended to support shrinking and for selectors like #+ " 		self assert: (#test numArgs: 0) = #test.	self assert: (#test numArgs: 1) = #test:.	self assert: (#test numArgs: 2) = #test:with:.	self assert: (#test numArgs: 3) = #test:with:with:.		self assert: (#test: numArgs: 0) = #test:.	self assert: (#test: numArgs: 1) = #test:.	self assert: (#test: numArgs: 2) = #test:with:.	self assert: (#test: numArgs: 3) = #test:with:with:.		self assert: (#test:with: numArgs: 0) = #test:with:.	self assert: (#test:with: numArgs: 1) = #test:with:.	self assert: (#test:with: numArgs: 2) = #test:with:.	self assert: (#test:with: numArgs: 3) = #test:with:with:.	self assert: (#test:with: numArgs: 4) = #test:with:with:with:.		self assert: (#test:with:with: numArgs: 0) = #test:with:with:.	self assert: (#test:with:with: numArgs: 1) = #test:with:with:.	self assert: (#test:with:with: numArgs: 2) = #test:with:with:.	self assert: (#test:with:with: numArgs: 3) = #test:with:with:.	self assert: (#test:with:with: numArgs: 4) = #test:with:with:with:.! !!SymbolTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Symbol. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!SyntaxError class methodsFor: '*ST80-Support' stamp: 'sd 11/20/2005 21:28'!buildMVCViewOn: aSyntaxError	"Answer an MVC view on the given SyntaxError."	| topView aListView aCodeView |	topView := StandardSystemView new		model: aSyntaxError;		label: 'Syntax Error';		minimumSize: 380@220.	aListView := PluggableListView on: aSyntaxError		list: #list		selected: #listIndex		changeSelected: nil		menu: #listMenu:.	aListView window: (0@0 extent: 380@20).	topView addSubView: aListView.	aCodeView := PluggableTextView on: aSyntaxError		text: #contents		accept: #contents:notifying:		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	aCodeView window: (0@0 extent: 380@200).	topView addSubView: aCodeView below: aListView.	^ topView! !!SyntaxError class methodsFor: '*ST80-Support' stamp: 'dtl 2/8/2010 23:01'!mvcOpen: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	topView := self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend! !!SystemChangeNotifier methodsFor: 'public' stamp: 'eem 6/11/2008 18:17'!doSilently: aBlock	"Perform the block, and ensure that no system notification are broadcasted while doing so."	silenceLevel := silenceLevel + 1.	^aBlock ensure: [silenceLevel > 0 ifTrue: [silenceLevel := silenceLevel - 1]]! !!SystemDictionary methodsFor: 'system attributes' stamp: 'eem 3/31/2010 15:58'!primitiveSetWindowSizeX: xVal y: yVal	"Primitive. Sets the window size for the main Squeak window."	<primitive: 'primitiveSetWindowSize'>	^nil! !!SystemDictionary methodsFor: 'system attributes' stamp: 'eem 3/31/2010 16:16'!windowSize: aPoint	"Set the size of the main Squeak window."	^self primitiveSetWindowSizeX: aPoint x y: aPoint y! !!SystemDictionary methodsFor: 'removing' stamp: 'eem 5/19/2010 15:35'!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in	the receiver, answer the result of evaluating aBlock. Otherwise, answer	the value externally named by key."	self flushClassNameCache.	^super removeKey: key ifAbsent: aBlock! !!SystemErrorHandler methodsFor: 'error handling' stamp: 'ar 12/12/2006 12:21'!handleError: anError	"Handle an otherwise unhandled error."	handlerBlock ifNil:[		"For convenience, we assume that the image contains some tool support 		and delegate to ToolSet directly."		ToolSet default debugError: anError.	] ifNotNil:[		"#fixTemps below to avoid problems with recursive errors."		handlerBlock fixTemps value: anError.	].! !!SystemErrorHandler methodsFor: 'accessing' stamp: 'ar 12/12/2006 12:19'!handlerBlock	"Answer the handler block associated with the receiver"	^handlerBlock! !!SystemErrorHandler methodsFor: 'accessing' stamp: 'ar 12/12/2006 12:23'!handlerBlock: aBlock	"Install the handler block associated with the receiver"	aBlock numArgs = 1 ifFalse:[self error: 'System error handler block must take 1 argument'].	handlerBlock := aBlock! !!SystemErrorHandler commentStamp: '<historical>' prior: 0!I represent an interface for a system-wide default error handler. When an exception is not handled directly (using on:do:) or indirectly (via an errorHandler in the active process) the default system error handler is invoked. Care must be taken that the error handler serializes requests properly since it can be invoked by different processes.!!SystemErrorHandler class methodsFor: 'accessing' stamp: 'ar 12/6/2006 11:34'!default	"Answer the default system error handler"	^Default ifNil:[Default := self new].! !!SystemErrorHandler class methodsFor: 'accessing' stamp: 'ar 12/6/2006 11:34'!default: anErrorHandler	"Set the default system error handler"	Default := anErrorHandler! !!SystemErrorHandler class methodsFor: 'instance creation' stamp: 'ar 12/12/2006 12:21'!handlerBlock: aBlock	"Create a new instance of the receiver with the given handlerBlock"	^(self new)		handlerBlock: aBlock;		yourself! !!SystemEventHandler methodsFor: 'handling' stamp: 'bgf 8/2/2008 01:17'!handleSystemEvent: eventName	"Handle a system-wide event; by default we ignore any we don't implement by name."	(self respondsTo: eventName) ifTrue: [		^ self perform: eventName	].	Transcript cr; show: 'Received system event: ', eventName printString.! !!SystemEventHandler methodsFor: 'standard-events' stamp: 'bgf 8/2/2008 01:19'!mainWindowCloseRequest		"Default handling of main-window close is to offer to quit."	(UIManager default chooseFrom: #('Save And Quit' 'Quit' 'Cancel'))	caseOf: {		[1] -> [ SmalltalkImage current snapshot: true andQuit: true ].		[2] -> [ SmalltalkImage current snapshot: false andQuit: true ].	} otherwise: [].	! !!SystemEventHandler commentStamp: '<historical>' prior: 0!Represents an interface for certain system-level events like main window close etc.!!SystemEventHandler class methodsFor: 'accessing' stamp: 'ar 8/1/2008 19:18'!default	"Answer the default system event handler"	^Default ifNil:[Default := self new].! !!SystemEventHandler class methodsFor: 'accessing' stamp: 'ar 8/1/2008 19:18'!default: anEventHandler	"Set the default system event handler"	Default := anEventHandler! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 6/21/2008 11:31'!allAccessesTo: instVarName from: aClass	"Answer MethodReferences for all methods in aClass's hierarchy	 that refer to the instance variable name."	"self new allAccessesTo: 'contents' from: Collection."		| coll |	coll := OrderedCollection new.	Cursor wait showWhile:		[aClass withAllSubAndSuperclassesDo:			[:class | 			(class whichSelectorsAccess: instVarName) do:				[:sel |				sel == #DoIt ifFalse:					[coll add: (MethodReference new								setStandardClass: class 								methodSymbol: sel)]]]].	^coll! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 6/21/2008 11:47'!allStoresInto: instVarName from: aClass	"Answer MethodReferences for all methods in aClass's hierarchy	 that assign to the instance variable name."		"self new browseAllStoresInto: 'contents' from: Collection."		| coll |	coll := OrderedCollection new.	Cursor wait showWhile:		[aClass withAllSubAndSuperclassesDo:			[:class | 			(class whichSelectorsStoreInto: instVarName) do:				[:sel |				sel == #DoIt ifFalse:					[coll add: (MethodReference new								setStandardClass: class 								methodSymbol: sel)]]]].	^coll! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 6/21/2008 11:33'!browseAllAccessesTo: instVarName from: aClass	"Create and schedule a Message Set browser for all methods in	 aClass's hierarchy that refer to the instance variable name."	"self new browseAllAccessesTo: 'contents' from: Collection."		^self 		browseMessageList: (self allAccessesTo: instVarName from: aClass) asSortedCollection 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:05'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to 	aLiteral. For example, SystemNavigation new browseAllCallsOn: #open:label:."	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self			browseMessageList: (self allCallsOn: aLiteral) asSortedCollection			name: label			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:27'!browseAllCallsOn: aLiteral from: aBehavior	"Create and schedule a Message Set browser for	 all the methods that call on aLiteral within aBehavior."	"self new browseAllCallsOn: #/ from: Number"	^self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self 			browseMessageList: (self  allCallsOn: aLiteral from: aBehavior)			name: label, ' from ', aBehavior name			autoSelect: autoSelect]	! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:15'!browseAllCallsOn: aLiteral localTo: aClass	"Create and schedule a message browser on each method in or below the given class that refers to	aLiteral. For example, SystemNavigation new browseAllCallsOn: #open:label: localTo: CodeHolder."	aClass ifNil: [ ^self inform: 'no selected class' ].	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self browseMessageList: (aClass allLocalCallsOn: aLiteral) asSortedCollection			name: label, ' local to ', aClass name			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:16'!browseAllCallsOn: aLiteral localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package	 that refers to aLiteral. For example,		SystemNavigation new browseAllCallsOn: #open:label: localToPackage: 'Tools'."	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self browseMessageList: (self allCallsOn: aLiteral localToPackage: packageNameOrInfo) asSortedCollection			name: label, ' local to package ', (self packageInfoFor: packageNameOrInfo) name			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 5/5/2008 11:43'!browseAllImplementorsOf: selector localTo: aClass	"Create and schedule a message browser on each method in or below the given class	that implements the message whose selector is the argument, selector. For example, 	SystemNavigation new browseAllImplementorsOf: #at:put: localTo: Dictionary."	aClass ifNil: [ ^self inform: 'no class selected' ].	^self browseMessageList: (self allImplementorsOf: selector localTo: aClass) asSortedCollection		name: 'Implementors of ' , selector, ' local to ', aClass name! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:13'!browseAllImplementorsOf: selector localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package	that implements the message whose selector is the argument, selector. For example, 	SystemNavigation new browseAllImplementorsOf: #at:put: localToPackage: 'Collections'."	self browseMessageList: (self								allImplementorsOf: selector								localToPackage: packageNameOrInfo) asSortedCollection		name: 'Implementors of ' , selector,				' local to package ', (self packageInfoFor: packageNameOrInfo) name! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 5/20/2008 11:30'!browseAllMethodsInCategory: category 	^self browseMessageList: (self allMethodsInCategory: category) asSortedCollection		name: 'Methods in category ', category! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 5/19/2008 15:12'!browseAllSelect: aBlock localTo: aClass	"Create and schedule a message browser on each method in or below the given class	 that, when used as the block argument to aBlock gives a true result. For example,  	 SystemNavigation default browseAllSelect: [:m | m numLiterals > 10] localTo: Morph."	aClass ifNil: [^self inform: 'no class selected'].	^self		browseMessageList: (self allMethodsSelect: aBlock localTo: aClass) asSortedCollection		name: 'selected messages local to ', aClass name! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 6/21/2008 11:48'!browseAllStoresInto: instVarName from: aClass	"Create and schedule a Message Set browser for all methods in	 aClass's hierarchy that assign to the instance variable name."		"self new browseAllStoresInto: 'contents' from: Collection."		^self 		browseMessageList: (self allStoresInto: instVarName from: aClass) asSortedCollection 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 12/16/2008 11:08'!browseInstVarDefs: aClass	"Copied from browseInstVarRefs.  Should be consolidated some day. 7/29/96 di	7/30/96 sw: did the consolidation"	"Change to use SystemNavigation  27 March 2003 sd"	aClass chooseInstVarThenDo:			[:aVar |		self browseAllStoresInto: aVar			from: (aClass classThatDefinesInstanceVariable: aVar)]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 12/16/2008 11:08'!browseInstVarRefs: aClass	"1/16/96 sw: moved here from Browser so that it could be used from a variety of places.	 7/30/96 sw: call chooseInstVarThenDo: to get the inst var choice"	aClass chooseInstVarThenDo: 		[:aVar |		self browseAllAccessesTo: aVar			from: (aClass classThatDefinesInstanceVariable: aVar)]! !!SystemNavigation methodsFor: 'browse' stamp: 'ar 7/7/2010 17:31'!browseMethodsWithString: aString matchCase: caseSensitive	"Launch a browser on all methods that contain string literals with aString as a substring. Make the search case-sensitive or insensitive as dictated by the caseSensitive boolean parameter"	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					(lit isString) and:					[lit includesSubstring: aString caseSensitive: caseSensitive]]]		name:  'Methods with string ', aString printString, (caseSensitive ifTrue: [' (case-sensitive)'] ifFalse: [' (case-insensitive)'])		autoSelect: aString.! !!SystemNavigation methodsFor: 'query' stamp: 'eem 1/21/2010 09:49'!allBlockArgumentAssignations	"Answer all methods containing an assignment to a block argument."	"SystemNavigation default		browseMessageList: SystemNavigation default allBlockArgumentAssignations asSortedCollection 		name: 'Assignments to block arguments'"	^self allMethodsSelect:		[:m| | d assignsToBlockArg scanner |		assignsToBlockArg := false.		(d := m blockpcsToBlockExtents) size >= 2 ifTrue:			[scanner := InstructionStream on: m.			d keysDo:				[:interval| | nArgs |				(interval first ~= m initialPC				 and: [(nArgs := m argumentCountForBlockAtPC: interval first) > 0]) ifTrue:					[scanner pc: interval first.					[scanner pc <= interval last] whileTrue:						[[scanner interpretNextInstructionFor: nil]							on: MessageNotUnderstood							do: [:ex|								((#(popIntoTemporaryVariable:									storeIntoTemporaryVariable:) includes: ex message selector)								and: [ex message arguments first + 1 <= nArgs]) ifTrue:									[assignsToBlockArg := true]]]]]].			assignsToBlockArg]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 3/30/2009 14:48'!allCallsOn: firstLiteral and: secondLiteral	"Answer a SortedCollection of all the methods that call on both aLiteral 	and secondLiteral."	| aCollection secondArray firstSpecial secondSpecial firstByte secondByte thorough |	self flag: #ShouldUseAllCallsOn:. "sd"	aCollection := SortedCollection new.	firstSpecial := Smalltalk hasSpecialSelector: firstLiteral ifTrueSetByte: [:b | firstByte := b].	secondSpecial := Smalltalk hasSpecialSelector: secondLiteral ifTrueSetByte: [:b | secondByte := b].	thorough := (firstLiteral isSymbol or: [secondLiteral isSymbol])				and: ["Possibly search for symbols embedded in literal arrays, pragmas etc"					Preferences thoroughSenders].	Cursor wait showWhile:		[self allBehaviorsDo:			[:class |			secondArray := thorough								ifTrue: [class										thoroughWhichSelectorsReferTo: secondLiteral										special: secondSpecial										byte: secondByte]								ifFalse: [class 										whichSelectorsReferTo: secondLiteral										special: secondSpecial										byte: secondByte].			((thorough				ifTrue: [class thoroughWhichSelectorsReferTo: firstLiteral special: firstSpecial byte: firstByte]				ifFalse: [class whichSelectorsReferTo: firstLiteral special: firstSpecial byte: firstByte]) select:				[:aSel | (secondArray includes: aSel)]) do:						[:sel | 							aCollection add: (								MethodReference new									setStandardClass: class 									methodSymbol: sel							)						]		]	].	^aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:42'!allCallsOn: aSymbol localTo: aClass	"Answer a Set of MethodReferences for all the methods	 that call on aSymbol in, above or below the given class."	| aSet special byte enum |	aSet := Set new.	special := Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [:b | byte := b].	enum := [:behavior|			(behavior whichSelectorsReferTo: aSymbol special: special byte: byte) do:				[:sel | aSet add: (MethodReference new setStandardClass: behavior  methodSymbol: sel)]].	aClass theNonMetaClass withAllSuperAndSubclassesDoGently: enum.		aClass theNonMetaClass class withAllSuperAndSubclassesDoGently: enum.	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:47'!allCallsOn: aLiteral localToPackage: packageNameOrInfo	"Answer a Set of MethodReferences for all the methods	 that call on aSymbol in the given package."	| aSet special byte |	aSet := Set new.	special := Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte := b].	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:method |			((method hasLiteral: aLiteral) or: [special and: [method scanFor: byte]]) ifTrue:				[((aLiteral isVariableBinding) not					or: [method literals allButLast includes: aLiteral])						ifTrue: [aSet add: method methodReference]]].].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/5/2008 11:44'!allImplementorsOf: aSelector  localTo: aClass	"Answer a SortedCollection of all the methods that implement the message 	 aSelector in, above, or below the given class."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[aClass theNonMetaClass withAllSuperAndSubclassesDoGently:			[:class |			(class includesSelector: aSelector) ifTrue:				[aSet add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]].		aClass theNonMetaClass class withAllSuperAndSubclassesDoGently:			[:class |			(class includesSelector: aSelector) ifTrue:				[aSet add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]]].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:33'!allImplementorsOf: aSelector  localToPackage: packageNameOrInfo	"Answer a SortedCollection of all the methods that implement the message 	 aSelector in the given package."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:m |			(m selector = aSelector) ifTrue:				[aSet add: m methodReference]]].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/6/2008 14:25'!allMethodsInCategory: category 	| aCollection |	aCollection := Set new.	Cursor wait showWhile:		[self allBehaviorsDo:			[:x |			((category = ClassOrganizer allCategory					ifTrue: [x organization allMethodSelectors]					ifFalse: [x organization listAtCategoryNamed: category])) do:				[:sel | aCollection add: (MethodReference new setStandardClass: x methodSymbol: sel)]]].	^aCollection.	! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/19/2008 14:57'!allMethodsSelect: aBlock localTo: aClass	"Answer a SortedCollection of each methodr in, above, or below the given	 class that, when used as the argument to aBlock, gives a true result."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[aClass theNonMetaClass withAllSuperAndSubclassesDoGently:			[:class |			class selectorsAndMethodsDo:				[:aSelector :aMethod|				(aBlock value: aMethod) ifTrue:					[aSet add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]]].		aClass theNonMetaClass class withAllSuperAndSubclassesDoGently:			[:class |			class selectorsAndMethodsDo:				[:aSelector :aMethod|				(aBlock value: aMethod) ifTrue:					[aSet add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]]]].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:38'!allMethodsSelect: aBlock localToPackage: packageNameOrInfo	"Answer a SortedCollection of each method in the given package	 for which the evaluation of aBlock with the metnod answers true."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:aMethod |			(aBlock value: aMethod) ifTrue:				[aSet add: aMethod methodReference]]].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'ar 8/18/2008 18:08'!allObjectsDo: aBlock 	"Evaluate the argument, aBlock, for each object in the system 	excluding SmallIntegers."	| object endMarker |	object := self someObject.	endMarker := Object new.	[endMarker == object]		whileFalse: [aBlock value: object.			object := object nextObject]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/5/2008 12:16'!allPrimitiveMethods	"Answer a Set of all the methods that are implemented by primitives."	"SystemNavigation default		browseMessageList: SystemNavigation default allPrimitiveMethods asSortedCollection		name: 'All primitive methods'"	| aColl method |	aColl := Set new: 200.	Cursor execute showWhile:		[self allBehaviorsDo:			[:class |			class selectorsDo:				[:sel | 				method := class compiledMethodAt: sel.				(method primitive ~= 0 and: [method isQuick not]) ifTrue:					[aColl add: (MethodReference new									setStandardClass: class									methodSymbol: sel									extraText: method primitive printString)]]]].	^ aColl! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/5/2008 12:25'!allPrimitiveMethodsInCategories: aList 	"Answer an OrderedCollection of all the methods that are implemented by 	 primitives in the given categories"	"SystemNavigation default		browseMessageList: (SystemNavigation new allPrimitiveMethodsInCategories:  								#('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh'))									asSortedCollection		name: 'All primitive methods in Collections-Streams Files-Streams Files-Abstract Files-Macintosh'"	| categories aColl method |	categories := (aList select: [:str| | sym |								(sym := Symbol findInterned: str) notNil								and: [SystemOrganization categories includes: sym]])						collect: [:str| str asSymbol].	aColl := Set new: 200.	Cursor execute showWhile:		[self allBehaviorsDo:			[:class |			(categories includes: class theNonMetaClass category) ifTrue:				[class selectorsDo:					[:sel | 					method := class compiledMethodAt: sel.					(method primitive ~= 0 and: [method isQuick not]) ifTrue:						[aColl add: (MethodReference new										setStandardClass: class										methodSymbol: sel										extraText: method primitive printString)]]]]].	^aColl! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/5/2008 12:26'!allSelect: aBlock 	"Answer a Set of each method that, when used as the block  	 argument to aBlock, gives a true result."	| aCollection |	aCollection := Set new.	Cursor execute showWhile:		[self allBehaviorsDo:			[:class |			class selectorsDo:				[:sel |				(aBlock value: (class compiledMethodAt: sel)) ifTrue:					[aCollection add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^aCollection! !!SystemNavigation methodsFor: 'query' stamp: 'eem 7/2/2010 17:17'!obsoleteClasses   	"SystemNavigation default obsoleteClasses inspect"	"NOTE:  Also try inspecting comments below"	| obs |	obs := OrderedCollection new.  Smalltalk garbageCollect.	Metaclass allInstancesDo:		[:m | | c |		c := m soleInstance.		(c ~~ nil and: ['AnOb*' match: c name asString])			ifTrue: [obs add: c]].	^ obs asArray"Likely in a ClassDict or Pool...(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray""Obsolete class refs or super pointer in last lit of a method...| n l found |SystemNavigation default browseAllSelect:	[:m | found := false.	1 to: m numLiterals do:		[:i | (((l := m literalAt: i) isMemberOf: Association)				and: [(l value isKindOf: Behavior)				and: ['AnOb*' match: l value name]])			ifTrue: [found := true]].	found]"! !!SystemNavigation methodsFor: 'ui' stamp: 'eem 7/5/2008 11:03'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: aCaption	"Show a sorted menu of the given selectors, preceded by firstItem, and all abbreviated to 40 characters.  Use aCaption as the menu title, if it is not nil.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList |	sortedList := selectorCollection asSortedCollection.	menuLabels := (sortedList asOrderedCollection collect: [:sel | sel contractTo: 40])						addFirst: (firstItem contractTo: 40);						yourself.	index := UIManager default chooseFrom: menuLabels lines: #(1).	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index - 1)]! !!SystemNavigation methodsFor: 'private' stamp: 'eem 8/30/2010 11:02'!headingAndAutoselectForLiteral: aLiteral do: binaryBlock	"Evaluate aBlock with either Users of ... or Senders of ... plus the auto-select string	 for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."	| autoSelect |	^aLiteral isSymbol		ifTrue: [binaryBlock value: 'Senders of ', aLiteral value: aLiteral keywords first]		ifFalse:			[autoSelect := aLiteral isVariableBinding							ifTrue: [aLiteral key]							ifFalse: [aLiteral printString].			binaryBlock value: 'Users of ', autoSelect value: autoSelect]! !!SystemNavigation methodsFor: 'private' stamp: 'eem 8/30/2010 10:34'!packageInfoFor: packageInfoOrString	^packageInfoOrString isString		ifTrue: [PackageInfo named: packageInfoOrString]		ifFalse: [packageInfoOrString]! !!SystemVersion class methodsFor: 'updating' stamp: 'ar 4/1/2007 12:59'!check: pluginVersion andRequestPluginUpdate: updateURL	"SystemVersion check: 'zzz' andRequestPluginUpdate: 'http://www.squeakland.org/installers/update.html' "	"We don't have a decent versioning scheme yet, so we are basically checking for a nil VM version on the mac."	(self pluginVersion: pluginVersion newerThan: self currentPluginVersion)		ifFalse: [^true].	(self confirm: 'There is a newer plugin version available. Do you want to install it now?')		ifFalse: [^false].	HTTPClient		requestURL: updateURL , (Smalltalk platformName copyWithout: Character space) asLowercase , '.html'		target: '_top'.	^false! !!SystemVersion class methodsFor: 'updating' stamp: 'ar 4/1/2007 12:59'!checkAndApplyUpdates: availableUpdate	"SystemVersion checkAndApplyUpdates: nil"	^(availableUpdate isNil		or: [availableUpdate > SystemVersion current highestUpdate])		ifTrue: [			(self confirm: 'There are updates available. Do you want to install them now?')				ifFalse: [^false].			Utilities				readServerUpdatesThrough: availableUpdate				saveLocally: false				updateImage: true.			Smalltalk snapshot: true andQuit: false.			true]		ifFalse: [false]! !!SystemVersion class methodsFor: 'updating' stamp: 'ar 4/1/2007 12:59'!currentPluginVersion	^Smalltalk vmVersion! !!SystemVersionTest methodsFor: 'as yet unclassified' stamp: 'tlk 11/14/2004 10:55'!testMajorMinorVersion	"	SystemVersionTest run: #testMajorMinorVersion	"	self assert: (SystemVersion new version: 'Squeak3.7alpha') majorMinorVersion = 'Squeak3.7'.	self assert: (SystemVersion new version: 'Squeak3.7') majorMinorVersion = 'Squeak3.7'.	self assert: (SystemVersion new version: 'Squeak3') majorMinorVersion = 'Squeak3'.	self assert: (SystemVersion new version: '') majorMinorVersion = ''.! !!SystemVersionTest commentStamp: 'tlk 11/14/2004 10:47' prior: 0!I am an sunit test for SystemVersion.  Originally created to test SqueakMapSystemVersionFix change set.I have no test fixtures.!!SystemWindow methodsFor: 'initialization' stamp: 'eem 7/6/2010 13:37'!addPaneSplitters	allowPaneSplitters == false ifTrue: [^self]. "Safety for uninitialized var"	self removePaneSplitters.	self removeCornerGrips.		self addCornerGrips.	self addPaneVSplitters.	self addPaneHSplitters.		self linkSubmorphsToSplitters! !!SystemWindow methodsFor: 'initialization' stamp: 'eem 7/6/2010 13:29'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowPaneSplitters := true.	labelString ifNil: [labelString := 'Untitled Window'].	isCollapsed := false.	activeOnlyOnTop := true.	paneMorphs := Array new.	borderColor := Color lightGray.	borderWidth := 1.	self color: Color veryVeryLightGray muchLighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose := false.	updatablePanes := Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'object fileIn' stamp: 'eem 7/6/2010 13:29'!convertToCurrentVersion: varDict refStream: smartRefStrm		allowPaneSplitters ifNil: [allowPaneSplitters := true].	self layoutPolicy ifNil: [self convertAlignment].	labelArea ifNil: [self convertAlignment].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 5/23/2008 13:17'!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^self].	model okToClose ifFalse: [^self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		 (thisWorld notNil 		  and: [(aPaintBox := thisWorld paintBoxOrNil) notNil]) ifTrue:			[aPaintBox delete]].			SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'eem 7/6/2010 13:28'!allowPaneSplitters	^ allowPaneSplitters! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'eem 7/6/2010 13:28'!allowPaneSplitters: aBoolean	allowPaneSplitters := aBoolean! !!SystemWindow commentStamp: '<historical>' prior: 0!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!TTCFont methodsFor: 'accessing' stamp: 'ar 1/24/2008 15:08'!textStyle	^textStyle ifNil:[textStyle := TextStyle actualTextStyles detect:									[:aStyle | aStyle fontArray includes: self] ifNone: [nil]]! !!TTCFont methodsFor: 'friend' stamp: 'ar 8/10/2007 14:37'!derivativeFont: aTTCFont	| index |	index := self indexOfSubfamilyName: (aTTCFont subfamilyName).	index < 1 ifTrue: [		Transcript cr; show: aTTCFont name.		Transcript cr; show: aTTCFont subfamilyName,': unknown sub family name.  This font will be skipped'.		^self	].	self derivativeFont: aTTCFont at: index.	self addLined: aTTCFont.! !!TTCFont methodsFor: 'private' stamp: 'ar 9/1/2010 20:06'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: self ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TempVariableNode methodsFor: 'testing' stamp: 'eem 8/14/2010 11:02'!isDeclaredAtMethodLevel	"For the explainer."	^scope = 0! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:22'!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:54'!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:23'!sizeCodeForLoad: encoder	^remoteNode isNil		ifTrue: [0]		ifFalse: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:51'!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 13:10'!timeout: seconds	"The timeout for a test should normally be set with a method annotation.	However, for tests that are expected to run in images that do not support	method annotations, the value may be set by setting the value from the	#setUp method (i.e. prior to running the test method)."	timeout := seconds! !!TestCase methodsFor: 'accessing' stamp: 'ar 8/5/2010 17:13'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	method ifNotNil:[		(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	].	^self defaultTimeout! !!TestCase methodsFor: 'accessing' stamp: 'ar 8/5/2010 17:13'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	method ifNotNil:[		(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	].	^timeout ifNil: [self defaultTimeout]! !!TestCase methodsFor: 'running' stamp: 'dtl 6/6/2010 15:10'!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout: [self setUp]		after: self timeoutForSetUp.	self timeout: [self performTest]		after: self timeoutForTest]		ensure: [self tearDown]! !!TestCase methodsFor: 'running' stamp: 'ar 7/9/2010 11:31'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error, Halt do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!TestCase class methodsFor: '*sunitgui' stamp: 'lr 4/12/2009 00:27'!packageNamesUnderTest	"Answer a collection of package names under test. This is used by the test runner to automatically instrument the code in these packages when checking for test coverage."		^ #()! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 20:26'!doesNotUnderstand: aMessage	^ method perform: aMessage selector withArguments: aMessage arguments! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:26'!flushCache! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:21'!mark	hasRun := true! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:27'!reference	^ reference! !!TestCoverage methodsFor: 'testing' stamp: 'lr 3/30/2009 15:09'!hasRun	^ hasRun! !!TestCoverage methodsFor: 'initialization' stamp: 'lr 3/30/2009 15:19'!initializeOn: aMethodReference	hasRun := false.	reference := aMethodReference.	method := reference compiledMethod! !!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:20'!install	reference actualClass methodDictionary		at: reference methodSymbol		put: self! !!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:31'!uninstall	reference actualClass methodDictionary		at: reference methodSymbol		put: method! !!TestCoverage methodsFor: 'evaluation' stamp: 'lr 3/30/2009 15:32'!run: aSelector with: anArray in: aReceiver	self mark; uninstall.	^ aReceiver withArgs: anArray executeMethod: method! !!TestCoverage class methodsFor: 'instance creation' stamp: 'lr 3/30/2009 15:23'!on: aMethodReference	^ self new initializeOn: aMethodReference! !!TestFailure methodsFor: 'camp smalltalk' stamp: 'eem 9/10/2009 13:06'!isResumable		^true! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!initialize	super initialize.	outOfWorldCount := intoWorldCount := 0.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:03'!intoWorld: aWorld	aWorld ifNil:[^self].	super intoWorld: aWorld.	intoWorldCount := intoWorldCount + 1.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!intoWorldCount	^intoWorldCount! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:03'!outOfWorld: aWorld	aWorld ifNil:[^self].	super outOfWorld: aWorld.	outOfWorldCount := outOfWorldCount + 1.! !!TestInWorldMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2003 00:06'!outOfWorldCount	^outOfWorldCount! !!TestInWorldMorph commentStamp: 'sd 6/5/2005 10:25' prior: 0!Helper class for MorphTest!!TestIndenting methodsFor: 'running' stamp: 'mha 10/12/2009 10:15'!setUp	| text style |	text := 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	style := (TextStyle named: #Accuny) copy.	style defaultFontIndex: 2. "Default to Accuny12 as expected by tests."	para := text asParagraph textStyle: style! !!TestIndenting methodsFor: 'testing' stamp: 'tlk 5/7/2006 17:14'!testBreakAtSpaceLeavesSpaceOnOriginalLine	"When an indented line is broken at a space, the character block must still lie in the line crossing the right margin."	| cb |	para compositionRectangle: (0@0 extent: para width - 24 @100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 7.	self assert: cb top = 0.	self assert: cb left >= 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 14:41'!testCR2	"Checks whether the drawing of indented text is really indented..."	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: (para asForm copy: (0@cb top extent: 24@cb height)) isAllWhite! !!TestIndenting methodsFor: 'testing' stamp: 'hmm 2/2/2001 15:17'!testCR3	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 11 to: 11 with: (Text string: (String with: Character cr) attribute: (TextIndent tabs: 1)) displaying: false.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 12.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'tlk 5/7/2006 16:52'!testNewLineAndTabProvidesDoubleIndent	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 11 to: 11 with: (Text string: (String with: Character cr) attribute: (TextIndent tabs: 1)) displaying: false. 	cb := para characterBlockForIndex: 12.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'tlk 5/7/2006 16:52'!testNewLineLeaveSpacesOnOldLine	"Checks whether the drawing of indented text is really indented..."	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false.	cb := para characterBlockForIndex: 8.	self assert: (para asForm copy: (0@cb top extent: 24@cb height)) isAllWhite! !!TestIndenting methodsFor: 'testing' stamp: 'tlk 5/7/2006 16:53'!testNewLineStartsIndented	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para replaceFrom: 7 to: 7 with: (String with: Character cr) displaying: false. 	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'mha 10/12/2009 10:19'!testNewLineStartsIndentedWhenWrapped	"Checks whether the beginning of a new line starts at the indented position"	| cb |	para compositionRectangle: (0@0 extent: para width - 24@100); updateCompositionHeight.	para clippingRectangle: (0@0 extent: 200@200).	cb := para characterBlockForIndex: 8.	self assert: cb top > 0.	self assert: cb left = 24! !!TestIndenting methodsFor: 'testing' stamp: 'tlk 5/7/2006 16:36'!testSetUp	"just reminding us all what the paragraph looks like to begin with. assuming Accuny12 font "	| cb |		cb := para characterBlockForIndex: 1.  "p"	self assert: cb top = 0.	self assert: cb left = 0.	self assert: cb right = 7.			cb := para characterBlockForIndex: 2.  "the tab"	self assert: cb top = 0.	self assert: cb left = 7.	self assert: cb right = 24.		cb := para characterBlockForIndex: 3.  "w" 	self assert: cb top = 0.	self assert: cb left = 24.	self assert: cb right = 34.		cb := para characterBlockForIndex: 7.  " " "between word and word"	self assert: cb top = 0.	self assert: cb left = 52.	self assert: cb right = 57.		cb := para characterBlockForIndex: 11.  "d" "last char"	self assert: cb top = 0.	self assert: cb left = 79.	self assert: cb right = 85.			! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph := TextMorph new contents: 'i i'.	morph fit.	para := morph paragraph! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingAll	^super testCharacterBlockAfterReplacingAll! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingOther	^super testCharacterBlockAfterReplacingOther! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:42'!testCharacterBlockAfterReplacingSpace	^super testCharacterBlockAfterReplacingSpace! !!TestNewParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 17:43'!testCharacterBlockNormal	^super testCharacterBlockNormal! !!TestNewParagraphFix commentStamp: '<historical>' prior: 0!This class tests the same things as its superclass, but for NewParagraph which is used in the Morphic environment.!!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:42'!expectedFailures	"Does crash VM with Cog"	^Smalltalk isRunningCogit		ifTrue:[#(testAddNumbers testDNU testAnswer42)]		ifFalse:[#()]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43'!testAddNumbers 	"self debug: #testAddNumbers"	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class basicRemoveSelector: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43'!testAnswer42 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.	self assert: self answer42 = 42.	self class basicRemoveSelector: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43'!testDNU 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: AbstractObjectsAsMethod new.	self should: [self answer42] raise: MessageNotUnderstood.	self class basicRemoveSelector: #answer42.! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para := 'i i' asParagraph! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:52'!testCharacterBlockAfterReplacingAll	para replaceFrom: 1 to: 3 with: 'mmm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingOther	para replaceFrom: 3 to: 3 with: 'm' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockAfterReplacingSpace	para replaceFrom: 3 to: 3 with: ' ' displaying: false.	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix methodsFor: 'tests' stamp: 'hmm 10/1/2000 15:05'!testCharacterBlockNormal	self assert: (para characterBlockForIndex: 4) stringIndex = 4! !!TestParagraphFix commentStamp: '<historical>' prior: 0!This class tests whether locating characters past the end of a text is possible in all cases.!!TestRunner methodsFor: 'actions' stamp: 'nice 10/20/2009 21:08'!addDeclaredPackagesUnderTestTo: packages 	classesSelected do: 		[ :class | 		(class class includesSelector: #packageNamesUnderTest) ifTrue: 			[ class packageNamesUnderTest do: [ :name | packages add: (PackageInfo named: name) ] ] ]! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:40'!addMethodsUnderTestIn: packages to: methods 	packages		do: [:package | package isNil				ifFalse: [package methods						do: [:method | ((#(#packageNamesUnderTest #classNamesNotUnderTest ) includes: method methodSymbol)									or: [method compiledMethod isAbstract											or: [method compiledMethod refersToLiteral: #ignoreForCoverage]])								ifFalse: [methods add: method]]]]! !!TestRunner methodsFor: 'actions' stamp: 'cmm 2/17/2010 22:03'!collectCoverageFor: methods	| wrappers suite |	wrappers := methods collect: [ :each | TestCoverage on: each ].	suite := self		reset;		suiteAll.		[ wrappers do: [ :each | each install ].	[ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.	wrappers := wrappers reject: [ :each | each hasRun ].	wrappers isEmpty 		ifTrue: 			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]		ifFalse: 			[ ToolSet 				browseMessageSet: (wrappers collect: [ :each | each reference ])				name: 'Not Covered Code (' , (100 - (100 * wrappers size // methods size)) printString , '% Code Coverage)'				autoSelect: nil ].	self saveResultInHistory! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:42'!debug: aTestCase	self debugSuite: (TestSuite new		addTest: aTestCase; 		yourself).! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:01'!debugSuite: aTestSuite	self basicRunSuite: aTestSuite do: [ :each | each debug ].! !!TestRunner methodsFor: 'actions' stamp: 'nice 12/27/2009 03:12'!excludeClassesNotUnderTestFrom: methods 		classesSelected do: 		[ :class | 		(class class includesSelector: #classNamesNotUnderTest) ifTrue: 			[ class classNamesNotUnderTest do: 				[ :className | | theClass | 				theClass := Smalltalk classNamed: className.				theClass ifNotNil:[				theClass methods do: 					[ :each | 					methods 						remove: each methodReference						ifAbsent: [  ] ].				theClass class methods do: 					[ :each | 					methods 						remove: each methodReference						ifAbsent: [  ] ]] ] ] ]! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:11'!promptForPackages	| packages |	packages := (PackageOrganizer default packages				reject: [:package | (package packageName beginsWith: 'Kernel')						or: [(package packageName beginsWith: 'Collections')								or: [(package packageName beginsWith: 'Exceptions')										or: [(package packageName beginsWith: 'SUnit')												or: [(package packageName beginsWith: 'System')														or: [package packageName includesSubstring: 'Test' caseSensitive: false]]]]]])				sort: [:a :b | a packageName < b packageName].	packages := Array				with: (UIManager default						chooseFrom: (packages								collect: [:package | package packageName])						values: packages						title: 'Select Package').	^ packages! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/8/2005 22:52'!reset	self result: TestResult new; updateResults.! !!TestRunner methodsFor: 'actions' stamp: 'simon.denier 11/13/2008 19:34'!runAll	self reset; runSuite: self suiteAll.	self saveResultInHistory! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:15'!runCoverage	| packages methods |	packages := Set new.	self addDeclaredPackagesUnderTestTo: packages.	packages isEmpty ifTrue: 		[ packages := self promptForPackages ].	methods := OrderedCollection new.	self 		addMethodsUnderTestIn: packages		to: methods.	self excludeClassesNotUnderTestFrom: methods.	methods isEmpty ifTrue: 		[ ^ UIManager default inform: 'No methods found for coverage analysis.' ].	self collectCoverageFor: methods! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/8/2005 23:02'!runErrors	self result instVarNamed: 'errors' put: OrderedCollection new.	self runSuite: self suiteErrors.! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/27/2005 10:42'!runFailures	self result instVarNamed: 'failures' put: Set new.	self runSuite: self suiteFailures.! !!TestRunner methodsFor: 'actions' stamp: 'lr 10/31/2005 17:13'!runProfiled	MessageTally spyOn: [ self runAll ].! !!TestRunner methodsFor: 'actions' stamp: 'lr 3/30/2009 14:50'!runSuite: aTestSuite	self basicRunSuite: aTestSuite do: [ :each | self runTest: each ].	self updateResults! !!TestRunner methodsFor: 'actions' stamp: 'lr 11/3/2005 09:15'!runTest: aTestCase	aTestCase run: result.	self updateStatus: true.! !!TestRunner methodsFor: 'accessing' stamp: 'lr 10/31/2005 15:31'!baseClass	^ TestCase! !!TestRunner methodsFor: 'accessing' stamp: 'lr 11/3/2005 09:37'!suiteAll	^ TestSuite new in: [ :suite |		classesSelected do: [ :each | 			each isAbstract 				ifFalse: [ each addToSuiteFromSelectors: suite ] ].		suite name: (self label: 'Test' forSuite: suite) ].! !!TestRunner methodsFor: 'accessing' stamp: 'lr 10/27/2005 10:29'!suiteErrors	^ TestSuite new in: [ :suite |		suite 			addTests: errorList; 			name: (self label: 'Error' forSuite: suite) ].! !!TestRunner methodsFor: 'accessing' stamp: 'lr 10/27/2005 10:42'!suiteFailures	^ TestSuite new in: [ :suite |		suite 			addTests: failedList; 			name: (self label: 'Failure' forSuite: suite) ].! !!TestRunner methodsFor: 'processing' stamp: 'lr 10/31/2005 17:43'!basicRunSuite: aTestSuite do: aBlock	self basicSetUpSuite: aTestSuite.	[ aTestSuite name isEmptyOrNil		ifTrue: [ aTestSuite tests do: aBlock ]		ifFalse: [ aTestSuite tests do: aBlock displayingProgress: aTestSuite name ] ]			ensure: [ self basicTearDownSuite: aTestSuite ].	! !!TestRunner methodsFor: 'processing' stamp: 'lr 10/27/2005 10:04'!basicSetUpSuite: aTestSuite	aTestSuite resources do: [ :each |		each isAvailable			ifFalse: [ each signalInitializationError ] ].! !!TestRunner methodsFor: 'processing' stamp: 'lr 10/27/2005 10:04'!basicTearDownSuite: aTestSuite	aTestSuite resources do: [ :each | each reset ].! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:49'!browseClass	(classes at: classIndex ifAbsent: [ ^ self ]) browse! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 10/8/2005 19:58'!classAt: anInteger	^ classesSelected includes: (classes at: anInteger ifAbsent: [ ^ false ]).! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 11/21/2005 13:19'!classAt: anInteger put: aBoolean	classesSelected := classesSelected		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])		with: (classes at: anInteger ifAbsent: [ ^ self ]).	self changed: #classSelected; changed: #hasRunnable.! !!TestRunner methodsFor: 'accessing-classes' stamp: 'nice 12/27/2009 03:12'!classList	| offset |	classes isEmpty ifTrue: [ ^ classes ].	offset := classes first allSuperclasses size.	^ classes collect: [ :each | | ident |		ident := String 			new: 2 * (0 max: each allSuperclasses size - offset) 			withAll: $ .		each isAbstract			ifFalse: [ ident , each name ]			ifTrue: [ 				ident asText , each name asText 					addAttribute: TextEmphasis italic;					yourself ] ].! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:45'!classMenu: aMenu	^ aMenu		title: 'Classes';		add: 'Browse' action: #browseClass;		addLine;		add: 'Select all' action: #selectAllClasses;		add: 'Select subclasses' action: #selectSubclasses;		add: 'Select inversion' action: #selectInverseClasses;		add: 'Select none' action: #selectNoClasses;		addLine;		add: 'Filter...' action: #filterClasses;		addLine;		add: 'Refresh' action: #updateClasses;		yourself.! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:46'!classSelected	^ classIndex! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:48'!classSelected: anInteger	classIndex := anInteger.	self changed: #classSelected! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 7/4/2009 15:10'!filterClasses	| pattern |	pattern := UIManager default 		request: 'Pattern to select tests:' 		initialAnswer: '*'.	pattern isNil ifTrue: [ ^ self ].	classesSelected := (classes select: [ :each | 		pattern match: each name ]) asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectAllClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := classes asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectInverseClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := classes asSet 		removeAll: classesSelected;		yourself.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 11:59'!selectNoClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := Set new.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectSubclasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		| classesForPackages |	classesForPackages := self findClassesForCategories: categoriesSelected.		classesSelected := (classesSelected gather: [ :class |		class withAllSubclasses select: [ :each |			classesForPackages includes: each ] ])		asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'private' stamp: 'lr 11/21/2005 13:36'!browserEnvironment	^ Smalltalk classNamed: #BrowserEnvironment.! !!TestRunner methodsFor: 'private' stamp: 'tfel 2/27/2010 22:06'!defaultBackgroundColor	"<lint: #expect rule: #overridesSuper rational: 'we want a different color than the parent'>"	^ Preferences testRunnerWindowColor! !!TestRunner methodsFor: 'private' stamp: 'lr 10/27/2005 10:32'!label: aString forSuite: aTestSuite	^ String streamContents: [ :stream |		stream nextPutAll: 'Running '; print: aTestSuite tests size; space; nextPutAll: aString.		aTestSuite tests size > 1 ifTrue: [ stream nextPut: $s ] ]. ! !!TestRunner methodsFor: 'private' stamp: 'lr 12/21/2005 10:39'!perform: selector orSendTo: otherTarget	"<lint: #expect rule: #badMessage rational: 'this is a common morphic pattern'>"		^ (self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ super perform: selector orSendTo: otherTarget ].! !!TestRunner methodsFor: 'private' stamp: 'lr 3/22/2006 19:26'!windowIsClosing	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self! !!TestRunner methodsFor: 'building' stamp: 'lr 11/21/2005 13:22'!buildButtonsWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self buttons collect: [ :each |			aBuilder pluggableButtonSpec new				model: self; 				label: each first;				action: each second;				enabled: each third;				yourself ]);		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/31/2005 15:12'!buildCategoriesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #categoryList;		menu: #categoryMenu:;		getIndex: #categorySelected;		setIndex: #categorySelected:;		getSelectionList: #categoryAt:;		setSelectionList: #categoryAt:put:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/17/2005 09:13'!buildClassesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #classList;		menu: #classMenu:;		getIndex: #classSelected;		setIndex: #classSelected:;		getSelectionList: #classAt:;		setSelectionList: #classAt:put:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!buildErrorListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Error List';		list: #errorList; 		menu: #errorMenu:;		getIndex: #errorSelected; 		setIndex: #errorSelected:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!buildFailureListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Failure List';		list: #failedList; 		menu: #failureMenu:;		getIndex: #failedSelected; 		setIndex: #failedSelected:;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:05'!buildStatusWith: aBuilder	^ aBuilder pluggableInputFieldSpec new		model: self;		menu: #statusMenu:;		color: #statusColor;		getText: #statusText;		yourself.! !!TestRunner methodsFor: 'building' stamp: 'lr 10/31/2005 15:12'!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildCategoriesWith: aBuilder)				frame: (0.00 @ 0.00 corner: 0.25 @ 0.92 );				yourself);			add: ((self buildClassesWith: aBuilder)				frame: (0.25 @ 0.00 corner: 0.50 @ 0.92 );				yourself);			add: ((self buildStatusWith: aBuilder)				frame: (0.50 @ 0.00 corner: 1.00 @ 0.08);				yourself);			add: ((self buildFailureListWith: aBuilder)				frame: (0.50 @ 0.08 corner: 1.00 @ 0.50);				yourself);			add: ((self buildErrorListWith: aBuilder)				frame: (0.50 @ 0.50 corner: 1.00 @ 0.92);				yourself);			add: ((self buildButtonsWith: aBuilder)				frame: (0.00 @ 0.92 corner: 1.00 @ 1.00);				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 3/30/2009 14:42'!buttons	^ #(( 'Run Selected' #runAll #hasRunnable )		( 'Run Profiled' #runProfiled #hasRunnable )		( 'Run Coverage' #runCoverage #hasRunnable )		( 'Run Failures' #runFailures #hasFailures )		( 'Run Errors' #runErrors #hasErrors ))! !!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 10/8/2005 18:39'!extent	^ 640 @ 480! !!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 1/20/2006 13:36'!label	^ 'Test Runner' ! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:09'!categoryAt: anIndex	^ categoriesSelected includes: (categories at: anIndex ifAbsent: [ ^ false ]).! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:51'!categoryAt: anInteger put: aBoolean	categoriesSelected := categoriesSelected		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])		with: (categories at: anInteger ifAbsent: [ ^ self ]).	self changed: #categorySelected; updateClasses.! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:10'!categoryList	^ categories! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 11/1/2005 19:25'!categoryMenu: aMenu	^ aMenu		title: 'Categories';		add: 'Select all' action: #selectAllCategories;		add: 'Select inversion' action: #selectInverseCategories;		add: 'Select none' action: #selectNoCategories;		addLine;		add: 'Filter...' action: #filterCategories;		addLine;		add: 'Refresh' action: #updateCategories;		yourself.! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:11'!categorySelected	^ 0! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:12'!categorySelected: anInteger	self changed: #categorySelected.! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!filterCategories	| pattern |	pattern := UIManager default 		request: 'Pattern to select categories:' 		initialAnswer: '*'.	pattern isNil ifTrue: [ ^ self ].	categoriesSelected := (categories 		select: [ :each | pattern match: each ]) asSet.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectAllCategories	categoriesSelected := categories asSet.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectInverseCategories	categoriesSelected := categories asSet 		removeAll: categoriesSelected;		yourself.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectNoCategories	categoriesSelected := Set new.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:37'!errorList	^ errorList collect: [ :each | each printString ].! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 19:46'!errorSelected	^ errorList indexOf: errorSelected.! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/27/2005 10:37'!errorSelected: anInteger	errorSelected := errorList at: anInteger ifAbsent: nil.	self changed: #errorSelected.	errorSelected ifNotNil: [ self debug: errorSelected ].! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:37'!failedList	^ failedList collect: [ :each | each printString ].! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 19:47'!failedSelected	^ failedList indexOf: failedSelected.! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 20:14'!failedSelected: anInteger	failedSelected := failedList at: anInteger ifAbsent: nil.	self changed: #failedSelected.	failedSelected ifNotNil: [ self debug: failedSelected ].! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/6/2005 15:47'!result	^ result! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:47'!result: aResult	result := aResult! !!TestRunner methodsFor: 'accessing-testing' stamp: 'laza 9/7/2009 15:11'!statusColor	result hasErrors 		ifTrue: [ ^ Color red ].	result hasFailures 		ifTrue:[ ^ Color yellow ].	^ Color green! !!TestRunner methodsFor: 'accessing-testing' stamp: 'lr 10/8/2005 22:45'!statusText	^ result printString.! !!TestRunner methodsFor: 'accessing-menu' stamp: 'lr 10/21/2008 18:10'!errorMenu: aMenu	^ self statusMenu: aMenu! !!TestRunner methodsFor: 'accessing-menu' stamp: 'lr 10/21/2008 18:05'!failureMenu: aMenu	^ aMenu! !!TestRunner methodsFor: 'accessing-menu' stamp: 'simon.denier 11/13/2008 19:43'!statusMenu: aMenu	^ aMenu		add: 'History' action: #showHistoryMenu;		add: 'Store result as progress reference' action: #storeResultIntoTestCases;		add: 'Show progress' action: #showProgress; 		yourself! !!TestRunner methodsFor: 'utilities' stamp: 'ul 12/12/2009 14:05'!findCategories	| visible |	visible := Set new.	self baseClass withAllSubclassesDo: [ :each |		each category ifNotNil: [ :category |			visible add: category ] ].	^ Array streamContents: [ :stream |		Smalltalk organization categories do: [ :each |			(visible includes: each)				ifTrue: [ stream nextPut: each ] ] ].! !!TestRunner methodsFor: 'utilities' stamp: 'klub 2/20/2010 15:24'!findClassesForCategories: aCollection	| items |	aCollection isEmpty 		ifTrue: [ ^ self baseClass withAllSubclasses asSet ].	items := aCollection gather: [ :category |		((Smalltalk organization listAtCategoryNamed: category)			collect: [ :each | Smalltalk at: each ])			select: [ :each | each includesBehavior: self baseClass ] ].	^ items asSet.! !!TestRunner methodsFor: 'utilities' stamp: 'lr 10/10/2005 08:43'!sortClass: aFirstClass before: aSecondClass	| first second |	first := aFirstClass withAllSuperclasses reversed.	second := aSecondClass withAllSuperclasses reversed.	1 to: (first size min: second size) do: [ :index | 		(first at: index) == (second at: index)			ifFalse: [ ^ (first at: index) name <= (second at: index) name ] ].	^ second includes: aFirstClass.! !!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!hasErrors	^ result hasErrors.! !!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!hasFailures	^ result hasFailures.! !!TestRunner methodsFor: 'testing' stamp: 'lr 11/21/2005 13:19'!hasRunnable	^ classesSelected notEmpty.! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 19:41'!hasHistory	self flag: #Useless. "No Senders?"	^ true! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 20:28'!hasProgress	result classesTested do: [:cls |		(cls class methodDictionary includesKey: #lastStoredRun)			ifTrue: [^ true]].	^ false! !!TestRunner methodsFor: 'history saving' stamp: 'GwenaelCasaccio 10/1/2008 22:00'!hasResults	^ result notNil! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/1/2008 12:00'!historyMenuList	^ {'** save current result **'}, (self previousRun collect: [:ts | ts printString])! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/1/2008 11:46'!previousRun	^ previousRun ifNil: [ previousRun := OrderedCollection new ]! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 19:36'!saveResultInHistory	result dispatchResultsIntoHistory! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/12/2008 11:55'!showDiffWith: aTestResult	| string diff |	diff := result diff: aTestResult.	string := String streamContents: [:str|		str nextPutAll: '----------------'; cr.		str nextPutAll: 'Diff between current result with: ', aTestResult asString; cr.		str nextPutAll: 'New passed: '.		diff first do: [:s| str nextPutAll: s printString, ' '].		str cr.		str nextPutAll: 'New failures: '.		diff second do: [:s| str nextPutAll: s printString, ' '].		str cr.				str nextPutAll: 'New errors: '.		diff third do: [:s| str nextPutAll: s printString, ' '].		str cr].		Workspace new contents: string; openLabel: 'SUnit Progress'	! !!TestRunner methodsFor: 'history saving' stamp: 'stephane.ducasse 10/12/2008 19:24'!showHistoryMenu	| selectionIndex selectedPreviousResult actionIndex |	selectionIndex := UIManager default chooseFrom: self historyMenuList title: 'History:'.	"We pressed outside the menu"	selectionIndex isZero ifTrue: [ ^ self ]. 					"save current result is selected"	selectionIndex = 1 ifTrue: [ self previousRun addFirst: result. ^ self ]. 				selectedPreviousResult := self previousRun at: (selectionIndex - 1). 	actionIndex := (UIManager default chooseFrom: #('delete' 'show diff')  title:  'Action:').	actionIndex = 1 ifTrue: [ self previousRun remove: selectedPreviousResult. ^ self ].	actionIndex = 2 ifTrue: [ self showDiffWith: selectedPreviousResult].	! !!TestRunner methodsFor: 'history saving' stamp: 'nice 12/27/2009 03:12'!showProgress	| testCaseClasses d string |	testCaseClasses := (self suiteAll tests collect: [:testCase | testCase class]) asSet.		"At the end of the algorithm, d will contains all the diff between what was saved and the current result"	d := Dictionary new.	d at: #passed put: OrderedCollection new.	d at: #failures put: OrderedCollection new.	d at: #errors put: OrderedCollection new.	testCaseClasses do: [ :cls | | t |		(cls class methodDict includesKey: #lastStoredRun)			ifTrue: [t := cls lastStoredRun.					(t at: #passed) do: [:s | 												(result isErrorFor: cls selector: s)												ifTrue: [(d at: #errors) add: {cls . s}].											(result isFailureFor: cls selector: s)												ifTrue: [(d at: #failures) add: {cls . s}]  ].																(t at: #failures) do: [:s | (result isPassedFor: cls selector: s)												ifTrue: [(d at: #passed) add: {cls . s}].											(result isErrorFor: cls selector: s)												ifTrue: [(d at: #errors) add: {cls . s}]].																(t at: #errors) do: [:s | 	(result isPassedFor: cls selector: s)												ifTrue: [(d at: #passed) add: {cls . s}].											(result isFailureFor: cls selector: s)												ifTrue: [(d at: #failures) add: {cls . s}]]]].						string := String streamContents: [:str|		str nextPutAll: '----------------'; cr.		str nextPutAll: 'Diff between current result and saved result'; cr.		str nextPutAll: 'New passed: '.		(d at: #passed) do: [:s| str nextPutAll: s printString, ' '].		str cr.		str nextPutAll: 'New failures: '.		(d at: #failures) do: [:s| str nextPutAll: s printString, ' '].		str cr.				str nextPutAll: 'New errors: '.		(d at: #errors) do: [:s| str nextPutAll: s printString, ' '].		str cr].		Workspace new contents: string; openLabel: 'SUnit Progress' string.	! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 20:28'!storeResultIntoTestCases	result classesTested do: [:testCaseCls | testCaseCls generateLastStoredRunMethod ]! !!TestRunner methodsFor: 'initialization' stamp: 'lr 3/22/2006 19:36'!initialize	super initialize.	failedList := errorList := Array new.	SystemChangeNotifier uniqueInstance 		notify: self ofSystemChangesOfItem: #class change: #Added using: #update;		notify: self ofSystemChangesOfItem: #category change: #Added using: #update;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #update;		notify: self ofSystemChangesOfItem: #category change: #Removed using: #update;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #update;		notify: self ofSystemChangesOfItem: #category change: #Renamed using: #update;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #update;		notify: self ofSystemChangesOfItem: #category change: #Recategorized using: #update.	self update; reset! !!TestRunner methodsFor: 'updating' stamp: 'lr 3/22/2006 19:35'!update	self updateCategories; updateClasses! !!TestRunner methodsFor: 'updating' stamp: 'lr 10/31/2005 15:45'!updateCategories	categories := self findCategories.	categoriesSelected := categoriesSelected isNil		ifTrue: [ Set new ]		ifFalse: [			categoriesSelected				select: [ :each | categories includes: each ] ].	self changed: #categoryList; changed: #categorySelected.! !!TestRunner methodsFor: 'updating' stamp: 'lr 1/20/2009 14:48'!updateClasses	| classesForCategories |	classesForCategories := self findClassesForCategories: categoriesSelected.	classes := classesForCategories asArray		sort: [ :a :b | self sortClass: a before: b ].	classIndex := 0.	classesSelected := classesSelected isNil		ifTrue: [ classesForCategories ]		ifFalse: [ 			classesSelected				select: [ :each | classesForCategories includes: each ] ].	self changed: #classList; changed: #classSelected; changed: #hasRunnable.! !!TestRunner methodsFor: 'updating' stamp: 'AlexandreBergel 10/1/2008 23:09'!updateResults	"<lint: #expect rule: #guardingClause>"	"<lint: #expect rule: #longMethods>"	self updateStatus: false.	failedList size = result failures size ifFalse: [		failedList := result failures asArray			sort: [ :a :b | a printString <= b printString ].		failedSelected := nil.		self 			changed: #failedList; 			changed: #failedSelected;			changed: #hasFailures;			changed: #hasProgress  ].	errorList size = result errors size ifFalse: [		errorList := result errors asArray			sort: [ :a :b | a printString <= b printString ].		errorSelected := nil.		self 			changed: #errorList; 			changed: #errorSelected;			changed: #hasErrors;			changed: #hasProgress ].! !!TestRunner methodsFor: 'updating' stamp: 'lr 11/3/2005 09:28'!updateStatus: aBoolean	"Update the status display, at most once a second if aBoolean is true."	(aBoolean and: [ lastUpdate = Time totalSeconds ])		ifTrue: [ ^ self ].	self changed: #statusText; changed: #statusColor.	lastUpdate := Time totalSeconds.! !!TestRunner commentStamp: '<historical>' prior: 0!<lint: #ignore rule: #classNotReferenced rational: 'this view is only accessed from menus'>!!TestRunner class methodsFor: 'instance-creation' stamp: 'KR 4/28/2006 21:07'!build	^ ToolBuilder build: self new.! !!TestRunner class methodsFor: 'instance-creation' stamp: 'lr 10/8/2005 18:35'!open	^ ToolBuilder open: self new.! !!TestRunner class methodsFor: 'initialization' stamp: 'lr 12/7/2005 13:56'!initialize	self registerInWorldMenu; registerInToolsFlap.! !!TestRunner class methodsFor: 'initialization' stamp: 'KR 4/28/2006 21:06'!registerInToolsFlap	self environment at: #Flaps ifPresent: [ :class |		class			registerQuad: #( TestRunner build 'SUnit Runner' 'A production scale test-runner.' ) forFlapNamed: 'Tools';			replaceToolsFlap ].! !!TestRunner class methodsFor: 'initialization' stamp: 'md 1/13/2006 18:14'!registerInWorldMenu	self environment at: #TheWorldMenu ifPresent: [ :class |		class registerOpenCommand: (Array 			with: 'Test Runner' 			with: (Array				with: self				with: #open)) ].! !!TestRunner class methodsFor: 'window color' stamp: 'tfel 2/27/2010 22:25'!windowColorSpecification	^ WindowColorSpec 		classSymbol: self name 		wording: 'Test Runner' 		brightColor:  Color orange		pastelColor: (Color r: 0.65 g: 0.753 b: 0.976)		helpMessage: 'The Camp Smalltalk TestRunner tool for SUnit'! !!TestURI methodsFor: 'running file' stamp: 'mir 6/20/2005 17:17'!testDefaultDirRoundtrip	| defaultDir defaultURI uriDir |	defaultDir := FileDirectory default.	defaultURI := defaultDir uri.	uriDir := FileDirectory uri: defaultURI.	self should: [defaultDir fullName = uriDir fullName]! !!TestURI methodsFor: 'running file' stamp: 'mir 6/20/2005 17:19'!testDirectoryRoot	| rootDir uriRoot uriDir |	rootDir := FileDirectory root.	uriRoot := 'file:///' asURI.	uriDir := FileDirectory uri: uriRoot.	self should: [rootDir fullName = uriDir fullName]! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal1	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal10	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './g/.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal11	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/./h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/h'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal12	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/../h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/h'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal13	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x=1/./y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x=1/y'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal14	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x=1/../y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/y'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal15	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y/./x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y/./x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 16:12'!testResolveAbnormal16	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y/../x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y/../x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal17	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s/./x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s/./x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal18	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s/../x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s/../x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal2	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../../g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal3	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/./g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/./g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal4	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal5	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g.'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal6	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '.g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/.g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal7	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g..'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal8	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '..g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/..g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal9	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal1	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g:h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'g:h'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal10	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y#s'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal11	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := ';x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/;x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal12	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal13	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x?y#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x?y#s'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal14	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal15	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal16	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal17	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal18	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal19	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal2	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal20	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal21	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal3	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal4	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal5	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal6	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '//g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal7	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '?y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/?y'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal8	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal9	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:21'!testSchemeAbsoluteFail1	self should: [URI fromString: 'http:'] raise: IllegalURIException! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:24'!testSchemeAbsolutePass1	| uri |	uri := URI fromString: 'http://www.squeakland.org'.	self should: [uri scheme = 'http'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative]! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:25'!testSchemeAbsolutePass2	| uri |	uri := URI fromString: 'mailto:somebody@somewhere.nowhere'.	self should: [uri scheme = 'mailto'].	self should: [uri isAbsolute].	self should: [uri isOpaque].	self shouldnt: [uri isRelative]! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:32'!testSchemeAbsolutePass3	| uri |	uri := URI fromString: 'ftp://ftp@squeak.org'.	self should: [uri scheme = 'ftp'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri userInfo = 'ftp'].	self should: [uri host = 'squeak.org'].	self should: [uri port isNil].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:38'!testSchemeAbsolutePass4	| uri |	uri := URI fromString: 'mailto:somebody@somewhere.nowhere#fragment'.	self should: [uri scheme = 'mailto'].	self should: [uri isAbsolute].	self should: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri fragment = 'fragment'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:39'!testSchemeAbsolutePass5	| uri |	uri := URI fromString: 'http://www.squeakland.org#fragment'.	self should: [uri scheme = 'http'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri fragment = 'fragment'].! !!TestURI commentStamp: 'mir 2/27/2002 14:42' prior: 0!Main comment stating the purpose of this class and relevant relationship to other classes.   Some parsers allow the scheme name to be present in a relative URI if   it is the same as the base URI scheme.  This is considered to be a   loophole in prior specifications of partial URI [RFC1630]. Its use   should be avoided.      http:g        =  http:g           ; for validating parsers                    |  http://a/b/c/g   ; for backwards compatibility!!TestURI class methodsFor: 'test generation' stamp: 'mir 2/27/2002 16:13'!generateAbnormalResolverTests	"TestURI generateAbnormalResolverTests"	| relURIString result method testPairs pair |	testPairs := #(		#('../../../g' 'http://a/../g' )		#('../../../../g' 'http://a/../../g' )		#('/./g' 'http://a/./g' )		#('/../g' 'http://a/../g' )		#('g.' 'http://a/b/c/g.' )		#('.g' 'http://a/b/c/.g' )		#('g..' 'http://a/b/c/g..' )		#('..g' 'http://a/b/c/..g' )		#('./../g' 'http://a/b/g' )		#('./g/.' 'http://a/b/c/g/' )		#('g/./h' 'http://a/b/c/g/h' )		#('g/../h' 'http://a/b/c/h' )		#('g;x=1/./y' 'http://a/b/c/g;x=1/y' )		#('g;x=1/../y' 'http://a/b/c/y' )		#('g?y/./x' 'http://a/b/c/g?y/./x' )		#('g?y/../x' 'http://a/b/c/g?y/../x' )		#('g#s/./x' 'http://a/b/c/g#s/./x' )		#('g#s/../x' 'http://a/b/c/g#s/../x' )	).	1 to: testPairs size do: [:index |		pair := testPairs at: index.		relURIString := pair first.		result := pair last.		method := String streamContents: [:stream |			stream nextPutAll: 'testResolveAbnormal' , index printString; cr.			stream				nextPutAll: '	| baseURI relURI resolvedURI |' ; cr;				nextPutAll: '	baseURI := ''http://a/b/c/d;p?q'' asURI.' ; cr;				nextPutAll: '	relURI := '; nextPut: $'; nextPutAll: relURIString; nextPutAll: '''.' ; cr;				nextPutAll: '	resolvedURI := baseURI resolveRelativeURI: relURI.' ; cr;				nextPutAll: '	self should: [resolvedURI asString = '''; nextPutAll: result; nextPutAll: '''].' ; cr].		self compile: method classified: 'running resolving'].! !!TestURI class methodsFor: 'test generation' stamp: 'mir 2/27/2002 14:42'!generateNormalResolverTests	"TestURI generateNormalResolverTests"	| relURIString result method testPairs pair |	testPairs := #(		#('g:h' 'g:h' )		#('g' 'http://a/b/c/g' )		#('./g' 'http://a/b/c/g' )		#('g/' 'http://a/b/c/g/' )		#('/g' 'http://a/g' )		#('//g' 'http://g' )		#('?y' 'http://a/b/c/?y' )		#('g?y' 'http://a/b/c/g?y' )		#('g#s' 'http://a/b/c/g#s' )		#('g?y#s' 'http://a/b/c/g?y#s' )		#(';x' 'http://a/b/c/;x' )		#('g;x' 'http://a/b/c/g;x' )		#('g;x?y#s' 'http://a/b/c/g;x?y#s' )		#('.' 'http://a/b/c/' )		#('./' 'http://a/b/c/' )		#('..' 'http://a/b/' )		#('../' 'http://a/b/' )		#('../g' 'http://a/b/g' )		#('../..' 'http://a/' )		#('../../' 'http://a/' )		#('../../g' 'http://a/g' )	).	1 to: testPairs size do: [:index |		pair := testPairs at: index.		relURIString := pair first.		result := pair last.		method := String streamContents: [:stream |			stream nextPutAll: 'testResolveNormal' , index printString; cr.			stream				nextPutAll: '	| baseURI relURI resolvedURI |' ; cr;				nextPutAll: '	baseURI := ''http://a/b/c/d;p?q'' asURI.' ; cr;				nextPutAll: '	relURI := '; nextPut: $'; nextPutAll: relURIString; nextPutAll: '''.' ; cr;				nextPutAll: '	resolvedURI := baseURI resolveRelativeURI: relURI.' ; cr;				nextPutAll: '	self should: [resolvedURI asString = '''; nextPutAll: result; nextPutAll: '''].' ; cr].		self compile: method classified: 'running resolving'].! !!TestValueWithinFix methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testValueWithinNonLocalReturnFixReal	"self run: #testValueWithinNonLocalReturnFixReal"	"The real test for the fix is just as obscure as the original problem"	| startTime |	self valueWithinNonLocalReturn.	startTime := Time millisecondClockValue.	[[] repeat] valueWithin: 100 milliSeconds onTimeout:[ | deltaTime |		"This *should* timeout after 100 msecs but the pending process from		the previous invokation will signal timeout after 20 msecs already		which will in turn cut this invokation short."		deltaTime := Time millisecondClockValue - startTime.		self deny: deltaTime < 90.	].! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!testValueWithinNonLocalReturnFixSimply	"self run: #testValueWithinNonLocalReturnFixSimply"	"The simple version to test the fix"	self valueWithinNonLocalReturn.	self shouldnt:[(Delay forMilliseconds: 50) wait] raise: TimedOut.! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:37'!valueWithinNonLocalReturn	"Do a non-local return from a valueWithin: block"	[^self] valueWithin: 20 milliSeconds onTimeout:[].! !!Text methodsFor: 'accessing' stamp: 'tk 8/11/2004 07:24'!findBetweenSubStrs: delimiters	"Answer the collection of Text tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self string skipAnySubStr: delimiters startingAt: keyStop.		keyStop := self string findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!Text methodsFor: 'accessing' stamp: 'tk 8/11/2004 07:26'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens := OrderedCollection new.	separators := delimiters class == Character 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self string skipDelimiters: separators startingAt: keyStop.		keyStop := self string findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!Text methodsFor: 'accessing' stamp: 'tween 9/13/2004 10:07'!size	^string size! !!Text methodsFor: 'accessing' stamp: 'tween 9/13/2004 10:07'!string	"Answer the string representation of the receiver."	^string! !!Text methodsFor: 'converting' stamp: 'nk 2/26/2004 13:32'!asNumber	"Answer the number created by interpreting the receiver as the textual 	representation of a number."	^string asNumber! !!Text methodsFor: 'copying' stamp: 'tk 8/11/2004 07:34'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first |	first := self string findFirst: [:c | c isSeparator not].	first = 0 ifTrue: [^ ''].  "no non-separator character"	^ self		copyFrom: first		to: (self string findLast: [:c | c isSeparator not])	" ' abc  d   'asText withBlanksTrimmed"! !!Text methodsFor: 'printing' stamp: 'tk 7/28/2004 16:59'!printStringText	"Just like printString, but includes my emphasis"	^ Text streamContents: [:strm |		self printNameOn: strm.		strm nextPutAll: ' for '; nextPutAll: self]! !!Text methodsFor: '*ST80-Support'!asParagraph	"Answer a Paragraph whose text is the receiver."	^Paragraph withText: self! !!TextAlignmentTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextAlignment centered;		 add: TextAlignment justified;		 add: TextAlignment leftFlush;		 add: TextAlignment rightFlush ! !!TextAnchorTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextAnchor new anchoredMorph: RectangleMorph new initialize);				add: (TextAnchor new anchoredMorph: EllipseMorph new initialize) ! !!TextAndTextStreamTest methodsFor: 'examples' stamp: 'BG 6/10/2003 20:17'!example1: size   | ts text |  ts := TextStream on: (Text new: size).  ts  nextPutAll: 'xxxxx' asText.  ts nextPutAll: ('yyyyy' asText allBold, 'zzzzzzz' asText).  text := ts contents.  ^text  ! !!TextAndTextStreamTest methodsFor: 'examples' stamp: 'BG 6/10/2003 20:26'!example2      | ts text |  ts := TextStream on: (Text new: 50).  ts  nextPutAll: 'abc' asText.  ts nextPutAll: 'def' asText allBold.  ts nextPutAll: 'ghijk' asText.  text := ts contents.  ^text  ! !!TextAndTextStreamTest methodsFor: 'examples' stamp: 'BG 6/11/2003 13:09'!replacementAtStartExample3   | text1  replacement  length  |   text1 := 'This is a simple text' copy asText.    " without the copy, we would modify a constant that the compiler attached at the compiled method. "   length  := 'This' size.   replacement := 'Tht' asText.   text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.! !!TextAndTextStreamTest methodsFor: 'examples' stamp: 'BG 6/11/2003 13:05'!replacementExample3  " for a Text  t,     the following assertion should always hold:     t string size = t run size     This test examines the preservation of this assertion for in-place replacement  Here, the replacement text is shorteer than the text that is shall replace. "   | text1 string replacement startPos length startPosInRep string2 |   text1 := (string := 'This is again simple text' copy) asText.     " without the copy, we would modify a constant that the compiler attached at the compiled method. "   startPos := string findString: 'simple'.    length  := 'simple' size.   replacement := (string2 := 'both simple and short') asText.   startPosInRep :=  string2 findString: 'short'.   text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.   ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:45'!testAddStringToTextStream	"It is possible to add a string into a TextStream.	This test verifies that the created text has text attributes for all its characters. "	| ts text |	ts := TextStream on: (Text new: 50).	ts nextPutAll: 'abc' asText.	ts nextPutAll: 'def' asText allBold.	ts nextPutAll: 'ghijk'.	text := ts contents.     " now, check the fundamental invariant of a text: "	self assert: text string size = text runs size.! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:40'!testExampleText1	"self run: #testExampleText1"	"inspired by a bug report from Tim Olson.	Text attributes are lost when the stream collection is expanded.	Documented BUG!!!!!!"    | text1 text2 atts1 atts2 |	text1 := self example1: 10. " here we will loose the attribute bold "	text2 := self example1: 50. " here we have a larger buffer and will not loose text attributes "	atts1 := text1 runs copyFrom: 6 to: 10. 	atts2 := text2 runs copyFrom: 6 to: 10. 	self assert: atts1 = atts2.      ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:40'!testExampleText2	"a Text looses its attributes when it is reversed "		| text1 text2 |	text1 := self example2.	text2 := text1 reversed reversed.	self assert: text1 runs = text2 runs. ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:35'!testRunArrayAdjacentMerge	"this demonstrates that adjancent runs with equal attributes are merged. "	| runArray |	runArray := RunArray new.	runArray 		addLast: TextEmphasis normal times: 5;		addLast: TextEmphasis bold times: 5;		addLast: TextEmphasis bold times: 5.	self assert: (runArray runs size = 2). ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:37'!testRunArrayInvariant	"this verifies that the fundamental invariant of a RunArray is always satisfied. "	"see comment below"	| runArray |	runArray := RunArray new.	runArray 		addLast: TextEmphasis normal times: 5;		addLast: TextEmphasis bold times: 5;		addLast: TextEmphasis normal times: 5.	self assert:       ((1 to: runArray size) allSatisfy:           [:idx |  | lastIndex lastOffset lastRun lengthOfPreviousRuns |               runArray at: idx.  " updates the cached values "               lastIndex := runArray instVarNamed: 'lastIndex'.               lastRun := runArray instVarNamed: 'lastRun'.               lastOffset := runArray instVarNamed: 'lastOffset'.               lengthOfPreviousRuns                    := (1 to: lastRun - 1)                      inject: 0                       into: [:sum :idx2 | sum + (runArray runs at: idx2)].               lastIndex = (lastOffset + lengthOfPreviousRuns + 1)            ]       ). " This method is a bit tricky. First, it uses Object>>instVarNamed: to access instance variables for which no accessors are defined. The same method is used by the debuggers and by various inspectors.The assertion itself explains the meaning of the cached values."! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:36'!testRunArrayReversal  	"this tests the reversal of a  RunArray "	| runArray |	runArray := RunArray new.	runArray 		addLast: TextEmphasis normal times: 5;		addLast: TextEmphasis bold times: 5;		addLast: TextEmphasis normal times: 5.	self assert: (runArray reversed runs size = 3). ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:32'!testRunArrayRunsAreNotMerged	" this demonstrates that different runs are not merged "	| runArray |	runArray := RunArray new.	runArray 		addLast: TextEmphasis normal times: 5;		addLast: TextEmphasis bold times: 5;		addLast: TextEmphasis normal times: 5.	self assert: (runArray runs size = 3). ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:33'!testRunArrayRunsSize 	"this demonstrates that the size of a run array is the sum of the sizes of its runs. "	| runArray |	runArray := RunArray new.  	runArray 		addLast: TextEmphasis normal times: 5;		addLast: TextEmphasis bold times: 5;		addLast: TextEmphasis normal times: 5.	self assert: (runArray size = 15). ! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:49'!testTextEmphasisRangeDetection1	"this tests the detection of the range of a text attribute. "	| text startPos boldStyle |	text := 'This is a text with attriute bold for some characters' asText.	startPos := text findString: 'bold' startingAt: 1.	text addAttribute: TextEmphasis bold from: startPos to: startPos + 3.	boldStyle := TextEmphasis bold.  " uncomment the following statement for examine failures: "  " -----------------       (1 to: text size) do:           [:idx | | range |              range := text rangeOf: boldStyle startingAt: idx.             Transcript show: startPos; show: ' -- '; show: idx printString; show: '  '; show: range printString; show: range size printString; show: ((idx between: startPos and: startPos + 3)                  ifTrue:                    [range first = startPos & (range size = 4)]                  ifFalse:                    [range first = idx & (range size = 0)]) printString; cr.           ].    ------------- "	self assert: 		((1 to: text size) allSatisfy:			[:idx | | range |				range := text rangeOf: boldStyle startingAt: idx.				(idx between: startPos and: startPos + 3)					ifTrue: [range first = startPos & (range size = 4)]					ifFalse: [range first = idx & (range size = 0)]])! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:51'!testTextEmphasisRangeDetection2	"this tests the detection of the range of a text attribute.	Here the searched attribute spans three runs. The objective of the test is whether the entire range is always found."	| text startPos searchedStyle |	text := 'This is a text with attriute bold for some characters' asText.	startPos := text findString: 'bold' startingAt: 1.	text addAttribute: TextEmphasis bold from: startPos to: startPos + 3.	text addAttribute: TextEmphasis italic from: startPos - 2 to: startPos + 5.	searchedStyle := TextEmphasis italic.  " uncomment the following statement for examine failures: "   " -----------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos; show: ' -- '; show: idx printString; show: '  '; show: range printString; show: range size printString; show: ((idx between: startPos - 2 and: startPos -2 + 7)                  ifTrue:                    [range first = (startPos - 2) & (range size = 8)]                  ifFalse:                    [range first = idx & (range size = 0)]) printString; cr.           ].   ----------------------- "	self assert: 			((1 to: text size) allSatisfy:				[:idx | | range |					range := text rangeOf: searchedStyle startingAt: idx.					(idx between: startPos - 2 and: startPos -2 + 7)						ifTrue: [range first = (startPos - 2) & (range size = 8)]						ifFalse: [range first = idx & (range size = 0)]])! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:53'!testTextEmphasisRangeDetection3	"this tests the detection of the range of a text attribute.    Here the searched attribute spans three runs. The the range to be detected begins at text position 1. The objective of the test is whether the entire range is always found."	| text startPos searchedStyle |	text := 'This is a text with attriute bold for some characters' asText.	startPos := text findString: 'bold' startingAt: 1.	text addAttribute: TextEmphasis bold from: startPos to: startPos + 3.	text addAttribute: TextEmphasis italic from: 1 to: startPos + 5.	searchedStyle := TextEmphasis italic.	" uncomment the following statement to examine failures: " 	" -----------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos;					show: ' -- ';					show: idx printString;					show: '  ';					show: range printString;					show: range size printString;                        show: ' ';					 show: ((idx between: 1 and: startPos + 5)                  					ifTrue:                  					  [range first = 1 & (range size = (startPos + 5))]                					ifFalse:                   					 [range first = idx & (range size = 0)]) printString; cr.           ].   ----------------------- "	self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: searchedStyle startingAt: idx.              (idx between: 1 and: startPos + 5)                  ifTrue:                    [range first = 1 & (range size = (startPos + 5))]                  ifFalse:                    [range first = idx & (range size = 0)]])! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:55'!testTextEmphasisRangeDetection4	"this tests the detection of the range of a text attribute.	Here the searched attribute spans three runs. The the range to be detected extends to the end of the text . The objective of the test is whether the 	entire range is always found."	| text startPos searchedStyle |	text := 'This is a text with attriute bold for some characters' asText.	startPos := text findString: 'bold' startingAt: 1.	text addAttribute: TextEmphasis bold from: startPos to: startPos + 3.		text addAttribute: TextEmphasis italic from: startPos - 2 to: text size.	searchedStyle := TextEmphasis italic.	" uncomment the following statement to examine failures: "  	" -----------------------------------------       (1 to: text size) do:           [:idx | | range |               range := text rangeOf: searchedStyle startingAt: idx.             Transcript show: startPos;					show: ' -- ';					show: idx printString;					show: '  ';					show: range printString;					show: range size printString;                        show: ' ';					 show: ((idx between: startPos - 2 and: text size)                  			ifTrue:   			                 [range first = (startPos - 2) & (range size = (text size - (startPos - 2) + 1))]                  			ifFalse: 			                 [range first = idx & (range size = 0)]) printString;					cr.           ].   -------------------------------"	self assert:        ((1 to: text size) allSatisfy:           [:idx | | range |              range := text rangeOf: searchedStyle startingAt: idx.              (idx between: startPos - 2 and: text size)                  ifTrue: [range first = (startPos - 2) & (range size = (text size - (startPos - 2) + 1))]                  ifFalse: [range first = idx & (range size = 0)]])! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:56'!testTextReplacement1	"for a Text  t,     the following assertion should always hold:     t string size = t run size 	This test examines the preservation of this assertion for in-place replacement "   | text1 string replacement startPos length startPosInRep string2 |   text1 := (string := 'This is a simple text' copy) asText.   "without the copy, we would modify a constant that the compiler attached at the compiled method. "   startPos := string findString: 'simple'.    length  := 'simple' size.   replacement := (string2 := 'both simple and short*') asText.   startPosInRep :=  string2 findString: 'short'.   text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.   self assert: text1 string size = text1 runs size.! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:57'!testTextReplacement2  	"for a Text  t,     the following assertion should always hold:     t string size = t run size     	This test examines the preservation of this assertion for in-place replacement.    	Here, the replacement text has trailing characters. "	| text1 string replacement startPos length startPosInRep string2 |	text1 := (string := 'This is simple text' copy) asText.	"without the copy, we would modify a constant that the compiler attached at the compiled method. "	startPos := string findString: 'simple'. 	length := 'simple' size.	replacement := (string2 := 'both simple and short*************') asText.	startPosInRep :=  string2 findString: 'short'.	text1 replaceFrom: startPos         to: startPos + length - 1        with: replacement        startingAt: startPosInRep.	self assert: text1 string size = text1 runs size.! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:58'!testTextReplacement3	"for a Text  t,	the following assertion should always hold:	t string size = t run size 	This test examines the preservation of this assertion for in-place replacement 	Here, the replacement text is shorteer than the text that is shall replace. "	self should: [self replacementExample3]  raise: Error! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:59'!testTextReplacementAtStartPos1	"for a Text  t,     the following assertion should always hold:     t string size = t run size 	This test examines the preservation of this assertion for in-place replacement "	| text1  replacement  length  |	text1 := 'This is a simple text' copy asText.	"without the copy, we would modify a constant that the compiler attached at the compiled method. "	length  := 'This' size.	replacement := 'That' asText.	text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.	self assert: text1 string size = text1 runs size.! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:00'!testTextReplacementAtStartPos2  	"for a Text  t,     the following assertion should always hold:     t string size = t run size 	This test examines the preservation of this assertion for in-place replacement "	| text1  replacement  length  |	text1 := 'This is a simple text' copy asText.	"without the copy, we would modify a constant that the compiler attached at the compiled method. "	length  := 'This' size.	replacement := 'That********' asText.	text1 replaceFrom: 1         to:   length        with: replacement        startingAt: 1.	self assert: text1 string size = text1 runs size.! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:00'!testTextReplacementAtStartPos3	"for a Text  t,	the following assertion should always hold:	t string size = t run size 	This test examines the preservation of this assertion for in-place replacement 	Here, the replacement text is shorteer than the text that is shall replace. "	self should: [self replacementAtStartExample3] raise: Error! !!TextAndTextStreamTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:44'!testTextStreamAdjacentRunsWithIdentitcalAttributes	"This test verifies that adjacent runs with identical attributes are coalesced."	| ts text rangeOfBold |	ts := TextStream on: (Text new: 50).	ts nextPutAll: 'abc' asText.	ts nextPutAll: 'def' asText allBold.	ts nextPutAll: 'ghijk'.	text := ts contents.	rangeOfBold := text find:  TextEmphasis bold.	text removeAttribute: TextEmphasis bold from: rangeOfBold first to: rangeOfBold last.      "now, check that only one run is left and that it has the correct size "	self assert: text runs runs size = 1 & (text runs size = text string size).! !!TextAndTextStreamTest commentStamp: '<historical>' prior: 0!At May 09, 2003 Tim Olson sent a bug report to the Squeak developers list that inspired me to examine the protocol of TextStream in greater detail.  (The bug that Tim reported was present in Squeak 3.4, it is shown in testExample1.) In a discussion that followed,  Daniel Vainsencher proposed that we should have tests for Text and TextStreams. This class is an attempt to implement that proposal. For Squeak 3.4, some of the test examples fail.!!TextAttribute methodsFor: 'testing' stamp: 'tk 3/17/2005 14:11'!temporary	"true means don't try to write this on the disk"	^ false! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'klub 12/28/2009 00:04'!convertToString: array	^String streamContents: [ :stream |		array do: [ :each |			stream nextPutAll: each asString; cr ] ]! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'ul 12/27/2009 21:03'!patchSequenceFor: x and: y	^(TextDiffBuilder		from: (self convertToString: x)		to:  (self convertToString: y)) buildPatchSequence! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs1	| patch |	patch := self patchSequenceFor: #(a b c) and: #().	self assert: patch size = 3.	self assert: (patch allSatisfy: [ :each | each key = #remove ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs2	| patch |	patch := self patchSequenceFor: #() and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #insert ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'klub 12/28/2009 00:02'!testEmptyLcs3	| patch |	patch := self patchSequenceFor: #(a b c) and: #(d e f g).	self assert: patch size = 7.		patch do: [ :each |		each key = #remove ifTrue: [ self assert: ('abc' includes: each value first) ].		each key = #insert ifTrue: [ self assert: ('defg' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:09'!testEmptySequences	| patch |	patch := self patchSequenceFor: #() and: #().	self assert: patch isEmpty! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfPatchIsMinimal	| patch |	patch := self patchSequenceFor: #(a a a b) and: #(a b a a).	self assert: patch size = 5.	"lcs is aaa"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $a ]			ifFalse: [ self assert: each value first = $b ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfSequence1	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d c b a).	self assert: patch size = 7.	"lcs is any one letter sequence"	self assert: (patch count: [ :each | each key = #match ]) = 1.	self assert: (patch count: [ :each | each key = #insert ]) = 3.	self assert: (patch count: [ :each | each key = #remove ]) = 3.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $d ]			ifFalse: [ self assert: ('abc' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:58'!testIfSequence2	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(c d b a).	self assert: patch size = 6.	"lcs is cd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('cd' includes: each value first) ]			ifFalse: [ self assert: ('ab' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:59'!testIfSequence3	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(b d c a).	self assert: patch size = 6.	"lcs is bd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bd' includes: each value first) ]			ifFalse: [ self assert: ('ac' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:00'!testIfSequence4	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d b c a).	self assert: patch size = 6.	"lcs is bc"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bc' includes: each value first) ]			ifFalse: [ self assert: ('ad' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:09'!testIfSequence5	| patch matches nonMatches |	patch := self patchSequenceFor: #(a b c d) and: #(c d a b).	self assert: patch size = 6.	"lcs is ab or cd"	matches := (patch select: [ :each | each key = #match ])		collect: [ :each | each value first ] as: String.	self assert: (#('ab' 'cd') includes: matches).	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	nonMatches := #('ab' 'cd') detect: [ :each | each ~= matches ].	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: (matches includes: each value first) ]			ifFalse: [ self assert: (nonMatches includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:10'!testIfSequence6	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d a b c).	self assert: patch size = 5.	"lcs is abc"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('abc' includes: each value first) ]			ifFalse: [ self assert: each value first = $d ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testSameSequence	| patch |	patch := self patchSequenceFor: #(a b c) and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:24'!testSameSequenceWithRepetitions	| patch |	patch := self patchSequenceFor: #(a a b a) and: #(a a b a).	self assert: patch size = 4.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!TextEditor methodsFor: 'menu messages' stamp: 'eem 7/6/2010 13:11'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol maybeBrowseInstVar |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	maybeBrowseInstVar :=		[| selectionString |		selectionString := self selection asString.		 ([model selectedClass] on: Error do: [:ex|]) ifNotNil:			[:class|			(class allInstVarNames includes: selectionString) ifTrue:				[self systemNavigation					browseAllAccessesTo: selectionString					from: (class classThatDefinesInstanceVariable: selectionString).				 ^nil]]].	(aSymbol := self selectedSymbol) ifNil:		[maybeBrowseInstVar value.		 ^self flash].	aSymbol first isUppercase		ifTrue:			[| anEntry |			([model selectedClass theNonMetaClass] on: Error do: [:ex|]) ifNotNil:				[:class| "If selection is a class or pool var (a binding exists but not in the environment)"				(class bindingOf: aSymbol) ifNotNil:					[:binding| "then browse its references"					 (class environment bindingOf: aSymbol) ~~ binding ifTrue:						[self systemNavigation browseAllCallsOn: binding.						 ^nil]]].			anEntry := (Smalltalk				at: aSymbol				ifAbsent:					[ self systemNavigation browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry isNil ifTrue: [^ self flash].			(anEntry isBehavior or: [ anEntry isTrait ])				ifFalse: [ anEntry := anEntry class ].			ToolSet browse: anEntry selector: nil]		ifFalse:			[self systemNavigation browseAllImplementorsOf: aSymbol.			 maybeBrowseInstVar value]! !!TextEditor methodsFor: 'explain' stamp: 'eem 8/15/2010 09:08'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode node |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	node := methodNode encoder lookupVariable: string ifAbsent: [^nil].	^node isTemp ifTrue:		[(node isArg			ifTrue: ['"is an argument to this ']			ifFalse: ['"is a temporary variable in this ']),		   (node isDeclaredAtMethodLevel			ifTrue: ['method"']			ifFalse: ['block"'])]! !!TextEmphasisTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextEmphasis bold;		 add: TextEmphasis italic;		 add: TextEmphasis narrow;		 add: TextEmphasis normal;		 add: TextEmphasis struckOut;		 add: TextEmphasis underlined ! !!TextEmphasisTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:03'!testAppendString	"tests the Text>>prepend: method when appending a String " 	"self run: # testAppendString"	| receiver argument result expectedResult |	receiver := 'xxx' asText  		addAttribute: TextEmphasis bold from: 1 to: 3.	argument := 'yyy'.	expectedResult := 'xxxyyy' asText 		addAttribute: TextEmphasis bold from: 1 to: 3.	result := receiver append: argument.	self assert: (result == receiver). 	self assert: (result string = expectedResult string).	self assert: (result runs = expectedResult runs)! !!TextEmphasisTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:04'!testAppendText	"tests the Text>>prepend: method when appending a Text " 	| receiver argument result expectedResult |	receiver := 'xxx' asText  		addAttribute: TextEmphasis bold from: 1 to: 3.	argument := 'yyy' asText		addAttribute: TextEmphasis italic from: 1 to: 3.		.	expectedResult := 'xxxyyy' asText 		addAttribute: TextEmphasis bold from: 1 to: 3;		addAttribute: TextEmphasis italic from: 4 to: 6.	result := receiver append: argument.	self assert: (result == receiver). 	self assert: (result string = expectedResult string).	self assert: (result runs = expectedResult runs)		! !!TextEmphasisTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:04'!testPrependString	"tests the Text>>prepend: method when prepending a String " 	| receiver argument result expectedResult |	receiver := 'xxx' asText  		addAttribute: TextEmphasis bold from: 1 to: 3.	argument := 'yyy'.	expectedResult := 'yyyxxx' asText 		addAttribute: TextEmphasis bold from: 4 to: 6.	result := receiver prepend: argument.	self assert: (result == receiver). 	self assert: (result string = expectedResult string).	self assert: (result runs = expectedResult runs)	! !!TextEmphasisTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:04'!testPrependText	"tests the Text>>prepend: method when prepending Text " 	| receiver argument result expectedResult |	receiver := 'xxx' asText  		addAttribute: TextEmphasis bold from: 1 to: 3.	argument := 'yyy' asText 		addAttribute: TextEmphasis italic from: 1 to: 3.	expectedResult := 'yyyxxx' asText 		addAttribute: TextEmphasis italic from: 1 to: 3;		addAttribute: TextEmphasis bold from: 4 to: 6.	result := receiver prepend: argument.	self assert: (result == receiver). 	self assert: (result string = expectedResult string).	self assert: (result runs = expectedResult runs)! !!TextFontChangeTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:55'!setUp	"create the prototypes for testing"	super setUp.	prototypes add: TextFontChange defaultFontChange.	prototypes add: TextFontChange font1.	prototypes add: TextFontChange font2.	prototypes add: TextFontChange font3.	prototypes add: TextFontChange font4.	prototypes		add: (TextFontChange fontNumber: 6) ! !!TextFontChangeTest methodsFor: 'tests' stamp: 'mjr 8/17/2003 20:29'!testEquality	"Check that different instances of the same TextFontChange are equal"	self assert: TextFontChange defaultFontChange = TextFontChange defaultFontChange.	self assert: TextFontChange font1 = TextFontChange font1.	self assert: TextFontChange font2 = TextFontChange font2.	self assert: TextFontChange font3 = TextFontChange font3.	self assert: TextFontChange font4 = TextFontChange font4.	self assert: (TextFontChange fontNumber: 6)			= (TextFontChange fontNumber: 6)! !!TextFontChangeTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:10'!testHash	"test that different instances of the same TextFontChange hash to the 	same value"	| hashes hash |	hashes := OrderedCollection new.	1		to: 100		do: [:i | hashes add: TextFontChange defaultFontChange hash].	hash := hashes at: 1.	2		to: 100		do: [:i | self assert: (hashes at: i)					= hash]! !!TextFontReferenceTest methodsFor: 'tests' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextFontReference				toFont: (StrikeFont familyName: 'NewYork' size: 15)) ! !!TextKernTest methodsFor: 'tests' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes		add: (TextKern kern: 1) ! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:06'!testDecoratedTextConversionCrLF	| text newText |	text := ('123456', String crlf, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText := text withSqueakLineEndings.	self assert: ((text size - 1) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 9).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:06'!testDecoratedTextConversionJustLF	| text newText |	text := ('123456', String lf, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText := text withSqueakLineEndings.	self assert: ((text size) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 8).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testDecoratedTextConversionNoLF	| text newText |	text := ('123456', String cr, '901234') asText.	text addAttribute: TextColor blue from: 4 to: 10.	text addAttribute: TextColor red from: 6 to: 9.	text addAttribute: TextEmphasis bold.	newText := text withSqueakLineEndings.	self assert: ((text size) = newText size).	self assert: (newText size = newText runs size).	self assert: (newText attributesAt: 6) = (text attributesAt: 6).	self assert: (newText attributesAt: 8) = (text attributesAt: 8).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testSimpleTextConversionCrLF	| string newText |	string := 'This is a test', String crlf, 'of the conversion'.	newText := string asText withSqueakLineEndings.	self assert: ((string size - 1) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testSimpleTextConversionJustCR	| string newText |	string := 'This is a test', String cr, 'of the conversion'.	newText := string asText withSqueakLineEndings.	self assert: ((string size) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testSimpleTextConversionJustLF	| string newText |	string := 'This is a test', String lf, 'of the conversion'.	newText := string asText withSqueakLineEndings.	self assert: ((string size) = newText size).	self assert: (newText size = newText runs size).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testStringConversionCrLF	| string newString |	string := 'This is a test', String crlf, 'of the conversion'.	newString := string withSqueakLineEndings.	self assert: ((string size - 1) = newString size).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testStringConversionJustLF	| string newString |	string := 'This is a test', String lf, 'of the conversion'.	newString := string withSqueakLineEndings.	self assert: (string size = newString size).! !!TextLineEndingsTest methodsFor: 'tests' stamp: 'sd 6/5/2005 10:07'!testStringConversionNoLF	| string newString |	string := 'This is a test', String cr, 'of the conversion'.	newString := string withSqueakLineEndings.	self assert: (string = newString).! !!TextLineEndingsTest commentStamp: 'nk 11/1/2003 07:55' prior: 0!This is a test case for Text>>withSqueakLineEndings and String>>withSqueakLineEndings.The main problem we've seen with the Text version is that it doesn't preserve formatting correctly.!!TextLineTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:56'!setUp	super setUp.	prototypes		add: (TextLine				start: 1				stop: 50				internalSpaces: 2				paddingWidth: 1) ! !!TextLiteralHTML methodsFor: 'as yet unclassified' stamp: 'eem 1/14/2009 10:55'!analyze: aString	^string := aString! !!TextLiteralHTML methodsFor: 'as yet unclassified' stamp: 'eem 1/14/2009 11:02'!mayActOnClick	^false! !!TextLiteralHTML commentStamp: '<historical>' prior: 0!I arrange that text with my attribute is stored as HTML literally without character conversion, so that e.g. <H2>Heading</H2> does not get mangled to &lt;H2&gt;Heading&lt;/H2&gt;.!!TextMorphEditor commentStamp: '<historical>' prior: 0!This is the ParagraphEditor for TextMorphs.-----In the past, BookMorphs had the ability to have each page be on the server as a .sp SqueakPage file.  The index of the book was a .bo file.  In text, Cmd-6 had a LinkTo option that linked to a page by its name, or created a new page of that name.  It assumed the book was on a server with a file per page.  Ted removed that code, and kept a copy on his disk in 'TME-ChngEmphasis.st for .bo .sp'!!TextMorphTest methodsFor: 'testing' stamp: 'md 11/13/2003 10:01'!testInitialize	"For now, just make sure initialization doesn't throw exception"	self shouldnt: [TextMorph initialize] raise: Error.! !!TextStyle methodsFor: 'accessing' stamp: 'ar 3/18/2008 16:48'!defaultFont: aFont	self defaultFontIndex: (fontArray indexOf: aFont ifAbsent:[self defaultFontIndex])! !!TextStyle methodsFor: 'accessing' stamp: 'ar 4/26/2003 16:27'!marginTabsArray	^marginTabsArray! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'ar 2/3/2002 23:05'!fontOfPointSize: aHeight	"See fontIndexOfSize.	Returns the actual font.  Leading not considered."	^ fontArray at: (self fontIndexOfPointSize: aHeight)! !!TextStyle methodsFor: 'private' stamp: 'ar 3/28/2008 10:42'!fixLineGrid	"For fixing the line grid so that it matches the default font"	"TextStyle allInstances do:[:tx| tx fixLineGrid]"	lineGrid := self defaultFont height + leading.	"For whole family"	baseline := self defaultFont ascent + leading.! !!TextStyle methodsFor: 'private' stamp: 'ar 3/28/2008 10:41'!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	, Make size depend on first font."	| priorDefault |	fontArray ifNotNil:[priorDefault := self defaultFont].	fontArray := anArray.	alignment := 0.	firstIndent := 0.	restIndent := 0.	rightIndent := 0.	tabsArray := DefaultTabsArray.	marginTabsArray := DefaultMarginTabsArray.	priorDefault ifNotNil:[self defaultFont: priorDefault].	lineGrid := self defaultFont height + leading.	"For whole family"	baseline := self defaultFont ascent + leading."TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyleTest methodsFor: 'initialize-release' stamp: 'mjr 8/20/2003 18:55'!setUp	super setUp.	prototypes add: TextStyle default ! !!TextTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Text. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!TextURL methodsFor: 'accessing' stamp: 'eem 1/6/2009 09:18'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		ProjectLoading thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m := anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m := m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	(UIManager default		chooseFrom: (Array with: 'open a browser to view this URL?' translated with: 'Cancel')		title: url) ~= 1 ifTrue:			[^true].	WebBrowser default notNil ifTrue:		[WebBrowser default openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response := (UIManager default 				chooseFrom: (Array with: 'View web page as source' translated									with: 'Cancel' translated)				title:  'Couldn''t find a web browser. View\page as source?' withCRs translated).	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TextURL methodsFor: 'accessing' stamp: 'eem 1/6/2009 09:06'!analyze: aString	| list |	list := self analyzeAsURL: aString.	list isNil ifTrue: [list := super analyze: aString].	url := list at: 1.	^ list at: 2! !!TextURL methodsFor: 'accessing' stamp: 'eem 1/6/2009 13:43'!analyzeAsURL: aString	"Try and detect <A=``URL''>foo</A>.  Answer an array of URL, foo if recognized, otherwise answer nil."	| lcString i1 i2 i3 |	lcString := aString asLowercase.	((i1 := lcString indexOfSubCollection: '<img src="') > 0	and: [(i2 := lcString indexOf: $" startingAt: i1 + 10) > i1	and: [(i3 := lcString indexOfSubCollection: '/>') > i2]]) ifTrue:		[^{	aString.			aString copyFrom: i1 + 10 to: i2 - 1 }].	^((i1 := lcString indexOfSubCollection: '<a href="') > 0	and: [(i2 := lcString indexOfSubCollection: '">') > i1	and: [(i3 := lcString indexOfSubCollection: '</a>') > i2]]) ifTrue:		[ {	aString copyFrom: i1 + 9 to: i2 - 1.			aString copyFrom: i2 + 2 to: i3 - 1 }]! !!TextURL methodsFor: 'accessing' stamp: 'tk 12/30/97 10:33'!info	^ url! !!TextURL methodsFor: 'accessing' stamp: 'tk 12/16/97 13:45'!writeScanOn: strm	strm nextPut: $R; nextPutAll: url; nextPut: $;! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'eem 7/4/2010 18:45'!createDockingBar	"Create a docking bar from the receiver's representation"		| dockingBar |	dockingBar := DockingBarMorph new		adhereToTop;		color: Preferences menuColor;		gradientRamp: self gradientRamp;		autoGradient: ColorTheme current dockingBarAutoGradient;		borderWidth: 0.	self fillDockingBar: dockingBar.	self labelIfNeeded: dockingBar.	^ dockingBar! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'eem 7/4/2010 19:28'!menusOn: aDockingBar 	self 		squeakMenuOn: aDockingBar;		projectsMenuOn: aDockingBar;		toolsMenuOn: aDockingBar;		extrasMenuOn: aDockingBar;		windowsMenuOn: aDockingBar;		helpMenuOn: aDockingBar.	aDockingBar addSpacer.	self projectNameOn: aDockingBar.	aDockingBar addSpacer.	self		searchBarOn: aDockingBar;		clockOn: aDockingBar! !!TheWorldMainDockingBar methodsFor: 'private' stamp: 'eem 7/4/2010 19:32'!labelIfNeeded: aDockingBar 	"Label the given docking bar with the project name, if needed"	(aDockingBar submorphWithProperty: #projectNameMorph)		contents: (Project current isTopProject ifTrue: [''] ifFalse: [Project current name]);		fitContents! !!TheWorldMainDockingBar methodsFor: 'private' stamp: 'eem 7/4/2010 19:37'!updateIfNeeded: aDockingBar "Update the given docking bar if needed"	| timeStamp |	timeStamp := aDockingBar				valueOfProperty: #mainDockingBarTimeStamp				ifAbsent: [^ self].	timeStamp = self class timeStamp		ifTrue: [^self labelIfNeeded: aDockingBar].	""	aDockingBar removeAllMorphs.	self fillDockingBar: aDockingBar.	self labelIfNeeded: aDockingBar! !!TheWorldMainDockingBar methodsFor: 'right side' stamp: 'eem 7/4/2010 19:31'!projectNameOn: aDockingBar	| morph |	morph := StringMorph contents: ''.	morph setProperty: #projectNameMorph toValue: #projectNameMorph.	aDockingBar addMorphBack: morph! !!Time commentStamp: 'dew 10/23/2004 17:58' prior: 0!This represents a particular point in time during any given day.  For example, '5:19:45 pm'.If you need a point in time on a particular day, use DateAndTime.  If you need a duration of time, use Duration.!!Time class methodsFor: 'general inquiries' stamp: 'ar 1/7/2009 16:21'!millisecondClockMask	"The VM mask for the max. millisecond clock value.	This should be primitive but it ain't so it's copied inline from the Interpreter."	 ^16r1FFFFFFF! !!Time class methodsFor: 'general inquiries' stamp: 'ar 8/13/2009 14:45'!millisecondClockValue	"Answer the number of milliseconds since the millisecond clock was last reset or rolled over.	Answer 0 if the primitive fails."	<primitive: 135>	^ 0! !!Time class methodsFor: 'general inquiries' stamp: 'ar 3/4/2009 11:49'!primMillisecondsClock	"Answer the number of milliseconds since the millisecond clock was last reset or rolled over.	Answer 0 if the primitive fails."	<primitive: 135>	^ 0! !!Time class methodsFor: 'smalltalk-80' stamp: 'ar 3/4/2009 15:23'!totalSeconds	"Answer the total seconds since the Squeak epoch: 1 January 1901."	"Limit number of actual calls to primSecondsClock to 20/sec"	| delta |	delta := JiffyClock - PrimSecondsUpdate.	(delta < 0 or:[delta > 50]) ifTrue:[		PrimSecondsUpdate := JiffyClock.		PrimSecondsClock := self primSecondsClock.	].	^PrimSecondsClock! !!Time class methodsFor: 'smalltalk-80' stamp: 'ar 3/4/2009 14:39'!utcSeconds	"Answer the total seconds since the Squeak epoch: 1 January 1901,	 in UTC time."	^ self totalSeconds - (DateAndTime primTimezoneOffset  * 60).! !!Time class methodsFor: 'squeak protocol' stamp: 'jcg 3/17/2009 08:42'!coarseMillisecondsSince: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	^self milliseconds: self coarseClockValue since: lastTime! !!Time class methodsFor: 'coarse fast clock' stamp: 'ar 3/4/2009 11:52'!coarseClockValue	"The coarse millisecond clock value.	 This value is in milliseconds against the same base as the millisecondClockValue,	 but is only updated about every 'jiffyGranularity' milliseconds.  (ie. around 50)"	^ JiffyClock! !!Time class methodsFor: 'coarse fast clock' stamp: 'bgf 2/25/2009 18:33'!jiffyGranularity	"The number of milliseconds (max) between updates of the coarse clock value."	^ 50! !!Time class methodsFor: 'coarse fast clock' stamp: 'bgf 2/25/2009 18:33'!jiffyUpdate: milliseconds	"Advance the coarse clock (i.e. cache a millisecond clock value.)"	JiffyClock := milliseconds.! !!Time class methodsFor: 'class initialization' stamp: 'ar 3/4/2009 15:19'!initialize	"Time initialize"	JiffyClock := self primMillisecondsClock.	PrimSecondsUpdate := JiffyClock.	PrimSecondsClock := self primSecondsClock.! !!Time class methodsFor: 'accessing' stamp: 'eem 9/28/2009 08:19'!localMicrosecondClock	"Answer the number of microseconds since the start of the 20th century in local time."	<primitive: 241>	^0! !!Time class methodsFor: 'accessing' stamp: 'eem 9/28/2009 08:18'!utcMicrosecondClock	"Answer the number of microseconds since the start of the 20th century in UTC."	<primitive: 240>	^0! !!Time class methodsFor: 'primitives' stamp: 'eem 12/11/2009 17:31'!primHeartbeatFrequency: reset	"Answer the frequency of the VM's heartbeat.  reset the stats if the argument is true."	<primitive: 'primitiveHeartbeatFrequency'>	^self primitiveFailed	"Time primHeartbeatFrequency: false"	"Time primHeartbeatFrequency: true"! !!Time class methodsFor: 'primitives' stamp: 'bgf 10/22/2007 22:24'!primTimezoneOffset	"If known, the UTC timezone offet (in minutes) of this VMs host. 	 Requires the LocalePlugin. 	 	DateAndTime primTimezoneOffset	 " 	<primitive: 'primitiveTimezoneOffset' module: 'LocalePlugin'>	^ 0! !!Time class methodsFor: 'primitives' stamp: 'eem 5/10/2010 12:17'!primitiveGetClockLogAddressesAndLogIf: aBoolean	"Turn clock logging on or off depending on the argument.  Answer the clock log	 addresses as a 5-element Array of the size of the log"	<primitive: 'primitiveClockLogAddresses' error: err>	^self primitiveFailed! !!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:50'!classToBeTested	^ self timestampClass! !!TimeStampTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:13'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #().	^ super selectorsToBeIgnored, deprecated, private, special.! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 1/21/2004 18:41'!setUp	timestamp := self timestampClass date: ('1-10-2000' asDate) time: ('11:55:00 am' asTime).	aTimeStamp := TimeStamp readFrom: '1-02-2004 12:34:56 am' readStream! !!TimeStampTest methodsFor: 'Running' stamp: 'brp 7/26/2003 21:53'!tearDown	timestamp := nil.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 21:56'!testAccessing	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: timestamp date = d;		assert: timestamp time = t.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:05'!testArithmetic	| ts |	ts := timestamp minusDays: 123.  	"9 September 1999, 11:55 am"	ts := ts minusSeconds: 1056.			"9 September 1999, 11:37:24 am"	ts := ts plusDays: 123.				"10 January 2000, 11:37:24 am"	ts := ts plusSeconds: 1056.			"10 January 2000, 11:55 am"	self		assert: ts  = timestamp.	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:34'!testArithmeticAcrossDateBoundary	| ts |	ts := timestamp minusSeconds: ((11*3600) + (55*60) + 1).	self		assert: ts = ('1-9-2000 11:59:59 pm' asTimeStamp).	! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 3/12/2004 15:54'!testComparing	| ts1 ts2 ts3 c1 c2 le |	ts1 := self timestampClass date: ('01-10-2000' asDate) time: ('11:55:00 am' asTime).	ts2 := self timestampClass date: ('07-26-2003' asDate) time: ('22:09:45 am' asTime).	ts3 := self timestampClass date: ('05-28-1972' asDate) time: ('04:31:14 pm' asTime).	self		assert: ts1 = timestamp;		assert: ts1 hash = timestamp hash;		assert: timestamp = timestamp copy;		assert: ts1 < ts2;		deny: ts1 < ts3.	c1 := self timestampClass current.	c2 := self timestampClass current.	le := (c1 <= c2).	self assert: le.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/26/2003 22:19'!testConverting	| d t |	d := '1-10-2000' asDate.	t := '11:55:00 am' asTime.	self		assert: timestamp asSeconds = (d asSeconds + t asSeconds);		assert: timestamp asDate = d;		assert: timestamp asTime = t;		assert: timestamp asTimeStamp == timestamp;		assert: timestamp dateAndTime = {d. t}.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:55'!testFromSeconds	self		assert: (self timestampClass fromSeconds: 3124958100) = timestamp.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testFromString	"This should signal an exception in 3.6beta as Time>>fromString: does not exist."	self should: [ timestamp = (self timestampClass fromString: '1-10-2000 11:55:00 am') ] ! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:12'!testInstanceCreation	self 		should: [ self timestampClass midnight asDuration = (0 hours) ];		should: [ self timestampClass noon asDuration = (12 hours) ].! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 15:02'!testPrinting	self			assert: timestamp printString = '10 January 2000 11:55 am'.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 17:47'!testSorting	| c1 c2 |	c1 := self timestampClass current.	c2 := self timestampClass current.	self		assert: (self timestampClass current) <= (self timestampClass current);		assert: (c1 <= c2).! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDate	self assert: aTimeStamp date = '01-02-2004' asDate! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testDateAndTime	self assert: aTimeStamp dateAndTime			= (Array with: '01-02-2004' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusDays	self assert: (aTimeStamp minusDays: 5) dateAndTime			= (Array with: '12-28-2003' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSeconds	self assert: (aTimeStamp minusSeconds: 34 * 60 + 56) dateAndTime			= (Array with: '01-02-2004' asDate with: '00:00:00' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testMinusSecondsOverMidnight	self assert: (aTimeStamp minusSeconds: 34 * 60 + 57) dateAndTime			= (Array with: '01-01-2004' asDate with: '23:59:59' asTime)	"Bug The results are actual results are: #(1 January 2005 11:25:03 pm)"! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusDays	self assert: (aTimeStamp plusDays: 366) dateAndTime			= (Array with: '01-02-2005' asDate with: '00:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSeconds	self assert: (aTimeStamp plusSeconds: 60 * 60 ) dateAndTime			= (Array with: '01-02-2004' asDate with: '01:34:56' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPlusSecondsOverMidnight	self assert: (aTimeStamp plusSeconds: 24 * 60 * 60 + 1) dateAndTime			= (Array with: '01-03-2004' asDate with: '00:34:57' asTime)! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testPrintOn	| cs rw |	cs := ReadStream on: '2 January 2004 12:34:56 am'.	rw := ReadWriteStream on: ''.	aTimeStamp printOn: rw.	self assert: rw contents = cs contents! !!TimeStampTest methodsFor: 'testing' stamp: 'cbc 2/4/2004 21:18'!testReadFromA1	|ts|	ts := TimeStamp current.	self assert: (ts = (TimeStamp fromString: ts asString)).! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testStoreOn	| cs rw |	cs := ReadStream on: '''2 January 2004 12:34:56 am'' asTimeStamp'.	rw := ReadWriteStream on: ''.	aTimeStamp storeOn: rw.	self assert: rw contents = cs contents! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTime	self assert: aTimeStamp time =  '00:34:56' asTime! !!TimeStampTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:41'!testTimeStamp	self assert: aTimeStamp = aTimeStamp asTimeStamp! !!TimeStampTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:50'!timestampClass	^ TimeStamp! !!TimeStampTest commentStamp: 'brp 7/26/2003 22:44' prior: 0!This is the unit test for the class TimeStamp.!!TimeTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 13:31'!classToBeTested	^ self timeClass! !!TimeTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:09'!selectorsToBeIgnored	 | deprecated private special primitives timing benchmarks |	deprecated := #().	private := #( #print24:on: #print24:showSeconds:on: ).	special := #( #< #= #new #printOn: #storeOn: ).	primitives := #( #primMillisecondClock #primSecondsClock ).	timing := #( #millisecondClockValue #milliseconds:since: #millisecondsSince: ).	benchmarks := #( #benchmarkMillisecondClock #benchmarkPrimitiveResponseDelay ). 	^ super selectorsToBeIgnored, deprecated, private, special, primitives, timing, benchmarks.! !!TimeTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:40'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	time := self timeClass fromSeconds: 14567.		"4:02:47 am"	aTime := Time readFrom: '12:34:56 pm' readStream! !!TimeTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:40'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:33'!testAccessing	self		assert: time hours = 4;		assert: time minutes = 2;		assert: time seconds = 47;		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:35'!testArithmetic	| t1 t2 t3 |	t1 := time addSeconds: 70.		"4:03:57 am"	self		assert: t1 hours = 4;		assert: t1 minutes = 3;		assert: t1 seconds = 57.	t2 := t1 addTime: (self timeClass fromSeconds: (60*60*5)).	self		assert: t2 hours = 9;		assert: t2 minutes = 3;		assert: t2 seconds = 57.	t3 := t2 subtractTime: (self timeClass fromSeconds: (60*60*5) + 70).	self		assert: t3 = time.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:36'!testComparing	| t1 t2 t3 |	t1 := self timeClass fromSeconds: 14567.		"4:02:47 am"	t2 := self timeClass fromSeconds: 5000.		"1:23:20 am"	t3 := self timeClass fromSeconds: 80000.		"10:13:20 pm"	self		assert: time = t1;		assert: time hash = t1 hash;		assert: time = time copy.	self		deny: t1 < t2;		assert: t1 < t3.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:37'!testConverting	self		assert: time asSeconds = 14567.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:38'!testFromSeconds	| t |	t := self timeClass fromSeconds: 14567.	self		assert: t = time! !!TimeTest methodsFor: 'Tests' stamp: 'laza 8/28/2009 00:28'!testGeneralInquiries	| now d t dt epsilon |	"vm clocks seem to work differently across platforms, so an epsilon is required"	epsilon := 1. "second"	now  := self timeClass dateAndTimeNow.	self 		assert: now size = 2;		assert: (now last asSeconds - self timeClass now asSeconds) abs <= epsilon.	self should: [ self timeClass timeWords ] raise: MessageNotUnderstood.	d := '2 June 1973' asDate.	t := '4:02:47 am' asTime.	dt := self timeClass dateAndTimeFromSeconds: (2285280000 + 14567).	self		assert: dt = {d. t.}.! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:44'!testNew		self assert: self timeClass new asSeconds = 0! !!TimeTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 22:27'!testPrinting	self			assert: time printString = '4:02:47 am';		assert: time intervalString =  '4 hours 2 minutes 47 seconds';		assert: time print24 = '04:02:47';		assert: time printMinutes = '4:02 am';		assert: time hhmm24 = '0402'.! !!TimeTest methodsFor: 'Tests' stamp: 'tfel 9/1/2009 07:14'!testReadFrom	| t1 t2 |	t1 := self timeClass readFrom: '4:02:47 am' readStream.	t2 := self timeClass readFrom: '4:02:47.000 am' readStream.	self		assert: time = t1;		assert: time = t2! !!TimeTest methodsFor: 'Tests' stamp: 'gk 8/31/2006 00:47'!testSqueakInquiries	| timewords totalseconds condensed corrected |	self assert: 		(self timeClass namesForTimes: #(2 10000023 10000026))			= #('January, 1901' 'April, 1901, 4/26/1901, 5:47 pm' 'April, 1901, 4/26/1901, 5:47 pm').	timewords := #(0.5 30 62 130 4000 10000 60000 86401) 		collect: [ :ss | self timeClass humanWordsForSecondsAgo: ss ].	self assert: 		timewords = #('a second ago' '30 seconds ago' 'a minute ago' '2 minutes ago' 			'an hour ago' '2 hours ago' '16 hours ago' 'yesterday').	totalseconds :=  self timeClass totalSeconds.	condensed := self timeClass condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [:tt | totalseconds - tt]).	corrected := condensed collect: [ :e | totalseconds - e ].	self		assert: (corrected includesAllOf: #(20 400 401 20000 40000 45000 200000)).! !!TimeTest methodsFor: 'Tests' stamp: 'brp 7/27/2003 13:47'!testStoring	self			assert: time storeString = '''4:02:47 am'' asTime';		assert: time = ('4:02:47 am' asTime).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAddSeconds	self assert: (aTime addSeconds: 1) = (Time readFrom: (ReadStream on: '12:34:57')).	self assert: (aTime addSeconds: 60) = (Time readFrom: (ReadStream on: '12:35:56')).		self assert: (aTime addSeconds: 3600) = (Time readFrom: (ReadStream on: '13:34:56')).	self assert: (aTime addSeconds: 24*60*60) = (Time readFrom: (ReadStream on: '12:34:56')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAddTime	self assert: (aTime addTime: aTime) = (Time readFrom: (ReadStream on: '01:09:52')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDate	self assert: (aTime asDate) = (Date current)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDateAndTime	self assert: (aTime asDateAndTime) = (DateAndTime current midnight + aTime)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsDuration	self assert: (aTime asDuration) = (Duration days: 0 hours: 12 minutes: 34 seconds: 56)! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsNanoSeconds	self assert: (aTime asNanoSeconds) = 45296000000000! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsSeconds	self assert: (aTime asSeconds) = 45296! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTime	self assert: (aTime asTime) = aTime! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsTimeStamp	self assert: (aTime asTimeStamp) = (DateAndTime current midnight + aTime) asTimeStamp! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsWeek	self assert: aTime asWeek = (DateAndTime current midnight + aTime) asWeek! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testAsYear	self assert: aTime asYear = (DateAndTime current midnight + aTime) asYear! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testDuration	self assert: aTime duration = 0 seconds! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testEqual	self assert: aTime = (Time readFrom: (ReadStream on: '12:34:56')).! !!TimeTest methodsFor: 'testing' stamp: 'tlk 4/30/2006 22:14'!testHash	self assert: aTime hash =  607004.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHhmm24	self assert: aTime hhmm24 = '1234'! !!TimeTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:42'!testHour	self assert: aTime hour =  12.	self assert: aTime hour12 =  12.	self assert: aTime hour24 =  12.	self assert: aTime hours =  12.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgo	self assert: (Time humanWordsForSecondsAgo: 0.999999999)			= 'a second ago'.	self assert: (Time humanWordsForSecondsAgo: 44.99999999)			= '44.99999999 seconds ago'.	self assert: (Time humanWordsForSecondsAgo: 89.999999999)			= 'a minute ago'.	self assert: (Time humanWordsForSecondsAgo: 2699.999999999)			= '44 minutes ago'.	self assert: (Time humanWordsForSecondsAgo: 5399.999999999)			= 'an hour ago'.	self assert: (Time humanWordsForSecondsAgo: 64799.999999999)			= '17 hours ago'.	! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testHumanWordsForSecondsAgoWithDays	self assert: (Time humanWordsForSecondsAgo: 18 * 60 * 60)					= 'yesterday'.	self assert: (Time humanWordsForSecondsAgo: 24 * 60 * 60)					= 'yesterday'.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testLessThan	self assert: aTime < (Time readFrom: (ReadStream on: '12:34:57')).! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMeridianAbbreviation	self assert: aTime meridianAbbreviation =  'PM'.! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testMinute	self assert: aTime minute =  34.	self assert: aTime minutes =  34! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testNanoSecond	self assert: aTime nanoSecond = 0	"Right now all times all seconds"! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24	self assert: aTime print24 = '12:34:56'! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24On	| cs rw |	cs := ReadStream on: '12:34:56'.	rw := ReadWriteStream on: ''.	aTime print24: true on: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24OnWithPM	| cs rw |	cs := ReadStream on: '12:34:56 pm'.	rw := ReadWriteStream on: ''.	aTime print24: false on: rw.	^ self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrint24OnWithoutSeconds	| cs rw |	cs := ReadStream on: '12:34:56'.	rw := ReadWriteStream on: ''.	aTime print24: true showSeconds: true on: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrintMinutes	self assert: aTime printMinutes = '12:34 pm'! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testPrintOn	| cs rw |	cs := ReadStream on: '12:34:56 pm'.	rw := ReadWriteStream on: ''.	aTime printOn: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSecond	self assert: aTime second =  56.	self assert: aTime seconds =  56! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testStoreOn	| cs rw |	cs := ReadStream on: '''12:34:56 pm'' asTime'.	rw := ReadWriteStream on: ''.	aTime storeOn: rw.	self assert: rw contents = cs contents! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testSubtractTime	self assert: (aTime subtractTime: aTime) = (Time readFrom: (ReadStream on: '00:00:00'))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTicks	self assert: aTime ticks = #(0 45296 0).	self assert: aTime  = (Time new ticks: #(0 45296 0))! !!TimeTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:52'!testTimeStamp	self assert: aTime = aTime asTimeStamp asTime! !!TimeTest methodsFor: 'Private' stamp: 'brp 7/27/2003 13:32'!timeClass	^ Time! !!TimeTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Time.!!TimeZone class methodsFor: 'accessing' stamp: 'bgf 10/22/2007 21:26'!local	"TimeZone of the local system of this VM		TimeZone local	"	| offset |	offset := Duration minutes:(Time primTimezoneOffset).	^ self timeZones 			detect: [ : tz | tz offset = offset ] 			ifNone: [self offset: offset name: 'Unknown' abbreviation: '???']! !!TimespanDoSpanAYearTest methodsFor: 'running' stamp: 'brp 9/26/2004 18:59'!setUp	aDate := DateAndTime year: 2004 month: 12 day: 25 hour: 0 minute: 0 second: 0.	aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aTimespan := Timespan starting: aDate duration: aDuration! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month starting: (DateAndTime year: 2004 day: 355) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 1) duration: 31 days)				with: (Month starting: (DateAndTime year: 2005 day: 32) duration: 29 days)				with: (Month starting: (DateAndTime year: 2005 day: 61) duration: 31 days).					self assert: aTimespan months = monthArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 1/16/2004 13:55'!testNext	self assert: aTimespan next			= (Timespan					starting: (DateAndTime							year: 2005							month: 3							day: 26							hour: 0							minute: 0							second: 0)					duration: aDuration)! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'brp 9/26/2004 19:06'!testWeeksDo	| weeks weekArray |	weeks := aTimespan weeks.	self assert: weeks size = ((aDuration days / 7.0) ceiling + 1).	weekArray := OrderedCollection new.	weekArray		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 19) duration: 7 days);		addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).	2 to: 79 by: 7 do:		[ :i | weekArray				addLast: (Week starting: (DateAndTime year: 2005 day: i) duration: 7 days) ].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoSpanAYearTest methodsFor: 'testing' stamp: 'nk 3/30/2004 11:08'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime								year: 2004								month: 12								day: 25)						duration: 366 days).	self assert: aTimespan years = yearArray! !!TimespanDoSpanAYearTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list. tlk.My fixtures include a Timespan that crosses over a year boundary:aDate = December 25, 2004, midnightaDuration = 91 daysaTimeSpan= 91 days, starting December 25, 2004, midnight!!TimespanDoTest methodsFor: 'running' stamp: 'tlk 1/5/2004 13:01'!setUp	aDate := DateAndTime				year: 2003				month: 01				day: 07				hour: 0				minute: 0				second: 0.	aDuration := Duration				days: 91				hours: 0				minutes: 0				seconds: 0				nanoSeconds: 0.	aTimespan := Timespan starting: aDate duration: aDuration! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 18:00'!testDatesDo	| dateArray |	dateArray := OrderedCollection new.	7		to: 97		do: [:each | dateArray				addLast: (Date year: 2003 day: each)].	dateArray := dateArray asArray.	self assert: aTimespan dates = dateArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:36'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan				starting: aDate				duration: 7 days).	self assert: count = 13! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:39'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: aDate duration: 7 days)		when: [:each | count < 5].	self assert: count = 5	! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 15:39'!testEveryDo	|count  duration |	count := 0.	duration := 7 days.	(aTimespan			every: duration			do: [:each | count := count + 1]).	self assert: count = 13			! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:05'!testMonthsDo	| monthArray |	monthArray := Array				with: (Month						starting: (DateAndTime year: 2003 day: 1)						duration: 31 days)				with: (Month						starting: (DateAndTime year: 2003 day: 32)						duration: 28 days)				with: (Month						starting: (DateAndTime year: 2003 day: 60)						duration: 31 days)						with: (Month						starting: (DateAndTime year: 2003 day: 91)						duration: 30 days).	self assert: aTimespan months = monthArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 16:09'!testNext	self assert: aTimespan next 			= (Timespan					starting: (DateAndTime							year: 2003							month: 4							day: 8							hour: 0							minute: 0							second: 0)					duration: aDuration)! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:07'!testWeeksDo	| weekArray |	weekArray := OrderedCollection new.	7		to: 98		by: 7		do: [:each | weekArray				addLast: (Week						starting: (DateAndTime year: 2003 day: each)						duration: 7 days)].	weekArray := weekArray asArray.	self assert: aTimespan weeks = weekArray! !!TimespanDoTest methodsFor: 'testing' stamp: 'tlk 1/5/2004 13:09'!testYearsDo	| yearArray |	yearArray := Array				with: (Year						starting: (DateAndTime year: 2003 day: 7)						duration: 365 days).	self assert: aTimespan years contents = yearArray contents! !!TimespanDoTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndTimeEpochTestCase for a complete list.  tlk.My fixtures are:aDate = January 8, 2003, midnightaDuration = 91 daysaTimeSpan= 91 days, starting January 8, 2003, midnight!!TimespanTest methodsFor: 'Coverage' stamp: 'brp 9/15/2003 14:15'!classToBeTested	^ Timespan! !!TimespanTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:21'!setUp	localTimeZoneToRestore := DateAndTime localTimeZone.	DateAndTime localTimeZone: TimeZone default.	"100 hours starting noon 22 March 2003"	timespan := Timespan starting:					(DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0)						duration: (Duration hours: 100).	dec31 := (DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0).	jan01 := (DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0).	jan08 := (DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second:0).	aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.	aTimespan := Timespan starting: jan01 duration: aWeek.	anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.	anIncludedTimespan := Timespan starting: jan01 duration: aDay.	aDisjointTimespan := Timespan starting: jan08 duration: aWeek.! !!TimespanTest methodsFor: 'Running' stamp: 'nk 3/30/2004 09:22'!tearDown	DateAndTime localTimeZone: localTimeZoneToRestore.	timespan := nil! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 16:25'!testAccessing	self 		assert: (timespan start =				 (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0));		assert: timespan duration = (Duration hours: 100);		assert: timespan month = 3;		assert: timespan monthName = 'March';		assert: timespan monthAbbreviation = 'Mar'		! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 9/15/2003 14:29'!testArithmetic	| ts1 ts2 d |	ts1 := timespan + 2 days.	ts2 := ts1 - 2 days.	d := ts1 - (DateAndTime year: 2003 month: 03 day: 20).	self 		assert: (ts1 start = 				 (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0));		assert: (ts1 duration = timespan duration);		assert: (ts2 start = timespan start);		assert: (ts2 duration = timespan duration).	self		assert: d = (Duration days: 4 hours: 12 minutes: 0 seconds: 0)! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:43'!testInclusion	| t1 t2 t3 t4 |	t1 := timespan start.	t2 := timespan start + (timespan duration / 2).	t3 := timespan end.	t4 := timespan start + (timespan duration).	self 		assert: (timespan includes: t1);		assert: (timespan includes: t2);		assert: (timespan includes: t3)";		deny: (timespan includes: t4).	self		assert: (timespan includes: (t1 to: t2));		assert: (timespan includes: (t1 to: t4));		deny: (timespan includes: (Timespan starting: t2 duration: (timespan duration * 2))).	self 		assert: (timespan includesAllOf: { t1. t2. t3 } );		deny: (timespan includesAllOf: { t1. t2. t3. t4} ).	self 		assert: (timespan includesAnyOf: { t1. t2. t3 } );		deny: (timespan includesAnyOf: { t4 } )."! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:49'!testUnion	| union |	union := timespan union: timespan.		self 		assert: (union start = timespan start);		assert: (union duration = timespan duration)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDate	self assert: aTimespan asDate =   jan01 asDate.	"MessageNotUnderstood: Date class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDateAndTime	self assert: aTimespan asDateAndTime =   jan01.	"MessageNotUnderstood: Date class>>starting:"	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsDuration	self assert: aTimespan asDuration =  aWeek.		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsMonth	self assert: aTimespan asMonth =   jan01 asMonth.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTime	self assert: aTimespan asTime =  jan01 asTime	"MessageNotUnderstood: Time class>>seconds:nanoSeconds:" ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsTimeStamp	self assert: aTimespan asTimeStamp =  ((TimeStamp readFrom: '1-01-2005 0:00 am' readStream) offset: 0 hours).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsWeek	self assert: aTimespan asWeek =   jan01 asWeek.	"DateAndTime new asWeek	 MessageNotUnderstood: Week class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testAsYear	self assert: aTimespan asYear =   jan01 asYear.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 9/23/2004 09:58'!testClockPrecisionDuration	| ts |	ts := Timespan starting: Date today duration: DateAndTime clockPrecision.	self		assert: ts start = ts end! !!TimespanTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:26'!testCurrent	self assert: (Timespan starting: DateAndTime current)			<= Timespan current.	self assert:  Timespan current			<= (Timespan starting: DateAndTime current)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDay	self assert: aTimespan day =   jan01 day! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfMonth	self assert: aTimespan dayOfMonth  = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfWeek	self assert: aTimespan  dayOfWeek  = 7.	self assert: aTimespan  dayOfWeekName = 'Saturday'.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDayOfYear	self assert: aTimespan  dayOfYear  = 1.	"MessageNotUnderstood: UndefinedObject>>year:, Undefined object is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInMonth	self assert: aTimespan  daysInMonth  = 31.	"MessageNotUnderstood: Month class>>starting:"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysInYear	self assert: aTimespan  daysInYear  = 365.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDaysLeftInYear	self assert: aTimespan  daysLeftInYear  = 364.	"MessageNotUnderstood: UndefinedObject>>starting:  UndefinedObject is Year class"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWith	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay).	self assert: count = 7! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDoWithWhen	| count |	count := 0.	aTimespan		do: [:each | count := count + 1]		with: (Timespan starting: jan01 duration: aDay)		when: [:each | count < 5].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testDuration	self assert: aTimespan duration  = aWeek.	aTimespan duration: aDay.	self assert: aTimespan duration =  aDay.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testEnd	self assert: aTimespan end 	+ (Duration  nanoSeconds:1)  =  aDisjointTimespan	"self assert: aTimespan end 	(DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours). "	"This should work once DateAndTime >> year:month:day:hour:minute:second:nanoSecond:offset: is fixed"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testEveryDo	| count duration |	count := 0.	duration := 7 days.	aTimespan		every: duration		do: [:each | count := count + 1].	self assert: count = 1! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testFirstDayOfMonth	self assert: aTimespan firstDayOfMonth =   1. 	self assert: aDisjointTimespan firstDayOfMonth =   1! !!TimespanTest methodsFor: 'testing' stamp: 'tlk 4/30/2006 22:15'!testHash	self assert: aTimespan hash =     101198424	"must be a more meaningful test?"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludes	self assert: (aTimespan includes: jan01).	self deny: (aTimespan includes: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAllOf	self assert: (aTimespan includesAllOf: (Bag with: jan01)).	self deny: (aTimespan includesAllOf: (Bag with: jan01 with: jan08))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIncludesAnyOf	self deny: (aTimespan includesAnyOf: (Bag with: dec31)).	self assert: (aTimespan includesAnyOf: (Bag with: jan01 with: jan08))	"Error is due to bug in Timespan includesAnyOf: aCollection "	"Answer whether any element of aCollection is included in the receiver"	"aCollection do: [ :elem | (self includes: elem) ifTrue: [^ true]].Shouldn't this return false if none are included?"! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithDisjoint	self assert: (aTimespan intersection: aDisjointTimespan) isNil.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithIncluded	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithOverlapping	self assert: (aTimespan intersection: anOverlappingTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 5 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).		! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSelf	self assert: (aTimespan intersection: aTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 6 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= aTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIntersectionWithSeparate	self assert: (aTimespan intersection: aDisjointTimespan) isNil.	self deny: (aTimespan intersection: anOverlappingTimespan) isNil.	self assert: (aTimespan intersection: anIncludedTimespan)  = 	(Timespan starting: jan01 duration: (Duration days: 0 hours: 23 minutes: 59 seconds: 59 nanoSeconds: 999999999)).			self deny: (aTimespan intersection: anIncludedTimespan)	= anIncludedTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testIsLeapYear	"self assert: anOverlappingTimespan isLeapYear."	"not sure why this fails"	self deny: aTimespan isLeapYear! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testJulianDayNumber	self assert: aTimespan julianDayNumber =  (jan01 julianDayNumber).! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testLessThan	self assert: aTimespan  < aDisjointTimespan.	self deny: anIncludedTimespan < aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADateAndTime	"It appears that subtracting a date from a Timespan gives you a duration = to the difference between the start of the timespan and the date "	self assert: aTimespan - dec31 =  aDay.	self assert: aDisjointTimespan - jan01 =  aWeek.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMinusADuration	"It appears that subtracting a duration from a Timespan gives you a Timespan shifted by the duration"	self assert: aTimespan - aDay =  anOverlappingTimespan.	self assert: aDisjointTimespan - aWeek =  aTimespan.	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testMonth	self assert: aTimespan month  = 1.	self assert: aTimespan monthName = 'January'.	self assert: aTimespan monthIndex = 1.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNew	self assert: Timespan new = (Timespan starting: '01-01-1901' asDate)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testNext	self assert: aTimespan next = aDisjointTimespan! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPlus	self assert: aTimespan + aWeek = aDisjointTimespan.	self assert: anOverlappingTimespan + aDay = aTimespan.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testPrevious	self assert: aTimespan  = aDisjointTimespan previous.	self assert: aTimespan next previous = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'nk 3/30/2004 09:23'!testPrintOn	| cs rw |	cs := ReadStream on: 'a Timespan(2005-01-01T00:00:00+00:00D7:00:00:00)'.	rw := ReadWriteStream on: ''.	aTimespan  printOn: rw.	self assert: rw contents = cs contents! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStart	self assert: aTimespan start =   jan01.	aTimespan start: jan08.	self assert: aTimespan start =   jan08.! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testStartingEnding	self assert: aTimespan  = (Timespan starting: jan01 ending: jan08)! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testTo	self assert: (anIncludedTimespan to: jan08) = aTimespan ! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithDisjoint	self assert: (aTimespan union: aDisjointTimespan)  = 		(Timespan starting: jan01 duration: (14 days)).				! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithIncluded	self 		assert: (aTimespan union: anIncludedTimespan) = aTimespan 	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithOverlapping	self 		assert: (aTimespan union: anOverlappingTimespan)  = 				(Timespan starting: dec31 duration: (8 days))! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSelf	self assert: (aTimespan union: aTimespan) = aTimespan	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testUnionWithSeparate	self 		assert: (anOverlappingTimespan union: aDisjointTimespan) = 			(Timespan 				starting: anOverlappingTimespan start				ending:  (aDisjointTimespan end + DateAndTime clockPrecision))			! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testWorkDatesDo	| count |	count := 0.	aTimespan		workDatesDo: [:each | count := count + 1].	self assert: count = 5! !!TimespanTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:31'!testYear	self assert: aTimespan year = 2005.	! !!TimespanTest methodsFor: 'testing' stamp: 'brp 9/23/2004 09:57'!testZeroDuration	| ts |	ts := Timespan starting: Date today duration: Duration zero.	self		assert: ts start = ts end! !!TopGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:22'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!TopGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!TopGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:31'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ -40  corner: 0@ 0)! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!ptName	^#top! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!resizeCursor	^ Cursor resizeForEdge: #top! !!TranscriptStream methodsFor: 'access' stamp: 'bgf 7/10/2006 14:01'!defaultStyle	^ DefaultStyle! !!TranscriptStream methodsFor: 'initialization' stamp: 'bgf 3/16/2008 01:45'!initialize	super initialize.! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'bgf 3/16/2008 01:49'!bs	self mutex critical: [		self position > 0 ifTrue: [^ self skip: -1].		self changed: #bs	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'bgf 3/16/2008 01:48'!clear	"Clear all characters and redisplay the view"	self mutex critical: [		self changed: #clearText.		self reset		].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'bgf 3/16/2008 01:44'!endEntry	"Display all the characters since the last endEntry, and reset the stream"	self mutex critical:[		self changed: #appendEntry.		self reset.	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'bgf 3/16/2008 01:49'!pastEndPut: anObject	"If the stream reaches its limit, just output the contents and reset."	self mutex critical: [		self endEntry.		^ self nextPut: anObject	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'bgf 3/16/2008 01:49'!show: anObject  "TextCollector compatibility"	self mutex critical: [		self nextPutAll: anObject asString; endEntry	].! !!TranscriptStream methodsFor: 'private' stamp: 'bgf 3/16/2008 02:02'!mutex	^AccessMutex ifNil:[AccessMutex := Mutex new]! !!TranscriptStream methodsFor: 'accessing' stamp: 'bgf 3/16/2008 01:44'!contents	self mutex critical: [		^ super contents	].! !!TranscriptStream methodsFor: 'accessing' stamp: 'bgf 3/16/2008 01:44'!next: anInteger putAll: aCollection startingAt: startIndex	self mutex critical: [		super next: anInteger putAll: aCollection startingAt: startIndex	].! !!TranscriptStream methodsFor: 'accessing' stamp: 'bgf 3/16/2008 01:44'!nextPut: char	self mutex critical: [		super nextPut: char	].! !!TranscriptStream methodsFor: 'accessing' stamp: 'bgf 3/16/2008 01:44'!nextPutAll: aCollection	self mutex critical: [		super nextPutAll: aCollection	].! !!TranscriptStream commentStamp: '<historical>' prior: 0!This class is a much simpler implementation of Transcript protocol that supports multiple views and very simple conversion to morphic.  Because it inherits from Stream, it is automatically compatible with code that is designe to write to streams.!!TranscriptStream class methodsFor: 'class initialization' stamp: 'bgf 3/21/2009 21:38'!initialize	"The transcript slows down if using antialiased TT fonts,       so we don't use 'default text font' for the Transcript;	 instead we bind the transcript to a bitmap strike font."	AccessMutex := Mutex new.	self useStyle: #Accumon size: 12.	"Big and ugly, but some folks like that."	self registerInFlapsRegistry.		"TranscriptStream initialize."! !!TranscriptStream class methodsFor: 'class initialization' stamp: 'bgf 11/25/2007 14:00'!useStyle: aStyleSymbol size: aPointSize	"Set the font for Transcript morphs.	 (A bitmap font like Accu* is best; TT font rendering slows the transcript a lot.)	 	An example do-it:		TranscriptStream useStyle: #Accuny size: 12	"	| fontArray |		fontArray := Array new: 1.	fontArray at: 1 put: ((TextStyle named: aStyleSymbol) fontOfSize: aPointSize).	DefaultStyle := (TextStyle fontArray: fontArray).! !!TransformMorphTest methodsFor: 'as yet unclassified' stamp: 'ar 4/15/2007 21:35'!tearDown	pasteUp ifNotNil:[pasteUp topRendererOrSelf delete].	childMorph ifNotNil:[childMorph topRendererOrSelf delete].! !!TransformMorphTest methodsFor: 'as yet unclassified' stamp: 'ar 4/15/2007 21:34'!testTransformedBy	"self run: #testTransformedBy"	"self debug: #testTransformedBy"		pasteUp := PasteUpMorph new openInWorld extent: 100@100.	pasteUp addMorph: (childMorph := Morph new).	childMorph heading: 30.	pasteUp heading: 30.	self shouldnt: 			[ActiveHand grabMorph: childMorph.			ActiveHand position: 10@10 + ActiveHand position.] 		raise: MessageNotUnderstood! !!True methodsFor: 'printing' stamp: 'ajh 7/1/2004 10:36'!printOn: aStream 	aStream nextPutAll: 'true'! !!TrueTest methodsFor: 'testing' stamp: 'sd 6/5/2005 09:06'!testAND	self assert: (true & true) = true.	self assert: (true & false) = false.! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:11'!testAnd	self assert: (true and: ['alternativeBlock']) = 'alternativeBlock'.! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:24'!testAsBit	self assert: (true asBit = 1).! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:12'!testIfFalse	self assert: (true ifFalse: ['alternativeBlock']) = nil. ! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:16'!testIfFalseIfTrue	self assert: (true ifFalse: ['falseAlternativeBlock']                       ifTrue: ['trueAlternativeBlock']) = 'trueAlternativeBlock'. ! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:20'!testIfTrue		self assert: (true ifTrue: ['alternativeBlock']) = 'alternativeBlock'. ! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:15'!testIfTrueIfFalse	self assert: (true ifTrue: ['trueAlternativeBlock']                       ifFalse: ['falseAlternativeBlock']) = 'trueAlternativeBlock'. ! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:22'!testInMemory	self assert: (true isInMemory = true).! !!TrueTest methodsFor: 'testing' stamp: 'sd 6/5/2005 09:06'!testNew	self should: [True new] raise: Error. ! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:22'!testNot	self assert: (true not = false).! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:07'!testOR	self assert: (true | true) = true.	self assert: (true | false) = true.! !!TrueTest methodsFor: 'testing' stamp: 'it 7/13/2009 22:19'!testOr	self assert: (true or: ['alternativeBlock']) = true.! !!TrueTest methodsFor: 'testing' stamp: 'sd 6/5/2005 09:06'!testPrintOn	self assert: (String streamContents: [:stream | true printOn: stream]) = 'true'. ! !!TrueTest methodsFor: 'testing' stamp: 'nice 10/14/2009 23:07'!testXor	self assert: (true xor: true) = false.	self assert: (true xor: false) = true.		self		should: [(true xor: [true])			ifTrue: ["This should never be true, do not signal an Error and let the test fail"]			ifFalse: [self error: 'OK, this should be false, raise an Error']]		raise: Error		description: 'a Block argument is not allowed. If it were, answer would be false'.! !!URI methodsFor: 'printing' stamp: 'ar 9/1/2010 15:18'!allButScheme	"Answer the entire url except its scheme"	^String streamContents:[:s|		s nextPutAll: schemeSpecificPart.		fragment ifNotNil: [			s nextPut: $# .			s nextPutAll: self fragment]	].! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."		^self class errorMalformedInput: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!nextFromStream: aStream	| char1 value1 char2 value2 unicode char3 value3 char4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	char1 := aStream basicNext.	char1 ifNil:[^ nil].	value1 := char1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte char"		^ char1	].	"at least 2-byte char"	char2 := aStream basicNext.	char2 ifNil:[^self errorMalformedInput: (String with: char1)].	value2 := char2 asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	"at least 3-byte char"	char3 := aStream basicNext.	char3 ifNil:[^self errorMalformedInput: (String with: char1 with: char2)].	value3 := char3 asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte char"		char4 := aStream basicNext.		char4 ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].		value4 := char4 asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].	unicode > 16r10FFFD ifTrue: [		^self errorMalformedInput: (String with: char1 with: char2 with: char3).	].		unicode = 16rFEFF ifTrue: [^ self nextFromStream: aStream].	^ Unicode value: unicode.! !!UTF8TextConverter commentStamp: '<historical>' prior: 0!Text converter for UTF-8.  Since the BOM is used to distinguish the MacRoman code and UTF-8 code, BOM is written for UTF-8 by #writeBOMOn: which is called by client.!!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."	self strictUtf8Conversions ifTrue:[		self error: 'Invalid utf8: ', aString	].	^aString! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions	"Preference setter for strict utf-8 conversions"	<preference: 'Strict utf8 conversions'		category: 'general' "should this be localization?"		description: 'If true, invalid utf-8 input will raise errors. If false, invalid utf-8 input will be allowed to pass through the conversion unchanged'		type: #Boolean>		^StrictUtf8Conversions ifNil:[true]! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions: aBool	"Preference setter for strict utf-8 conversions"	StrictUtf8Conversions := aBool.! !!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:11'!decodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size) writeStream.	[		outStream next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex.		byte1 := aByteString byteAt: nextIndex.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[	^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63)].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte4 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63)].		unicode ifNil: [ ^self errorMalformedInput: aByteString ].		unicode = 16rFEFF ifFalse: [ "Skip byte order mark"			outStream nextPut: (Unicode value: unicode) ].		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:30'!testLazyConversion	"Ensure the lazy conversions do what they should"	| strict result |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: false.	self shouldnt:[result := 'Gr Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].	self assert: result = 'Gr Gott'.! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:29'!testSqueakToUtf8	"Ensure proper encoding"	self assert: '' squeakToUtf8 equals: ''.	self assert: 'Hello World' squeakToUtf8 equals: 'Hello World'.	self assert: 'Gr Gott' squeakToUtf8 asByteArray 		equals: #[71 114 195 188 195 159 32 71 111 116 116]! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:27'!testStrictConversion	"Ensure the strict conversions do what they should"	| strict |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: true.	self should:[ 'Gr Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:28'!testUtf8ToSqueak	"Ensure proper encoding"	self assert: '' utf8ToSqueak equals: ''.	self assert: 'Hello World' utf8ToSqueak equals: 'Hello World'.	self assert: #[71 114 195 188 195 159 32 71 111 116 116] asString utf8ToSqueak		equals: 'Gr Gott'! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:14'!testCreation	| uuid |	uuid := UUID new.	self should: [uuid size = 16].	self shouldnt: [uuid isNilUUID].	self should: [uuid asString size = 36].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:27'!testCreationEquality	| uuid1 uuid2 |	uuid1 := UUID new.	uuid2 := UUID new.	self should: [uuid1 = uuid1].	self should: [uuid2 = uuid2].	self shouldnt: [uuid1 = uuid2].	self shouldnt: [uuid1 hash = uuid2 hash].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:17'!testCreationFromString	| uuid string |	string := UUID nilUUID asString.	uuid := UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid = UUID nilUUID].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:18'!testCreationFromStringNotNil	| uuid string |	string := UUID new asString.	uuid := UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid asString size = 36].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:16'!testCreationNil	| uuid |	uuid := UUID nilUUID.	self should: [uuid size = 16].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'nice 12/27/2009 04:14'!testCreationNodeBased		(UUID new asString last: 12) = (UUID new asString last: 12) ifFalse: [^self].	1000 timesRepeat:		[ | uuid |		uuid := UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r10].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'nice 12/27/2009 04:15'!testDuplicationsKinda	| check size |	size := 5000.	check := Set new: size.	size timesRepeat: 		[ | uuid |		uuid := UUID new.		self shouldnt: [check includes: uuid].		check add: uuid].		! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'nice 12/27/2009 04:15'!testOrder		100 timesRepeat:		[ | uuid1 uuid2 |		uuid1 := UUID new.		uuid2 := UUID new.		(uuid1 asString last: 12) = (uuid2 asString last: 12) ifTrue:			[self should: [uuid1 < uuid2].			self should: [uuid2 > uuid1].			self shouldnt: [uuid1 = uuid2]]]! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'eem 8/17/2010 16:35'!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare method temp'.			actions add: [parser declareTemp: name at: #method].			labels add: 'declare block-local temp'.			actions add: [parser declareTemp: name at: #block].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!UndeclaredVariableNode methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:51'!accept: aVisitor	^aVisitor visitUndeclaredVariableNode: self! !!UndeclaredVariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^true! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	^tag! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag: anObject	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	tag := anObject! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!ifNil: aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!UndefinedObject methodsFor: 'testing' stamp: 'sma 6/6/2000 22:53'!isNil 	"Refer to the comment in Object|isNil."	^true! !!UndefinedObject methodsFor: '*Collections' stamp: 'Igor.Stasenko 11/13/2009 06:16'!asSetElement	"Since nil is a singleton, we need only a single wrapper instance to represent it in set,	created in advance"	^ SetElement withNil! !!UndefinedObjectTest methodsFor: 'tests - Class Methods' stamp: 'nice 11/14/2009 19:25'!testAllInstances	self assert: UndefinedObject allInstances size = 1 description: 'There should be a single instance of UndefinedObject'.	self assert: (UndefinedObject allInstances includes: nil) description: 'nil should be an instance of UndefinedObject'.! !!UndefinedObjectTest methodsFor: 'tests - Class Methods' stamp: 'sd 6/5/2005 09:08'!testInitializedInstance	self assert: ( UndefinedObject initializedInstance class == UndefinedObject).! !!UndefinedObjectTest methodsFor: 'tests - Class Methods' stamp: 'sd 6/5/2005 09:09'!testNew	self should: [ UndefinedObject new] raise: Error.! !!UndefinedObjectTest methodsFor: 'tests - copying' stamp: 'sd 6/5/2005 09:07'!testClone	self assert: ( nil clone = nil).! !!UndefinedObjectTest methodsFor: 'tests - copying' stamp: 'sd 6/5/2005 09:07'!testDeepCopy	self assert:  (nil deepCopy = nil).! !!UndefinedObjectTest methodsFor: 'tests - copying' stamp: 'sd 6/5/2005 09:07'!testShallowCopy	self assert: (nil shallowCopy = nil).! !!UndefinedObjectTest methodsFor: 'tests - copying' stamp: 'sd 6/5/2005 09:07'!testVeryDeepCopyWith	self assert: ((nil veryDeepCopyWith: nil) = nil).! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:07'!testHaltIfNil	self should: [ nil haltIfNil] raise: Halt.! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 15:47'!testIfNil	| object block |	object := Object new.	self should: [ nil ifNil: [ self halt ] ] raise: Halt.	self assert: (nil ifNil: [ object ]) == object.	"Now the same without inlining."		block := [ self halt ].	self should: [ nil ifNil: block ] raise: Halt.	block := [ object ].	self assert: (nil ifNil: block) == object.	! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:46'!testIfNilIfNotNil	| object block |	object := Object new.	self should: [ nil ifNil: [self halt] ifNotNil: [ self error] ] raise: Halt.	self should: [ nil ifNil: [ self halt ] ifNotNil: [ :o | self error ] ] raise: Halt.	self assert: (nil ifNil: [ object ] ifNotNil: [ 1 ]) == object.	self assert: (nil ifNil: [ object ] ifNotNil: [ :o | 1 ]) == object.	"Now the same without inlining."	block := [ self halt ].	self should: [ nil ifNil: block ifNotNil: [ self error ] ] raise: Halt.	self should: [ nil ifNil: block ifNotNil: [ :o | self error ] ] raise: Halt.	block := [ object ].	self assert: (nil ifNil: block ifNotNil: [ 1 ]) == object.	self assert: (nil ifNil: block ifNotNil: [ :o | 1 ]) == object! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:46'!testIfNotNil	| block |	self shouldnt: [ nil ifNotNil: [ self halt ] ] raise: Halt.	self shouldnt: [ nil ifNotNil: [ :object | self halt ] ] raise: Halt.	self assert: (nil ifNotNil: [ 1 ]) == nil.	self assert: (nil ifNotNil: [ :o | 1 ]) == nil.	"Now the same without inlining."		block := [ self halt ].	self shouldnt: [ nil ifNotNil: block ] raise: Halt.	block := [ :object | self halt ].	self shouldnt: [ nil ifNotNil: block ] raise: Halt.	block := [ 1 ].	self assert: (nil ifNotNil: block) == nil.	block := [ :o | 1 ].	self assert: (nil ifNotNil: block) == nil.		! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:08'!testIfNotNilDo	self shouldnt: [ nil ifNotNilDo: [self halt]] raise: Halt.! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:42'!testIfNotNilIfNil	| object block |	object := Object new.	self should: [ nil ifNotNil: [ self error ] ifNil: [ self halt ] ] raise: Halt.	self should: [ nil ifNotNil: [ :o | self error] ifNil: [ self halt ] ] raise: Halt.	self assert: (nil ifNotNil: [ 1 ] ifNil: [ object ]) == object.	self assert: (nil ifNotNil: [ :o | 1 ] ifNil: [ object ]) == object.	"Now the same without inlining."	block := [ self error ].	self should: [ nil ifNotNil: block ifNil: [ self halt ] ] raise: Halt.	block := [ :o | self error].	self should: [ nil ifNotNil: block ifNil: [ self halt ] ] raise: Halt.	block := [ 1 ].	self assert: (nil ifNotNil: block ifNil: [ object ]) == object.	block := [ :o | 1 ].	self assert: (nil ifNotNil: block ifNil: [ object ]) == object! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:08'!testIsEmptyOrNil	self assert: (nil isEmptyOrNil).! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:08'!testIsLiteral	self assert: (nil isLiteral).! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:42'!testIsNil	self assert: nil isNil! !!UndefinedObjectTest methodsFor: 'tests - testing' stamp: 'ul 12/18/2009 17:43'!testNotNil	self deny: nil notNil! !!UndefinedObjectTest methodsFor: 'tests - printing' stamp: 'sd 6/5/2005 09:09'!testPrintOn	| string |	string := String streamContents: [:stream | nil printOn: stream].	self assert: (string = 'nil').! !!UndefinedObjectTest methodsFor: 'tests - printing' stamp: 'sd 6/5/2005 09:09'!testStoreOn	| string |	string := String streamContents: [:stream | nil storeOn: stream].	self assert: ((Compiler evaluate: string) = nil).! !!UndefinedObjectTest commentStamp: '<historical>' prior: 0!This is the unit test for the class UndefinedObject. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!UnhandledError methodsFor: 'priv handling' stamp: 'ar 12/6/2006 11:35'!defaultAction	"Handle an otherwise unhandled error. The default mechanism delegates to the currently active process which can decide whether to delegate further, log the error, terminate the computation, raise a debugger or whatever more. Typically, the request will delegated to SystemErrorHandler default for final consumption."	^Processor activeProcess handleError: exception! !!UnimplementedCallBugz methodsFor: 'as yet unclassified' stamp: 'wiz 5/3/2007 19:53'!testPolyIntersect"self run: #testPolyIntersect"self shouldnt: [ PolygonMorph initializedInstance 					intersects: ( Rectangle center: Display center 											extent: 100 asPoint ) ] 	raise: Error .! !!UnixFileDirectory methodsFor: 'file names' stamp: 'eem 6/2/2010 09:38'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName |	fName := super checkName: aFileName fixErrors: fixing.	(fName includes: self class pathNameDelimiter) ifFalse:		[^fName].	^fixing		ifTrue: [fName copyReplaceAll: (String with: self class pathNameDelimiter) with: '#']		ifFalse: [self error:'Invalid file name']! !!UnixFileDirectory methodsFor: 'private' stamp: 'ar 12/31/2007 10:54'!setPathName: pathString	"Unix path names start with a leading delimiter character."	(pathString isEmpty or: [pathString first ~= self pathNameDelimiter])		ifTrue: [pathName := self pathNameDelimiter asString, pathString]		ifFalse: [pathName := pathString].! !!UnixFileDirectoryTests methodsFor: 'testing' stamp: 'bobw 7/27/2010 09:26'!testCheckNameFixErrors	| directory bigName maxLength |	"Do not use #on:, it will use the default directory class, which 	 might be different on this platform."	directory := UnixFileDirectory new setPathName: '.'.	self assert: ('abc' = (directory checkName: 'abc' fixErrors: false)).	self assert: ('abc' = (directory checkName: 'abc' fixErrors: true)).		"These test the superclass implementation."	self should: [directory checkName: '' fixErrors: false] raise: Error.	self should: [directory checkName: '' fixErrors: true] raise: Error.	maxLength := directory class maxFileNameLength.	bigName := String streamContents: [:s | maxLength + 1 timesRepeat: [s nextPut: $1]].	self should: [directory checkName: bigName fixErrors: false] raise: Error.	"#contractTo: seems a little odd, but it is what #checkName:fixErrors: uses"	self assert: ((bigName contractTo: maxLength)  = (directory checkName: bigName fixErrors: true)).		"UnixFileDirectory specific tests"	"UnixFileDirectory will turn / into #, if told to fix errors."	self assert: ('a#b#c' = (directory checkName: 'a/b/c' fixErrors: true)).	"And it will raise an error if it does not fix errors."	self should: [(directory checkName: 'a/b/c' fixErrors: false)] raise: Error! !!UnixFileDirectoryTests commentStamp: 'bobw 7/27/2010 09:08' prior: 0!Just some simply unit tests for UnixFileDirectoryInstance Variables:!!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents	^ contents! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents: c	contents := c! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 16:31'!getSelector	"Answer the getSelector"	^ getSelector! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector := aSymbol.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:28'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector	^ putSelector! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector: aSymbol	putSelector := aSymbol! !!UpdatingRectangleMorph methodsFor: 'accessing'!target	^ target! !!UpdatingRectangleMorph methodsFor: 'accessing'!target: anObject	target := anObject.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 11/15/2001 16:22'!userEditsAllowed	"Answer whether it is suitable for a user to change the value represented by this readout"	^ putSelector notNil! !!UpdatingRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color lightGray lighter! !!UpdatingRectangleMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:45'!handlesMouseDown: evt 	^putSelector notNil! !!UpdatingRectangleMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 18:54'!mouseUp: evt	self changeColorTarget: self selector: #setTargetColor: originalColor: color hand: evt hand.! !!UpdatingRectangleMorph methodsFor: 'target access' stamp: 'dgd 2/22/2003 14:40'!readFromTarget	"Read the color value from my target"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	target isMorph ifTrue: [target isInWorld ifFalse: [^contents]].	v := self valueProvider perform: getSelector.	lastValue := v.	^v! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 23:26'!setTargetColor: aColor	"Set my target's color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents := aColor.		self valueProvider perform: self putSelector withArguments: (Array with: aColor)]! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 13:24'!valueProvider	"Answer the object to which my get/set messages should be sent.  This is inefficient and contorted in order to support grandfathered content for an earlier design"	^ target isMorph		ifTrue:			[target topRendererOrSelf player ifNil: [target]]		ifFalse:			[target]! !!UpdatingRectangleMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:27'!step	| s |	super step.	s := self readFromTarget.	s = contents ifFalse:		[self contents: s.		self color: s]! !!UpdatingRectangleMorph methodsFor: 'testing'!stepTime	^ 50! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied"lastValue := lastValue veryDeepCopyWith: deepCopier."getSelector := getSelector.		a Symbol""putSelector := putSelector.		a Symbol"contents := contents veryDeepCopyWith: deepCopier.! !!UpdatingRectangleMorph commentStamp: '<historical>' prior: 0!Intended for use as a color swatch coupled to a color obtained from the target, but made just slightly more general than that.!!Url class methodsFor: 'parsing' stamp: 'ar 8/30/2010 14:43'!urlClassForScheme: scheme	(scheme isNil or: [scheme = 'http']) ifTrue: [^HttpUrl].	scheme = 'https' ifTrue: [^HttpUrl].	scheme = 'ftp' ifTrue: [^FtpUrl].	scheme = 'file' ifTrue: [^FileUrl].	scheme = 'mailto' ifTrue: [^MailtoUrl].	scheme = 'browser' ifTrue: [^BrowserUrl].	^GenericUrl! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:58'!testAbsoluteBrowser	url := Url absoluteFromText: 'browser:bookmarks#mainPart'.	self assert: url schemeName = 'browser'.	self assert: url locator = 'bookmarks'.	self assert:url fragment = 'mainPart'.	self assert: url class = BrowserUrl.	! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:29'!testAbsoluteFILE		url := Url absoluteFromText: 'file:/etc/passwd#foo'.	self assert: url schemeName = 'file'.	self assert: url path first = 'etc'.	self assert: url path size = 2.		self assert: url fragment = 'foo'.! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:32'!testAbsoluteFILE2		url := 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.	self assert: url schemeName = 'file'.	self assert: url class = FileUrl.	self assert: url path first ='foo'.	self assert: url path size = 5.	self assert: url fragment = 'fragger'.! !!UrlTest methodsFor: 'tests' stamp: 'gk 2/12/2004 21:30'!testAbsoluteFILE3	"Just a few selected tests for FileUrl, not complete by any means."	{'file:'. 'file:/'. 'file://'} do: [:s |	 	url := FileUrl absoluteFromText: s.		self assert: (url asString = 'file:///').		self assert: (url host = '').		self assert: url isAbsolute].		url := FileUrl absoluteFromText: 'file://localhost/dir/file.txt'.	self assert: (url asString = 'file://localhost/dir/file.txt').	self assert: (url host = 'localhost').		url := FileUrl absoluteFromText: 'file://localhost/dir/file.txt'.	self assert: (url asString = 'file://localhost/dir/file.txt').	self assert: (url host = 'localhost').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'file:///dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self assert: (url host = '').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: '/dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self deny: url isAbsolute.		url := FileUrl absoluteFromText: 'c:/dir/file.txt'.	self assert: (url asString = 'file:///c%3A/dir/file.txt').	self assert: url isAbsolute.		"Only a drive letter doesn't refer to a directory."	url := FileUrl absoluteFromText: 'c:'.	self assert: (url asString = 'file:///c%3A/').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'c:/'.	self assert: (url asString = 'file:///c%3A/').	self assert: url isAbsolute! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:05'!testAbsoluteFTP		url := 'ftP://some.server/some/directory/' asUrl.	self assert: url schemeName = 'ftp'.	self assert: url class = FtpUrl.	self assert: url authority = 'some.server'.		self assert: url path first = 'some'.	self assert: url path size  = 3.	! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:05'!testAbsoluteHTTP		url := 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.	self assert: url schemeName = 'http'.	self assert: url authority = 'chaos.resnet.gatech.edu'.	self assert: url path first = 'docs'.	self assert: url path size = 3.	self assert: url query = 'A%20query%20'.	self assert: url fragment = 'part'.! !!UrlTest methodsFor: 'tests' stamp: 'md 1/5/2004 14:51'!testAbsolutePortErrorFix		self shouldnt: [Url absoluteFromText: 'http://swikis.ddo.jp:8823/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:-1/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:65536/'] raise: Error.	self should: [Url absoluteFromText: 'http://swikis.ddo.jp:auau/'] raise: Error.! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:08'!testAbsoluteTELNET		url := 'telNet:chaos.resnet.gatech.edu#goo' asUrl.	self assert: url schemeName = 'telnet'.	self assert: url locator = 'chaos.resnet.gatech.edu'.	self assert: url fragment = 'goo'.	! !!UrlTest methodsFor: 'tests' stamp: 'st 9/27/2004 15:48'!testCombineWithRelative	#(#('http://www.rfc1149.net/' 'foo.html' 'http://www.rfc1149.net/foo.html') #('http://www.rfc1149.net/index.html' 'foo.html' 'http://www.rfc1149.net/foo.html') #('http://www.rfc1149.net/devel/' '../sam/' 'http://www.rfc1149.net/sam/') #('http://www.rfc1149.net/devel/index.html' '../sam/' 'http://www.rfc1149.net/sam/')) 		do: [:a | self assert: (Url combine: a first withRelative: a second) = a third]! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFILE		| url2 |	baseUrl := 'file:/some/dir#fragment1' asUrl.	url := baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.	self assert: url asText =  'file:///another/dir/#fragment2'.		url := FileUrl absoluteFromText: 'file://localhost/dir/dir2/file.txt'.	url2 := FileUrl absoluteFromText: 'file://hostname/flip/file.txt'.	url2 privateInitializeFromText: '../file2.txt' relativeTo: url.	self assert: (url2 asString = 'file://localhost/dir/file2.txt').	self assert: (url2 host = 'localhost').	self assert: url2 isAbsolute.		url := FileUrl absoluteFromText: 'file://localhost/dir/dir2/file.txt'.	url2 := FileUrl absoluteFromText: 'flip/file.txt'.	self deny: url2 isAbsolute.	url2 privateInitializeFromText: '.././flip/file.txt' relativeTo: url.	self assert: (url2 asString = 'file://localhost/dir/flip/file.txt').	self assert: (url2 host = 'localhost').	self assert: url2 isAbsolute.	! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'ftp://a.b'.	self assert: url asString =  'ftp://a.b/'.! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP2		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'ftp:xyz'.	self assert: url asString =  'ftp://somewhere/some/dir/xyz'.! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP3		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'http:xyz'.	self assert: url asString = 'http://xyz/'.! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeHTTP		baseUrl := 'http://some.where/some/dir?query1#fragment1' asUrl.	url := baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.	self assert: url asString =  'http://some.where/another/dir/?query2#fragment2'.! !!UrlTest methodsFor: 'tests' stamp: 'gk 2/12/2004 21:31'!testRoundTripFILE	"File URLs should round-trip OK. This test should ultimately be	tested on all platforms."	| fileName |	fileName := FileDirectory default fullNameFor: 'xxx.st'.	url := FileDirectory urlForFileNamed: fileName.	self assert: (url pathForFile = fileName) description: 'fileName didn''t round-trip'.! !!UrlTest methodsFor: 'tests' stamp: 'md 7/21/2003 10:48'!testUsernamePassword	"basic case with a username+password specified"	url := 'http://user:pword@someserver.blah:8000/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"basic case for a relative url"	baseUrl := 'http://anotherserver.blah:9999/somedir/someotherdir/stuff/' asUrl.	url := 'http://user:pword@someserver.blah:8000/root/index.html' asUrlRelativeTo: baseUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"a true relative test that should keep the username and password from the base URL"	baseUrl := 'http://user:pword@someserver.blah:8000/root/index.html' asUrl.	url := '/anotherdir/stuff/' asUrlRelativeTo: baseUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'anotherdir' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].		"just a username specified"	url := 'http://user@someserver.blah:8000/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = 8000 ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = nil ].	"the port is not specified"	url := 'http://user:pword@someserver.blah/root/index.html' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = nil ].	self should: [ url path first = 'root' ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"neither a path nor a port is specified"	url := 'http://user:pword@someserver.blah' asUrl.	self should: [ url schemeName = 'http' ].	self should: [ url authority = 'someserver.blah' ].	self should: [ url port = nil ].	self should: [ url username = 'user' ].	self should: [ url password = 'pword' ].	"relative URL where the username+password should be forgotten"	baseUrl := 'http://user:pword@someserver.blah' asUrl.	url := 'http://anotherserver.blah' asUrlRelativeTo: baseUrl.	self should: [ url username = nil ].	self should: [ url password = nil ].! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:22'!testUsernamePasswordPrinting	#(	'http://user:pword@someserver.blah:8000/root/index.html'		'http://user@someserver.blah:8000/root/index.html' 		'http://user:pword@someserver.blah/root/index.html'	) do: [ :urlText |		self should: [ urlText = urlText asUrl asString ] ].! !!UrlTest methodsFor: 'testing' stamp: 'bp 2/12/2005 20:21'!testFromFileNameOrUrlString	url := Url absoluteFromFileNameOrUrlString: 'asdf'.	self assert: url schemeName = 'file'.	self assert: url fragment isNil.	self assert: url class = FileUrl.	url := Url absoluteFromFileNameOrUrlString: 'http://209.143.91.36/super/SuperSwikiProj/AAEmptyTest.001.pr'.	self assert: url schemeName = 'http'.	self assert: url fragment isNil.	self assert: url class = HttpUrl.! !!UrlTest commentStamp: '<historical>' prior: 0!This is the unit test for the class Url. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Utilities class methodsFor: 'class initialization' stamp: 'eem 10/24/2008 13:44'!initialize	"Initialize the class variables.  5/16/96 sw"	self initializeCommonRequestStrings.	RecentSubmissions := OrderedCollection new.	self registerInFlapsRegistry.	Smalltalk addToStartUpList: self after: SmalltalkImage! !!Utilities class methodsFor: 'class initialization' stamp: 'eem 10/24/2008 13:41'!startUp: resuming	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #event:.	resuming ifTrue:		[LastStats := nil]! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 7/19/2010 12:00'!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	MCMcmUpdater defaultUpdateURL isEmptyOrNil 		ifTrue:[^self inform: 'Cannot update Squeak:\No update url is available' withCRs].	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	self setSystemVersionFromConfig: config.	self inform: 'Update completed.Current update number: ', SystemVersion current highestUpdate.! !!Utilities class methodsFor: '*ST80-Support' stamp: 'jm 5/3/1998 20:12'!openScratchWorkspaceLabeled: labelString contents: initialContents	"Open a scratch text view with the given label on the given string. A scratch text view won't warn you about unsaved changes when you close it."	"Utilities openScratchWorkspaceLabeled: 'Scratch' contents: 'Hello. world!!'"	| model topView stringView |	model := StringHolder new contents: initialContents.	topView := StandardSystemView new.	topView		model: model;		label: labelString;		minimumSize: 180@120.	topView borderWidth: 1.	stringView := PluggableTextView on: model 		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	stringView		askBeforeDiscardingEdits: false;		window: (0@0 extent: 180@120).	topView addSubView: stringView.	topView controller open.! !!Utilities class methodsFor: 'vm statistics' stamp: 'ar 4/1/2007 12:46'!textMarkerForShortReport	^  'Since last view	'! !!Utilities class methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		Utilities vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!Utilities class methodsFor: 'vm statistics' stamp: 'ar 4/1/2007 12:46'!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"StringHolderView open: (StringHolder new contents: Utilities vmStatisticsShortString)		label: 'VM Recent Statistics'"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; upTo: Character cr; upToEnd! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:58'!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStore: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStorePop: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:54'!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^false! !!VariableNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableReference	^true! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitVariableNode: self! !!VariableScopeFinder methodsFor: 'private' stamp: 'eem 8/12/2010 16:50'!enclosingNodeFor: enumerator of: rootNode	"Answer the minimum enclosing root node for aVariabe or nil if none.	 If the variable is accessed in more than one subnode then the rootNode is the	 enclosing node, otherwise it is which ever single subnode node that includes it, if any.	 enumerator applies its argument to all relevant subnodes of rootNode."	| enclosingNodeOrNil |	enclosingNodeOrNil := nil.	enumerator value:		[:subnode|		(subnode accept: self) ifNotNil:			[:enclosingNode|			enclosingNodeOrNil := enclosingNodeOrNil										ifNil: [enclosingNode]										ifNotNil: [rootNode]]].	^enclosingNodeOrNil! !!VariableScopeFinder methodsFor: 'initialize-release' stamp: 'eem 8/12/2010 16:18'!ofVariable: aVariableNode	theVariable := aVariableNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:51'!visitAssignmentNode: anAssignmentNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then anAssignmentNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock								value: anAssignmentNode value;								value: anAssignmentNode variable]		of: anAssignmentNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBlockNode: aBlockNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one statement then aBlockNode is the	 enclosing node, otherwise it is which ever single block node that includes it, if any."	^(self enclosingNodeFor: [:aBlock| aBlockNode statements do: aBlock] of: aBlockNode) ifNotNil:		[:aNode|		aNode isBlockNode ifTrue: [aNode] ifFalse: [aBlockNode]]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBraceNode: aBraceNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aBraceNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock| aBraceNode elements do: aBlock]		of: aBraceNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/16/2010 18:02'!visitCascadeNode: aCascadeNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aCascadeNode receiver.							aCascadeNode messages do:								[:msg| msg argumentsInEvaluationOrder do: aBlock]]		of: aCascadeNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitCommentNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitFieldNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:55'!visitFutureNode: aFutureNode	^aFutureNode receiver accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitInstanceVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitLiteralNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:03'!visitLiteralVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:07'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aMessageNode receiver.							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:00'!visitMethodNode: aMethodNode	^aMethodNode block accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitNewArrayNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitRemoteTempVectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:01'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitSelectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitTempVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode	^theVariable name = aVariableNode name ifTrue: [theVariable]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:06'!visitVariableNode: aVariableNode	^nil! !!VariableScopeFinder commentStamp: 'eem 8/14/2010 19:45' prior: 0!A VariableScopeFinder is used to find the minimum enclosing scope of a variable in a method.  This is used when auto-declaring temporaries to find the smallest enclosing block in which to declare the temp.Instance Variables	theVariable:		<VariableNode>theVariable	- the varable whose scope is to be determined!!View methodsFor: 'subView inserting'!addSubView: aView 	"Remove aView from the tree of Views it is in (if any) and adds it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.']! !!View methodsFor: 'subView inserting'!addSubView: aSubView above: lowerView	"Adds aView (see View|addSubView:) so that it lies above topView."	self addSubView: aSubView		align: aSubView viewport bottomLeft		with: lowerView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView align: aPoint1 with: aPoint2 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and translate aView so that aPoint1 coincides with aPoint2. It is typically 	used to build up a hierarchy of Views (a structured picture). Normally, 	aPoint1 is a point on aView's viewport (e.g. aView viewport topLeft), 	and aPoint2 is either an arbitrary point in the receiver's coordinate 	system or a point on the receiver's window (e.g., self window topRight)."	self addSubView: aSubView.	aSubView align: aPoint1 with: aPoint2! !!View methodsFor: 'subView inserting'!addSubView: aSubView below: lowerView	"Add the argument, aSubView, (see View|addSubView:) so that it lies 	below the view, topView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: lowerView viewport bottomLeft! !!View methodsFor: 'subView inserting'!addSubView: aView ifCyclic: exceptionBlock 	"Remove aView from the tree of Views it is in (if any) and add it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	(self isCyclic: aView)		ifTrue: [exceptionBlock value]		ifFalse: 			[aView removeFromSuperView.			subViews addLast: aView.			aView superView: self]! !!View methodsFor: 'subView inserting'!addSubView: aSubView toLeftOf: rightView	"Adds aView (see addSubView:) so that it lies to the right of rightView."	self addSubView: aSubView		align: aSubView viewport topRight		with:  rightView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView toRightOf: leftView	"Add the argument, aSubView, (see View|addSubView:) so that it lies to 	the right of the view, leftView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: leftView viewport topRight! !!View methodsFor: 'subView inserting'!addSubView: aView viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) and 	applies to aView a scale and translation computed from its window and 	aViewport (such that its window fills aViewport)."	self addSubView: aView.	aView window: aView window viewport: aViewport! !!View methodsFor: 'subView inserting'!addSubView: aView window: aWindow viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and applies to aView a scale and translation computed from aWindow 	and aViewport (such that aWindow fills aViewport)."	self addSubView: aView.	aView window: aWindow viewport: aViewport! !!View methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Add a translation of (aPoint2 - aPoint1) to the receiver's local 	transformation. The point in the receiver's coordinate system that 	previously was transformed to aPoint1 in the superView's coordinate 	system will now be transformed to aPoint2 in the superView's coordinate 	system. Other points will be translated by the same amount. It is 	normally used when adding subViews to their superView in order to 	line up the Viewport of one subView with that of another subView (see 	View|addSubView:align:with:). aPoint1 and aPoint2 are usually points on 	the viewports that are to be aligned. For example, 'subView2 align: 	subView2 viewport topLeft with: subView1 viewport topRight' would be 	used to place the viewport of subView2 next to the viewport of 	subView1 with the topLeft and topRight corners, respectively, 	coinciding. It is also possible to align the viewport of a subView with 	the window of the superView, e.g., 'subView align: subView viewport 	center with: superView window center'. View|align:with: assumes that 	the view has been properly scaled, if necessary, to match its superView 	(see View|scaleBy:). Typically, the coordinate systems of the receiver 	and its superView will differ only by a translation offset so that no 	scaling is necessary."	self setTransformation: (transformation align: aPoint1 with: aPoint2)! !!View methodsFor: 'transforming'!scale: aScale translation: aTranslation 	"The x component of aScale (a Point) specifies the scale (translation) in 	the x direction; the y component specifies the scale (translation) in the y 	direction. aScale can optionally be an instance of Integer or Float in 	order to specify uniform scaling in both directions. Create a new local 	transformation for the receiver with a scale factor of aScale and a 	translation offset of aTranslation. When the transformation is applied (see 	View|transform:), the scale is applied first, followed by the translation. It 	is typically used when building a superView from its subViews in order 	to line up the viewports of the subViews in the desired way. If no 	scaling is required between subView and superView, then 	View|align:with: is often more convenient to use."	self setTransformation:		(WindowingTransformation scale: aScale translation: aTranslation)! !!View methodsFor: 'transforming'!scaleBy: aScale 	"The x component of aScale (a Point) specifies the scale in the x 	direction; the y component specifies the scale in the y direction. aScale 	can, optionally, be an instance of Integer or Float in order to specify 	uniform scaling in both directions. Scales the View by aScale. The scale 	is concatenated with the current transformation of the receiver and is 	applied when View|transform is sent. This happens automatically in the 	process of displaying the receiver, for example."	self setTransformation: (transformation scaleBy: aScale)! !!View methodsFor: 'transforming'!transform: anObject 	"Apply the local transformation of the receiver to anObject and answer 	the resulting transformation. It is used to get the superView coordinates 	of an object. For example, the viewport is equal to the window 	transformed."	^transformation applyTo: anObject! !!View methodsFor: 'transforming'!transformation	"Answer a copy of the receiver's local transformation."	^transformation copy! !!View methodsFor: 'transforming'!transformation: aTransformation 	"Set the receiver's local transformation to a copy of aTransformation, 	unlock the receiver (see View|unlock) and set the viewport to undefined 	(this forces it to be recomputed when needed)."	self setTransformation: aTransformation copy! !!View methodsFor: 'transforming'!translateBy: aPoint 	"Translate the receiver by aPoint. The translation is concatenated with 	the current transformation of the receiver and is applied when 	View|transform is sent. This happens automatically in the process of 	displaying the receiver."	self setTransformation: (transformation translateBy: aPoint)! !!View methodsFor: 'transforming'!window: aWindow viewport: aViewport 	"Set the receiver's window to aWindow, set its viewport to aViewport, and 	create a new local transformation for the receiver based on aWindow and 	aViewport. The receiver is scaled and translated so that aWindow, when 	transformed, coincides with aViewport. It is used to position a subView's 	window within some specific region of its superView's area. For example, 	'subView window: aRectangle1 viewport: aRectangle2' sets subView's 	window to aRectangle1, its viewport to aRectangle2, and its local 	transformation to one that transforms aRectangle1 to aRectange2."	self window: aWindow.	self setTransformation:		(WindowingTransformation window: aWindow viewport: aViewport).	self getViewport! !!View methodsFor: 'display box access'!apparentDisplayBox	^self insetDisplayBox expandBy: 2 @ 2! !!View methodsFor: 'display box access'!boundingBox	"Answer the bounding box which for the default case is the rectangular 	area surrounding the bounding boxes of all the subViews."	boundingBox ~~ nil		ifTrue: [^boundingBox]		ifFalse: [^self computeBoundingBox]! !!View methodsFor: 'display box access' stamp: 'nice 12/27/2009 22:39'!computeBoundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of the 	receiver's subViews. If the receiver has no subViews, then the bounding 	box is the receiver's window. Subclasses should redefine 	View|boundingBox if a more suitable default for the case of no subViews 	is available."	| aRectangle |	subViews isEmpty ifTrue: [^self getWindow].	aRectangle := (self firstSubView transform: self firstSubView boundingBox) copy.	subViews do: 		[:aView | 		aRectangle swallow: (aView transform: aView boundingBox).].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'display box access'!displayBox	"Answer the receiver's inset display box (see View|insetDisplayBox) 	expanded by the borderWidth. The display box represents the region of 	the display screen in which the receiver (including the border) is 	displayed. If the receiver is totally clipped by the display screen and its 	superView, the resulting Rectangle will be invalid."	^self insetDisplayBox expandBy: borderWidth! !!View methodsFor: 'display box access' stamp: 'acg 2/23/2000 00:08'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: [insetDisplayBox := self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor := Color white]].	insideColor := aColor! !!View methodsFor: 'bordering'!borderWidth	"Answer either 0, indicating no border, or a Rectangle whose left value is 	the width in display coordinates of the receiver's left border. Right, top, 	and bottom widths are analogous. The border width is initially 0. A 	View with a border width of 0 will not have any border displayed."	^borderWidth! !!View methodsFor: 'bordering'!borderWidth: anInteger	"Set the four border widths of the receiver to anInteger."	self		borderWidthLeft: anInteger		right: anInteger		top: anInteger		bottom: anInteger! !!View methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border widths of the receiver. These arguments represent the left, 	right, top, and bottom border widths."	borderWidth :=			Rectangle				left: anInteger1				right: anInteger2				top: anInteger3				bottom: anInteger4.	self unlock! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35'!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!View methodsFor: 'bordering'!foregroundColor: aColor	borderColor := aColor! !!View methodsFor: 'bordering'!insideColor: aColor 	^ self backgroundColor: aColor! !!View methodsFor: 'testing' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this pane is not dirty."	^ true! !!View methodsFor: 'testing'!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'testing' stamp: 'jm 3/17/98 13:35'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ false! !!View methodsFor: 'testing'!isObscured	| topController displayRect |	(topController := self topView controller)		== ScheduledControllers activeController			ifTrue: [^false].	displayRect := self insetDisplayBox.	ScheduledControllers scheduledControllers do: [:ctrlr |		ctrlr == topController ifTrue: [^false].		(displayRect intersects: ctrlr view insetDisplayBox)			ifTrue: [^true]].	self error: 'not in ScheduledControllers'.	^false! !!View methodsFor: 'clearing'!clear	"Use the border color to paint the display box (including the border, see 	View|displayBox) of the receiver."	borderColor ~= nil ifTrue: [self clear: Color black]! !!View methodsFor: 'clearing'!clear: aColor 	"Use aColor to paint the display box (including the border, see 	View|displayBox) of the receiver."	aColor ~= nil ifTrue: [Display fill: self displayBox fillColor: aColor]! !!View methodsFor: 'clearing'!clearInside	"Use the inside color to paint the inset display box (excluding the border, 	see View|insetDisplayBox) of the receiver."	self clearInside: self backgroundColor! !!View methodsFor: 'clearing'!clearInside: aColor 	"Use aColor to paint the inset display box (excluding the border, see 	View|insetDisplayBox) of the receiver."	aColor ~~ nil ifTrue: [Display fill: self insetDisplayBox fillColor: aColor]! !!View methodsFor: 'miscellaneous'!clipRect	^ superView clipRect! !!View methodsFor: 'miscellaneous'!clipRect: r	superView clipRect: r! !!View methodsFor: 'miscellaneous'!gridSpacing	^ superView gridSpacing! !!View methodsFor: 'miscellaneous'!nestedViewport	"The viewport size used to control scaling of nested user views."	^ (0@0 extent: self viewport extent)			insetBy: 16 @ 16! !!View methodsFor: 'miscellaneous'!printViewSpecOn: strm nested: level	"Print window and viewport specs	of this and all nested views."	strm crtab: level; nextPutAll: self class name.	strm crtab: level; nextPutAll: 'window: '; print: self window.	strm crtab: level; nextPutAll: 'viewport: '; print: self viewport.	strm crtab: level; nextPutAll: 'displayBox: '; print: self displayBox.	strm crtab: level; nextPutAll: 'border: '; print: self borderWidth.	subViews do: [:v | v printViewSpecOn: strm nested: level+1]! !!View methodsFor: 'miscellaneous' stamp: 'JMM 10/21/2003 18:12'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click delay |	delay := Delay forMilliseconds: 10.	frame := startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click := false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[delay wait.		click := click | Sensor anyButtonPressed.		newFrame := newFrameBlock value: frame.		newFrame := newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame := newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!View methodsFor: 'displaying'!clippingTo: rect do: aBlock	superView clippingTo: rect do: aBlock! !!View methodsFor: 'displaying' stamp: 'hmm 6/27/2000 07:07'!display	"Display the receiver's border, display the receiver, then display the 	subViews of the receiver. Can be sent to the top View of a structured 	picture in order to display the entire structure, or to any particular View 	in the structure in order to display that View and its subViews. It is 	typically sent in response to an update request to a View."	Display deferUpdatesIn: self displayBox while: [		self displayBorder.		self displayView.		self displaySubViews]! !!View methodsFor: 'displaying'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	borderWidth = 0		ifTrue:			[insideColor == nil				ifFalse: 					[Display fill: self displayBox fillColor: self backgroundColor]]		ifFalse:			[Display				border: self displayBox				widthRectangle: borderWidth				rule: Form over				fillColor: self foregroundColor.			insideColor == nil ifFalse:				[Display fill: self insetDisplayBox fillColor: self backgroundColor]]! !!View methodsFor: 'displaying'!displayClippingTo: rect	| bigRect |	bigRect := rect insetBy: -1.	self clippingTo: bigRect do: [Display clippingTo: bigRect do: [self display]]! !!View methodsFor: 'displaying'!displayDeEmphasized	self display; deEmphasize! !!View methodsFor: 'displaying'!displaySubViews	"Display all the subViews of the receiver."	subViews do: [:aSubView | aSubView display]! !!View methodsFor: 'displaying'!displayView	"Subclasses should redefine View|displayView in order to display 	particular objects associated with the View such as labels, lines, and 	boxes."	^self! !!View methodsFor: 'displaying'!displayViewDeEmphasized	self displayView; deEmphasizeView! !!View methodsFor: 'displaying'!inspectFirstSubView	subViews notNil ifTrue:		[subViews size > 0 ifTrue:			[(subViews at: 1) inspect]]! !!View methodsFor: 'displaying'!inspectModel	model notNil		ifTrue: [^ model inspect]		ifFalse: [self flash]! !!View methodsFor: 'displaying'!inspectView	^self inspect! !!View methodsFor: 'displaying'!maximumSize	"Answer the maximum size of the receiver."	^ 10000 @ 10000	! !!View methodsFor: 'displaying'!minimumSize	"Answer the minimum size of the receiver."	^ 10 @ 10	! !!View methodsFor: 'private'!computeDisplayTransformation	"Answer a WindowingTransformation that transforms the coordinate 	system of the View into that of the display screen. The transformation is 	computed by composing the View's transformation with all transformations 	along its superView chain. It is sent by View|displayTransformation when	the View is unlocked (see View|unlock)."	self isTopView		ifTrue: [^transformation]		ifFalse: [^superView displayTransformation compose: transformation]! !!View methodsFor: 'private'!computeInsetDisplayBox	"Compute the View's inset display box by intersecting the superView's	inset display box with the View's window transformed to display	coordinates and then inseting the result by the border width. It is sent by 	View|insetDisplayBox if the inset display box is nil.	The insetDisplayBox points are truncated to prevent sending floating point numbers to QuickDraw which will die."	self isTopView		ifTrue:			[^((self displayTransform: self getWindow) insetBy: borderWidth) truncated]		ifFalse:			[^(superView insetDisplayBox				intersect: (self displayTransform: self getWindow)) truncated						insetBy: borderWidth]! !!View methodsFor: 'private'!getController	"Answer the View's controller if one exists. nil indicates that the default	controller is to be used."	^controller! !!View methodsFor: 'private'!getViewport	"Answer the Rectangle representing the View's viewport (in the	coordinate system of the superclass). If no viewport has been specified,	the View's window transformed into the superView's coordinate system is	saved and returned. It should be used by methods of View and subclasses	(instead of directly referring to the viewport) unless it is known that a	viewport actually exists. It should not be used outside of View or	subclasses because the viewport is not sharable."	viewport == nil ifTrue: [viewport := (self transform: self getWindow) truncated].	^viewport! !!View methodsFor: 'private'!getWindow	"Answer the Rectangle that represents the window of this View. If no	window has been specified, a default window (see View|defaultWindow)	is created, saved, and returned. Should be used by methods of View and	subclasses to access the View window instead of directly accessing the	field unless it is known that a window actually exists. It is not to be used	outside of View (or subclasses) because the window is not sharable.	View|window should be used for outside access to the window."	window == nil ifTrue: [self setWindow: self defaultWindow].	^window! !!View methodsFor: 'private'!isCyclic: aView 	"Answer true if aView is the same as this View or its superView, false 	otherwise."	self == aView ifTrue: [^true].	self isTopView ifTrue: [^false].	^superView isCyclic: aView! !!View methodsFor: 'private'!setTransformation: aTransformation 	"Set the View's local transformation to aTransformation, unlock the View 	(see View|unlock), and set the viewport to undefined (this forces it to be 	recomputed when needed). Should be used instead of setting the 	transformation directly."	transformation := aTransformation.	self unlock.	viewport := nil! !!View methodsFor: 'private'!setWindow: aWindow 	"Set the View's window to aWindow and unlock the View (see	View|unlock). View|setWindow should be used by methods of View and	subclasses to set the View window (rather than directly setting the	instance variable) to insure that the View is unlocked."	window := aWindow.	viewport := nil.	self unlock! !!View methodsFor: 'private'!superView: aView 	"Set the View's superView to aView and unlock the View (see	View|unlock). It is sent by View|addSubView: in order to properly set all	the links."	superView := aView.	self unlock! !!View methodsFor: 'controller access'!controller	"If the receiver's controller is nil (the default case), answer an initialized 	instance of the receiver's default controller. If the receiver does not 	allow a controller, answer the symbol #NoControllerAllowed."	controller == nil ifTrue: [self controller: self defaultController].	^controller! !!View methodsFor: 'controller access'!controller: aController 	"Set the receiver's controller to aController. #NoControllerAllowed can be 	specified to indicate that the receiver will not have a controller. The 	model of aController is set to the receiver's model."	self model: model controller: aController! !!View methodsFor: 'controller access'!defaultController	"Answer an initialized instance of the receiver's default controller. 	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new! !!View methodsFor: 'controller access'!defaultControllerClass	"Answer the class of the default controller for the receiver. Subclasses 	should redefine View|defaultControllerClass if the class of the default 	controller is not Controller."	^Controller! !!View methodsFor: 'controller access'!model: aModel controller: aController 	"Set the receiver's model to aModel, add the receiver to aModel's list of 	dependents, and set the receiver's controller to aController. Subsequent 	changes to aModel (see Model|change) will result in View|update: 	messages being sent to the receiver. #NoControllerAllowed for the value 	of aController indicates that no default controller is available; nil for the 	value of aController indicates that the default controller is to be used 	when needed. If aController is neither #NoControllerAllowed nor nil, its 	view is set to the receiver and its model is set to aModel."	model ~~ nil & (model ~~ aModel)		ifTrue: [model removeDependent: self].	aModel ~~ nil & (aModel ~~ model)		ifTrue: [aModel addDependent: self].	model := aModel.	aController ~~ nil		ifTrue: 			[aController view: self.			aController model: aModel].	controller := aController! !!View methodsFor: 'deEmphasizing'!deEmphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is not presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self deEmphasizeView.	self deEmphasizeSubViews! !!View methodsFor: 'deEmphasizing'!deEmphasizeForDebugger	"Overridden by StandardSystemView. This default behavior does nothing."! !!View methodsFor: 'deEmphasizing'!deEmphasizeSubViews	"Send the deEmphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView deEmphasize]! !!View methodsFor: 'deEmphasizing'!deEmphasizeView	"Subclasses should redefine View|deEmphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'deEmphasizing'!emphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self emphasizeView.	self emphasizeSubViews! !!View methodsFor: 'deEmphasizing'!emphasizeSubViews	"Send the emphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView emphasize]! !!View methodsFor: 'deEmphasizing'!emphasizeView	"Subclasses should redefine View|emphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'window access' stamp: 'nice 12/27/2009 22:39'!defaultWindow	"Build the minimum Rectangle that encloses all the windows of the 	receiver's subViews. The answer is a Rectangle obtained by expanding 	this minimal Rectangle by the borderWidth of the receiver. If the 	receiver has no subViews, then a Rectangle enclosing the entire display 	screen is answered. It is used internally by View methods if no window 	has been specified for the View. Specialized subclasses of View should 	redefine View|defaultWindow to handle the default case for instances 	that have no subViews."	| aRectangle |	subViews isEmpty ifTrue: [^DisplayScreen boundingBox].	aRectangle := self firstSubView viewport copy.	subViews do: [:aView | aRectangle swallow: aView viewport].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'window access'!insetWindow	"Answer a Rectangle that is obtained by insetting the receiver's window 	rectangle by the border width."	^self getWindow insetBy: borderWidth! !!View methodsFor: 'window access'!window	"Answer a copy of the receiver's window."	^self getWindow copy! !!View methodsFor: 'window access'!window: aWindow 	"Set the receiver's window to a copy of aWindow."	self setWindow: aWindow copy! !!View methodsFor: 'display transformation'!displayTransform: anObject 	"Apply the display transformation of the receiver to anObject (see 	View|displayTransformation) and answer the resulting scaled, translated 	object. It is normally applied to Rectangles, Points, and other objects with 	coordinates defined in the View's local coordinate system in order to get 	a corresponding object in display coordinates."	^(self displayTransformation applyTo: anObject) rounded! !!View methodsFor: 'display transformation'!displayTransformation	"Answer a WindowingTransformation that is the result of composing all 	local transformations in the receiver's superView chain with the 	receiver's own local transformation. The resulting transformation 	transforms objects in the receiver's coordinate system into objects in the 	display screen coordinate system."	displayTransformation == nil		ifTrue: [displayTransformation := self computeDisplayTransformation].	^displayTransformation! !!View methodsFor: 'display transformation'!inverseDisplayTransform: aPoint 	"Answer a Point that is obtained from the argument, aPoint, by applying 	to it the inverse of the receiver's display transformation. It is typically 	used by the Controller of the receiver in order to convert a point in 	display coordinates, such as the cursor point, to the local coordinate 	system of the receiver."	^self displayTransformation applyInverseTo: aPoint! !!View methodsFor: 'subView access'!firstSubView	"Answer the first subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews first]! !!View methodsFor: 'subView access'!lastSubView	"Answer the last subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews last]! !!View methodsFor: 'subView access'!resetSubViews	"Set the list of subviews to an empty collection."		subViews := OrderedCollection new! !!View methodsFor: 'subView access'!subViewContaining: aPoint 	"Answer the first subView that contains aPoint within its window and 	answer nil, otherwise. It is typically sent from a Controller in order to 	determine where to pass control (usually to the Controller of the View 	returned by View|subViewContaining:)."	subViews reverseDo: 		[:aSubView | 		(aSubView displayBox containsPoint: aPoint) ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'subView access'!subViewSatisfying: aBlock	"Return the first subview that satisfies aBlock, or nil if none does.  1/31/96 sw"	^ subViews detect: [:aView | aBlock value: aView] ifNone: [nil]! !!View methodsFor: 'subView access'!subViews	"Answer the receiver's collection of subViews."	^subViews! !!View methodsFor: 'subView access'!textEditorView	"Return the first view in the receiver whose controller is a ParagraphEdior, or nil if none.  1/31/96 sw"	(controller isKindOf: ParagraphEditor) ifTrue: [^ self].	^ self subViewSatisfying:		[:v | v textEditorView ~~ nil]! !!View methodsFor: 'indicating'!flash	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement twice in succession."	Display flash: self insetDisplayBox! !!View methodsFor: 'indicating'!highlight	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement."	Display reverse: self insetDisplayBox! !!View methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	self resetSubViews.	transformation := WindowingTransformation identity.	self borderWidth: 0! !!View methodsFor: 'initialize-release'!release	"Remove the receiver from its model's list of dependents (if the model	exists), and release all of its subViews. It is used to break possible cycles	in the receiver and should be sent when the receiver is no longer needed.	Subclasses should include 'super release.' when redefining release."	model removeDependent: self.	model := nil.	controller release.	controller := nil.	subViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].	subViews := nil.	superView := nil! !!View methodsFor: 'initialize-release'!setDefaultBackgroundColor	"Obtain the background color from the receiver's model, unless the #uniformWindowColors preference is set to true, in which case obtain it from generic Object; and install it as the receiver's background color.  5/1/96 sw"	| colorToUse |	colorToUse := Preferences uniformWindowColors		ifTrue:			[Object new defaultBackgroundColor]		ifFalse:			[model defaultBackgroundColor].	self backgroundColor: colorToUse! !!View methodsFor: 'lock access'!isLocked	"Answer whether the receiver is locked. A View is 'locked' if its display 	transformation and inset display box are defined. If these are undefined, 	the View is 'unlocked'. The display transformation and inset display box 	become undefined when the transformation of the View (or the 	transformation of a View in its superView chain) is changed, or when 	the superView of the View is changed, or any other change to the View 	that affects the display screen coordinates of the View. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired (see View|lock, and 	View|unlock)."	displayTransformation == nil | (insetDisplayBox == nil)		ifTrue: [^false]		ifFalse: [^true]! !!View methodsFor: 'lock access'!isUnlocked	"Answer whether the receiver is unlocked. See comment in 	View|isLocked."	^displayTransformation == nil & (insetDisplayBox == nil)! !!View methodsFor: 'lock access'!lock	"'Lock' the receiver and all of its subViews (see View|isLocked). This has 	the effect of computing and storing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews. The locking 	and unlocking of a View is handled automatically by the internal 	methods of the View, but can also be done explicitly if desired."	self isLocked ifTrue: [^self].	displayTransformation := self computeDisplayTransformation.	insetDisplayBox := self computeInsetDisplayBox.	subViews do: [:aSubView | aSubView lock]! !!View methodsFor: 'lock access'!unlock	"Unlock the receiver and all of its subViews (see View|isUnlocked). This 	has the effect of forcing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews to be 	recomputed the next time they are referenced. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired."	self isUnlocked ifTrue: [^self].	displayTransformation := nil.	insetDisplayBox := nil.	subViews do: [:aSubView | aSubView unlock]! !!View methodsFor: 'superView access'!isTopView	"Answer whether the receiver is a top view, that is, if it has no 	superView."	^superView == nil! !!View methodsFor: 'superView access'!superView	"Answer the superView of the receiver."	^superView! !!View methodsFor: 'superView access'!topView	"Answer the root of the tree of Views in which the receiver is a node. 	The root of the tree is found by going up the superView path until 	reaching a View whose superView is nil."	superView == nil		ifTrue: [^self]		ifFalse: [^superView topView]! !!View methodsFor: 'model access'!model	"Answer the receiver's model."	^model! !!View methodsFor: 'model access'!model: aModel 	"Set the receiver's model to aModel. The model of the receiver's controller 	is also set to aModel."	self model: aModel controller: controller! !!View methodsFor: 'subView removing'!releaseSubView: aView 	"Delete aView from the receiver's list of subViews and send it the 	message 'release' (so that it can break up cycles with subViews, etc.)."	self removeSubView: aView.	aView release! !!View methodsFor: 'subView removing'!releaseSubViews	"Release (see View|releaseSubView:) all subViews in the receiver's list of 	subViews."	subViews do: [:aView | aView release].	self resetSubViews! !!View methodsFor: 'subView removing'!removeFromSuperView	"Delete the receiver from its superView's collection of subViews."	superView ~= nil ifTrue: [superView removeSubView: self]! !!View methodsFor: 'subView removing'!removeSubView: aView 	"Delete aView from the receiver's list of subViews. If the list of subViews 	does not contain aView, create an error notification."	subViews remove: aView.	aView superView: nil.	aView unlock! !!View methodsFor: 'subView removing'!removeSubViews	"Delete all the receiver's subViews."	subViews do: 		[:aView | 		aView superView: nil.		aView unlock].	self resetSubViews! !!View methodsFor: 'scrolling'!scrollBy: aPoint 	"The x component of aPoint specifies the amount of scrolling in the x 	direction; the y component specifies the amount of scrolling in the y 	direction. The amounts are specified in the receiver's local coordinate 	system. Scroll the receiver up or down, left or right. The window of the 	receiver is kept stationary and the subViews and other objects in the 	receiver are translated relative to it. Scrolling doesn't change the 	insetDisplayBox or the viewport since the change in the transformation 	is canceled by the change in the window. In other words, all display 	objects in the view, except the window, are translated by the scrolling 	operation.	Note: subclasses may override to return false if no scrolling takes place."	| aRectangle |	aRectangle := insetDisplayBox.	transformation := transformation scrollBy: aPoint.	window := self getWindow translateBy: aPoint x negated @ aPoint y negated.	self unlock.	insetDisplayBox := aRectangle.	^ true! !!View methodsFor: 'morphic compatibility' stamp: 'mdr 1/24/2000 17:27'!setBalloonText: aString	"Unfortunately we just ignore this help text because we are not morphic"! !!View methodsFor: 'basic control sequence'!subViewWantingControl	"Answer the first subView that has a controller that now wants control."	subViews reverseDo: 		[:aSubView | aSubView controller isControlWanted ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'updating'!update	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	self update: self! !!View methodsFor: 'updating'!update: aParameter 	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	^self! !!View methodsFor: 'viewport access'!viewport	"Answer a copy of the receiver's viewport."	^self getViewport copy! !!View commentStamp: '<historical>' prior: 0!My instances are intended to be components in a structured picture. Each View in the structured picture can contain other Views as sub-components. These sub-components are called subViews. A View can be a subView of only one View. This View is called its superView. The set of Views in a structured picture forms a hierarchy. The one View in the hierarchy that has no superView is called the topView of the structured picture. A View in a structured picture with no subViews is called a bottom View. A View and all of its subViews, and all of their subViews and so on, are treated as a unit in many operations on the View. For example, if a View is displayed, all of its subViews are displayed as well. There are several categories of operations that can be performed on a View. Among these are the following:		1.	Adding subViews to a View.	2.	Positioning subViews within a View.	3.	Deleting subViews from a View.	4.	Transforming a View.	5.	Displaying a View.	Each View has its own coordinate system. In order to change from one coordinate system to another, each View has two transformations associated with it. The local transformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the coordinate system of the superView of the View. The displayTransformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the display screen coordinate system.	The part of the space that is to be made visible is represented by the window of the View. The window of a View is a Rectangle expressed in the coordinate system of the View. The area occupied by a View in the coordinate system of its superView is called its viewport. The viewport of a View is its window transformed by its local transformation. The region of the display screen occupied by a View is called its displayBox. The display box of a View can include a border. The width of the border expressed in display screen coordinates is called the border width of the View. The color of the border is called the border color. The region of the display box of a View excluding the border is called the inset display box. The color of the inset display box is called the inside color of the View.!!WarpBlt methodsFor: 'primitives' stamp: 'ar 12/1/2003 12:52'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	self sourceForm: srcForm.	sourceX := sourceY := 0.	destX := dstRectangle left.	destY := dstRectangle top.	width := dstRectangle width.	height := dstRectangle height.	w := 16384 * (srcForm width - 1).	h := 16384 * (srcForm height - 1).	p1x := 0.	p2x := 0.	p3x := w.	p4x := w.	p1y := 0.	p2y := h.	p3y := h.	p4y := 0.	p1z := p2z := p3z := p4z := 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives' stamp: 'ar 6/22/2010 11:59'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFailed].		pix := Array new: n*n].	nSteps := height-1 max: 1.	deltaP12 := (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA := (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 := (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB := (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker := BitBlt current bitPeekerFromForm: sourceForm.	poker := BitBlt current bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps := width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB := (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp := (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp := sp + deltaPAB].		pA := pA + deltaP12.		pB := pB + deltaP43]! !!WarpBlt methodsFor: 'setup' stamp: 'ar 4/26/2007 22:24'!cellSize: s	"Set the number of samples used for averaging"	cellSize := s.	cellSize = 1 ifTrue: [^ self].	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the	destination depth. Note that we need to install the 32->32 color map explicitly because	the VM will substitute a colorMap derived from sourceForm->destForm mapping which	is just plain wrong for <32 source and 32bit dest depth"	(destForm depth = 32 and:[sourceForm depth < 32])		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].! !!WarpBlt methodsFor: 'smoothing' stamp: 'di (auto pragmas 12/08) 6/24/97 00:08'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	<inline: true>	(d := nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 << nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel << d.			mask := mask << d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 << nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel >> d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix >> d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!WarpBlt class methodsFor: 'examples' stamp: 'eem 6/18/2008 20:36'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp := (self toForm: Display)		sourceForm: Display;		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		combinationRule: Form over.	warp2 := (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]! !!WeakArray commentStamp: '<historical>' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'accessing' stamp: 'eem 9/17/2008 10:17'!isFinalizationSupported	"All closure VMs support finalization so we can simply answer true."	^true! !!WeakArray class methodsFor: 'accessing' stamp: 'eem 9/17/2008 10:19'!removeWeakDependent: anObject	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'eem 9/17/2008 10:18'!restartFinalizationProcess	"kill any old process, just in case"	FinalizationProcess ifNotNil:		[FinalizationProcess terminate.		 FinalizationProcess := nil].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] forkAt: Processor userInterruptPriority! !!WeakCache methodsFor: 'accessing' stamp: 'das 3/22/2007 00:30'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	super at: key ifAbsent:[ "only add the key to the cache if it is missing from the Dictionary"		anObject ifNotNil:[			cacheData at: (cacheIndex := cacheIndex\\cacheData size +1) put: key.		].	].	^ super at: key put: anObject.! !!WeakCache methodsFor: 'accessing' stamp: 'das 3/15/2007 19:36'!cache"used for debugging"	^ cacheData.! !!WeakCache methodsFor: 'initialize' stamp: 'das 3/15/2007 19:39'!cacheSize: csize	cacheData := Array new: csize.	cacheIndex :=0.! !!WeakCache commentStamp: 'das 3/15/2007 20:05' prior: 0!I am a weakly held cache of objects that are accessed as a dictionary. I have a maximum size of cache, which when exceeded, I simply start wrapping. In the long run, this will cause unused objects to be dumped, making room for new objects. It is also a FIFO stack. We could instead keep the cache as a sorted array - where the last accessed object is at the front of the stack. Maybe later.You can always resize this cache, but the result is that you will very likely lose the current contents.!!WeakCache class methodsFor: 'initialize' stamp: 'das 3/15/2007 19:40'!newCache: cacheSize	^ self new cacheSize:cacheSize.! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'md 7/15/2006 18:02'!testNoNils	| d |	d := WeakIdentityKeyDictionary new	at: 'hello' copy put: 'world';		yourself.	Smalltalk garbageCollect.	self deny: (d keys includes: nil)! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 6/12/2010 18:38'!finalizeValues	"Remove and finalize all elements which have nil key"		|  cleanUpAfterRemove |	tally = 0 ifTrue: [ ^self ].	cleanUpAfterRemove := false.	1 to: array size do: [ :index |		(array at: index) 			ifNil: [ cleanUpAfterRemove := false ]			ifNotNil: [ :element |				element key					ifNil: [						finalizer ifNotNil: [ finalizer value: element value ].						array at: index put: nil.						tally := tally - 1.						cleanUpAfterRemove := true ]					ifNotNil: [ :key |						cleanUpAfterRemove ifTrue: [							| newIndex |							(newIndex := self scanFor: key) = index ifFalse: [								array 									at: newIndex put: element;									at: index put: nil ] ] ] ] ].	cleanUpAfterRemove ifTrue: [ "Continue rehashing at the front of array"		self fixCollisionsFrom: array size ]					! !!WeakMessageSendTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:10'!testNoArguments	"self run: #testNoArguments"	| m |	m := WeakMessageSend			receiver: true			selector: #yourself.	self assert: (m value).! !!WeakMessageSendTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:11'!testOneArgument	"self run: #testOneArgument"		| m |	m := WeakMessageSend		receiver: Array		selector: #with:		argument: 1.	Smalltalk garbageCollectMost.	self assert: (m value  = { 1 })! !!WeakMessageSendTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:11'!testOneArgumentWithGC	| m |	m := WeakMessageSend		receiver: Array		selector: #with:		arguments: { Object new }.	Smalltalk garbageCollectMost.	self assert: (m value isNil)! !!WeakMessageSendTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:11'!testReceiverWithGC	| m |	m := WeakMessageSend		receiver: Object new		selector: #isNil.	Smalltalk garbageCollectMost.	self assert: (m value isNil).! !!WeakMessageSendTest methodsFor: 'tests' stamp: 'sd 6/5/2005 09:11'!testTwoArguments	| m |	m := WeakMessageSend		receiver: Array		selector: #with:with:		arguments: { 1 . 2 }.	Smalltalk garbageCollectMost.	self assert: (m value = { 1 . 2 }).! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 6/15/2010 11:17'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		| collectedExecutors |	self protected: [ 		valueDictionary finalizeValues.		collectedExecutors := executors.		executors := nil ].	collectedExecutors ifNotNil: [		collectedExecutors do: #finalize ]! !!WeakRegistry methodsFor: 'initialize' stamp: 'ul 6/15/2010 11:17'!installFinalizer	valueDictionary finalizer: [ :executor |		(executors ifNil: [ executors := OrderedCollection new ]) add: executor ]! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 6/15/2010 11:21'!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		valueDictionary associationsDo: [ :each |			each value class == ObjectFinalizerCollection 				ifTrue: [ each value: each value copy ] ].		executors := executors copy.		self installFinalizer ]! !!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry class methodsFor: 'class initialization' stamp: 'ar 1/11/2008 11:10'!initialize	Default := nil. "force recreation"! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ar 4/6/2010 22:31'!testFinalization	| w finalized block object |	w := WeakRegistry new: 1.	finalized := false.	block := [ :v | finalized := v ].	object := ObjectFinalizer "an object that responds to #finalize"		receiver: block		selector: #value:		argument: true.	w add: object.	object := nil. "let it go"	Smalltalk garbageCollect. "finalize it"	"This is an odd issue. It seems that in some situations the finalization	process doesn't run 'in time' for the isEmpty assertion below to succeed.	This really *shouldn't* happen since isEmpty is full of real sends and	there ought to be an interrupt check in there somewhere. However,	since there are no real-time guarantees about finalization, it's fair to	just wait a little to ensure that the finalization process has been run."	(Delay forMilliseconds: 100) wait.	self assert: w isEmpty.	self assert: finalized! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ul 2/26/2010 13:59'!testFinalizationWithMultipleFinalizersPerObject	| object registry counter |	registry := WeakRegistry new.	object := Object new.	counter := 0.	5 timesRepeat: [		registry add: object executor: (ObjectFinalizer			receiver: [ counter := counter + 1 ]			selector: #value) ].	self assert: registry size = 1.	object := nil. 	Smalltalk garbageCollect.	registry finalizeValues.	self assert: registry isEmpty.	self assert: counter = 5! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ul 2/26/2010 14:50'!testGrowingByAHighPriorityProcessDoesntLeak	| w finalized block object executor semaphore |	w := WeakRegistry new: 1.	finalized := false.	block := [ :v | finalized := v ].	object := Object new.	executor := ObjectFinalizer		receiver: block		selector: #value:		argument: true.	w add: object executor: executor.	semaphore := Semaphore new.	[ 		object := nil. "let it go"		w addAll: (1 to: 1000). "force growing"		semaphore signal ] 			forkAt: WeakArray runningFinalizationProcess priority + 1.	semaphore wait.	Smalltalk garbageCollect. "finalize it"	self assert: w size = 1000.	self assert: finalized! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ul 2/26/2010 14:50'!testGrowingDoesntLeak	| w finalized block object executor |	w := WeakRegistry new: 1.	finalized := false.	block := [ :v | finalized := v ].	object := Object new.	executor := ObjectFinalizer		receiver: block		selector: #value:		argument: true.	w add: object executor: executor.	object := nil. "let it go"	w addAll: (1 to: 1000). "force growing"	Smalltalk garbageCollect. "finalize it"	self assert: w size = 1000.	self assert: finalized! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ul 2/26/2010 14:50'!testRemovingByAHighPriorityProcessDoesntLeak	| w finalized block hash object executor semaphore |	w := WeakRegistry new: 1.	finalized := false.	block := [ :v | finalized := v ].	object := Object new.	executor := ObjectFinalizer		receiver: block		selector: #value:		argument: true.	hash := object hash.	w add: hash.	w add: object executor: executor.	semaphore := Semaphore new.	[ 		object := nil. "let it go"		w remove: hash.		semaphore signal ] 			forkAt: WeakArray runningFinalizationProcess priority + 1.	semaphore wait.	Smalltalk garbageCollect. "finalize it"	self assert: w isEmpty.	self assert: finalized! !!WeakRegistryTest methodsFor: 'tests' stamp: 'ul 2/26/2010 14:46'!testRemovingDoesntLeak	| w finalized block hash object executor |	w := WeakRegistry new: 1.	finalized := false.	block := [ :v | finalized := v ].	object := Object new.	executor := ObjectFinalizer		receiver: block		selector: #value:		argument: true.	hash := object hash.	w add: hash.	w add: object executor: executor.	object := nil. "let it go"	w remove: hash.	Smalltalk garbageCollect. "finalize it"	self assert: w isEmpty.	self assert: finalized! !!WeakSetInspectorTest methodsFor: 'testing' stamp: 'nice 12/15/2007 11:51'!testSymbolTableM6812	"this test is related to http://bugs.squeak.org/view.php?id=6812"		| aWeakSet anInspector fieldSize |	aWeakSet := (Symbol classPool at: #SymbolTable).	anInspector := (ToolSet inspectorClassOf: aWeakSet) inspect: aWeakSet.		fieldSize := anInspector fieldList size.	3 timesRepeat:		[Smalltalk garbageCollect.		self assert: fieldSize = anInspector fieldList size.]	! !!WeakSetTest methodsFor: 'as yet unclassified' stamp: 'ul 11/20/2009 22:53'!testIncludes	| weakSet transientFakeNilObject |	weakSet := WeakSet new.	#(true nil 1) do: [ :each |		self deny: (weakSet includes: each) ].	weakSet add: true.	self assert: (weakSet includes: true).	weakSet remove: true.	self deny: (weakSet includes: true).	transientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\ weakSet capacity = 0 ]) asString. "this string will occupy the same slot as nil would"	weakSet add: transientFakeNilObject.	transientFakeNilObject := transientFakeNilObject copy.	Smalltalk garbageCollect. "get rid of transientFakeNilObject"	self deny: (weakSet includes: transientFakeNilObject).	self deny: (weakSet includes: nil)			! !!WeekTest methodsFor: 'Coverage' stamp: 'brp 7/27/2003 12:42'!classToBeTested	^ Week! !!WeekTest methodsFor: 'Coverage' stamp: 'brp 1/30/2005 09:21'!selectorsToBeIgnored	| deprecated private special |	deprecated := #().	private := #( #printOn: ).	special := #( #next #do: ).	^ super selectorsToBeIgnored, deprecated, private, special.! !!WeekTest methodsFor: 'Running' stamp: 'brp 9/26/2004 18:52'!setUp	"June 1998, 5th week"	super setUp.	restoredStartDay := Week startDay.	Week startDay: #Sunday.	week := Week starting: '4 July 1998' asDate! !!WeekTest methodsFor: 'Running' stamp: 'brp 9/26/2004 18:53'!tearDown	super tearDown.	Week startDay: restoredStartDay.	week := nil.! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:47'!testDayNames	self assert: (Week dayNames) = #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).! !!WeekTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:32'!testEnumerating	| days |	days := OrderedCollection new.	0 to: 6 do: [ :i | days add: ('28 June 1998' asDate addDays: i) ].	week datesDo: [ :d | days remove: d ].		self assert: days isEmpty.! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:52'!testIndexOfDay	| days |	days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).		days withIndexDo: [:item :index | self assert: (Week indexOfDay: item) = index].		"This should probably raise an error rather than returning 0."	self assert: (Week indexOfDay: 0) = 0.	self assert: (Week indexOfDay: 1) = 0.	self assert: (Week indexOfDay: 7) = 0.	self assert: (Week indexOfDay: 8) = 0.	self assert: (Week indexOfDay: #Sunnyday) = 0.! !!WeekTest methodsFor: 'Tests' stamp: 'brp 1/30/2005 09:30'!testInquiries	self		assert: week start asDate = '28 June 1998' asDate;		assert: week end asDate = '4 July 1998' asDate;		assert: week index = 5;		assert: week duration = (7 days).! !!WeekTest methodsFor: 'Tests' stamp: 'it 7/14/2009 19:46'!testNameOfDay	| days |	days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).		days withIndexDo: [:item :index | self assert: (Week nameOfDay: index) = item].		self should: [Week nameOfDay: 0] raise: TestResult error.	self should: [Week nameOfDay: 8] raise: TestResult error.	self should: [Week nameOfDay: #Sunday] raise: TestResult error.! !!WeekTest methodsFor: 'Tests' stamp: 'nk 7/30/2004 17:52'!testPreviousNext	self		assert: week next = (Week starting: '6 July 1998' asDate);		assert: week previous = (Week starting:  '22 June 1998' asDate)! !!WhitespaceForCodeDiff methodsFor: 'comparing' stamp: 'eem 5/9/2008 09:04'!= anOtherObject	^self species == anOtherObject species! !!WhitespaceForCodeDiff methodsFor: 'accessing' stamp: 'eem 5/9/2008 11:26'!at: index	^1 = index		ifTrue: ["(string includes: Character cr)					ifTrue: [Character cr]					ifFalse: ["Character space"]"]		ifFalse: [super at: index]! !!WhitespaceForCodeDiff methodsFor: 'accessing' stamp: 'eem 5/9/2008 08:58'!size	^1! !!WhitespaceForCodeDiff methodsFor: 'accessing' stamp: 'eem 5/9/2008 08:58'!string	^string! !!WhitespaceForCodeDiff methodsFor: 'accessing' stamp: 'eem 5/9/2008 08:57'!string: aString	string := aString! !!WhitespaceForCodeDiff methodsFor: 'testing' stamp: 'eem 7/15/2010 17:02'!isOctetString	"For DiffElement>>string:"	^false! !!WhitespaceForCodeDiff commentStamp: '<historical>' prior: 0!I am a special form of whitespace for code diffing.  I masquerade as a string of a single space but remember my actual whitespace. Depending on the definition of at: I may differentiate between whitespace containing a line break from whitespace that doesn't, (which may result in better-formatted diffs).!!WideCharacterSetTest methodsFor: 'testing' stamp: 'nice 11/19/2007 23:36'!testAddingToCharacterSet	| cs wcs wc |	cs := CharacterSet newFrom: 'aeiouy'.	wcs := cs copy.	wc := 4452 asCharacter.		self shouldnt: [wcs add: wc] raise: Error description: 'adding a WideCharacter to an ordinary CharacterSet should turn it into a WideCharacterSet'.	self should: [wcs size = (cs size + 1)] description: 'We just added a Character, size should be increased by one'.	self shouldnt: [wcs = cs] description: 'We just added a Character, sets should not be equal'.	self shouldnt: [cs = wcs] description: 'We just added a Character, sets should not be equal'.	self should: [cs allSatisfy: [:char | wcs includes: char]] description: 'Each character of the original CharacterSet should be included in the WideCharacterSet'.	self should: [wcs hasWideCharacters] description: 'We just added a WideCharacter, so this WideCharacterSet definitely has one'.	self should: [wcs includes: wc] description: 'We just added this WideCharacter, so this WideCharacterSet should include it'.		wcs add: wc.	self should: [wcs size = (cs size + 1)] description: 'We just added a Character already included in the set, size should be unchanged'.		wcs remove: wc.	self should: [wcs size = cs size] description: 'We added then removed a Character, now size should be equal to original'.	self shouldnt: [wcs hasWideCharacters] description: 'We just removed the only WideCharacter, so this WideCharacterSet definitely has no WideCharacter'.		self should: [wcs = cs] description: 'A WideCharacterSet can be equal to an Ordinary CharacterSet'.	self should: [cs = wcs] description: 'An ordinary CharacterSet can be equal to a WideCharacterSet'.	self should: [cs hash = wcs hash] description: 'If some objects are equal, then they should have same hash code'.		! !!WideCharacterSetTest methodsFor: 'testing' stamp: 'nice 11/19/2007 23:34'!testCreation	"By now, only creation method is newFrom:"	| cs1 wcs1 cs2 wcs2 byteString wideString |	byteString := 'aeiouy'.	wideString := 'aeiouy' copyWith: 340 asCharacter.	cs1 := CharacterSet newFrom: byteString.	wcs1 := WideCharacterSet newFrom: byteString.	self should: [wcs1 = cs1].	self should: [wcs1 size = byteString "asSet" size].		cs2 := CharacterSet newFrom: wideString.	wcs2 := WideCharacterSet newFrom: wideString.	self should: [wcs2 = cs2].	self should: [wcs2 size = wideString "asSet" size].		self should: [(byteString indexOfAnyOf: wcs1) = 1] description: 'This should used optimized byteArrayMap method'.	self should: [(byteString indexOfAnyOf: wcs2) = 1] description: 'This should used optimized byteArrayMap method'.		self should: [('bcd' indexOfAnyOf: wcs1) = 0] description: 'This should used optimized byteArrayMap method'.	self should: [('bcd' indexOfAnyOf: wcs2) = 0] description: 'This should used optimized byteArrayMap method'.! !!WideCharacterSetTest commentStamp: 'nice 11/19/2007 22:45' prior: 0!WideCharacterSetTest holds tests for WideCharacterSet!!WideStringTest methodsFor: 'tests - converting' stamp: 'ar 4/12/2005 17:36'!testAsInteger	self assert: '1796exportFixes-tkMX' asWideString asInteger = 1796.	self assert: 'donald' asWideString asInteger isNil.	self assert: 'abc234def567' asWideString asInteger = 234.	self assert: '-94' asWideString asInteger = -94.	self assert: 'foo-bar-92' asWideString asInteger = -92.	self assert: '1796exportFixes-tkMX' asWideString asSignedInteger = 1796.	self assert: 'donald' asWideString asSignedInteger isNil.	self assert: 'abc234def567' asWideString asSignedInteger = 234.	self assert: '-94' asWideString asSignedInteger = -94.	self assert: 'foo-bar-92' asWideString asSignedInteger = -92.	self assert: '1796exportFixes-tkMX' asWideString asUnsignedInteger = 1796.	self assert: 'donald' asWideString asUnsignedInteger isNil.	self assert: 'abc234def567' asWideString asUnsignedInteger = 234.	self assert: '-94' asWideString asUnsignedInteger = 94.	self assert: 'foo-bar-92' asWideString asUnsignedInteger = 92! !!WideStringTest methodsFor: 'testing' stamp: 'nice 4/2/2008 23:49'!testAtPut	"Non regression test for http://bugs.squeak.org/view.php?id=6998"		| w1 |	w1 := WideString with: (Unicode value: 402) with: $a with: (Unicode value: 400) with: $b.	self assert: (w1 at: 2 put: $b) = $b description: 'at:put: should return the put-object'! !!WideStringTest methodsFor: 'tests - beginsWith' stamp: 'nice 7/28/2007 23:29'!testBeginsWith	"from johnmci at http://bugs.squeak.org/view.php?id=5331"		| w1 w2 |	self assert: ('abc' beginsWith: 'ab').	self assert: ('abc' beginsWith: 'ab' asWideString).	self assert: ('abc' asWideString beginsWith: 'ab').	self assert: ('abc' beginsWith: 'aX') not .	self assert: ('abc' beginsWith: 'AB') not.	self assert: ('abc' beginsWith: 'AB' asWideString) not .	self assert: ('ABC' asWideString beginsWith: 'ab') not.	w1 := WideString with: (Unicode value: 402) with: $a with: (Unicode value: 400) with: $b.	w2 := WideString with: (Unicode value: 402).	w1 beginsWith: w2.! !!WideStringTest methodsFor: 'tests - match' stamp: 'nice 7/28/2007 23:22'!testCharactersExactlyMatching	"from johnmci at http://bugs.squeak.org/view.php?id=5331"		self assert: ('abc' charactersExactlyMatching: 'abc') = 3.	self assert: ('abd' charactersExactlyMatching: 'abc') = 2.	self assert: ('abc' charactersExactlyMatching: 'abc' asWideString) = 3.	self assert: ('abd' charactersExactlyMatching: 'abc' asWideString) = 2.	self assert: ('abc' asWideString charactersExactlyMatching: 'abc') = 3.	self assert: ('abd' asWideString charactersExactlyMatching: 'abc') = 2.	self assert: ('abc' asWideString charactersExactlyMatching: 'abc' asWideString) = 3.	self assert: ('abd' asWideString charactersExactlyMatching: 'abc' asWideString)= 2.	self assert: ('abc' charactersExactlyMatching: 'ABC') = 0.! !!WideStringTest methodsFor: 'tests - match' stamp: 'nice 7/28/2007 23:16'!testMatch	"from johnmci at http://bugs.squeak.org/view.php?id=5331"		self assert: ('*baz' match: 'mobaz' ).	self assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' ).	self assert: ('*baz' match: 'mobaz' ).	self assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' ).		self assert: ('*baz' match: 'mobaz' asWideString).	self assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' asWideString).	self assert: ('*baz' match: 'mobaz' asWideString).	self assert: ('*foo#zort' match: 'afoo3zortthenfoo3zort' asWideString).		self assert: ('*baz' asWideString match: 'mobaz' ).	self assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' ).	self assert: ('*baz' asWideString match: 'mobaz' ).	self assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' ).		self assert: ('*baz' asWideString match: 'mobaz' asWideString).	self assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' asWideString).	self assert: ('*baz' asWideString match: 'mobaz' asWideString).	self assert: ('*foo#zort' asWideString match: 'afoo3zortthenfoo3zort' asWideString).! !!WideStringTest methodsFor: 'tests - compare' stamp: 'nice 7/28/2007 23:19'!testCompare	"from johnmci at http://bugs.squeak.org/view.php?id=5331"		self assert: ('abc' compare: 'abc') = 2.	self assert: ('abc' compare: 'abd') = 1.	self assert: ('abd' compare: 'abc') = 3.	self assert: ('abc' compare: 'abC') = 2.	self assert: ('abc' compare: 'abD') = 1.	self assert: ('abd' compare: 'abC') = 3.	self assert: ('aBc' compare: 'abC') = 2.	self assert: ('aBc' compare: 'abD') = 1.	self assert: ('aDd' compare: 'abC') = 3.			self assert: ('abc' compare: 'abc' asWideString) = 2.	self assert: ('abc' compare: 'abd' asWideString) = 1.	self assert: ('abd' compare: 'abc' asWideString) = 3.	self assert: ('abc' compare: 'abC' asWideString) = 2.	self assert: ('abc' compare: 'abD' asWideString) = 1.	self assert: ('abd' compare: 'abC' asWideString) = 3.	self assert: ('aBc' compare: 'abC' asWideString) = 2.	self assert: ('aBc' compare: 'abD' asWideString) = 1.	self assert: ('aDd' compare: 'abC' asWideString) = 3.		self assert: ('abc' asWideString compare: 'abc') = 2.	self assert: ('abc' asWideString compare: 'abd') = 1.	self assert: ('abd' asWideString compare: 'abc') = 3.	self assert: ('abc' asWideString compare: 'abC') = 2.	self assert: ('abc' asWideString compare: 'abD') = 1.	self assert: ('abd' asWideString compare: 'abC') = 3.	self assert: ('aBc' asWideString compare: 'abC') = 2.	self assert: ('aBc' asWideString compare: 'abD') = 1.	self assert: ('aDd' asWideString compare: 'abC') = 3.		self assert: ('abc' asWideString compare: 'abc' asWideString) = 2.	self assert: ('abc' asWideString compare: 'abd' asWideString) = 1.	self assert: ('abd' asWideString compare: 'abc' asWideString) = 3.	self assert: ('abc' asWideString compare: 'abC' asWideString) = 2.	self assert: ('abc' asWideString compare: 'abD' asWideString) = 1.	self assert: ('abd' asWideString compare: 'abC' asWideString) = 3.	self assert: ('aBc' asWideString compare: 'abC' asWideString) = 2.	self assert: ('aBc' asWideString compare: 'abD' asWideString) = 1.	self assert: ('aDd' asWideString compare: 'abC' asWideString) = 3.		self assert: ('abc' compare: 'abc' caseSensitive: true) = 2.	self assert: ('abc' compare: 'abC' caseSensitive: false) = 2.	self assert: ('abc' compare: 'abc' asWideString caseSensitive: true) = 2.	self assert: ('abc' compare: 'abC' asWideString caseSensitive: false) = 2.	self assert: ('abc' asWideString compare: 'abc' caseSensitive: true) = 2.	self assert: ('abc' asWideString compare: 'abC' caseSensitive: false) = 2.	self assert: ('abc' asWideString compare: 'abc' asWideString caseSensitive: true) = 2.	self assert: ('abc' asWideString compare: 'abC' asWideString caseSensitive: false) = 2.! !!WideStringTest methodsFor: 'tests - compare' stamp: 'nice 1/18/2010 14:55'!testEqual	"from johnmci at http://bugs.squeak.org/view.php?id=5331"		self assert: 'abc' = 'abc'.	self assert: 'abc' = 'abc' asWideString.	self assert: 'abc' asWideString = 'abc'.	self assert: 'abc' asWideString = 'abc' asWideString.	self assert: ('abc' = 'ABC') not.	self assert: ('abc' = 'ABC' asWideString) not.	self assert: ('abc' asWideString = 'ABC') not.	self assert: ('abc' asWideString = 'abc' asWideString).	self assert: (#[ 97 0 0 0 ] asString ~= 'a000' asWideString).	self assert: ('a000' asWideString ~= #[ 97 0 0 0 ] asString).! !!WideStringTest methodsFor: 'tests - compare' stamp: 'nice 1/18/2010 14:56'!testSameAs	"from johnmci at http://bugs.squeak.org/view.php?id=5331"	self assert: ('abc' sameAs: 'aBc' asWideString).	self assert: ('aBc' asWideString sameAs: 'abc').	self assert: (#[ 97 0 0 0 ] asString sameAs: 'Abcd' asWideString) not.	self assert: ('a000' asWideString sameAs: #[ 97 0 0 0 ] asString) not.	! !!WideStringTest methodsFor: 'tests - endsWith' stamp: 'nice 10/3/2009 21:18'!testEndsWith	"Mix of tests from http://bugs.squeak.org/view.php?id=6366	#endsWith: was broken because using broken findSubstring	and tests from johnmci at http://bugs.squeak.org/view.php?id=5331"	| ws |			self assert: ('abc' endsWith: 'bc').	self assert: ('abc' endsWith: 'bc' asWideString).	self assert: ('abc' asWideString endsWith: 'bc').	self assert: ('abc' endsWith: 'bX') not.	self assert: ('abc' endsWith: 'BC') not.	self assert: ('abc' endsWith: 'BC' asWideString) not.	self assert: ('ABC' asWideString endsWith: 'bc') not.		self assert: ('Elvis' endsWith: 'vis').	self assert: ('Elvis' asWideString endsWith: 'vis').	self assert: ((WideString with: (Unicode value: 530)) , 'Elvis' endsWith: 'vis').		self deny: ('Elvis' endsWith: 'Vis').	self deny: ('Elvis' asWideString endsWith: 'vIs').	self deny: ((WideString with: (Unicode value: 530)) , 'Elvis' endsWith: 'viS').		ws := 'vis' , (WideString with: (Unicode value: 530)).	self deny: ('Elvis' endsWith: ws).	self assert: ('Elvis' , ws endsWith: ws).	self deny: ((WideString with: (Unicode value: 530)) , 'Elvis' endsWith: ws).! !!WideStringTest methodsFor: 'tests - substrings' stamp: 'nice 7/28/2007 00:46'!testFindSubstring	"This is related to http://bugs.squeak.org/view.php?id=6366	finding substring in a WideString was broken because matchTable are byte-wise"		| ws1 ws2 |		self assert: ('abcd' findString: 'bc' startingAt: 1) = 2.	self assert: ('abcd' asWideString findString: 'bc' startingAt: 1) = 2.	self assert: ('abcd' findString: 'bc' asWideString startingAt: 1) = 2.	self assert: ('abcd' asWideString findString: 'bc' asWideString startingAt: 1) = 2.		ws1 := 'A' , (WideString with: (Unicode value: 530)) , 'BCD'.	self assert: (ws1 findString: 'bc' startingAt: 1 caseSensitive: true) = 0.	self assert: (ws1 findString: 'bc' startingAt: 1 caseSensitive: false) = 3.		ws2 := (WideString with: (Unicode value: 530)) , 'b'.	self assert: (ws1 findString: ws2 startingAt: 1 caseSensitive: true) = 0.	self assert: (ws1 findString: ws2 startingAt: 1 caseSensitive: false) = 2.		self assert: ('abc' findString: ws2 startingAt: 1 caseSensitive: true) = 0.	self assert: ('abc' findString: ws2 startingAt: 1 caseSensitive: false) = 0.! !!WideStringTest methodsFor: 'tests - substrings' stamp: 'nice 3/23/2007 01:52'!testSubstrings	"this is related to http://bugs.squeak.org/view.php?id=6367"		| w1 w2 |	w1 := WideString with: 401 asCharacter with: $a with: 402 asCharacter with: $b.	w2 := WideString with: 403 asCharacter with: 404 asCharacter.	self assert: w1 substrings first = w1.	self assert: (w1 , ' ' , w2) substrings size = 2.	self assert: (w1 , ' ' , w2) substrings last = w2.! !!WideStringTest methodsFor: 'tests - relation order' stamp: 'nice 7/28/2007 23:14'!testRelationOrder	"from johnmci at http://bugs.squeak.org/view.php?id=5331"	self assert: ('aa' < 'ab').	self assert: ('aa' <= 'ab').	self assert: ('aa' <= 'aa').	self assert: ('ab' > 'aa').	self assert: ('ab' >= 'aa').	self assert: ('aa' >= 'aa').		self assert: ('aa' < 'ab' asWideString).	self assert: ('aa' <= 'ab' asWideString).	self assert: ('aa' <= 'aa' asWideString).	self assert: ('ab' > 'aa' asWideString).	self assert: ('ab' >= 'aa' asWideString).	self assert: ('aa' >= 'aa' asWideString).		self assert: ('aa' asWideString < 'ab').	self assert: ('aa' asWideString <= 'ab').	self assert: ('aa' asWideString <= 'aa').	self assert: ('ab' asWideString > 'aa').	self assert: ('ab' asWideString >= 'aa').	self assert: ('aa' asWideString >= 'aa').		self assert: ('aa' asWideString< 'ab' asWideString).	self assert: ('aa' asWideString<= 'ab' asWideString).	self assert: ('aa' asWideString<= 'aa' asWideString).	self assert: ('ab' asWideString> 'aa' asWideString).	self assert: ('ab' asWideString >= 'aa' asWideString).	self assert: ('aa' asWideString>= 'aa' asWideString).! !!WideStringTest methodsFor: 'tests - relation order' stamp: 'nice 7/28/2007 23:21'!testRelationOrderWithCase	"from johnmci at http://bugs.squeak.org/view.php?id=5331"			self assert: ('ABC' caseInsensitiveLessOrEqual: 'abc').	self assert: ('ABC' caseInsensitiveLessOrEqual: 'abd').	self assert: ('ABD' caseInsensitiveLessOrEqual: 'abc') not.	self assert: ('ABC' caseInsensitiveLessOrEqual: 'abc' asWideString).	self assert: ('ABC' caseInsensitiveLessOrEqual: 'abd' asWideString).	self assert: ('ABD' caseInsensitiveLessOrEqual: 'abc' asWideString) not.	self assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abc').	self assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abd').	self assert: ('ABD' asWideString caseInsensitiveLessOrEqual: 'abc') not.	self assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abc' asWideString).	self assert: ('ABC' asWideString caseInsensitiveLessOrEqual: 'abd' asWideString).	self assert: ('ABD' asWideString caseInsensitiveLessOrEqual: 'abc' asWideString) not.			self assert: ('abc' caseSensitiveLessOrEqual: 'abc').	self assert: ('abc' caseSensitiveLessOrEqual: 'abd').	self assert: ('abd' caseSensitiveLessOrEqual: 'abc') not.	self assert: ('abc' caseSensitiveLessOrEqual: 'abc' asWideString).	self assert: ('abc' caseSensitiveLessOrEqual: 'abd' asWideString).	self assert: ('abd' caseSensitiveLessOrEqual: 'abc' asWideString) not.	self assert: ('abc' asWideString caseSensitiveLessOrEqual: 'abc').	self assert: ('abc' asWideString caseSensitiveLessOrEqual: 'abd').	self assert: ('abd' asWideString caseSensitiveLessOrEqual: 'abc') not.	self assert: ('abc' caseSensitiveLessOrEqual: 'ABC') not.	! !!WideStringTest commentStamp: '<historical>' prior: 0!This is the unit test for the class String. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!Win32VMTest methodsFor: 'tests' stamp: 'nice 3/7/2010 01:33'!testWinVM3ButtonMousePreference	"Ensure that swapMouseButtons agrees with 3ButtonMouse preference"	| iniData iniPref exePath |	Smalltalk platformName = 'Win32' ifFalse:[^self].	exePath := Smalltalk vmPath.	iniData := [		(FileStream readOnlyFileNamed: (exePath copyUpToLast: $.), '.ini')			 contentsOfEntireFile	] on: Error do:[:ex| ex return: ''].	iniPref := false. "default is OFF"	iniData linesDo:[:line|		(line beginsWith: '3ButtonMouse') ifTrue:[			iniPref := (line copyAfter: $=) withBlanksTrimmed ~= '0'.		].	].	self assert: iniPref = Preferences swapMouseButtons.! !!WindowingTransformation methodsFor: 'transforming'!align: point1 with: point2 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of (aPoint2 - aPoint1). It is normally used when 	the source and destination coordinate systems are scaled the same (that 	is, there is no scaling between them), and is then a convenient way of 	specifying a translation, given two points that are intended to coincide."	^self translateBy: point2 - point1! !!WindowingTransformation methodsFor: 'transforming'!noScale	"Answer true if the identity scale is in effect; answer false, otherwise."	^scale == nil! !!WindowingTransformation methodsFor: 'transforming'!scale	"Answer a copy of the point that represents the current scale of the 	receiver."	scale == nil		ifTrue: [^1.0 @ 1.0]		ifFalse: [^scale copy]! !!WindowingTransformation methodsFor: 'transforming'!scaleBy: aScale 	"Answer a WindowingTransformation with the scale and translation of 	the receiver both scaled by aScale."	| checkedScale newScale newTranslation |	aScale == nil		ifTrue: 			[newScale := scale.			newTranslation := translation]		ifFalse: 			[checkedScale := self checkScale: aScale.			scale == nil				ifTrue: [newScale := checkedScale]				ifFalse: [newScale := scale * checkedScale].			newTranslation := checkedScale * translation].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!translateBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint. It is used 	when the translation is known in scaled source coordinates, rather than 	source coordinates (see WindowingTransformation|scrollBy:). If no scaling 	is in effect (scale = nil), then WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	^WindowingTransformation scale: scale translation: translation + aPoint! !!WindowingTransformation methodsFor: 'transforming'!translation	"Answer a copy of the receiver's translation."	^translation copy! !!WindowingTransformation methodsFor: 'applying transform'!applyInverseTo: anObject 	"Apply the inverse of the receiver to anObject and answer the result. 	Used to map some object in destination coordinates to one in source 	coordinates."	| transformedObject |	transformedObject := anObject translateBy: translation x negated @ translation y negated.	scale == nil		ifFalse: [transformedObject := transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!applyTo: anObject 	"Apply the receiver to anObject and answer the result. Used to map some 	object in source coordinates to one in destination coordinates."	| transformedObject |	scale == nil		ifTrue: [transformedObject := anObject]		ifFalse: [transformedObject := anObject scaleBy: scale].	transformedObject := transformedObject translateBy: translation.	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!compose: aTransformation 	"Answer a WindowingTransformation that is the composition of the 	receiver and aTransformation. The effect of applying the resulting 	WindowingTransformation to an object is the same as that of first 	applying aTransformation to the object and then applying the receiver to 	its result."	| aTransformationScale newScale newTranslation |	aTransformationScale := aTransformation scale.	scale == nil		ifTrue: 			[aTransformation noScale				ifTrue: [newScale := nil]				ifFalse: [newScale := aTransformationScale].			newTranslation := translation + aTransformation translation]		ifFalse: 			[aTransformation noScale				ifTrue: [newScale := scale]				ifFalse: [newScale := scale * aTransformationScale].			newTranslation := translation + (scale * aTransformation translation)].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'private'!checkScale: aScale	"Convert aScale to the internal format of a floating-point Point." 	| checkedScale |	checkedScale := aScale asPoint.	^checkedScale x asFloat @ checkedScale y asFloat! !!WindowingTransformation methodsFor: 'private'!setScale: aScale translation: aTranslation 	"Sets the scale to aScale and the translation to aTranslation."	scale := aScale.	translation := aTranslation! !!WindowingTransformation methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name, ' scale: ';		print: scale; nextPutAll: ' translation: ';		print: translation! !!WindowingTransformation methodsFor: 'scrolling'!scrollBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint scaled by 	the current scale. It is used when the translation is known in source 	coordinates, rather than scaled source coordinates (see 	WindowingTransformation|translateBy:). An example is that of scrolling 	objects with respect to a stationary window in the source coordinate 	system. If no scaling is in effect (scale = nil), then 	WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	| newTranslation |	scale == nil		ifTrue: [newTranslation := aPoint]		ifFalse: [newTranslation := scale * aPoint].	^self translateBy: newTranslation! !!WindowingTransformation commentStamp: '<historical>' prior: 0!My instances are used to transform objects from a source coordinate system to a destination coordinate system. Each instance contains a scale and a translation which can be applied to objects that respond to scaleBy: and translateBy:. It can be created with a default identity scale and translation, or with a specified scale and translation, or with a scale and translation computed from a window (a Rectangle in the source coordinate system) and a viewport (a Rectangle in the destination coordinate system). In applying a WindowingTransformation to an object, the object is first scaled (around the origin of the source coordinate system) and then translated. WindowingTransformations can be composed to form a single compound transformation.!!WindowingTransformation class methodsFor: 'instance creation'!identity	"Answer an instance of me with no scaling (nil) and no translation 	(0@0)."	^self new setScale: nil translation: 0 @ 0! !!WindowingTransformation class methodsFor: 'instance creation'!scale: aScale translation: aTranslation 	"Answer an instance of me with a scale factor of aScale and a translation 	offset of aTranslation. When the transformation is applied (see 	WindowingTransformation|apply:), the scale is applied first, followed by 	the translation."	^self new setScale: aScale translation: aTranslation! !!WindowingTransformation class methodsFor: 'instance creation'!window: aWindow viewport: aViewport 	"Answer an instance of me with a scale and translation based on 	aWindow and aViewport. The scale and translation are computed such 	that aWindow, when transformed, coincides with aViewport."	| scale translation |	aViewport width = aWindow width & (aViewport height = aWindow height)		ifTrue:			[scale := nil]		ifFalse:			[scale := aViewport width asFloat / aWindow width asFloat						@ (aViewport height asFloat / aWindow height asFloat)].	scale == nil		ifTrue: [translation := aViewport left - aWindow left								@ (aViewport top - aWindow top)]		ifFalse: [translation := aViewport left - (scale x * aWindow left)								@ (aViewport top - (scale y * aWindow top))].	^self new setScale: scale translation: translation! !!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:16'!bindingOf: aString 	mustDeclareVariables ifTrue: [^ nil].	"I want to have workspace that force the user to declare  	variables. Still subclasses may want to do something else"	bindings ifNil: [self initializeBindings].	(bindings includesKey: aString) ifFalse: [		| val |		val := self lookupInPools: aString.		val 			ifNotNil: [				"Caveat: since we're not inserting the pool's Association into				 the dictionary, assigning a new value to the variable will only				 affect the one Workspace (i.e. you can't assign to a variable in a				 SharedPool)."				bindings at: aString put: val]			ifNil: [aString first isUppercase					ifTrue: [^nil]					ifFalse: [bindings at: aString put: nil]]	].	^ bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:00'!lookupInPools: aString 	"Iterate through all of the lookup pools to find a match for the specified name."	LookupPools ifNil: [^nil].	LookupPools do: [:pool | (pool bindingOf: aString) ifNotNil: [:assoc | ^assoc value]].	^nil! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 6/18/2010 18:26'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool.	" Ugly hack, to restyle our contents. "	self codeTextMorph in: [ :codeTextMorph |		codeTextMorph setText:			codeTextMorph textMorph text asString asText ]! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 6/18/2010 18:32'!toggleStyling	self shouldStyle: self shouldStyle not.! !!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 0!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!addLookupPool: sharedPool	"Add a SharedPool that bindings should be looked up in."	LookupPools ifNil: [LookupPools := IdentitySet new].	LookupPools add: sharedPool! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 11:08'!clearLookupPools	LookupPools := nil.! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!removeLookupPool: sharedPool	"Workspaces should no longer look up bindings in the specified SharedPool."	LookupPools ifNil: [^self].	LookupPools remove: sharedPool ifAbsent: [].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:43'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	"The following is to circumvent a Monticello loading problem"	[canvas finish: allDamage] on: MessageNotUnderstood do:[:ex| ex return].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:04'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!WorldStateTest methodsFor: 'tests' stamp: 'ar 2/4/2010 22:44'!testDeferredUIQueueTimeout	"Ensure that the World's deferredUIMessage will take no more time than	specified by WorldState's deferredExecutionTimeLimit"	| firstWasRun secondWasRun thirdWasRun |	firstWasRun := secondWasRun := thirdWasRun := false.	WorldState addDeferredUIMessage:[		firstWasRun := true.		(Delay forMilliseconds: WorldState deferredExecutionTimeLimit + 50) wait.	].	WorldState addDeferredUIMessage:[		secondWasRun := true.	].	WorldState addDeferredUIMessage:[		thirdWasRun := true.	].	self deny: firstWasRun.	self deny: secondWasRun.	self deny: thirdWasRun.	World doOneCycleNow.	self assert: firstWasRun.	self deny: secondWasRun.	self deny: thirdWasRun.	World doOneCycleNow.	self assert: firstWasRun.	self assert: secondWasRun.	self assert: thirdWasRun.! !!WriteStream methodsFor: 'accessing' stamp: 'ar 6/25/2007 14:34'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd numPut |	anInteger < 0 ifTrue:[^self error: 'Cannot write negative amounts'].	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex ].	numPut := anInteger min: (aCollection size - startIndex + 1).	newEnd := position + numPut.	newEnd > writeLimit ifTrue:		[^ super next: anInteger putAll: aCollection startingAt: startIndex "Trigger normal pastEndPut: logic"].	collection replaceFrom: position+1 to: newEnd with: aCollection startingAt: startIndex.	position := newEnd.! !!WriteStream methodsFor: 'accessing' stamp: 'bgf 5/23/2008 18:04'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	"<primitive: 66>  Doesn't pay its way."	((collection class == ByteString) and: [		anObject isCharacter and:[anObject isOctetCharacter not]]) ifTrue: [			collection := (WideString from: collection).			^self nextPut: anObject.	].	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position := position + 1.			^collection at: position put: anObject]! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:22'!testCr	"self debug: #testCr"		| stream |	stream := WriteStream on: 'stream'.	stream cr.	self assert: stream last = Character cr.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'ul 12/2/2009 05:53'!testCrLf	"self debug: #testCrLf"		| stream |	stream := WriteStream on: 'stream'.	stream crlf.	self assert: (stream contents last: 2) = String crlf.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:26'!testCrTab	"self debug: #testCrTab"		| stream |	stream := WriteStream on: 'stream'.	stream crtab.	self assert: (stream contents last: 2) = (String with: Character cr with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:28'!testCrTabs	"self debug: #testCrTabs"		| stream |	stream := WriteStream on: 'stream'.	stream crtab: 2.	self assert: (stream contents last: 3) = (String with: Character cr with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:14'!testEnsureASpace	"self debug: #testEnsureASpace"	| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test'.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.		"Manually put a space and verify there are no 2 consecutive spaces"	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test '.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:17'!testEnsureASpace2	"self debug: #testEnsureASpace2"	| stream |	stream := WriteStream on: String new.	stream ensureASpace.	self assert: stream contents = ' '.	! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:29'!testEnsureNoSpace	"self debug: #testEnsureNoSpace"		| stream |	stream := WriteStream with: 'stream'.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: 'stream '.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: ' '.	stream ensureNoSpace.	self assert: stream contents = ''.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'ul 12/2/2009 05:52'!testLf	"self debug: #testLf"		| stream |	stream := WriteStream on: 'stream'.	stream lf.	self assert: stream last = Character lf.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:39'!testSpace	"self debug: #testSpace"		| stream |	stream := WriteStream on: 'stream'.	stream space.	self assert: stream last = Character space.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:40'!testSpaces	"self debug: #testSpaces"		| stream |	stream := WriteStream on: 'stream'.	stream space: 3.	self assert: (stream contents last: 3) = '   '! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:42'!testTab	"self debug: #testTab"		| stream |	stream := WriteStream on: 'stream'.	stream tab.	self assert: (stream contents last) = Character tab! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:41'!testTabs	"self debug: #testTabs"		| stream |	stream := WriteStream on: 'stream'.	stream tab: 3.	self assert: (stream contents last: 3) = (String with: Character tab with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingOn	"self debug: #testInstanciationUsingOn"	| stream |	stream := WriteStream on: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingWith	"self debug: #testInstanciationUsingWith"	| stream |	stream := WriteStream with: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(1 2 3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 09:24'!testNew	self should: [WriteStream new] raise: Error. ! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:15'!testNextPutAllDifferentFromNextPuts	"self debug: #testNextPutAllDifferentFromNextPuts"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		"nextPutAll verifies the size of the parameter and directly grows the underlying collection of the required size."	|string stream|		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPutAll: 'abc'.	self assert: string = 'z'. "string hasn't been modified because #nextPutAll: detects that 'abc' is bigger than the underlying collection. Thus, it starts by creating a new collection and doesn't modify our variable."		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPut: $a; nextPut: $b; nextPut: $c.	self assert: string = 'a'. "The first #nextPut: has no problem and replaces $z by $a in the string. Others will detect that string is too small."! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:05'!testStreamUseGivenCollection	"self debug: #testStreamUseGivenCollection"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		|string stream|		string := String withAll: 'erased'.	stream := WriteStream on: string.	self assert: string = 'erased'.		stream nextPutAll: 'test'.	self assert: string = 'tested'. "Begining of 'erased' has been replaced by 'test'".! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:20'!testIsEmpty	| stream |	stream := WriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'edc 4/12/2007 07:01'!testIsEmpty2    self assert: (WriteStream on: (String new: 100)) isEmpty! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:12'!testNextPut	"self debug: #testNextPut"	| stream |	stream := WriteStream on: String new.	stream		nextPut: $t;		nextPut: $e;		nextPut: $s;		nextPut: $t.	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPut2	"self debug: #testNextPut2"	| stream |	stream := WriteStream with: 'test'.	stream nextPut: $s.	self assert: stream contents = 'tests'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPutAll	"self debug: #testNextPutAll"	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: #($t $e $s $t).	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'sd 6/5/2005 09:24'!testSetToEnd	| string stream |	string := 'hello'.	stream := WriteStream with: ''.	stream nextPutAll: string.	self assert: stream position = string size.	stream setToEnd.	self assert: stream position = string size.	self assert: stream contents = string! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:19'!testSize	"self debug: #testSize"	| string streamEmpty streamFull |	string := 'a string'.	streamEmpty := WriteStream on: string.	streamFull := WriteStream with: 'a string'.		self assert: streamEmpty size = 0.	self assert: streamFull size = 8.		streamEmpty nextPut: $..	streamFull nextPut: $..	self assert: streamEmpty size = 1.	self assert: streamFull size = (string size + 1).! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:48'!testPosition	"self debug: #testPosition"		| stream |	stream := WriteStream with: 'an elephant'.	stream position: 6.	self assert: stream contents = 'an ele'.	stream nextPutAll: 'vator'.	stream assert: stream contents = 'an elevator'! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:52'!testPosition2	"self debug: #testPosition2"		| stream |	stream := WriteStream with: ''.	self should: [stream position: 2] raise: Error.	self should: [stream position: -2] raise: Error.	stream := WriteStream with: 'a test'.	self shouldnt: [stream position: 2] raise: Error.	self should: [stream position: 7] raise: Error.	self should: [stream position: -2] raise: Error.! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/24/2007 17:55'!testReset	"self debug: #testReset"	|stream stream2|	stream := WriteStream with: 'a test ' copy.	stream reset.	stream nextPutAll: 'to test'.	self assert: stream contents = 'to test'.	stream2 := WriteStream with: 'a test ' copy.	stream2 nextPutAll: 'to test'.	self assert: stream2 contents = 'a test to test'! !!XBMReadWriter methodsFor: 'private' stamp: 'ar 4/5/2006 01:25'!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth :=true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement := XMLStringNode string: aString.	self top addContent: newElement.! !!XMLDOMParser methodsFor: 'content' stamp: 'thf 9/2/2005 14:09'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:19'!endDocument	self pop.	super endDocument! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement := self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement := self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement := XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 11/30/2000 18:14'!startDocument	self document: XMLDocument new.	self push: self document ! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement := XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement := namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement := XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 6/16/2003 17:20'!defaultNamespace	^self top		ifNotNil: [self top namespace]! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop := self stack removeLast.	entity := oldTop.	^oldTop! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity := anObject! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 8/14/2000 18:28'!stack	^stack! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 11:46'!top	^self stack isEmpty		ifTrue: [nil]		ifFalse: [self stack last]! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/5/2003 19:29'!domDocument	[self startDocument; parseDocument]		ensure: [self driver stream close].	^document! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop := self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 12/21/2000 14:02'!nextEntityStart	[self driver nextEntity.	self stack isEmpty] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental	^incremental! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental := aBoolean! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack := OrderedCollection new.	incremental := false! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:26'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream useNamespaces: true! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream useNamespaces: aBoolean	^(super parseDocumentFrom: aStream useNamespaces: aBoolean) document! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'ar 7/18/2008 10:53'!parseOneElementFrom: aStream	| parser |	parser := self on: aStream.	parser startDocument.	[parser document elements isEmpty] whileTrue:[parser nextEntity].	^parser document topElement! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd	^dtd! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd := aDTD! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 5/16/2003 14:09'!encoding		^encoding ifNil: ['UTF-8']! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding := aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup		^requiredMarkup! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup := aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/29/2007 14:42'!root	"return my root element"	^ self topElement ! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version		^version! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version := aString! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer := XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLDocument methodsFor: 'printing' stamp: 'mir 5/16/2003 14:08'!printXMLOn: writer	version ifNotNil: [writer xmlDeclaration: self version encoding: self encoding].	super printXMLOn: writer! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre.Bergel 6/1/2009 10:31'!@ aSymbol	"shorthand form"	^ self at: aSymbol ! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre.Bergel 6/1/2009 10:29'!allAttributes	^ self attributes asOrderedCollection! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre Bergel 1/21/2010 22:13'!at: aSymbol    ^ self attributeAt: aSymbol ifAbsent: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName	^self attributeAt: attributeName ifAbsent: [nil]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName ifAbsent: aBlock	^self attributes at: attributeName ifAbsent: [^aBlock value]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:24'!attributeAt: attributeName put: attributeValue	self attributes at: attributeName asSymbol put: attributeValue! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes := Dictionary new]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 3/7/2000 16:24'!characterData	^self contentString! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre Bergel 11/26/2009 17:41'!contentString	| contentElements |	contentElements := self elementsAndContents.	^(contentElements size > 0		and: [contentElements first isText])		ifTrue: [contentElements first string]		ifFalse: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/18/2003 13:47'!contentStringAt: entityName	^(self elementAt: entityName ifAbsent: [^'']) contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:24'!contents	^self elementsAndContents select: [:each | each isText]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:25'!elements	^self elementsAndContents select: [:each | each isText not]! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!name	^ self qualifiedName! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent	^ parent! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent: anXMLElement	parent := anXMLElement ! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!tag	^ self name asSymbol! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/5/2003 12:02'!valueFor: aSymbol 	^self valueFor: aSymbol ifAbsent: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:28'!valueFor: aSymbol ifAbsent: aBlock 	^self attributes at: aSymbol ifAbsent: aBlock! !!XMLElement methodsFor: 'initialize' stamp: 'mir 10/31/2007 17:55'!addContent: contentString	self addElement: contentString! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name := aString asSymbol! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes := newAttributes! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!contentsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifTrue: [aBlock value: each]]! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 1/3/2008 14:18'!elementsAndContentsDo: aBlock	self elementsAndContents do: aBlock! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!elementsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifFalse: [aBlock value: each]]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag.	If it is not the receiver, pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [^self].	^super firstTagNamed: aSymbol ! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that allows	the block to evaluate to true. Pass the message on"	((self localName == aSymbol		or: [self tag == aSymbol]) 		and: [aBlock value: self])		ifTrue: [^self].	^super firstTagNamed: aSymbol with: aBlock.! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:33'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver	if the receiver tag equals aSymbol. Pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [self contentsDo: aBlock].	super tagsNamed: aSymbol contentsDo: aBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol do: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Continue the search"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol do: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Then recurse through all the children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver.	For each of the receivers children do the same. Do not go beyond direct children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock! !!XMLElement methodsFor: 'testing' stamp: 'ar 8/10/2010 13:19'!isEmpty	"Answer true if the receiver is empty"	^self elementsAndContents isEmpty! !!XMLElement methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^true! !!XMLElement methodsFor: 'name space' stamp: 'sd 5/25/2003 18:24'!localName	^ name! !!XMLElement methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!qualifiedName	^self namespace		ifNil: [self localName]		ifNotNil: [self namespace , ':' , self localName]! !!XMLElement methodsFor: 'printing' stamp: 'ar 8/10/2010 13:20'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !!XMLElement class methodsFor: 'instance creation' stamp: 'ar 6/11/2009 11:54'!name: nodeName contentString: contentString	"Creates an XMLElement with the give nodeName and a simple string content node.	Equivalent to XMLWriter>>tag:pcData:"	^(self new) name: nodeName;			addContent: (XMLStringNode string: contentString);			setAttributes: (Dictionary new);			yourself! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 3/7/2000 16:33'!named: aString	^self new name: aString! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:01'!named: aString attributes: attributeList	^self new		name: aString;		setAttributes: attributeList! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 15:21'!named: aString namespace: ns uri: uri attributes: attributeList	^self new		name: aString;		namespace: ns uri: uri;		setAttributes: attributeList! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 15:51'!currentScope	^self scope last! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 16:08'!establishLocalBindings	(self currentScope at: 2)		ifNil: [			currentBindings := currentBindings copy.			self currentScope at: 2 put: currentBindings]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:25'!initScope	scope := OrderedCollection new: 20.	currentBindings := Dictionary new.	scope addLast: {'http://www.w3.org/TR/REC-xml-names'. currentBindings. nil. }.! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases := Set new.	uri := self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:26'!scope	scope ifNil: [self initScope].	^scope! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/16/2003 16:37'!declareNamespace: ns uri: uri	"Declare the given name space prefix with the given URL"	ns = 'xmlns'		ifTrue: [^self defaultNamespace: uri].	self establishLocalBindings.	currentBindings removeKey: ns ifAbsent: [].	currentBindings at: ns put: uri! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/5/2003 19:28'!enterScope	self scope addLast: { self defaultNamespace. nil. currentBindings. }! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/4/2003 16:05'!leaveScope	| leftScope |	leftScope := self scope removeLast.	currentBindings := (self currentScope at: 2) ifNil: [leftScope at: 3]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:22'!defaultNamespace	^self currentScope first! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self currentScope at: 1 put: ns! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'sd 5/28/2003 09:33'!namespaceURIOf: ns	"Retrieve the URI of the given namespace prefix, if it is defined. A nil namespace	returns the global namespace"	^ self namespaceURIOf: ns ifAbsent: [ nil ]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 13:33'!namespaceURIOf: ns ifAbsent: aBlock	"Retrieve the URI of the given namespace prefix, if it is defined. 	A nil namespace returns the default namespace. 	If no namespace can be found the value of the block is returned"	^ns		ifNil: [self defaultNamespace]		ifNotNil: [currentBindings at: ns ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:32'!namespaces	^currentBindings! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'nice 12/27/2009 03:26'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"		attributeList keysDo: [:attrName |		| namespace localName |		self splitName: attrName into: [:ns :ln |			namespace := ns.			localName := ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLNode methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:44'!addContent: contentString	SAXParseException signal: 'Illegal string data.'! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 1/17/2002 14:49'!contentsDo: aBlock! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:02'!elementsAndContentsDo: aBlock	self elementsDo: aBlock! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:56'!elementsDo: aBlock! !!XMLNode methodsFor: 'searching' stamp: 'nice 12/26/2009 22:30'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	self elementsDo: [:node |		| answer |		(answer := node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'nice 12/26/2009 22:31'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	self elementsDo: [:node |		| answer |		(answer := node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDo: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDoAndRecurse: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match and recurse"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'jcg 3/26/2009 12:08'!tagsNamed: aSymbol collect: aOneArgumentBlock	"Search for nodes with tag aSymbol. When encountered evaluate aOneArgumentBlock"	| collection |	collection := OrderedCollection new.	self tagsNamed: aSymbol do: [:node | 		collection add: (aOneArgumentBlock value: node)	].	^collection! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver.	The receiver has no tag, so pass the message on"	self elementsDo: [:each | each tagsNamed: aSymbol contentsDo: aBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol do: aOneArgumentBlock	"Search for nodes with tag aSymbol. When encountered evaluate aOneArgumentBlock"	self elementsDo: [:each | each tagsNamed: aSymbol do: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'bp 12/4/2009 10:29'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"Handled only by XMLElement subclass"! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isText	^false! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printOn: stream	self printXMLOn: (XMLWriter on: stream)! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printXMLOn: writer	self subclassResponsibility! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:25'!addElement: element	self elementsAndContents add: element! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:22'!addEntity: entityName value: entityValue	self entities add: entityName->entityValue! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'hrs 8/21/2009 15:14'!contentStringAt: entityName	^self contentStringAt: entityName ifAbsent: ['']! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'hrs 8/21/2009 15:14'!contentStringAt: entityName ifAbsent: aBlock	^(self elementAt: entityName ifAbsent: [^aBlock value]) contentString! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:46'!elementAt: entityName	^self elementAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each isProcessingInstruction not and: [each name = entityName or: [each localName = entityName]]] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName	^self elementUnqualifiedAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elements	^self elementsAndContents! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elementsAndContents	elementsAndContents ifNil: [elementsAndContents := OrderedCollection new].	^elementsAndContents! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'ar 6/17/2010 10:09'!removeElement: element	"Used to purge certain elements from a document after parsing."	elementsAndContents := elementsAndContents copyWithout: element.! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:50'!topElement	^self elements first! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 11/14/2007 17:21'!elementsDo: aBlock	self elements do: [:each | aBlock value: each]! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespace	^ namespace! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace := ns.	uri := u! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespaceURI	^ uri! !!XMLNodeWithElements methodsFor: 'printing' stamp: 'mir 3/6/2002 10:49'!printXMLOn: writer	self elementsDo: [:element | element printXMLOn: writer]! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data	^data! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data := aString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target	^target! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target := aString! !!XMLPI methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^true! !!XMLPI methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pi: self target data: self data! !!XMLPI class methodsFor: 'instance creation' stamp: 'mir 1/17/2002 13:03'!target: targetName data: aString	^self new		target: targetName;		data: aString! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:51'!attribute: aSymbol value: aString	"This method is called for each attribute/value pair in a start tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!beginStartTag: aSymbol asPI: aBoolean	"This method is called for at the beginning of a start tag.	The asPI parameter defines whether or not the tag is a 'processing	instruction' rather than a 'normal' tag."	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endStartTag: aSymbol	"This method is called at the end of the start tag after all of the	attributes have been processed"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endTag: aSymbol	"This method is called when the parser encounters either an	end tag or the end of a unary tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!text: aString	"This method is called for the blocks of text between tags.	It preserves whitespace, but has all of the enclosed entities expanded"	^self subclassResponsibility! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handleCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleEndTag: aString	self endTag: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handlePCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleStartTag: tagName attributes: attributes	self beginStartTag: tagName asPI: false.	attributes keysAndValuesDo: [:key :value |		self attribute: key value: value].	self endStartTag: tagName! !!XMLParser commentStamp: 'Alexandre.Bergel 6/1/2009 10:03' prior: 0!This is a generic parser. There is two ways to parse XML files, either using SAX, or using DOM. Both ways are supported in the XML-Parser package. SAX is event-based while DOM is tree-based. Ask google for more information!!XMLParserTest methodsFor: 'source' stamp: 'AlexandreBergel 1/29/2009 11:49'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLParserTest methodsFor: 'source' stamp: 'AlexandreBergel 1/29/2009 11:49'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 9/2/2010 11:33'!testDecodingWideChars	| encoded node |	encoded := '<test>a&#500;&#800;z</test>'.	node := (XMLDOMParser parseDocumentFrom: encoded readStream) elements first.	self assert: node contentString		equals: (String with: $a with: 500 asCharacter  with: 800 asCharacter with: $z).! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 9/2/2010 11:33'!testEncodingWideChars	| encoded |	encoded := String streamContents:[:s|		(XMLWriter on: s) 			startTag: 'test'; endTag; 			pcData: (String with: $a with: 500 asCharacter  with: 800 asCharacter with: $z);			endTag: 'test'.	].	self assert: encoded equals: '<test>a&#500;&#800;z</test>'.! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 11:52'!testExampleAddressBook	| tokenizer |	"self debug: #testExampleAddressBook"	tokenizer := XMLTokenizer on: self addressBookXML readStream.	"We enumerate the first characters of the addressbook example. The file being parsed begins with <addressbook"	self assert: tokenizer next = $<.	self assert: tokenizer next = $a.		self assert: tokenizer next = $d.	self assert: tokenizer next = $d.	self assert: tokenizer next = $r.	self shouldnt: ([tokenizer next notNil] whileTrue: []) raise: Error. ! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 11:53'!testExampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer := XMLTokenizer on: self addressBookXMLWithDTD readStream.	self shouldnt: ([tokenizer next notNil] whileTrue: []) raise: Error! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 14:38'!testParsing	| xmlDocument root firstPerson numberOfPersons |	"self debug: #testParsing"	xmlDocument := XMLDOMParser parseDocumentFrom: self addressBookXML readStream.	self assert: (xmlDocument isKindOf: XMLDocument).	root := xmlDocument root.	self assert: (root class == XMLElement).		"the tag has to be a symbol!!"	self assert: (root firstTagNamed: 'person') isNil.	self assert: (root firstTagNamed: 'addressbook') isNil.	self assert: (root firstTagNamed: #addressbook) == root.	numberOfPersons := 0.	root tagsNamed: #person do: [:p | numberOfPersons := numberOfPersons + 1].	self assert: numberOfPersons = 4.	firstPerson := root firstTagNamed: #person.	self assert: (firstPerson attributeAt: #'employee-number') = 'A0000'.	self assert: (firstPerson attributeAt: #'family-name') = 'Gates'.	self assert: (firstPerson attributeAt: #'first-name') = 'Bob'.! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 12:21'!testParsingCharacters	| parser |	"This test is actually not that useful. This is not the proper way of using the parser. This test is here just for specification purpose"	"self debug: #testParsingCharacters"	parser := XMLParser on: self addressBookXML readStream.	self assert: parser next = $<.	self assert: parser next = $a.		self assert: parser next = $d.	self assert: parser next = $d.	self assert: parser next = $r.! !!XMLStringNode methodsFor: 'accessing'!characterData	^self string! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string	^string ifNil: ['']! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string := aString! !!XMLStringNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:27'!isText	^true! !!XMLStringNode methodsFor: 'printing' stamp: 'jcg 11/15/2009 10:17'!printStringText	"I don't know why 'XMLStringNode isText == true', but since it is, we need to implement #printStringText."	^self printString! !!XMLStringNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pcData: self string! !!XMLStringNode class methodsFor: 'instance creation' stamp: 'mir 10/25/2000 11:30'!string: aString	^self new string: aString! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:58'!atEnd	nestedStreams == nil		ifTrue: [^peekChar == nil and: [stream atEnd]].	^stream atEnd		ifTrue: [			self popNestingLevel.			self atEnd]		ifFalse: [false]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:59'!checkNestedStream	nestedStreams == nil		ifFalse: [(peekChar == nil and: [self stream atEnd])			ifTrue: [				self popNestingLevel.				self checkNestedStream]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/28/2001 16:45'!hasNestedStreams	^nestedStreams notNil! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 18:16'!match: subCollection into: resultStream	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := ReadStream on: subCollection.	startMatch := nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch := nil]]].	^ true! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar := stream next]		ifNotNil: [			nextChar := peekChar.			peekChar := nil.			^nextChar].	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'bf 4/27/2006 17:55'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	nextChar := nil.	[(nextChar := self next) == delimiter]		whileFalse: [			nextChar == $  ifFalse: [				resultStream nextPut: nextChar]].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:42'!nextUpToAll: delimitingString	| string |	self unpeek.	string := self upToAll: delimitingString.	string		ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar := stream next]		ifNotNil: [^peekChar]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams := nil]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:13'!pushBack: aString	"Fixed to push the string before the peek char (if any)."		| pushBackString |	pushBackString := peekChar		ifNil: [aString]		ifNotNil: [aString, peekChar asString].	peekChar := nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:54'!pushStream: newStream	"Continue parsing from the new nested stream."	self unpeek.	self nestedStreams addLast: self stream.	self stream: newStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 10/31/2007 16:33'!skipSeparators	| nextChar |	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:40'!stream: aStream upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (not inclusive) of aCollection. If aCollection is not in the stream, answer nil."	| startPos endMatch result |	startPos := aStream position.	(aStream  match: aCollection) 		ifTrue: [endMatch := aStream position.			aStream position: startPos.			result := aStream next: endMatch - startPos - aCollection size.			aStream position: endMatch.			^ result]		ifFalse: [			aStream position: startPos.			^nil]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'nice 12/26/2009 22:31'!streamEncoding: encodingString	Smalltalk at: #TextConverter ifPresent: [:tc | 		(stream respondsTo: #converter:) ifTrue: [			| converterClass |			converterClass := tc defaultConverterClassForEncoding: encodingString asLowercase.			converterClass ifNotNil: [stream converter: converterClass new]]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/17/2002 14:31'!topStream	^self hasNestedStreams		ifTrue: [self nestedStreams first]		ifFalse: [self stream]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:19'!unpeek	"Fixed to use nested stream since multi-byte streams	do not properly override pushBack: to deal with multi-byte	characters."		peekChar ifNotNil: [self pushBack: '']! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 20:00'!upToAll: delimitingString	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of delimitingString. If delimitingString is not in the stream, answer the entire rest of the stream."	| result |	self hasNestedStreams		ifFalse: [			result := self stream: self stream upToAll: delimitingString.			result				ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].			^result].	result := self stream: self stream upToAll: delimitingString.	result		ifNotNil: [^result].	result := String streamContents: [:resultStream |		resultStream nextPutAll: self stream upToEnd.		self atEnd			ifTrue: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].		self stream position timesRepeat: [			self atEnd				ifFalse: [					resultStream nextPut: self next]]].	self pushBack: result.	^self upToAll: delimitingString! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar := self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString := self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/16/2000 21:41'!conditionalInclude: conditionalKeyword	conditionalKeyword = 'INCLUDE'		ifTrue: [^true].	conditionalKeyword = 'IGNORE'		ifTrue: [^false].	^self conditionalInclude: (self parameterEntity: conditionalKeyword) value! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName := self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue := self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:51'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream := attributeBuffer reset.	[	nextPeek := nextChar := self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata := self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar := self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword := self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base := self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue := [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string := self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:48'!nextEndTag	| tagName |	"Skip /"	self next.	tagName := self nextName.	self skipSeparators.	(self nextTrimmedBlanksUpTo: $>)		ifNotEmpty: [self parseError: 'XML invalid end tag ' , tagName].	self handleEndTag: tagName! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'gvc 6/6/2007 13:17'!nextEntity	"return the next XMLnode, or nil if there are no more.	Fixed to retain leading whitespace when PCDATA is detected."	|whitespace|	"branch, depending on what the first character is"	whitespace := self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [whitespace isEmpty					ifFalse: [self pushBack: whitespace].				self nextPCData]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream := WriteStream on: (String new).	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek := nextChar := self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					nextChar := self handleEntity: referenceString in: #entityValue.					nextPeek := nextChar := self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section := self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'nice 12/27/2009 03:26'!nextLiteral	| resultStream nextChar |	resultStream := (String new: 10) writeStream.	((nextChar := self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[ | resultString |	nextChar := self peek.	(LiteralChars includes: nextChar)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar := self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString := resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 16:20'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar := self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters includes: nextChar] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar := self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar := self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:52'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream := (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget := self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData := self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextPubidLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextSystemLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName := self nextName.	self skipSeparators.	attributes := Dictionary new: 33.	namespaces := Dictionary new: 5.	[(nextChar := self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 17:49'!nextWhitespace	| nextChar resultStream resultString|	resultStream := (String new: 10) writeStream.	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString := resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].	^resultString! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'thf 9/2/2005 15:04'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes := Dictionary new.	namespaces := Dictionary new.	[(nextChar := self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	(attributes includesKey: 'encoding') ifTrue: [self streamEncoding: (attributes at: 'encoding')].	self handleXMLDecl: attributes namespaces: namespaces	! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 6/29/2001 00:08'!endDocTypeDecl	"Skip ]>"	self next; next.	^nil! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType := self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar := self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass := self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName := self nextLiteral.	self skipSeparators.	entityDef := (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference := referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType := self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId := self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId := self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir := self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType := self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/4/2002 11:05'!skipMarkupDeclaration	self skipUpTo: $>! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup := false! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize := writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 12/7/2000 16:46'!log: aString	"Transcript show: aString; cr"! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams := OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!parsingMarkup	^parsingMarkup! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString := self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value := 0.	digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value := digit.	[digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value := value * base + digit]		] repeat.	^ value! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup := true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream	^stream! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream := newStream! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities := self initEntities].	^entities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 13:53'!entity: refName	^self validating		ifTrue: [self entities			at: refName			ifAbsentPut: [self parseError: 'XML undefined entity ' , refName printString]]		ifFalse: [DTDEntityDeclaration name: refName value: '']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:43'!entity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self entities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities := Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntity: refName	^self entities		at: refName		ifAbsentPut: ['']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity := self entity: referenceString.	entityValue := entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue := entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/23/2007 15:45'!initEntities	| ents |	ents := Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: '&');		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: '"');		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: '''');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: '>');		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: '<').	^ents! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities := Dictionary new].	^parameterEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:40'!parameterEntity: refName	^self parameterEntities		at: refName		ifAbsent: [self parseError: 'XML undefined parameter entity ' , refName printString]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:42'!parameterEntity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self parameterEntities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'errors' stamp: 'nice 1/18/2010 19:24'!errorExpected: expectedString	| actualString |	actualString := ''.	self atEnd		ifFalse: [			actualString := [self next: 20]				on: Error				do: ['']].	self parseError: 'XML expected ' , expectedString printString , ': ' , actualString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/9/2002 15:26'!malformedError: errorString	SAXMalformedException signal: errorString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/8/2002 15:37'!parseError: errorString	SAXParseException signal: errorString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 11/13/2000 16:04'!handleCData: aString	self log: 'CData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:37'!handleComment: aString	self log: 'Comment: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:27'!handleEndDocument	self log: 'End Doc '! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handleEndTag: aString	self log: 'End tag: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handlePCData: aString	self log: 'PCData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 12/11/2000 16:10'!handlePI: piTarget data: piData	self log: 'PI: ' , piTarget , ' data ' , piData! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:26'!handleStartDocument	self log: 'Start Doc'! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:39'!handleStartTag: tagName attributes: attributes	self log: 'Start tag: ' , tagName.	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 21:08'!handleWhitespace: aString	self log: 'Whitespace: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 6/5/2003 14:53'!handleXMLDecl: attributes namespaces: namespaces	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup := false.	validating := false.	attributeBuffer := WriteStream on: (String new: 128).	nameBuffer := WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 6/28/2001 16:51'!parseStream: aStream	self stream: aStream! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating := aBoolean! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 6/5/2003 16:33'!usesNamespaces	^false! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 1/14/2002 17:51'!validating	^validating! !!XMLTokenizer commentStamp: '<historical>' prior: 0!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:49'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer := XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer := XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 10/31/2007 17:22'!initialize	"XMLTokenizer initialize"	CharEscapes := CharacterSet newFrom: #( $& $" $' $> $< ).	SeparatorTable  := CharacterSet new.	#(9 10 12 13 32) do: [:each | SeparatorTable add: each asCharacter].	LiteralChars := CharacterSet newFrom: #( $: $- $: $= $.).	0 to: 255 do: [:i | 		| char |		char := i asCharacter.		(char isDigit or: [char isLetter])		ifTrue: [LiteralChars add: char]].	NameDelimiters := CharacterSet new.	#(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger")		do: [:each | NameDelimiters add: each asCharacter].	DigitTable := Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($a to: $f) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 11/23/2007 15:50'!isCharEscape: entityValue	^entityValue size = 1		and: [CharEscapes includes: entityValue first]! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 8/2/2000 19:25'!new	^super new initialize! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 07:58'!on: aStream	^self new parseStream: aStream! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:04'!attribute: attributeName value: attributeValue	self stream		space;		nextPutAll: attributeName.	self		eq;		putAsXMLString: attributeValue! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:55'!cdata: aString	self startCData.	self stream nextPutAll: aString.	self endCData! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!comment: aString	self startComment.	self stream nextPutAll: aString.	self endComment! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 6/17/2010 16:17'!endEmptyTag: tagName	self popTag: tagName.	self stream nextPutAll: '/>'.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:07'!endTag	self stream nextPutAll: '>'.	self indent.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 17:02'!endTag: tagName	self outdent.	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:46'!endTag: tagName xmlns: xmlns	self popTag: tagName.	self stream		nextPutAll: '</'.	(xmlns notNil		and: [xmlns ~= self defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	stream nextPutAll: tagName.	self endTag.! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:13'!flush	self stream flush! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 9/2/2010 11:28'!pcData: aStringOrText	| lastIndex nextIndex string |	string := aStringOrText asString.	string isWideString ifTrue:[ | entity |		"A slow version of #pcData: which replaces all non-latin characters with		their corresponding entity encodings."		string do:[:ch|			ch charCode > 255 				ifTrue:[entity := '&#', ch charCode, ';']				ifFalse:[entity := XMLTranslation at: ch charCode ifAbsent:[nil]].			entity 				ifNil:[self stream nextPut: ch]				ifNotNil:[self stream nextPutAll: entity]].		^self].	lastIndex := 1.	"Unroll the first search to avoid copying"	nextIndex := string class findFirstInString: string inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self stream nextPutAll: string].	[self stream nextPutAll: (string copyFrom: lastIndex to: nextIndex-1).	self stream nextPutAll: (XMLTranslation at: (string at: nextIndex)).	lastIndex := nextIndex + 1.	nextIndex := string class findFirstInString: string inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0] whileFalse.	self stream nextPutAll: (string copyFrom: lastIndex to: string size).! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/11/2000 16:12'!pi: piTarget data: piData	self startPI: piTarget.	self stream nextPutAll: piData.	self endPI! !!XMLWriter methodsFor: 'writing xml' stamp: 'nice 10/21/2009 00:01'!startElement: elementName attributeList: attributeList	self canonical		ifFalse: [self stream cr].	self startTag: elementName.	attributeList keys asArray sort do: [:key |		self attribute: key value: (attributeList at: key)]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:08'!startTag: tagName	self writeIndent.	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:10'!startTag: tagName xmlns: xmlns	self stream		nextPut: $<.	(xmlns notNil		and: [xmlns ~= self scope defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	self stream		nextPutAll: tagName.	"self canonical		ifFalse: [self stream space]."	self pushTag: tagName! !!XMLWriter methodsFor: 'writing xml' stamp: 'jcg 3/8/2009 01:44'!tag: aTag attributes: attributes value: aBlock 		"Write a begin and end tag for aValue.  'attributes' is either nil, a Dictionary, or an Array (for the last, see Dictionary#newFromPairs:)."	| dataString attributeDict |	attributeDict := attributes ifNotNil: [		attributes isArray			ifTrue: [Dictionary newFromPairs: attributes]			ifFalse: [attributes]	].	(attributeDict notNil and: [attributeDict notEmpty]) ifTrue: [		self startElement: aTag attributeList: attributeDict.	] ifFalse: [		self startTag: aTag.	].	self endTag.	dataString := aBlock value.	dataString isString ifTrue: [		self pcData: aBlock value.	].	self endTag: aTag.! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 4/24/2008 20:13'!tag: tagName pcData: aString	"Convenience."	^self startTag: tagName; endTag; pcData: aString; endTag: tagName.! !!XMLWriter methodsFor: 'writing xml' stamp: 'RJT 3/2/2008 00:25'!tag: aTag value: aBlock		"write a begin and end tag for aValue"	^self tag: aTag attributes: nil value: aBlock 	! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 2/23/2005 16:35'!xmlDeclaration: versionString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				endPI]! !!XMLWriter methodsFor: 'writing xml' stamp: 'thf 9/2/2005 14:08'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical	^canonical! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical := aBoolean! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentString: aString	currentIndent := 0.	indentString := aString! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentTab	self indentString: (String with: Character tab)! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream	^stream! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream := aStream! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:09'!declareNamespace: ns uri: uri	self scope declareNamespace: ns uri: uri! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace	^self scope defaultNamespace! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self scope defaultNamespace: ns! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:02'!enterScope	self scope enterScope! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:47'!leaveScope	self scope leaveScope! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endCData	self stream nextPutAll: ']]>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endComment	self stream nextPutAll: ' -->'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 5/20/2003 12:13'!endPI	self stream nextPutAll: ' ?>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startCData	self stream nextPutAll: '<!![CDATA['! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startComment	self stream nextPutAll: '<-- '! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startPI: identifier	self stream		nextPutAll: '<?';		nextPutAll: identifier;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 8/8/2000 18:13'!endDecl: type	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!endDeclaration	self stream		cr;		nextPut: $].	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type named: aString	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space;		nextPutAll: aString;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDeclaration: dtdName	self startDecl: 'DOCTYPE' named: dtdName.	self stream		nextPut: $[;		cr! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/8/2000 18:00'!eq	self stream nextPut: $=! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:52'!indent	currentIndent		ifNotNil: [currentIndent := currentIndent +1]! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 17:05'!outdent	currentIndent		ifNotNil: [			stream cr.			currentIndent := currentIndent-1.			self writeIndent.			currentIndent := currentIndent-1.]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop := self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:18'!pushTag: tagName	self stack add: tagName! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/11/2000 16:24'!putAsXMLString: aValue	self stream nextPut: $".	self pcData: aValue.	self stream nextPut: $"! !!XMLWriter methodsFor: 'private' stamp: 'mir 6/24/2003 14:22'!scope	^scope! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/8/2000 17:02'!stack	^stack! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:58'!writeIndent	currentIndent ifNotNil: [		currentIndent timesRepeat: [self stream nextPutAll: indentString]]! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 7/12/2006 15:54'!initialize	stack := OrderedCollection new.	canonical := false.	scope := XMLNamespaceScope new! !!XMLWriter class methodsFor: 'class initialization' stamp: 'ar 8/8/2008 19:09'!initialize	"XMLWriter initialize"	XMLTranslation := Dictionary new.	0 to: 31 do:[:i| XMLTranslation at: i asCharacter put: '\',(i asString padded: #left to: 2 with: $0)].	XMLTranslation		at: Character cr put: '&#13;';		at: Character lf put: '&#10;';		at: Character tab put: '&#9;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;';"		at: $' put: '&apos;'; "		at: $" put: '&quot;'.	XMLTranslationMap := ByteArray new: 256.	XMLTranslation keysDo:[:ch| XMLTranslationMap at: ch asciiValue+1 put: 1].! !!XMLWriter class methodsFor: 'instance creation' stamp: 'mir 12/8/2000 17:54'!on: aStream	^self basicNew initialize stream: aStream! !!YearMonthWeekTest methodsFor: 'running' stamp: 'brp 9/26/2004 19:26'!setUp	restoredStartDay := Week startDay.	restoredTimeZone := DateAndTime localTimeZone.	Week startDay: #Sunday.	DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz | tz abbreviation = 'GMT']).! !!YearMonthWeekTest methodsFor: 'running' stamp: 'brp 9/26/2004 19:27'!tearDown	Week startDay: restoredStartDay.	DateAndTime localTimeZone: restoredTimeZone.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:51'!testDaysInMonth	self assert: (Month daysInMonth: 2 forYear: 2000) = 29.	self assert: (Month daysInMonth: 2 forYear: 2001) = 28.	self assert: (Month  daysInMonth: 2 forYear: 2004) = 29.	self assert: (Month  daysInMonth: 2 forYear: 2100) = 28.		self assert: (Month  daysInMonth: 'January' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'February' forYear: 2003) = 28.	self assert: (Month  daysInMonth: 'March' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'April' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'May' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'June' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'July' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'August' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'September' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'October' forYear: 2003) = 31.	self assert: (Month  daysInMonth: 'November' forYear: 2003) = 30.	self assert: (Month  daysInMonth: 'December' forYear: 2003) = 31.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:37'!testDaysInYear	self assert: (Year daysInYear: 2000) = 366.	self assert: (Year daysInYear: 2001) = 365.	self assert: (Year daysInYear: 2004) = 366.	self assert: (Year daysInYear: 2100) = 365.	self assert: (Year daysInYear: 2003) = 365.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:37'!testIndexOfDay	self assert: (Week indexOfDay: 'Friday') = 6.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 12:33'!testIsLeapYear	self assert: (Year isLeapYear: 2000).	self deny: (Year isLeapYear: 2001).	self assert: (Year isLeapYear: 2004).	self deny: (Year isLeapYear: 2100).	self deny: (Year isLeapYear: 2002).! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:31'!testMonthPrintOn    	| aMonth cs rw |	aMonth := Month starting: DateAndTime new duration: 31 days.  	cs := ReadStream on: 'January 1901'.	rw := ReadWriteStream on: ''.     aMonth printOn: rw.     self assert: rw contents = cs contents.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'tlk 1/3/2004 13:34'!testStartDay	Week startDay: 'Wednesday'.	self assert: Week startDay = 'Wednesday'.	Week startDay: 'Thursday'.	self assert: Week startDay = 'Thursday'.! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:49'!testWeekPrintOn	| aWeek cs rw |	aWeek := Week starting: (DateAndTime year: 1900 month: 12 day: 31).	cs := 'a Week starting: 1900-12-30T00:00:00+00:00'.	rw := WriteStream on: ''.	aWeek printOn: rw.	self assert: rw contents = cs! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:32'!testYearPrintOn    	| aYear cs rw |	aYear := Year starting: DateAndTime new duration: 365 days. 	cs := ReadStream on: 'a Year (1901)'.	rw := ReadWriteStream on: ''.     aYear printOn: rw.     self assert: rw contents = cs contents.! !!YearMonthWeekTest commentStamp: 'tlk 1/6/2004 17:55' prior: 0!I am one of several Sunit test Cases intentended to provide complete coverage for the Chronology set of classes as part of the external testing. See DateAndEpochTestCase for a complete list.  tlk.I have no fixtures but do make sure to restore anything I change.!!YearTest methodsFor: 'Coverage' stamp: 'brp 9/11/2003 14:31'!classToBeTested	^ Year! !!YearTest methodsFor: 'Tests' stamp: 'brp 9/11/2003 14:30'!testCurrent	| yyyy |	yyyy := DateAndTime now year.		self assert: Year current start = (DateAndTime year: yyyy month: 1 day: 1)! !!YearTest methodsFor: 'Tests' stamp: 'brp 6/16/2008 08:37'!testPreviousInLeapYear	| leap |	leap := Year year: 2008.	self assert: leap isLeapYear. 	self assert: (Year year: (leap year - 1)) = leap previous ! !!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 1/11/2007 12:51'!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'bgf 8/14/2008 19:57'!clearLastModFileDateTime	"Set the last-mod time of this member to a fixed value.	 Useful to prevent auto-dated members from changing the overall SHA of an archive.	 If the members of a software-generated archive are all cleared this way,	 then independently assembled archives can be compared for content equality."	lastModFileDateTime := (3600 * 24 * 365) * 20	 "Roughly the year 2000, depending on OS unpacking"! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15'!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipEncoder methodsFor: 'accessing' stamp: 'bgf 5/23/2008 18:04'!nextBytePut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	"<primitive: 66>   Doesn't pay its way."	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position := position + 1.			^collection byteAt: position put: anObject]! !"Fix all reference to OldMutex and remove OldMutex package"(Smalltalk at: #OldMutex)    allInstancesDo:[:om| om become: Mutex new].Smalltalk garbageCollect.(MCWorkingCopy allManagers    select:[:wc| wc packageName = 'OldMutex']    thenDo:[:wc| wc unload]).Smalltalk removeClassNamed: 'OldMutex'.Smalltalk removeClassNamed: 'MorphObjectOut'.1 to: 31 do:[:i|         (Smalltalk compactClassesArray at: i) ifNotNil:[:aClass|                aClass isObsolete                         ifTrue:[Smalltalk compactClassesArray at: i put: nil]]].Smalltalk recreateSpecialObjectsArray.SystemOrganization removeEmptyCategories; sortCategories.DebuggerMethodMap voidMapCache.Compiler recompileAll.Smalltalk garbageCollect."Condense changes for the base image"Smalltalk saveAs: 'oqbase.image'.Smalltalk condenseChanges.!----SNAPSHOT----{25 May 2011 . 8:51:15 pm} oqbase.image priorSource: 2988846!----STARTUP----{25 May 2011 . 9:08:33 pm} as C:\OpenQwaq\images\oqbase.image!"MorphicExtras"!----QUIT----{25 May 2011 . 9:08:52 pm} oqbase.image priorSource: 2989673!